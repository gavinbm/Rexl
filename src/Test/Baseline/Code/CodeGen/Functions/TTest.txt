> "Compare these results with CrossChecks/TTest.ipynb."
"Compare these results with CrossChecks/TTest.ipynb." : s
BndKind:Str, Type:s, Bnd:(str(Compare these results with CrossChecks/TTest.ipynb.))
Func sig: () to s
Type: str, Value: Compare these results with CrossChecks/TTest.ipynb.
###

**** New definitions: A0_1, type: r8*
**** New definitions: B0_1, type: r8*
**** New definitions: A0_5, type: r8*
**** New definitions: A1_1, type: r8*
**** New definitions: N0_1, type: r8*
**** New definitions: Samps, type: (r8*, s)*
**** New definitions: Pairs, type: ((r8*, s), (r8*, s))*
**** New definitions: Means, type: i8*
**** New definitions: EqualVars, type: b*

> "One-sample"
"One-sample" : s
BndKind:Str, Type:s, Bnd:(str(One-sample))
Func sig: () to s
Type: str, Value: One-sample
###
> ForEach(s: Samps, ForEach(mean: Means, (s[1], mean, TTest.OneSample(s[0], mean))))->ChainMap()
ForEach(s : Samps, ForEach(mean : Means, (s[1], mean, TTest.OneSample(s[0], mean))))->ChainMap() : (s, i8, {Count:i8, Dof:r8, Mean:r8, P2:r8, PL:r8, PR:r8, Stderr:r8, T:r8, Var:r8})*
BndKind:Call, Type:(s, i8, {Count:i8, Dof:r8, Mean:r8, P2:r8, PL:r8, PR:r8, Stderr:r8, T:r8, Var:r8})*, Bnd:(Call(∂.ChainMap(Call(∂.ForEach([map:1] Global(Samps), Call(∂.ForEach([map:2] Global(Means), (GetSlot(Scope(1), 1), Scope(2), Call(∂.TTest.OneSample(GetSlot(Scope(1), 0), Num<r8>(Scope(2))))):(s, i8, {Count:i8, Dof:r8, Mean:r8, P2:r8, PL:r8, PR:r8, Stderr:r8, T:r8, Var:r8})):(s, i8, {Count:i8, Dof:r8, Mean:r8, P2:r8, PL:r8, PR:r8, Stderr:r8, T:r8, Var:r8})*)):(s, i8, {Count:i8, Dof:r8, Mean:r8, P2:r8, PL:r8, PR:r8, Stderr:r8, T:r8, Var:r8})**)):(s, i8, {Count:i8, Dof:r8, Mean:r8, P2:r8, PL:r8, PR:r8, Stderr:r8, T:r8, Var:r8})*))
Func sig: (<ctx>:x, Samps:(r8*, s)*, Means:i8*) to (s, i8, {Count:i8, Dof:r8, Mean:r8, P2:r8, PL:r8, PR:r8, Stderr:r8, T:r8, Var:r8})*
Sequence: Seq<(str,i8,{i8,r8,r8,r8,r8,r8,r8,r8,r8})>
 0) (A0_1, -1, { Count: 30, Dof: 29, Mean: 0.3380896233333333, P2: 1.3724122949199113E-07, PL: 0.9999999313793853, PR: 6.862061474599557E-08, Stderr: 0.19374953948101742, T: 6.906285439013559, Var: 1.1261665214731897 })
 1) (A0_1, 0, { Count: 30, Dof: 29, Mean: 0.3380896233333333, P2: 0.09157801313145231, PL: 0.9542109934342738, PR: 0.045789006565726154, Stderr: 0.19374953948101742, T: 1.7449828486764356, Var: 1.1261665214731897 })
 2) (A0_1, 1, { Count: 30, Dof: 29, Mean: 0.3380896233333333, P2: 0.0018979925385539493, PL: 0.0009489962692769747, PR: 0.999051003730723, Stderr: 0.19374953948101742, T: -3.416319741660688, Var: 1.1261665214731897 })
 3) (B0_1, -1, { Count: 30, Dof: 29, Mean: -0.41506455433333345, P2: 0.0035128322837523207, PL: 0.9982435838581238, PR: 0.0017564161418761604, Stderr: 0.18407582260652472, T: 3.177687527802106, Var: 1.0165172540480627 })
 4) (B0_1, 0, { Count: 30, Dof: 29, Mean: -0.41506455433333345, P2: 0.03186438008493438, PL: 0.01593219004246719, PR: 0.9840678099575328, Stderr: 0.18407582260652472, T: -2.2548564415249888, Var: 1.0165172540480627 })
 5) (B0_1, 1, { Count: 30, Dof: 29, Mean: -0.41506455433333345, P2: 1.7780982490933334E-08, PL: 8.890491245466667E-09, PR: 0.9999999911095088, Stderr: 0.18407582260652472, T: -7.687400410852084, Var: 1.0165172540480627 })
 6) (A0_5, -1, { Count: 30, Dof: 29, Mean: 0.08202627299999984, P2: 0.22207681240377086, PL: 0.8889615937981146, PR: 0.11103840620188543, Stderr: 0.8671290357123554, T: 1.2478261347933115, Var: 22.55738293726318 })
 7) (A0_5, 0, { Count: 30, Dof: 29, Mean: 0.08202627299999984, P2: 0.9252869305146936, PL: 0.5373565347426532, PR: 0.4626434652573468, Stderr: 0.8671290357123554, T: 0.09459523279901984, Var: 22.55738293726318 })
 8) (A0_5, 1, { Count: 30, Dof: 29, Mean: 0.08202627299999984, P2: 0.29850430963019126, PL: 0.14925215481509563, PR: 0.8507478451849044, Stderr: 0.8671290357123554, T: -1.0586356691952719, Var: 22.55738293726318 })
 9) (A1_1, -1, { Count: 30, Dof: 29, Mean: 1.0516422093333329, P2: 2.2462032234216167E-12, PL: 0.9999999999988769, PR: 1.1231016117108084E-12, Stderr: 0.17752129423845914, T: 11.557161174013425, Var: 0.9454142972429277 })
10) (A1_1, 0, { Count: 30, Dof: 29, Mean: 1.0516422093333329, P2: 1.9622677660535714E-06, PL: 0.999999018866117, PR: 9.811338830267857E-07, Stderr: 0.17752129423845914, T: 5.924034149507117, Var: 0.9454142972429277 })
11) (A1_1, 1, { Count: 30, Dof: 29, Mean: 1.0516422093333329, P2: 0.7731927967794416, PL: 0.6134036016102792, PR: 0.3865963983897208, Stderr: 0.17752129423845914, T: 0.2909071250008092, Var: 0.9454142972429277 })
12) (N0_1, -1, { Count: 31, Dof: 30, Mean: NaN, P2: NaN, PL: NaN, PR: NaN, Stderr: NaN, T: NaN, Var: NaN })
13) (N0_1, 0, { Count: 31, Dof: 30, Mean: NaN, P2: NaN, PL: NaN, PR: NaN, Stderr: NaN, T: NaN, Var: NaN })
14) (N0_1, 1, { Count: 31, Dof: 30, Mean: NaN, P2: NaN, PL: NaN, PR: NaN, Stderr: NaN, T: NaN, Var: NaN })
15) (null, -1, { Count: 0, Dof: NaN, Mean: NaN, P2: NaN, PL: NaN, PR: NaN, Stderr: NaN, T: NaN, Var: NaN })
16) (null, 0, { Count: 0, Dof: NaN, Mean: NaN, P2: NaN, PL: NaN, PR: NaN, Stderr: NaN, T: NaN, Var: NaN })
17) (null, 1, { Count: 0, Dof: NaN, Mean: NaN, P2: NaN, PL: NaN, PR: NaN, Stderr: NaN, T: NaN, Var: NaN })
*** Ctx ping count: 475
    [0](468): TTest.OneSample(*1x.0, Num<r8>(*2x))
    [1](7): ChainMap(ForEach(*1: Samps, ForEach(*2: Means, (*1.1, *2, TTest.OneSample(*1.0, Num<r8>(*2))))))
###
> With(s: Samps->TakeAt(0), (s[1], TTest.OneSample(s[0]))) // Default to mean of 0.
With(s : Samps->TakeAt(0), (s[1], TTest.OneSample(s[0]))) : (s, {Count:i8, Dof:r8, Mean:r8, P2:r8, PL:r8, PR:r8, Stderr:r8, T:r8, Var:r8})
BndKind:Call, Type:(s, {Count:i8, Dof:r8, Mean:r8, P2:r8, PL:r8, PR:r8, Stderr:r8, T:r8, Var:r8}), Bnd:(Call(∂.With([with:1] Call(∂.TakeAt(Global(Samps), 0:i8):(r8*, s)), (GetSlot(Scope(1), 1), Call(∂.TTest.OneSample(GetSlot(Scope(1), 0)))):(s, {Count:i8, Dof:r8, Mean:r8, P2:r8, PL:r8, PR:r8, Stderr:r8, T:r8, Var:r8})):(s, {Count:i8, Dof:r8, Mean:r8, P2:r8, PL:r8, PR:r8, Stderr:r8, T:r8, Var:r8})))
Func sig: (<ctx>:x, Samps:(r8*, s)*) to (s, {Count:i8, Dof:r8, Mean:r8, P2:r8, PL:r8, PR:r8, Stderr:r8, T:r8, Var:r8})
Type: (str,{i8,r8,r8,r8,r8,r8,r8,r8,r8}), Value: (A0_1, { Count: 30, Dof: 29, Mean: 0.3380896233333333, P2: 0.09157801313145231, PL: 0.9542109934342738, PR: 0.045789006565726154, Stderr: 0.19374953948101742, T: 1.7449828486764356, Var: 1.1261665214731897 })
*** Ctx ping count: 31
    [1](31): TTest.OneSample(!1x.0)
###
> "Two-sample"
"Two-sample" : s
BndKind:Str, Type:s, Bnd:(str(Two-sample))
Func sig: () to s
Type: str, Value: Two-sample
###
> ForEach(p: Pairs, ForEach(eqv: EqualVars, (p[0][1], p[1][1], eqv, TTest.TwoSample(p[0][0], p[1][0], equal_var: eqv))))->ChainMap()
ForEach(p : Pairs, ForEach(eqv : EqualVars, (p[0][1], p[1][1], eqv, TTest.TwoSample(p[0][0], p[1][0], equal_var : eqv))))->ChainMap() : (s, s, b, {CountX:i8, CountY:i8, Dof:r8, MeanX:r8, MeanY:r8, P2:r8, PL:r8, PR:r8, Stderr:r8, T:r8, VarX:r8, VarY:r8})*
BndKind:Call, Type:(s, s, b, {CountX:i8, CountY:i8, Dof:r8, MeanX:r8, MeanY:r8, P2:r8, PL:r8, PR:r8, Stderr:r8, T:r8, VarX:r8, VarY:r8})*, Bnd:(Call(∂.ChainMap(Call(∂.ForEach([map:1] Global(Pairs), Call(∂.ForEach([map:2] Global(EqualVars), (GetSlot(GetSlot(Scope(1), 0), 1), GetSlot(GetSlot(Scope(1), 1), 1), Scope(2), Call(∂.TTest.TwoSample(GetSlot(GetSlot(Scope(1), 0), 0), GetSlot(GetSlot(Scope(1), 1), 0), equal_var : Scope(2)))):(s, s, b, {CountX:i8, CountY:i8, Dof:r8, MeanX:r8, MeanY:r8, P2:r8, PL:r8, PR:r8, Stderr:r8, T:r8, VarX:r8, VarY:r8})):(s, s, b, {CountX:i8, CountY:i8, Dof:r8, MeanX:r8, MeanY:r8, P2:r8, PL:r8, PR:r8, Stderr:r8, T:r8, VarX:r8, VarY:r8})*)):(s, s, b, {CountX:i8, CountY:i8, Dof:r8, MeanX:r8, MeanY:r8, P2:r8, PL:r8, PR:r8, Stderr:r8, T:r8, VarX:r8, VarY:r8})**)):(s, s, b, {CountX:i8, CountY:i8, Dof:r8, MeanX:r8, MeanY:r8, P2:r8, PL:r8, PR:r8, Stderr:r8, T:r8, VarX:r8, VarY:r8})*))
Func sig: (<ctx>:x, Pairs:((r8*, s), (r8*, s))*, EqualVars:b*) to (s, s, b, {CountX:i8, CountY:i8, Dof:r8, MeanX:r8, MeanY:r8, P2:r8, PL:r8, PR:r8, Stderr:r8, T:r8, VarX:r8, VarY:r8})*
Sequence: Seq<(str,str,bool,{i8,i8,r8,r8,r8,r8,r8,r8,r8,r8,r8,r8})>
 0) (A0_1, B0_1, false, { CountX: 30, CountY: 30, Dof: 57.848508775907504, MeanX: 0.3380896233333333, MeanY: -0.41506455433333345, P2: 0.006599893682512459, PL: 0.9967000531587438, PR: 0.0032999468412562294, Stderr: 0.2672504303408604, T: 2.818158895782013, VarX: 1.1261665214731897, VarY: 1.0165172540480627 })
 1) (A0_1, B0_1, true , { CountX: 30, CountY: 30, Dof: 58, MeanX: 0.3380896233333333, MeanY: -0.41506455433333345, P2: 0.006594935702908256, PL: 0.9967025321485459, PR: 0.003297467851454128, Stderr: 0.26725043034086043, T: 2.818158895782012, VarX: 1.1261665214731897, VarY: 1.0165172540480627 })
 2) (A0_1, A0_5, false, { CountX: 30, CountY: 30, Dof: 31.888422903130824, MeanX: 0.3380896233333333, MeanY: 0.08202627299999984, P2: 0.7750633343479234, PL: 0.6124683328260383, PR: 0.3875316671739617, Stderr: 0.8885109164352151, T: 0.28819381461364874, VarX: 1.1261665214731897, VarY: 22.55738293726318 })
 3) (A0_1, A0_5, true , { CountX: 30, CountY: 30, Dof: 58, MeanX: 0.3380896233333333, MeanY: 0.08202627299999984, P2: 0.7742257724439034, PL: 0.6128871137780483, PR: 0.3871128862219517, Stderr: 0.8885109164352151, T: 0.28819381461364874, VarX: 1.1261665214731897, VarY: 22.55738293726318 })
 4) (A0_1, A1_1, false, { CountX: 30, CountY: 30, Dof: 57.561774433233765, MeanX: 0.3380896233333333, MeanY: 1.0516422093333329, P2: 0.008723287624436752, PL: 0.004361643812218376, PR: 0.9956383561877816, Stderr: 0.26277879282241157, T: -2.715411614217382, VarX: 1.1261665214731897, VarY: 0.9454142972429277 })
 5) (A0_1, A1_1, true , { CountX: 30, CountY: 30, Dof: 58, MeanX: 0.3380896233333333, MeanY: 1.0516422093333329, P2: 0.008706443993589528, PL: 0.004353221996794764, PR: 0.9956467780032052, Stderr: 0.26277879282241157, T: -2.715411614217382, VarX: 1.1261665214731897, VarY: 0.9454142972429277 })
 6) (A0_1, N0_1, false, { CountX: 30, CountY: 31, Dof: NaN, MeanX: 0.3380896233333333, MeanY: NaN, P2: NaN, PL: NaN, PR: NaN, Stderr: NaN, T: NaN, VarX: 1.1261665214731897, VarY: NaN })
 7) (A0_1, N0_1, true , { CountX: 30, CountY: 31, Dof: 59, MeanX: 0.3380896233333333, MeanY: NaN, P2: NaN, PL: NaN, PR: NaN, Stderr: NaN, T: NaN, VarX: 1.1261665214731897, VarY: NaN })
 8) (B0_1, A0_5, false, { CountX: 30, CountY: 30, Dof: 31.608392816981596, MeanX: -0.41506455433333345, MeanY: 0.08202627299999984, P2: 0.5789117362975793, PL: 0.28945586814878965, PR: 0.7105441318512103, Stderr: 0.8864517319311346, T: -0.5607646862513554, VarX: 1.0165172540480627, VarY: 22.55738293726318 })
 9) (B0_1, A0_5, true , { CountX: 30, CountY: 30, Dof: 58, MeanX: -0.41506455433333345, MeanY: 0.08202627299999984, P2: 0.5771179506115091, PL: 0.28855897530575453, PR: 0.7114410246942455, Stderr: 0.8864517319311346, T: -0.5607646862513554, VarX: 1.0165172540480627, VarY: 22.55738293726318 })
10) (B0_1, A1_1, false, { CountX: 30, CountY: 30, Dof: 57.923920864155264, MeanX: -0.41506455433333345, MeanY: 1.0516422093333329, P2: 3.7192619201634485E-07, PL: 1.8596309600817243E-07, PR: 0.999999814036904, Stderr: 0.2557297760847695, T: -5.735377342920291, VarX: 1.0165172540480627, VarY: 0.9454142972429277 })
11) (B0_1, A1_1, true , { CountX: 30, CountY: 30, Dof: 58, MeanX: -0.41506455433333345, MeanY: 1.0516422093333329, P2: 3.706047182251445E-07, PL: 1.8530235911257225E-07, PR: 0.9999998146976409, Stderr: 0.2557297760847695, T: -5.735377342920291, VarX: 1.0165172540480627, VarY: 0.9454142972429277 })
12) (B0_1, N0_1, false, { CountX: 30, CountY: 31, Dof: NaN, MeanX: -0.41506455433333345, MeanY: NaN, P2: NaN, PL: NaN, PR: NaN, Stderr: NaN, T: NaN, VarX: 1.0165172540480627, VarY: NaN })
13) (B0_1, N0_1, true , { CountX: 30, CountY: 31, Dof: 59, MeanX: -0.41506455433333345, MeanY: NaN, P2: NaN, PL: NaN, PR: NaN, Stderr: NaN, T: NaN, VarX: 1.0165172540480627, VarY: NaN })
14) (A0_5, A1_1, false, { CountX: 30, CountY: 30, Dof: 31.4266058770155, MeanX: 0.08202627299999984, MeanY: 1.0516422093333329, P2: 0.28163525792492683, PL: 0.14081762896246341, PR: 0.8591823710375366, Stderr: 0.8851138765625229, T: -1.0954702688641453, VarX: 22.55738293726318, VarY: 0.9454142972429277 })
15) (A0_5, A1_1, true , { CountX: 30, CountY: 30, Dof: 58, MeanX: 0.08202627299999984, MeanY: 1.0516422093333329, P2: 0.27783879173014603, PL: 0.13891939586507301, PR: 0.861080604134927, Stderr: 0.8851138765625229, T: -1.0954702688641453, VarX: 22.55738293726318, VarY: 0.9454142972429277 })
16) (A0_5, N0_1, false, { CountX: 30, CountY: 31, Dof: NaN, MeanX: 0.08202627299999984, MeanY: NaN, P2: NaN, PL: NaN, PR: NaN, Stderr: NaN, T: NaN, VarX: 22.55738293726318, VarY: NaN })
17) (A0_5, N0_1, true , { CountX: 30, CountY: 31, Dof: 59, MeanX: 0.08202627299999984, MeanY: NaN, P2: NaN, PL: NaN, PR: NaN, Stderr: NaN, T: NaN, VarX: 22.55738293726318, VarY: NaN })
18) (A1_1, N0_1, false, { CountX: 30, CountY: 31, Dof: NaN, MeanX: 1.0516422093333329, MeanY: NaN, P2: NaN, PL: NaN, PR: NaN, Stderr: NaN, T: NaN, VarX: 0.9454142972429277, VarY: NaN })
19) (A1_1, N0_1, true , { CountX: 30, CountY: 31, Dof: 59, MeanX: 1.0516422093333329, MeanY: NaN, P2: NaN, PL: NaN, PR: NaN, Stderr: NaN, T: NaN, VarX: 0.9454142972429277, VarY: NaN })
20) (null, null, false, { CountX: 0, CountY: 0, Dof: NaN, MeanX: NaN, MeanY: NaN, P2: NaN, PL: NaN, PR: NaN, Stderr: NaN, T: NaN, VarX: NaN, VarY: NaN })
21) (null, null, true , { CountX: 0, CountY: 0, Dof: NaN, MeanX: NaN, MeanY: NaN, P2: NaN, PL: NaN, PR: NaN, Stderr: NaN, T: NaN, VarX: NaN, VarY: NaN })
22) (A0_1, null, false, { CountX: 0, CountY: 0, Dof: NaN, MeanX: NaN, MeanY: NaN, P2: NaN, PL: NaN, PR: NaN, Stderr: NaN, T: NaN, VarX: NaN, VarY: NaN })
23) (A0_1, null, true , { CountX: 0, CountY: 0, Dof: NaN, MeanX: NaN, MeanY: NaN, P2: NaN, PL: NaN, PR: NaN, Stderr: NaN, T: NaN, VarX: NaN, VarY: NaN })
24) (null, A0_1, false, { CountX: 0, CountY: 0, Dof: NaN, MeanX: NaN, MeanY: NaN, P2: NaN, PL: NaN, PR: NaN, Stderr: NaN, T: NaN, VarX: NaN, VarY: NaN })
25) (null, A0_1, true , { CountX: 0, CountY: 0, Dof: NaN, MeanX: NaN, MeanY: NaN, P2: NaN, PL: NaN, PR: NaN, Stderr: NaN, T: NaN, VarX: NaN, VarY: NaN })
*** Ctx ping count: 1262
    [0:2](1248=620+628): TTest.TwoSample(*1x.0.0, *1x.1.0, equal_var : *2x)
    [2](14): ChainMap(ForEach(*1: Pairs, ForEach(*2: EqualVars, (*1.0.1, *1.1.1, *2, TTest.TwoSample(*1.0.0, *1.1.0, equal_var : *2)))))
###
> With(p: Pairs->TakeAt(1), (p[0][1], p[1][1], TTest.TwoSample(p[0][0], p[1][0]))) // Default to unequal variance.
With(p : Pairs->TakeAt(1), (p[0][1], p[1][1], TTest.TwoSample(p[0][0], p[1][0]))) : (s, s, {CountX:i8, CountY:i8, Dof:r8, MeanX:r8, MeanY:r8, P2:r8, PL:r8, PR:r8, Stderr:r8, T:r8, VarX:r8, VarY:r8})
BndKind:Call, Type:(s, s, {CountX:i8, CountY:i8, Dof:r8, MeanX:r8, MeanY:r8, P2:r8, PL:r8, PR:r8, Stderr:r8, T:r8, VarX:r8, VarY:r8}), Bnd:(Call(∂.With([with:1] Call(∂.TakeAt(Global(Pairs), 1:i8):((r8*, s), (r8*, s))), (GetSlot(GetSlot(Scope(1), 0), 1), GetSlot(GetSlot(Scope(1), 1), 1), Call(∂.TTest.TwoSample(GetSlot(GetSlot(Scope(1), 0), 0), GetSlot(GetSlot(Scope(1), 1), 0)))):(s, s, {CountX:i8, CountY:i8, Dof:r8, MeanX:r8, MeanY:r8, P2:r8, PL:r8, PR:r8, Stderr:r8, T:r8, VarX:r8, VarY:r8})):(s, s, {CountX:i8, CountY:i8, Dof:r8, MeanX:r8, MeanY:r8, P2:r8, PL:r8, PR:r8, Stderr:r8, T:r8, VarX:r8, VarY:r8})))
Func sig: (<ctx>:x, Pairs:((r8*, s), (r8*, s))*) to (s, s, {CountX:i8, CountY:i8, Dof:r8, MeanX:r8, MeanY:r8, P2:r8, PL:r8, PR:r8, Stderr:r8, T:r8, VarX:r8, VarY:r8})
Type: (str,str,{i8,i8,r8,r8,r8,r8,r8,r8,r8,r8,r8,r8}), Value: (A0_1, A0_5, { CountX: 30, CountY: 30, Dof: 31.888422903130824, MeanX: 0.3380896233333333, MeanY: 0.08202627299999984, P2: 0.7750633343479234, PL: 0.6124683328260383, PR: 0.3875316671739617, Stderr: 0.8885109164352151, T: 0.28819381461364874, VarX: 1.1261665214731897, VarY: 22.55738293726318 })
*** Ctx ping count: 62
    [1:3](62=31+31): TTest.TwoSample(!1x.0.0, !1x.1.0)
###
> "Paired"
"Paired" : s
BndKind:Str, Type:s, Bnd:(str(Paired))
Func sig: () to s
Type: str, Value: Paired
###
> ForEach(p: Pairs, (p[0][1], p[1][1], TTest.Paired(p[0][0], p[1][0])))->Chain()
ForEach(p : Pairs, (p[0][1], p[1][1], TTest.Paired(p[0][0], p[1][0])))->Chain() : (s, s, {Count:i8, Dof:r8, Mean:r8, P2:r8, PL:r8, PR:r8, Stderr:r8, T:r8, Var:r8})*
BndKind:Call, Type:(s, s, {Count:i8, Dof:r8, Mean:r8, P2:r8, PL:r8, PR:r8, Stderr:r8, T:r8, Var:r8})*, Bnd:(Call(∂.ForEach([map:1] Global(Pairs), (GetSlot(GetSlot(Scope(1), 0), 1), GetSlot(GetSlot(Scope(1), 1), 1), Call(∂.TTest.Paired(GetSlot(GetSlot(Scope(1), 0), 0), GetSlot(GetSlot(Scope(1), 1), 0)))):(s, s, {Count:i8, Dof:r8, Mean:r8, P2:r8, PL:r8, PR:r8, Stderr:r8, T:r8, Var:r8})):(s, s, {Count:i8, Dof:r8, Mean:r8, P2:r8, PL:r8, PR:r8, Stderr:r8, T:r8, Var:r8})*))
Func sig: (<ctx>:x, Pairs:((r8*, s), (r8*, s))*) to (s, s, {Count:i8, Dof:r8, Mean:r8, P2:r8, PL:r8, PR:r8, Stderr:r8, T:r8, Var:r8})*
Sequence: Seq<(str,str,{i8,r8,r8,r8,r8,r8,r8,r8,r8})>
 0) (A0_1, B0_1, { Count: 30, Dof: 29, Mean: 0.7531541776666667, P2: 0.011889521711396567, PL: 0.9940552391443017, PR: 0.005944760855698283, Stderr: 0.2805851366355025, T: 2.684226921987891, Var: 2.3618405670229086 })
 1) (A0_1, A0_5, { Count: 30, Dof: 29, Mean: 0.2560633503333333, P2: 0.7777809706914469, PL: 0.6111095146542765, PR: 0.38889048534572346, Stderr: 0.8989307769977265, T: 0.2848532466410157, Var: 24.242296255012086 })
 2) (A0_1, A1_1, { Count: 30, Dof: 29, Mean: -0.7135525860000002, P2: 0.012950642532735635, PL: 0.006475321266367818, PR: 0.9935246787336321, Stderr: 0.2694404016974833, T: -2.648276136409372, Var: 2.1779439020070344 })
 3) (A0_1, N0_1, { Count: 30, Dof: 29, Mean: NaN, P2: NaN, PL: NaN, PR: NaN, Stderr: NaN, T: NaN, Var: NaN })
 4) (B0_1, A0_5, { Count: 30, Dof: 29, Mean: -0.4970908273333332, P2: 0.5849865826846158, PL: 0.2924932913423079, PR: 0.707506708657692, Stderr: 0.900066192627979, T: -0.5522825225575314, Var: 24.303574533354787 })
 5) (B0_1, A1_1, { Count: 30, Dof: 29, Mean: -1.4667067636666666, P2: 2.781799775760654E-06, PL: 1.390899887880327E-06, PR: 0.9999986091001121, Stderr: 0.25300030247121563, T: -5.797253004602779, Var: 1.9202745915157977 })
 6) (B0_1, N0_1, { Count: 30, Dof: 29, Mean: NaN, P2: NaN, PL: NaN, PR: NaN, Stderr: NaN, T: NaN, Var: NaN })
 7) (A0_5, A1_1, { Count: 30, Dof: 29, Mean: -0.9696159363333332, P2: 0.2918486712587962, PL: 0.1459243356293981, PR: 0.8540756643706019, Stderr: 0.9031333905260119, T: -1.0736132076443323, Var: 24.469497632490302 })
 8) (A0_5, N0_1, { Count: 30, Dof: 29, Mean: NaN, P2: NaN, PL: NaN, PR: NaN, Stderr: NaN, T: NaN, Var: NaN })
 9) (A1_1, N0_1, { Count: 30, Dof: 29, Mean: NaN, P2: NaN, PL: NaN, PR: NaN, Stderr: NaN, T: NaN, Var: NaN })
10) (null, null, { Count: 0, Dof: NaN, Mean: NaN, P2: NaN, PL: NaN, PR: NaN, Stderr: NaN, T: NaN, Var: NaN })
11) (A0_1, null, { Count: 0, Dof: NaN, Mean: NaN, P2: NaN, PL: NaN, PR: NaN, Stderr: NaN, T: NaN, Var: NaN })
12) (null, A0_1, { Count: 0, Dof: NaN, Mean: NaN, P2: NaN, PL: NaN, PR: NaN, Stderr: NaN, T: NaN, Var: NaN })
*** Ctx ping count: 300
    [0](300): TTest.Paired(*1x.0.0, *1x.1.0)
###
> "Paired with selectors"
"Paired with selectors" : s
BndKind:Str, Type:s, Bnd:(str(Paired with selectors))
Func sig: () to s
Type: str, Value: Paired with selectors
###

**** New definitions: ZippedPairs, type: (r8, r8)**

> ForEach(p: ZippedPairs, TTest.Paired(p, it[0], it[1]))
ForEach(p : ZippedPairs, TTest.Paired(p, it[0], it[1])) : {Count:i8, Dof:r8, Mean:r8, P2:r8, PL:r8, PR:r8, Stderr:r8, T:r8, Var:r8}*
BndKind:Call, Type:{Count:i8, Dof:r8, Mean:r8, P2:r8, PL:r8, PR:r8, Stderr:r8, T:r8, Var:r8}*, Bnd:(Call(∂.ForEach([map:1] Global(ZippedPairs), Call(∂.TTest.Paired([map:2] Scope(1), GetSlot(Scope(2), 0), GetSlot(Scope(2), 1))))))
Func sig: (<ctx>:x, ZippedPairs:(r8, r8)**) to {Count:i8, Dof:r8, Mean:r8, P2:r8, PL:r8, PR:r8, Stderr:r8, T:r8, Var:r8}*
Sequence: Seq<{i8,r8,r8,r8,r8,r8,r8,r8,r8}>
 0) { Count: 30, Dof: 29, Mean: 0.7531541776666667, P2: 0.011889521711396567, PL: 0.9940552391443017, PR: 0.005944760855698283, Stderr: 0.2805851366355025, T: 2.684226921987891, Var: 2.3618405670229086 }
 1) { Count: 30, Dof: 29, Mean: 0.2560633503333333, P2: 0.7777809706914469, PL: 0.6111095146542765, PR: 0.38889048534572346, Stderr: 0.8989307769977265, T: 0.2848532466410157, Var: 24.242296255012086 }
 2) { Count: 30, Dof: 29, Mean: -0.7135525860000002, P2: 0.012950642532735635, PL: 0.006475321266367818, PR: 0.9935246787336321, Stderr: 0.2694404016974833, T: -2.648276136409372, Var: 2.1779439020070344 }
 3) { Count: 30, Dof: 29, Mean: NaN, P2: NaN, PL: NaN, PR: NaN, Stderr: NaN, T: NaN, Var: NaN }
 4) { Count: 30, Dof: 29, Mean: -0.4970908273333332, P2: 0.5849865826846158, PL: 0.2924932913423079, PR: 0.707506708657692, Stderr: 0.900066192627979, T: -0.5522825225575314, Var: 24.303574533354787 }
 5) { Count: 30, Dof: 29, Mean: -1.4667067636666666, P2: 2.781799775760654E-06, PL: 1.390899887880327E-06, PR: 0.9999986091001121, Stderr: 0.25300030247121563, T: -5.797253004602779, Var: 1.9202745915157977 }
 6) { Count: 30, Dof: 29, Mean: NaN, P2: NaN, PL: NaN, PR: NaN, Stderr: NaN, T: NaN, Var: NaN }
 7) { Count: 30, Dof: 29, Mean: -0.9696159363333332, P2: 0.2918486712587962, PL: 0.1459243356293981, PR: 0.8540756643706019, Stderr: 0.9031333905260119, T: -1.0736132076443323, Var: 24.469497632490302 }
 8) { Count: 30, Dof: 29, Mean: NaN, P2: NaN, PL: NaN, PR: NaN, Stderr: NaN, T: NaN, Var: NaN }
 9) { Count: 30, Dof: 29, Mean: NaN, P2: NaN, PL: NaN, PR: NaN, Stderr: NaN, T: NaN, Var: NaN }
10) { Count: 0, Dof: NaN, Mean: NaN, P2: NaN, PL: NaN, PR: NaN, Stderr: NaN, T: NaN, Var: NaN }
11) { Count: 0, Dof: NaN, Mean: NaN, P2: NaN, PL: NaN, PR: NaN, Stderr: NaN, T: NaN, Var: NaN }
12) { Count: 0, Dof: NaN, Mean: NaN, P2: NaN, PL: NaN, PR: NaN, Stderr: NaN, T: NaN, Var: NaN }
*** Ctx ping count: 300
    [0](300): TTest.Paired(*2: *1x, *2.0, *2.1)
###
> "Paired with selectors: add index to each datapoint. Pairs remain unchanged"
"Paired with selectors: add index to each datapoint. Pairs remain unchanged" : s
BndKind:Str, Type:s, Bnd:(str(Paired with selectors: add index to each datapoint. Pairs remain unchanged))
Func sig: () to s
Type: str, Value: Paired with selectors: add index to each datapoint. Pairs remain unchanged
###
> ForEach(p: ZippedPairs, TTest.Paired(p, it[0] + #, it[1] + #))
ForEach(p : ZippedPairs, TTest.Paired(p, it[0] + #, it[1] + #)) : {Count:i8, Dof:r8, Mean:r8, P2:r8, PL:r8, PR:r8, Stderr:r8, T:r8, Var:r8}*
BndKind:Call, Type:{Count:i8, Dof:r8, Mean:r8, P2:r8, PL:r8, PR:r8, Stderr:r8, T:r8, Var:r8}*, Bnd:(Call(∂.ForEach([map:1] Global(ZippedPairs), Call(∂.TTest.Paired([map:3] Scope(1), Add(GetSlot(Scope(3), 0), Num<r8>(Scope(2))), Add(GetSlot(Scope(3), 1), Num<r8>(Scope(2))))))))
Func sig: (<ctx>:x, ZippedPairs:(r8, r8)**) to {Count:i8, Dof:r8, Mean:r8, P2:r8, PL:r8, PR:r8, Stderr:r8, T:r8, Var:r8}*
Sequence: Seq<{i8,r8,r8,r8,r8,r8,r8,r8,r8}>
 0) { Count: 30, Dof: 29, Mean: 0.7531541776666667, P2: 0.011889521711396345, PL: 0.9940552391443018, PR: 0.005944760855698172, Stderr: 0.2805851366355024, T: 2.684226921987892, Var: 2.361840567022907 }
 1) { Count: 30, Dof: 29, Mean: 0.2560633503333338, P2: 0.7777809706914469, PL: 0.6111095146542765, PR: 0.38889048534572346, Stderr: 0.8989307769977265, T: 0.28485324664101624, Var: 24.242296255012086 }
 2) { Count: 30, Dof: 29, Mean: -0.7135525859999999, P2: 0.012950642532735635, PL: 0.006475321266367818, PR: 0.9935246787336321, Stderr: 0.2694404016974832, T: -2.648276136409372, Var: 2.1779439020070326 }
 3) { Count: 30, Dof: 29, Mean: NaN, P2: NaN, PL: NaN, PR: NaN, Stderr: NaN, T: NaN, Var: NaN }
 4) { Count: 30, Dof: 29, Mean: -0.4970908273333332, P2: 0.5849865826846158, PL: 0.2924932913423079, PR: 0.707506708657692, Stderr: 0.9000661926279793, T: -0.5522825225575312, Var: 24.303574533354798 }
 5) { Count: 30, Dof: 29, Mean: -1.466706763666667, P2: 2.781799775760638E-06, PL: 1.390899887880319E-06, PR: 0.9999986091001121, Stderr: 0.2530003024712156, T: -5.797253004602782, Var: 1.9202745915157975 }
 6) { Count: 30, Dof: 29, Mean: NaN, P2: NaN, PL: NaN, PR: NaN, Stderr: NaN, T: NaN, Var: NaN }
 7) { Count: 30, Dof: 29, Mean: -0.9696159363333334, P2: 0.2918486712587962, PL: 0.1459243356293981, PR: 0.8540756643706019, Stderr: 0.903133390526012, T: -1.0736132076443325, Var: 24.46949763249031 }
 8) { Count: 30, Dof: 29, Mean: NaN, P2: NaN, PL: NaN, PR: NaN, Stderr: NaN, T: NaN, Var: NaN }
 9) { Count: 30, Dof: 29, Mean: NaN, P2: NaN, PL: NaN, PR: NaN, Stderr: NaN, T: NaN, Var: NaN }
10) { Count: 0, Dof: NaN, Mean: NaN, P2: NaN, PL: NaN, PR: NaN, Stderr: NaN, T: NaN, Var: NaN }
11) { Count: 0, Dof: NaN, Mean: NaN, P2: NaN, PL: NaN, PR: NaN, Stderr: NaN, T: NaN, Var: NaN }
12) { Count: 0, Dof: NaN, Mean: NaN, P2: NaN, PL: NaN, PR: NaN, Stderr: NaN, T: NaN, Var: NaN }
*** Ctx ping count: 300
    [0](300): TTest.Paired(*3: *1x, Add(*3.0, Num<r8>(#2)), Add(*3.1, Num<r8>(#2)))
###
> "End cross checking section."
"End cross checking section." : s
BndKind:Str, Type:s, Bnd:(str(End cross checking section.))
Func sig: () to s
Type: str, Value: End cross checking section.
###
> "Two-sample standard error calculations. For the given data, the reported standard errors are 3.58067 and 3.05833 for equal and unequal variances respectively."
"Two-sample standard error calculations. For the given data, the reported standard errors are 3.58067 and 3.05833 for equal and unequal variances respectively." : s
BndKind:Str, Type:s, Bnd:(str(Two-sample standard error calculations. For the given data, the reported standard errors are 3.58067 and 3.05833 for equal and unequal variances respectively.))
Func sig: () to s
Type: str, Value: Two-sample standard error calculations. For the given data, the reported standard errors are 3.58067 and 3.05833 for equal and unequal variances respectively.
###

**** New definitions: Males, type: i8*
**** New definitions: Females, type: i8*

> TTest.TwoSample(Males, Females, equal_var: true ).Stderr
TTest.TwoSample(Males, Females, equal_var : true).Stderr : r8
BndKind:GetField, Type:r8, Bnd:(GetField(Call(∂.TTest.TwoSample(Call(∂.ForEach([map:1] Global(Males), Num<r8>(Scope(1))):r8*), Call(∂.ForEach([map:2] Global(Females), Num<r8>(Scope(2))):r8*), equal_var : true:b)), Stderr))
Func sig: (<ctx>:x, Males:i8*, Females:i8*) to r8
Type: r8, Value: 3.580667613107303
*** Ctx ping count: 22
    [0:2](22=13+9): TTest.TwoSample(ForEach(*1: Males, Num<r8>(*1)), ForEach(*2: Females, Num<r8>(*2)), equal_var : true)
###
> TTest.TwoSample(Males, Females, equal_var: false).Stderr
TTest.TwoSample(Males, Females, equal_var : false).Stderr : r8
BndKind:GetField, Type:r8, Bnd:(GetField(Call(∂.TTest.TwoSample(Call(∂.ForEach([map:1] Global(Males), Num<r8>(Scope(1))):r8*), Call(∂.ForEach([map:2] Global(Females), Num<r8>(Scope(2))):r8*), equal_var : false:b)), Stderr))
Func sig: (<ctx>:x, Males:i8*, Females:i8*) to r8
Type: r8, Value: 3.058325518703818
*** Ctx ping count: 22
    [0:2](22=13+9): TTest.TwoSample(ForEach(*1: Males, Num<r8>(*1)), ForEach(*2: Females, Num<r8>(*2)), equal_var : false)
###
> "Check proper null filtering."
"Check proper null filtering." : s
BndKind:Str, Type:s, Bnd:(str(Check proper null filtering.))
Func sig: () to s
Type: str, Value: Check proper null filtering.
###

**** New definitions: nA0_1, type: r8?*
**** New definitions: B0_1n, type: r8?*

> "One-sample"
"One-sample" : s
BndKind:Str, Type:s, Bnd:(str(One-sample))
Func sig: () to s
Type: str, Value: One-sample
###
> ForEach(mean: Means, ("nA0_1", mean, TTest.OneSample(nA0_1, mean)))
ForEach(mean : Means, ("nA0_1", mean, TTest.OneSample(nA0_1, mean))) : (s, i8, {Count:i8, Dof:r8, Mean:r8, P2:r8, PL:r8, PR:r8, Stderr:r8, T:r8, Var:r8})*
BndKind:Call, Type:(s, i8, {Count:i8, Dof:r8, Mean:r8, P2:r8, PL:r8, PR:r8, Stderr:r8, T:r8, Var:r8})*, Bnd:(Call(∂.ForEach([map:1] Global(Means), (str(nA0_1), Scope(1), Call(∂.TTest.OneSample(Global(nA0_1), Num<r8>(Scope(1))))):(s, i8, {Count:i8, Dof:r8, Mean:r8, P2:r8, PL:r8, PR:r8, Stderr:r8, T:r8, Var:r8})):(s, i8, {Count:i8, Dof:r8, Mean:r8, P2:r8, PL:r8, PR:r8, Stderr:r8, T:r8, Var:r8})*))
Func sig: (<ctx>:x, Means:i8*, nA0_1:r8?*) to (s, i8, {Count:i8, Dof:r8, Mean:r8, P2:r8, PL:r8, PR:r8, Stderr:r8, T:r8, Var:r8})*
Sequence: Seq<(str,i8,{i8,r8,r8,r8,r8,r8,r8,r8,r8})>
 0) (nA0_1, -1, { Count: 30, Dof: 29, Mean: 0.3380896233333333, P2: 1.3724122949199113E-07, PL: 0.9999999313793853, PR: 6.862061474599557E-08, Stderr: 0.19374953948101742, T: 6.906285439013559, Var: 1.1261665214731897 })
 1) (nA0_1, 0, { Count: 30, Dof: 29, Mean: 0.3380896233333333, P2: 0.09157801313145231, PL: 0.9542109934342738, PR: 0.045789006565726154, Stderr: 0.19374953948101742, T: 1.7449828486764356, Var: 1.1261665214731897 })
 2) (nA0_1, 1, { Count: 30, Dof: 29, Mean: 0.3380896233333333, P2: 0.0018979925385539493, PL: 0.0009489962692769747, PR: 0.999051003730723, Stderr: 0.19374953948101742, T: -3.416319741660688, Var: 1.1261665214731897 })
*** Ctx ping count: 93
    [0](93): TTest.OneSample(nA0_1, Num<r8>(*1x))
###
> "Two-sample"
"Two-sample" : s
BndKind:Str, Type:s, Bnd:(str(Two-sample))
Func sig: () to s
Type: str, Value: Two-sample
###
> ForEach(eqv: EqualVars, ("nA0_1", "B0_1n", eqv, TTest.TwoSample(nA0_1, B0_1n, eqv)))
ForEach(eqv : EqualVars, ("nA0_1", "B0_1n", eqv, TTest.TwoSample(nA0_1, B0_1n, eqv))) : (s, s, b, {CountX:i8, CountY:i8, Dof:r8, MeanX:r8, MeanY:r8, P2:r8, PL:r8, PR:r8, Stderr:r8, T:r8, VarX:r8, VarY:r8})*
BndKind:Call, Type:(s, s, b, {CountX:i8, CountY:i8, Dof:r8, MeanX:r8, MeanY:r8, P2:r8, PL:r8, PR:r8, Stderr:r8, T:r8, VarX:r8, VarY:r8})*, Bnd:(Call(∂.ForEach([map:1] Global(EqualVars), (str(nA0_1), str(B0_1n), Scope(1), Call(∂.TTest.TwoSample(Global(nA0_1), Global(B0_1n), Scope(1)))):(s, s, b, {CountX:i8, CountY:i8, Dof:r8, MeanX:r8, MeanY:r8, P2:r8, PL:r8, PR:r8, Stderr:r8, T:r8, VarX:r8, VarY:r8})):(s, s, b, {CountX:i8, CountY:i8, Dof:r8, MeanX:r8, MeanY:r8, P2:r8, PL:r8, PR:r8, Stderr:r8, T:r8, VarX:r8, VarY:r8})*))
Func sig: (<ctx>:x, EqualVars:b*, nA0_1:r8?*, B0_1n:r8?*) to (s, s, b, {CountX:i8, CountY:i8, Dof:r8, MeanX:r8, MeanY:r8, P2:r8, PL:r8, PR:r8, Stderr:r8, T:r8, VarX:r8, VarY:r8})*
Sequence: Seq<(str,str,bool,{i8,i8,r8,r8,r8,r8,r8,r8,r8,r8,r8,r8})>
 0) (nA0_1, B0_1n, false, { CountX: 30, CountY: 30, Dof: 57.848508775907504, MeanX: 0.3380896233333333, MeanY: -0.41506455433333345, P2: 0.006599893682512459, PL: 0.9967000531587438, PR: 0.0032999468412562294, Stderr: 0.2672504303408604, T: 2.818158895782013, VarX: 1.1261665214731897, VarY: 1.0165172540480627 })
 1) (nA0_1, B0_1n, true , { CountX: 30, CountY: 30, Dof: 58, MeanX: 0.3380896233333333, MeanY: -0.41506455433333345, P2: 0.006594935702908256, PL: 0.9967025321485459, PR: 0.003297467851454128, Stderr: 0.26725043034086043, T: 2.818158895782012, VarX: 1.1261665214731897, VarY: 1.0165172540480627 })
*** Ctx ping count: 124
    [0:2](124=62+62): TTest.TwoSample(nA0_1, B0_1n, *1x)
###
> ForEach(eqv: EqualVars, ("A0_1", "B0_1n", eqv, TTest.TwoSample(A0_1, B0_1n, eqv)))
ForEach(eqv : EqualVars, ("A0_1", "B0_1n", eqv, TTest.TwoSample(A0_1, B0_1n, eqv))) : (s, s, b, {CountX:i8, CountY:i8, Dof:r8, MeanX:r8, MeanY:r8, P2:r8, PL:r8, PR:r8, Stderr:r8, T:r8, VarX:r8, VarY:r8})*
BndKind:Call, Type:(s, s, b, {CountX:i8, CountY:i8, Dof:r8, MeanX:r8, MeanY:r8, P2:r8, PL:r8, PR:r8, Stderr:r8, T:r8, VarX:r8, VarY:r8})*, Bnd:(Call(∂.ForEach([map:1] Global(EqualVars), (str(A0_1), str(B0_1n), Scope(1), Call(∂.TTest.TwoSample(Global(A0_1), Global(B0_1n), Scope(1)))):(s, s, b, {CountX:i8, CountY:i8, Dof:r8, MeanX:r8, MeanY:r8, P2:r8, PL:r8, PR:r8, Stderr:r8, T:r8, VarX:r8, VarY:r8})):(s, s, b, {CountX:i8, CountY:i8, Dof:r8, MeanX:r8, MeanY:r8, P2:r8, PL:r8, PR:r8, Stderr:r8, T:r8, VarX:r8, VarY:r8})*))
Func sig: (<ctx>:x, EqualVars:b*, A0_1:r8*, B0_1n:r8?*) to (s, s, b, {CountX:i8, CountY:i8, Dof:r8, MeanX:r8, MeanY:r8, P2:r8, PL:r8, PR:r8, Stderr:r8, T:r8, VarX:r8, VarY:r8})*
Sequence: Seq<(str,str,bool,{i8,i8,r8,r8,r8,r8,r8,r8,r8,r8,r8,r8})>
 0) (A0_1, B0_1n, false, { CountX: 30, CountY: 30, Dof: 57.848508775907504, MeanX: 0.3380896233333333, MeanY: -0.41506455433333345, P2: 0.006599893682512459, PL: 0.9967000531587438, PR: 0.0032999468412562294, Stderr: 0.2672504303408604, T: 2.818158895782013, VarX: 1.1261665214731897, VarY: 1.0165172540480627 })
 1) (A0_1, B0_1n, true , { CountX: 30, CountY: 30, Dof: 58, MeanX: 0.3380896233333333, MeanY: -0.41506455433333345, P2: 0.006594935702908256, PL: 0.9967025321485459, PR: 0.003297467851454128, Stderr: 0.26725043034086043, T: 2.818158895782012, VarX: 1.1261665214731897, VarY: 1.0165172540480627 })
*** Ctx ping count: 124
    [0:2](124=62+62): TTest.TwoSample(A0_1, B0_1n, *1x)
###
> ForEach(eqv: EqualVars, ("nA0_1", "B0_1", eqv, TTest.TwoSample(nA0_1, B0_1, eqv)))
ForEach(eqv : EqualVars, ("nA0_1", "B0_1", eqv, TTest.TwoSample(nA0_1, B0_1, eqv))) : (s, s, b, {CountX:i8, CountY:i8, Dof:r8, MeanX:r8, MeanY:r8, P2:r8, PL:r8, PR:r8, Stderr:r8, T:r8, VarX:r8, VarY:r8})*
BndKind:Call, Type:(s, s, b, {CountX:i8, CountY:i8, Dof:r8, MeanX:r8, MeanY:r8, P2:r8, PL:r8, PR:r8, Stderr:r8, T:r8, VarX:r8, VarY:r8})*, Bnd:(Call(∂.ForEach([map:1] Global(EqualVars), (str(nA0_1), str(B0_1), Scope(1), Call(∂.TTest.TwoSample(Global(nA0_1), Global(B0_1), Scope(1)))):(s, s, b, {CountX:i8, CountY:i8, Dof:r8, MeanX:r8, MeanY:r8, P2:r8, PL:r8, PR:r8, Stderr:r8, T:r8, VarX:r8, VarY:r8})):(s, s, b, {CountX:i8, CountY:i8, Dof:r8, MeanX:r8, MeanY:r8, P2:r8, PL:r8, PR:r8, Stderr:r8, T:r8, VarX:r8, VarY:r8})*))
Func sig: (<ctx>:x, EqualVars:b*, nA0_1:r8?*, B0_1:r8*) to (s, s, b, {CountX:i8, CountY:i8, Dof:r8, MeanX:r8, MeanY:r8, P2:r8, PL:r8, PR:r8, Stderr:r8, T:r8, VarX:r8, VarY:r8})*
Sequence: Seq<(str,str,bool,{i8,i8,r8,r8,r8,r8,r8,r8,r8,r8,r8,r8})>
 0) (nA0_1, B0_1, false, { CountX: 30, CountY: 30, Dof: 57.848508775907504, MeanX: 0.3380896233333333, MeanY: -0.41506455433333345, P2: 0.006599893682512459, PL: 0.9967000531587438, PR: 0.0032999468412562294, Stderr: 0.2672504303408604, T: 2.818158895782013, VarX: 1.1261665214731897, VarY: 1.0165172540480627 })
 1) (nA0_1, B0_1, true , { CountX: 30, CountY: 30, Dof: 58, MeanX: 0.3380896233333333, MeanY: -0.41506455433333345, P2: 0.006594935702908256, PL: 0.9967025321485459, PR: 0.003297467851454128, Stderr: 0.26725043034086043, T: 2.818158895782012, VarX: 1.1261665214731897, VarY: 1.0165172540480627 })
*** Ctx ping count: 124
    [0:2](124=62+62): TTest.TwoSample(nA0_1, B0_1, *1x)
###
> "Paired"
"Paired" : s
BndKind:Str, Type:s, Bnd:(str(Paired))
Func sig: () to s
Type: str, Value: Paired
###

**** New definitions: PA0_1, type: r8?*
**** New definitions: PB0_1, type: r8?*
**** New definitions: A0_1z, type: r8*
**** New definitions: zB0_1, type: r8*

> TTest.Paired(PA0_1, PB0_1)
TTest.Paired(PA0_1, PB0_1) : {Count:i8, Dof:r8, Mean:r8, P2:r8, PL:r8, PR:r8, Stderr:r8, T:r8, Var:r8}
BndKind:Call, Type:{Count:i8, Dof:r8, Mean:r8, P2:r8, PL:r8, PR:r8, Stderr:r8, T:r8, Var:r8}, Bnd:(Call(∂.TTest.Paired(Global(PA0_1), Global(PB0_1))))
Func sig: (<ctx>:x, PA0_1:r8?*, PB0_1:r8?*) to {Count:i8, Dof:r8, Mean:r8, P2:r8, PL:r8, PR:r8, Stderr:r8, T:r8, Var:r8}
Type: {i8,r8,r8,r8,r8,r8,r8,r8,r8}, Value: { Count: 30, Dof: 29, Mean: 0.7531541776666667, P2: 0.011889521711396567, PL: 0.9940552391443017, PR: 0.005944760855698283, Stderr: 0.2805851366355025, T: 2.684226921987891, Var: 2.3618405670229086 }
*** Ctx ping count: 33
    [0](33): TTest.Paired(PA0_1, PB0_1)
###
> TTest.Paired(A0_1z, B0_1n)
TTest.Paired(A0_1z, B0_1n) : {Count:i8, Dof:r8, Mean:r8, P2:r8, PL:r8, PR:r8, Stderr:r8, T:r8, Var:r8}
BndKind:Call, Type:{Count:i8, Dof:r8, Mean:r8, P2:r8, PL:r8, PR:r8, Stderr:r8, T:r8, Var:r8}, Bnd:(Call(∂.TTest.Paired(Global(A0_1z), Global(B0_1n))))
Func sig: (<ctx>:x, A0_1z:r8*, B0_1n:r8?*) to {Count:i8, Dof:r8, Mean:r8, P2:r8, PL:r8, PR:r8, Stderr:r8, T:r8, Var:r8}
Type: {i8,r8,r8,r8,r8,r8,r8,r8,r8}, Value: { Count: 30, Dof: 29, Mean: 0.7531541776666667, P2: 0.011889521711396567, PL: 0.9940552391443017, PR: 0.005944760855698283, Stderr: 0.2805851366355025, T: 2.684226921987891, Var: 2.3618405670229086 }
*** Ctx ping count: 31
    [0](31): TTest.Paired(A0_1z, B0_1n)
###
> TTest.Paired(nA0_1, zB0_1)
TTest.Paired(nA0_1, zB0_1) : {Count:i8, Dof:r8, Mean:r8, P2:r8, PL:r8, PR:r8, Stderr:r8, T:r8, Var:r8}
BndKind:Call, Type:{Count:i8, Dof:r8, Mean:r8, P2:r8, PL:r8, PR:r8, Stderr:r8, T:r8, Var:r8}, Bnd:(Call(∂.TTest.Paired(Global(nA0_1), Global(zB0_1))))
Func sig: (<ctx>:x, nA0_1:r8?*, zB0_1:r8*) to {Count:i8, Dof:r8, Mean:r8, P2:r8, PL:r8, PR:r8, Stderr:r8, T:r8, Var:r8}
Type: {i8,r8,r8,r8,r8,r8,r8,r8,r8}, Value: { Count: 30, Dof: 29, Mean: 0.7531541776666667, P2: 0.011889521711396567, PL: 0.9940552391443017, PR: 0.005944760855698283, Stderr: 0.2805851366355025, T: 2.684226921987891, Var: 2.3618405670229086 }
*** Ctx ping count: 31
    [0](31): TTest.Paired(nA0_1, zB0_1)
###
> "Paired with selectors"
"Paired with selectors" : s
BndKind:Str, Type:s, Bnd:(str(Paired with selectors))
Func sig: () to s
Type: str, Value: Paired with selectors
###
> TTest.Paired(Zip(x: PA0_1, y: PB0_1, (x, y)), it[0], it[1])
TTest.Paired(Zip(x : PA0_1, y : PB0_1, (x, y)), it[0], it[1]) : {Count:i8, Dof:r8, Mean:r8, P2:r8, PL:r8, PR:r8, Stderr:r8, T:r8, Var:r8}
BndKind:Call, Type:{Count:i8, Dof:r8, Mean:r8, P2:r8, PL:r8, PR:r8, Stderr:r8, T:r8, Var:r8}, Bnd:(Call(∂.TTest.Paired([map:3] Call(∂.ForEach([map:1] Global(PA0_1), [map:2] Global(PB0_1), (Scope(1), Scope(2)):(r8?, r8?)):(r8?, r8?)*), GetSlot(Scope(3), 0), GetSlot(Scope(3), 1))))
Func sig: (<ctx>:x, PA0_1:r8?*, PB0_1:r8?*) to {Count:i8, Dof:r8, Mean:r8, P2:r8, PL:r8, PR:r8, Stderr:r8, T:r8, Var:r8}
Type: {i8,r8,r8,r8,r8,r8,r8,r8,r8}, Value: { Count: 30, Dof: 29, Mean: 0.7531541776666667, P2: 0.011889521711396567, PL: 0.9940552391443017, PR: 0.005944760855698283, Stderr: 0.2805851366355025, T: 2.684226921987891, Var: 2.3618405670229086 }
*** Ctx ping count: 33
    [0](33): TTest.Paired(*3: ForEach(*1: PA0_1, *2: PB0_1, (*1, *2)), *3.0, *3.1)
###
> TTest.Paired(Zip(x: A0_1z, y: B0_1n, (x, y)), it[0], it[1])
TTest.Paired(Zip(x : A0_1z, y : B0_1n, (x, y)), it[0], it[1]) : {Count:i8, Dof:r8, Mean:r8, P2:r8, PL:r8, PR:r8, Stderr:r8, T:r8, Var:r8}
BndKind:Call, Type:{Count:i8, Dof:r8, Mean:r8, P2:r8, PL:r8, PR:r8, Stderr:r8, T:r8, Var:r8}, Bnd:(Call(∂.TTest.Paired([map:3] Call(∂.ForEach([map:1] Global(A0_1z), [map:2] Global(B0_1n), (Scope(1), Scope(2)):(r8, r8?)):(r8, r8?)*), GetSlot(Scope(3), 0), GetSlot(Scope(3), 1))))
Func sig: (<ctx>:x, A0_1z:r8*, B0_1n:r8?*) to {Count:i8, Dof:r8, Mean:r8, P2:r8, PL:r8, PR:r8, Stderr:r8, T:r8, Var:r8}
Type: {i8,r8,r8,r8,r8,r8,r8,r8,r8}, Value: { Count: 30, Dof: 29, Mean: 0.7531541776666667, P2: 0.011889521711396567, PL: 0.9940552391443017, PR: 0.005944760855698283, Stderr: 0.2805851366355025, T: 2.684226921987891, Var: 2.3618405670229086 }
*** Ctx ping count: 31
    [0](31): TTest.Paired(*3: ForEach(*1: A0_1z, *2: B0_1n, (*1, *2)), *3.0, *3.1)
###
> TTest.Paired(Zip(x: nA0_1, y: zB0_1, (x, y)), it[0], it[1])
TTest.Paired(Zip(x : nA0_1, y : zB0_1, (x, y)), it[0], it[1]) : {Count:i8, Dof:r8, Mean:r8, P2:r8, PL:r8, PR:r8, Stderr:r8, T:r8, Var:r8}
BndKind:Call, Type:{Count:i8, Dof:r8, Mean:r8, P2:r8, PL:r8, PR:r8, Stderr:r8, T:r8, Var:r8}, Bnd:(Call(∂.TTest.Paired([map:3] Call(∂.ForEach([map:1] Global(nA0_1), [map:2] Global(zB0_1), (Scope(1), Scope(2)):(r8?, r8)):(r8?, r8)*), GetSlot(Scope(3), 0), GetSlot(Scope(3), 1))))
Func sig: (<ctx>:x, nA0_1:r8?*, zB0_1:r8*) to {Count:i8, Dof:r8, Mean:r8, P2:r8, PL:r8, PR:r8, Stderr:r8, T:r8, Var:r8}
Type: {i8,r8,r8,r8,r8,r8,r8,r8,r8}, Value: { Count: 30, Dof: 29, Mean: 0.7531541776666667, P2: 0.011889521711396567, PL: 0.9940552391443017, PR: 0.005944760855698283, Stderr: 0.2805851366355025, T: 2.684226921987891, Var: 2.3618405670229086 }
*** Ctx ping count: 31
    [0](31): TTest.Paired(*3: ForEach(*1: nA0_1, *2: zB0_1, (*1, *2)), *3.0, *3.1)
###
> "Paired with selectors: add index to each datapoint. Pairs remain unchanged."
"Paired with selectors: add index to each datapoint. Pairs remain unchanged." : s
BndKind:Str, Type:s, Bnd:(str(Paired with selectors: add index to each datapoint. Pairs remain unchanged.))
Func sig: () to s
Type: str, Value: Paired with selectors: add index to each datapoint. Pairs remain unchanged.
###
> TTest.Paired(Zip(x: PA0_1, y: PB0_1, (x, y)), it[0] + #, it[1] + #)
TTest.Paired(Zip(x : PA0_1, y : PB0_1, (x, y)), it[0] + #, it[1] + #) : {Count:i8, Dof:r8, Mean:r8, P2:r8, PL:r8, PR:r8, Stderr:r8, T:r8, Var:r8}
BndKind:Call, Type:{Count:i8, Dof:r8, Mean:r8, P2:r8, PL:r8, PR:r8, Stderr:r8, T:r8, Var:r8}, Bnd:(Call(∂.TTest.Paired([map:4] Call(∂.ForEach([map:1] Global(PA0_1), [map:2] Global(PB0_1), (Scope(1), Scope(2)):(r8?, r8?)):(r8?, r8?)*), Call(∂.Guard([guard:5] GetSlot(Scope(4), 0), Add(Scope(5), Num<r8>(Scope(3)))):r8?), Call(∂.Guard([guard:6] GetSlot(Scope(4), 1), Add(Scope(6), Num<r8>(Scope(3)))):r8?))))
Func sig: (<ctx>:x, PA0_1:r8?*, PB0_1:r8?*) to {Count:i8, Dof:r8, Mean:r8, P2:r8, PL:r8, PR:r8, Stderr:r8, T:r8, Var:r8}
Type: {i8,r8,r8,r8,r8,r8,r8,r8,r8}, Value: { Count: 30, Dof: 29, Mean: 0.7531541776666667, P2: 0.011889521711396345, PL: 0.9940552391443018, PR: 0.005944760855698172, Stderr: 0.2805851366355024, T: 2.684226921987892, Var: 2.361840567022907 }
*** Ctx ping count: 33
    [0](33): TTest.Paired(*4: ForEach(*1: PA0_1, *2: PB0_1, (*1, *2)), Guard(?5: *4.0, Add(?5, Num<r8>(#3))), Guard(?6: *4.1, Add(?6, Num<r8>(#3))))
###
> TTest.Paired(Zip(x: A0_1z, y: B0_1n, (x, y)), it[0] + #, it[1] + #)
TTest.Paired(Zip(x : A0_1z, y : B0_1n, (x, y)), it[0] + #, it[1] + #) : {Count:i8, Dof:r8, Mean:r8, P2:r8, PL:r8, PR:r8, Stderr:r8, T:r8, Var:r8}
BndKind:Call, Type:{Count:i8, Dof:r8, Mean:r8, P2:r8, PL:r8, PR:r8, Stderr:r8, T:r8, Var:r8}, Bnd:(Call(∂.TTest.Paired([map:4] Call(∂.ForEach([map:1] Global(A0_1z), [map:2] Global(B0_1n), (Scope(1), Scope(2)):(r8, r8?)):(r8, r8?)*), Add(GetSlot(Scope(4), 0), Num<r8>(Scope(3))), Call(∂.Guard([guard:5] GetSlot(Scope(4), 1), Add(Scope(5), Num<r8>(Scope(3)))):r8?))))
Func sig: (<ctx>:x, A0_1z:r8*, B0_1n:r8?*) to {Count:i8, Dof:r8, Mean:r8, P2:r8, PL:r8, PR:r8, Stderr:r8, T:r8, Var:r8}
Type: {i8,r8,r8,r8,r8,r8,r8,r8,r8}, Value: { Count: 30, Dof: 29, Mean: 0.7531541776666667, P2: 0.011889521711396345, PL: 0.9940552391443018, PR: 0.005944760855698172, Stderr: 0.2805851366355024, T: 2.684226921987892, Var: 2.361840567022907 }
*** Ctx ping count: 31
    [0](31): TTest.Paired(*4: ForEach(*1: A0_1z, *2: B0_1n, (*1, *2)), Add(*4.0, Num<r8>(#3)), Guard(?5: *4.1, Add(?5, Num<r8>(#3))))
###
> TTest.Paired(Zip(x: nA0_1, y: zB0_1, (x, y)), it[0] + #, it[1] + #)
TTest.Paired(Zip(x : nA0_1, y : zB0_1, (x, y)), it[0] + #, it[1] + #) : {Count:i8, Dof:r8, Mean:r8, P2:r8, PL:r8, PR:r8, Stderr:r8, T:r8, Var:r8}
BndKind:Call, Type:{Count:i8, Dof:r8, Mean:r8, P2:r8, PL:r8, PR:r8, Stderr:r8, T:r8, Var:r8}, Bnd:(Call(∂.TTest.Paired([map:4] Call(∂.ForEach([map:1] Global(nA0_1), [map:2] Global(zB0_1), (Scope(1), Scope(2)):(r8?, r8)):(r8?, r8)*), Call(∂.Guard([guard:5] GetSlot(Scope(4), 0), Add(Scope(5), Num<r8>(Scope(3)))):r8?), Add(GetSlot(Scope(4), 1), Num<r8>(Scope(3))))))
Func sig: (<ctx>:x, nA0_1:r8?*, zB0_1:r8*) to {Count:i8, Dof:r8, Mean:r8, P2:r8, PL:r8, PR:r8, Stderr:r8, T:r8, Var:r8}
Type: {i8,r8,r8,r8,r8,r8,r8,r8,r8}, Value: { Count: 30, Dof: 29, Mean: 0.7531541776666667, P2: 0.011889521711396345, PL: 0.9940552391443018, PR: 0.005944760855698172, Stderr: 0.2805851366355024, T: 2.684226921987892, Var: 2.361840567022907 }
*** Ctx ping count: 31
    [0](31): TTest.Paired(*4: ForEach(*1: nA0_1, *2: zB0_1, (*1, *2)), Guard(?5: *4.0, Add(?5, Num<r8>(#3))), Add(*4.1, Num<r8>(#3)))
###
> "Check dof behavior with insufficient count(s)."
"Check dof behavior with insufficient count(s)." : s
BndKind:Str, Type:s, Bnd:(str(Check dof behavior with insufficient count(s).))
Func sig: () to s
Type: str, Value: Check dof behavior with insufficient count(s).
###

**** New definitions: Dn, type: (v*, s)
**** New definitions: D1, type: (i8*, s)
**** New definitions: D1n, type: (i8?*, s)
**** New definitions: D2, type: (i8*, s)
**** New definitions: Ds, type: (i8?*, s)*
**** New definitions: DPairs, type: ((i8?*, s), (i8?*, s))*

> "One-sample"
"One-sample" : s
BndKind:Str, Type:s, Bnd:(str(One-sample))
Func sig: () to s
Type: str, Value: One-sample
###
> ForEach(x: Ds, [if] x[1] != "D2", (x[1], TTest.OneSample(x[0])))->Chain()
ForEach(x : Ds, [if] x[1] !@= "D2", (x[1], TTest.OneSample(x[0])))->Chain() : (s, {Count:i8, Dof:r8, Mean:r8, P2:r8, PL:r8, PR:r8, Stderr:r8, T:r8, Var:r8})*
BndKind:Call, Type:(s, {Count:i8, Dof:r8, Mean:r8, P2:r8, PL:r8, PR:r8, Stderr:r8, T:r8, Var:r8})*, Bnd:(Call(∂.ForEach([map:1] Global(Ds), [if] Cmp(GetSlot(Scope(1), 1) !@= str(D2)), (GetSlot(Scope(1), 1), Call(∂.TTest.OneSample(Call(∂.ForEach([map:2] GetSlot(Scope(1), 0), Call(∂.Guard([guard:3] Scope(2), Num<r8>(Scope(3))):r8?)):r8?*)))):(s, {Count:i8, Dof:r8, Mean:r8, P2:r8, PL:r8, PR:r8, Stderr:r8, T:r8, Var:r8})):(s, {Count:i8, Dof:r8, Mean:r8, P2:r8, PL:r8, PR:r8, Stderr:r8, T:r8, Var:r8})*))
Func sig: (<ctx>:x, Ds:(i8?*, s)*) to (s, {Count:i8, Dof:r8, Mean:r8, P2:r8, PL:r8, PR:r8, Stderr:r8, T:r8, Var:r8})*
Sequence: Seq<(str,{i8,r8,r8,r8,r8,r8,r8,r8,r8})>
 0) (Dn, { Count: 0, Dof: NaN, Mean: NaN, P2: NaN, PL: NaN, PR: NaN, Stderr: NaN, T: NaN, Var: NaN })
 1) (D1, { Count: 1, Dof: 0, Mean: 1, P2: NaN, PL: NaN, PR: NaN, Stderr: NaN, T: NaN, Var: NaN })
 2) (D1n, { Count: 1, Dof: 0, Mean: 1, P2: NaN, PL: NaN, PR: NaN, Stderr: NaN, T: NaN, Var: NaN })
*** Ctx ping count: 8
    [0](3): TTest.OneSample(ForEach(*2: *1x.0, Guard(?3: *2, Num<r8>(?3))))
    [1](5): ForEach(*1: Ds, [if] *1.1 !@= "D2", (*1.1, TTest.OneSample(ForEach(*2: *1.0, Guard(?3: *2, Num<r8>(?3))))))
###
> TTest.OneSample([ 1 ]->Take(Wrap(0)))
TTest.OneSample([1]->Take(Wrap(0))) : {Count:i8, Dof:r8, Mean:r8, P2:r8, PL:r8, PR:r8, Stderr:r8, T:r8, Var:r8}
BndKind:Call, Type:{Count:i8, Dof:r8, Mean:r8, P2:r8, PL:r8, PR:r8, Stderr:r8, T:r8, Var:r8}, Bnd:(Call(∂.TTest.OneSample(Call(∂.ForEach([map:1] Call(∂.Take([1:i8]:i8*, Call(∂.Test.Wrap(0:i8):i8)):i8*), Num<r8>(Scope(1))):r8*))))
Func sig: (<ctx>:x) to {Count:i8, Dof:r8, Mean:r8, P2:r8, PL:r8, PR:r8, Stderr:r8, T:r8, Var:r8}
Type: {i8,r8,r8,r8,r8,r8,r8,r8,r8}, Value: { Count: 0, Dof: NaN, Mean: NaN, P2: NaN, PL: NaN, PR: NaN, Stderr: NaN, T: NaN, Var: NaN }
*** Ctx ping count: 0
###
> "Two-sample"
"Two-sample" : s
BndKind:Str, Type:s, Bnd:(str(Two-sample))
Func sig: () to s
Type: str, Value: Two-sample
###
> ForEach(p: DPairs, ForEach(eqv: EqualVars, (p[0][1], p[1][1], eqv, TTest.TwoSample(p[0][0], p[1][0], equal_var: eqv))))->ChainMap()
ForEach(p : DPairs, ForEach(eqv : EqualVars, (p[0][1], p[1][1], eqv, TTest.TwoSample(p[0][0], p[1][0], equal_var : eqv))))->ChainMap() : (s, s, b, {CountX:i8, CountY:i8, Dof:r8, MeanX:r8, MeanY:r8, P2:r8, PL:r8, PR:r8, Stderr:r8, T:r8, VarX:r8, VarY:r8})*
BndKind:Call, Type:(s, s, b, {CountX:i8, CountY:i8, Dof:r8, MeanX:r8, MeanY:r8, P2:r8, PL:r8, PR:r8, Stderr:r8, T:r8, VarX:r8, VarY:r8})*, Bnd:(Call(∂.ChainMap(Call(∂.ForEach([map:1] Global(DPairs), Call(∂.With([with:4] Call(∂.ForEach([map:2] GetSlot(GetSlot(Scope(1), 0), 0), Call(∂.Guard([guard:3] Scope(2), Num<r8>(Scope(3))):r8?)):r8?*), [with:7] Call(∂.ForEach([map:5] GetSlot(GetSlot(Scope(1), 1), 0), Call(∂.Guard([guard:6] Scope(5), Num<r8>(Scope(6))):r8?)):r8?*), Call(∂.ForEach([map:8] Global(EqualVars), (GetSlot(GetSlot(Scope(1), 0), 1), GetSlot(GetSlot(Scope(1), 1), 1), Scope(8), Call(∂.TTest.TwoSample(Scope(4), Scope(7), equal_var : Scope(8)))):(s, s, b, {CountX:i8, CountY:i8, Dof:r8, MeanX:r8, MeanY:r8, P2:r8, PL:r8, PR:r8, Stderr:r8, T:r8, VarX:r8, VarY:r8})):(s, s, b, {CountX:i8, CountY:i8, Dof:r8, MeanX:r8, MeanY:r8, P2:r8, PL:r8, PR:r8, Stderr:r8, T:r8, VarX:r8, VarY:r8})*)):(s, s, b, {CountX:i8, CountY:i8, Dof:r8, MeanX:r8, MeanY:r8, P2:r8, PL:r8, PR:r8, Stderr:r8, T:r8, VarX:r8, VarY:r8})*)):(s, s, b, {CountX:i8, CountY:i8, Dof:r8, MeanX:r8, MeanY:r8, P2:r8, PL:r8, PR:r8, Stderr:r8, T:r8, VarX:r8, VarY:r8})**)):(s, s, b, {CountX:i8, CountY:i8, Dof:r8, MeanX:r8, MeanY:r8, P2:r8, PL:r8, PR:r8, Stderr:r8, T:r8, VarX:r8, VarY:r8})*))
Func sig: (<ctx>:x, DPairs:((i8?*, s), (i8?*, s))*, EqualVars:b*) to (s, s, b, {CountX:i8, CountY:i8, Dof:r8, MeanX:r8, MeanY:r8, P2:r8, PL:r8, PR:r8, Stderr:r8, T:r8, VarX:r8, VarY:r8})*
Sequence: Seq<(str,str,bool,{i8,i8,r8,r8,r8,r8,r8,r8,r8,r8,r8,r8})>
 0) (Dn, Dn, false, { CountX: 0, CountY: 0, Dof: NaN, MeanX: NaN, MeanY: NaN, P2: NaN, PL: NaN, PR: NaN, Stderr: NaN, T: NaN, VarX: NaN, VarY: NaN })
 1) (Dn, Dn, true , { CountX: 0, CountY: 0, Dof: NaN, MeanX: NaN, MeanY: NaN, P2: NaN, PL: NaN, PR: NaN, Stderr: NaN, T: NaN, VarX: NaN, VarY: NaN })
 2) (Dn, D1, false, { CountX: 0, CountY: 0, Dof: NaN, MeanX: NaN, MeanY: NaN, P2: NaN, PL: NaN, PR: NaN, Stderr: NaN, T: NaN, VarX: NaN, VarY: NaN })
 3) (Dn, D1, true , { CountX: 0, CountY: 0, Dof: NaN, MeanX: NaN, MeanY: NaN, P2: NaN, PL: NaN, PR: NaN, Stderr: NaN, T: NaN, VarX: NaN, VarY: NaN })
 4) (Dn, D1n, false, { CountX: 0, CountY: 0, Dof: NaN, MeanX: NaN, MeanY: NaN, P2: NaN, PL: NaN, PR: NaN, Stderr: NaN, T: NaN, VarX: NaN, VarY: NaN })
 5) (Dn, D1n, true , { CountX: 0, CountY: 0, Dof: NaN, MeanX: NaN, MeanY: NaN, P2: NaN, PL: NaN, PR: NaN, Stderr: NaN, T: NaN, VarX: NaN, VarY: NaN })
 6) (Dn, D2, false, { CountX: 0, CountY: 0, Dof: NaN, MeanX: NaN, MeanY: NaN, P2: NaN, PL: NaN, PR: NaN, Stderr: NaN, T: NaN, VarX: NaN, VarY: NaN })
 7) (Dn, D2, true , { CountX: 0, CountY: 0, Dof: NaN, MeanX: NaN, MeanY: NaN, P2: NaN, PL: NaN, PR: NaN, Stderr: NaN, T: NaN, VarX: NaN, VarY: NaN })
 8) (D1, Dn, false, { CountX: 0, CountY: 0, Dof: NaN, MeanX: NaN, MeanY: NaN, P2: NaN, PL: NaN, PR: NaN, Stderr: NaN, T: NaN, VarX: NaN, VarY: NaN })
 9) (D1, Dn, true , { CountX: 0, CountY: 0, Dof: NaN, MeanX: NaN, MeanY: NaN, P2: NaN, PL: NaN, PR: NaN, Stderr: NaN, T: NaN, VarX: NaN, VarY: NaN })
10) (D1, D1, false, { CountX: 1, CountY: 1, Dof: NaN, MeanX: 1, MeanY: 1, P2: NaN, PL: NaN, PR: NaN, Stderr: NaN, T: NaN, VarX: NaN, VarY: NaN })
11) (D1, D1, true , { CountX: 1, CountY: 1, Dof: 0, MeanX: 1, MeanY: 1, P2: NaN, PL: NaN, PR: NaN, Stderr: NaN, T: NaN, VarX: NaN, VarY: NaN })
12) (D1, D1n, false, { CountX: 1, CountY: 1, Dof: NaN, MeanX: 1, MeanY: 1, P2: NaN, PL: NaN, PR: NaN, Stderr: NaN, T: NaN, VarX: NaN, VarY: NaN })
13) (D1, D1n, true , { CountX: 1, CountY: 1, Dof: 0, MeanX: 1, MeanY: 1, P2: NaN, PL: NaN, PR: NaN, Stderr: NaN, T: NaN, VarX: NaN, VarY: NaN })
14) (D1, D2, false, { CountX: 1, CountY: 2, Dof: NaN, MeanX: 1, MeanY: 1.5, P2: NaN, PL: NaN, PR: NaN, Stderr: NaN, T: NaN, VarX: NaN, VarY: 0.5 })
15) (D1, D2, true , { CountX: 1, CountY: 2, Dof: 1, MeanX: 1, MeanY: 1.5, P2: NaN, PL: NaN, PR: NaN, Stderr: NaN, T: NaN, VarX: NaN, VarY: 0.5 })
16) (D1n, Dn, false, { CountX: 0, CountY: 0, Dof: NaN, MeanX: NaN, MeanY: NaN, P2: NaN, PL: NaN, PR: NaN, Stderr: NaN, T: NaN, VarX: NaN, VarY: NaN })
17) (D1n, Dn, true , { CountX: 0, CountY: 0, Dof: NaN, MeanX: NaN, MeanY: NaN, P2: NaN, PL: NaN, PR: NaN, Stderr: NaN, T: NaN, VarX: NaN, VarY: NaN })
18) (D1n, D1, false, { CountX: 1, CountY: 1, Dof: NaN, MeanX: 1, MeanY: 1, P2: NaN, PL: NaN, PR: NaN, Stderr: NaN, T: NaN, VarX: NaN, VarY: NaN })
19) (D1n, D1, true , { CountX: 1, CountY: 1, Dof: 0, MeanX: 1, MeanY: 1, P2: NaN, PL: NaN, PR: NaN, Stderr: NaN, T: NaN, VarX: NaN, VarY: NaN })
20) (D1n, D1n, false, { CountX: 1, CountY: 1, Dof: NaN, MeanX: 1, MeanY: 1, P2: NaN, PL: NaN, PR: NaN, Stderr: NaN, T: NaN, VarX: NaN, VarY: NaN })
21) (D1n, D1n, true , { CountX: 1, CountY: 1, Dof: 0, MeanX: 1, MeanY: 1, P2: NaN, PL: NaN, PR: NaN, Stderr: NaN, T: NaN, VarX: NaN, VarY: NaN })
22) (D1n, D2, false, { CountX: 1, CountY: 2, Dof: NaN, MeanX: 1, MeanY: 1.5, P2: NaN, PL: NaN, PR: NaN, Stderr: NaN, T: NaN, VarX: NaN, VarY: 0.5 })
23) (D1n, D2, true , { CountX: 1, CountY: 2, Dof: 1, MeanX: 1, MeanY: 1.5, P2: NaN, PL: NaN, PR: NaN, Stderr: NaN, T: NaN, VarX: NaN, VarY: 0.5 })
24) (D2, Dn, false, { CountX: 0, CountY: 0, Dof: NaN, MeanX: NaN, MeanY: NaN, P2: NaN, PL: NaN, PR: NaN, Stderr: NaN, T: NaN, VarX: NaN, VarY: NaN })
25) (D2, Dn, true , { CountX: 0, CountY: 0, Dof: NaN, MeanX: NaN, MeanY: NaN, P2: NaN, PL: NaN, PR: NaN, Stderr: NaN, T: NaN, VarX: NaN, VarY: NaN })
26) (D2, D1, false, { CountX: 2, CountY: 1, Dof: NaN, MeanX: 1.5, MeanY: 1, P2: NaN, PL: NaN, PR: NaN, Stderr: NaN, T: NaN, VarX: 0.5, VarY: NaN })
27) (D2, D1, true , { CountX: 2, CountY: 1, Dof: 1, MeanX: 1.5, MeanY: 1, P2: NaN, PL: NaN, PR: NaN, Stderr: NaN, T: NaN, VarX: 0.5, VarY: NaN })
28) (D2, D1n, false, { CountX: 2, CountY: 1, Dof: NaN, MeanX: 1.5, MeanY: 1, P2: NaN, PL: NaN, PR: NaN, Stderr: NaN, T: NaN, VarX: 0.5, VarY: NaN })
29) (D2, D1n, true , { CountX: 2, CountY: 1, Dof: 1, MeanX: 1.5, MeanY: 1, P2: NaN, PL: NaN, PR: NaN, Stderr: NaN, T: NaN, VarX: 0.5, VarY: NaN })
*** Ctx ping count: 68
    [0:2](52=26+26): TTest.TwoSample(!1x, !2x, equal_var : *3x)
    [2](16): ChainMap(ForEach(*1: DPairs, With(!4: ForEach(*2: *1.0.0, Guard(?3: *2, Num<r8>(?3))), !7: ForEach(*5: *1.1.0, Guard(?6: *5, Num<r8>(?6))), ForEach(*8: EqualVars, (*1.0.1, *1.1.1, *8, TTest.TwoSample(!4, !7, equal_var : *8))))))
###
> ForEach(eqv: EqualVars, (eqv, TTest.TwoSample([ 1 ]->Take(Wrap(0)), [ 1 ], equal_var: eqv)))
ForEach(eqv : EqualVars, (eqv, TTest.TwoSample([1]->Take(Wrap(0)), [1], equal_var : eqv))) : (b, {CountX:i8, CountY:i8, Dof:r8, MeanX:r8, MeanY:r8, P2:r8, PL:r8, PR:r8, Stderr:r8, T:r8, VarX:r8, VarY:r8})*
BndKind:Call, Type:(b, {CountX:i8, CountY:i8, Dof:r8, MeanX:r8, MeanY:r8, P2:r8, PL:r8, PR:r8, Stderr:r8, T:r8, VarX:r8, VarY:r8})*, Bnd:(Call(∂.With([with:2] Call(∂.ForEach([map:1] Call(∂.Take([1:i8]:i8*, Call(∂.Test.Wrap(0:i8):i8)):i8*), Num<r8>(Scope(1))):r8*), [with:3] [1:r8]:r8*, Call(∂.ForEach([map:4] Global(EqualVars), (Scope(4), Call(∂.TTest.TwoSample(Scope(2), Scope(3), equal_var : Scope(4)))):(b, {CountX:i8, CountY:i8, Dof:r8, MeanX:r8, MeanY:r8, P2:r8, PL:r8, PR:r8, Stderr:r8, T:r8, VarX:r8, VarY:r8})):(b, {CountX:i8, CountY:i8, Dof:r8, MeanX:r8, MeanY:r8, P2:r8, PL:r8, PR:r8, Stderr:r8, T:r8, VarX:r8, VarY:r8})*)):(b, {CountX:i8, CountY:i8, Dof:r8, MeanX:r8, MeanY:r8, P2:r8, PL:r8, PR:r8, Stderr:r8, T:r8, VarX:r8, VarY:r8})*))
Func sig: (<ctx>:x, EqualVars:b*) to (b, {CountX:i8, CountY:i8, Dof:r8, MeanX:r8, MeanY:r8, P2:r8, PL:r8, PR:r8, Stderr:r8, T:r8, VarX:r8, VarY:r8})*
Sequence: Seq<(bool,{i8,i8,r8,r8,r8,r8,r8,r8,r8,r8,r8,r8})>
 0) (false, { CountX: 0, CountY: 0, Dof: NaN, MeanX: NaN, MeanY: NaN, P2: NaN, PL: NaN, PR: NaN, Stderr: NaN, T: NaN, VarX: NaN, VarY: NaN })
 1) (true , { CountX: 0, CountY: 0, Dof: NaN, MeanX: NaN, MeanY: NaN, P2: NaN, PL: NaN, PR: NaN, Stderr: NaN, T: NaN, VarX: NaN, VarY: NaN })
*** Ctx ping count: 0
###
> "Coverage for null samples when one sample contains nulls."
"Coverage for null samples when one sample contains nulls." : s
BndKind:Str, Type:s, Bnd:(str(Coverage for null samples when one sample contains nulls.))
Func sig: () to s
Type: str, Value: Coverage for null samples when one sample contains nulls.
###
> TTest.TwoSample([ 1 ]->Take(Wrap(0)), [ 1, null ])
TTest.TwoSample([1]->Take(Wrap(0)), [1, null]) : {CountX:i8, CountY:i8, Dof:r8, MeanX:r8, MeanY:r8, P2:r8, PL:r8, PR:r8, Stderr:r8, T:r8, VarX:r8, VarY:r8}
BndKind:Call, Type:{CountX:i8, CountY:i8, Dof:r8, MeanX:r8, MeanY:r8, P2:r8, PL:r8, PR:r8, Stderr:r8, T:r8, VarX:r8, VarY:r8}, Bnd:(Call(∂.TTest.TwoSample(Call(∂.ForEach([map:1] Call(∂.Take([1:i8]:i8*, Call(∂.Test.Wrap(0:i8):i8)):i8*), Num<r8>(Scope(1))):r8*), [Opt<r8?>(1:r8), null:r8?]:r8?*)))
Func sig: (<ctx>:x) to {CountX:i8, CountY:i8, Dof:r8, MeanX:r8, MeanY:r8, P2:r8, PL:r8, PR:r8, Stderr:r8, T:r8, VarX:r8, VarY:r8}
Type: {i8,i8,r8,r8,r8,r8,r8,r8,r8,r8,r8,r8}, Value: { CountX: 0, CountY: 0, Dof: NaN, MeanX: NaN, MeanY: NaN, P2: NaN, PL: NaN, PR: NaN, Stderr: NaN, T: NaN, VarX: NaN, VarY: NaN }
*** Ctx ping count: 0
###
> TTest.TwoSample([ 1 ], [ 1, null ]->Take(Wrap(0)))
TTest.TwoSample([1], [1, null]->Take(Wrap(0))) : {CountX:i8, CountY:i8, Dof:r8, MeanX:r8, MeanY:r8, P2:r8, PL:r8, PR:r8, Stderr:r8, T:r8, VarX:r8, VarY:r8}
BndKind:Call, Type:{CountX:i8, CountY:i8, Dof:r8, MeanX:r8, MeanY:r8, P2:r8, PL:r8, PR:r8, Stderr:r8, T:r8, VarX:r8, VarY:r8}, Bnd:(Call(∂.TTest.TwoSample([1:r8]:r8*, Call(∂.ForEach([map:1] Call(∂.Take([Opt<i8?>(1:i8), null:i8?]:i8?*, Call(∂.Test.Wrap(0:i8):i8)):i8?*), Call(∂.Guard([guard:2] Scope(1), Num<r8>(Scope(2))):r8?)):r8?*))))
Func sig: (<ctx>:x) to {CountX:i8, CountY:i8, Dof:r8, MeanX:r8, MeanY:r8, P2:r8, PL:r8, PR:r8, Stderr:r8, T:r8, VarX:r8, VarY:r8}
Type: {i8,i8,r8,r8,r8,r8,r8,r8,r8,r8,r8,r8}, Value: { CountX: 0, CountY: 0, Dof: NaN, MeanX: NaN, MeanY: NaN, P2: NaN, PL: NaN, PR: NaN, Stderr: NaN, T: NaN, VarX: NaN, VarY: NaN }
*** Ctx ping count: 0
###
> TTest.TwoSample([ 1, null ]->Take(Wrap(0)), [ 1 ])
TTest.TwoSample([1, null]->Take(Wrap(0)), [1]) : {CountX:i8, CountY:i8, Dof:r8, MeanX:r8, MeanY:r8, P2:r8, PL:r8, PR:r8, Stderr:r8, T:r8, VarX:r8, VarY:r8}
BndKind:Call, Type:{CountX:i8, CountY:i8, Dof:r8, MeanX:r8, MeanY:r8, P2:r8, PL:r8, PR:r8, Stderr:r8, T:r8, VarX:r8, VarY:r8}, Bnd:(Call(∂.TTest.TwoSample(Call(∂.ForEach([map:1] Call(∂.Take([Opt<i8?>(1:i8), null:i8?]:i8?*, Call(∂.Test.Wrap(0:i8):i8)):i8?*), Call(∂.Guard([guard:2] Scope(1), Num<r8>(Scope(2))):r8?)):r8?*), [1:r8]:r8*)))
Func sig: (<ctx>:x) to {CountX:i8, CountY:i8, Dof:r8, MeanX:r8, MeanY:r8, P2:r8, PL:r8, PR:r8, Stderr:r8, T:r8, VarX:r8, VarY:r8}
Type: {i8,i8,r8,r8,r8,r8,r8,r8,r8,r8,r8,r8}, Value: { CountX: 0, CountY: 0, Dof: NaN, MeanX: NaN, MeanY: NaN, P2: NaN, PL: NaN, PR: NaN, Stderr: NaN, T: NaN, VarX: NaN, VarY: NaN }
*** Ctx ping count: 0
###
> TTest.TwoSample([ 1, null ], [ 1 ]->Take(Wrap(0)))
TTest.TwoSample([1, null], [1]->Take(Wrap(0))) : {CountX:i8, CountY:i8, Dof:r8, MeanX:r8, MeanY:r8, P2:r8, PL:r8, PR:r8, Stderr:r8, T:r8, VarX:r8, VarY:r8}
BndKind:Call, Type:{CountX:i8, CountY:i8, Dof:r8, MeanX:r8, MeanY:r8, P2:r8, PL:r8, PR:r8, Stderr:r8, T:r8, VarX:r8, VarY:r8}, Bnd:(Call(∂.TTest.TwoSample([Opt<r8?>(1:r8), null:r8?]:r8?*, Call(∂.ForEach([map:1] Call(∂.Take([1:i8]:i8*, Call(∂.Test.Wrap(0:i8):i8)):i8*), Num<r8>(Scope(1))):r8*))))
Func sig: (<ctx>:x) to {CountX:i8, CountY:i8, Dof:r8, MeanX:r8, MeanY:r8, P2:r8, PL:r8, PR:r8, Stderr:r8, T:r8, VarX:r8, VarY:r8}
Type: {i8,i8,r8,r8,r8,r8,r8,r8,r8,r8,r8,r8}, Value: { CountX: 0, CountY: 0, Dof: NaN, MeanX: NaN, MeanY: NaN, P2: NaN, PL: NaN, PR: NaN, Stderr: NaN, T: NaN, VarX: NaN, VarY: NaN }
*** Ctx ping count: 0
###
> TTest.TwoSample([ 1, null ]->Take(Wrap(0)), [ 1, null ])
TTest.TwoSample([1, null]->Take(Wrap(0)), [1, null]) : {CountX:i8, CountY:i8, Dof:r8, MeanX:r8, MeanY:r8, P2:r8, PL:r8, PR:r8, Stderr:r8, T:r8, VarX:r8, VarY:r8}
BndKind:Call, Type:{CountX:i8, CountY:i8, Dof:r8, MeanX:r8, MeanY:r8, P2:r8, PL:r8, PR:r8, Stderr:r8, T:r8, VarX:r8, VarY:r8}, Bnd:(Call(∂.TTest.TwoSample(Call(∂.ForEach([map:1] Call(∂.Take([Opt<i8?>(1:i8), null:i8?]:i8?*, Call(∂.Test.Wrap(0:i8):i8)):i8?*), Call(∂.Guard([guard:2] Scope(1), Num<r8>(Scope(2))):r8?)):r8?*), [Opt<r8?>(1:r8), null:r8?]:r8?*)))
Func sig: (<ctx>:x) to {CountX:i8, CountY:i8, Dof:r8, MeanX:r8, MeanY:r8, P2:r8, PL:r8, PR:r8, Stderr:r8, T:r8, VarX:r8, VarY:r8}
Type: {i8,i8,r8,r8,r8,r8,r8,r8,r8,r8,r8,r8}, Value: { CountX: 0, CountY: 0, Dof: NaN, MeanX: NaN, MeanY: NaN, P2: NaN, PL: NaN, PR: NaN, Stderr: NaN, T: NaN, VarX: NaN, VarY: NaN }
*** Ctx ping count: 0
###
> TTest.TwoSample([ 1, null ], [ 1, null ]->Take(Wrap(0)))
TTest.TwoSample([1, null], [1, null]->Take(Wrap(0))) : {CountX:i8, CountY:i8, Dof:r8, MeanX:r8, MeanY:r8, P2:r8, PL:r8, PR:r8, Stderr:r8, T:r8, VarX:r8, VarY:r8}
BndKind:Call, Type:{CountX:i8, CountY:i8, Dof:r8, MeanX:r8, MeanY:r8, P2:r8, PL:r8, PR:r8, Stderr:r8, T:r8, VarX:r8, VarY:r8}, Bnd:(Call(∂.TTest.TwoSample([Opt<r8?>(1:r8), null:r8?]:r8?*, Call(∂.ForEach([map:1] Call(∂.Take([Opt<i8?>(1:i8), null:i8?]:i8?*, Call(∂.Test.Wrap(0:i8):i8)):i8?*), Call(∂.Guard([guard:2] Scope(1), Num<r8>(Scope(2))):r8?)):r8?*))))
Func sig: (<ctx>:x) to {CountX:i8, CountY:i8, Dof:r8, MeanX:r8, MeanY:r8, P2:r8, PL:r8, PR:r8, Stderr:r8, T:r8, VarX:r8, VarY:r8}
Type: {i8,i8,r8,r8,r8,r8,r8,r8,r8,r8,r8,r8}, Value: { CountX: 0, CountY: 0, Dof: NaN, MeanX: NaN, MeanY: NaN, P2: NaN, PL: NaN, PR: NaN, Stderr: NaN, T: NaN, VarX: NaN, VarY: NaN }
*** Ctx ping count: 0
###
> TTest.Paired([ 1 ]->Take(Wrap(0)), [ 1, null ])
TTest.Paired([1]->Take(Wrap(0)), [1, null]) : {Count:i8, Dof:r8, Mean:r8, P2:r8, PL:r8, PR:r8, Stderr:r8, T:r8, Var:r8}
BndKind:Call, Type:{Count:i8, Dof:r8, Mean:r8, P2:r8, PL:r8, PR:r8, Stderr:r8, T:r8, Var:r8}, Bnd:(Call(∂.TTest.Paired(Call(∂.ForEach([map:1] Call(∂.Take([1:i8]:i8*, Call(∂.Test.Wrap(0:i8):i8)):i8*), Num<r8>(Scope(1))):r8*), [Opt<r8?>(1:r8), null:r8?]:r8?*)))
Func sig: (<ctx>:x) to {Count:i8, Dof:r8, Mean:r8, P2:r8, PL:r8, PR:r8, Stderr:r8, T:r8, Var:r8}
Type: {i8,r8,r8,r8,r8,r8,r8,r8,r8}, Value: { Count: 0, Dof: NaN, Mean: NaN, P2: NaN, PL: NaN, PR: NaN, Stderr: NaN, T: NaN, Var: NaN }
*** Ctx ping count: 0
###
> TTest.Paired([ 1 ], [ 1, null ]->Take(Wrap(0)))
TTest.Paired([1], [1, null]->Take(Wrap(0))) : {Count:i8, Dof:r8, Mean:r8, P2:r8, PL:r8, PR:r8, Stderr:r8, T:r8, Var:r8}
BndKind:Call, Type:{Count:i8, Dof:r8, Mean:r8, P2:r8, PL:r8, PR:r8, Stderr:r8, T:r8, Var:r8}, Bnd:(Call(∂.TTest.Paired([1:r8]:r8*, Call(∂.ForEach([map:1] Call(∂.Take([Opt<i8?>(1:i8), null:i8?]:i8?*, Call(∂.Test.Wrap(0:i8):i8)):i8?*), Call(∂.Guard([guard:2] Scope(1), Num<r8>(Scope(2))):r8?)):r8?*))))
Func sig: (<ctx>:x) to {Count:i8, Dof:r8, Mean:r8, P2:r8, PL:r8, PR:r8, Stderr:r8, T:r8, Var:r8}
Type: {i8,r8,r8,r8,r8,r8,r8,r8,r8}, Value: { Count: 0, Dof: NaN, Mean: NaN, P2: NaN, PL: NaN, PR: NaN, Stderr: NaN, T: NaN, Var: NaN }
*** Ctx ping count: 0
###
> TTest.Paired([ 1, null ]->Take(Wrap(0)), [ 1 ])
TTest.Paired([1, null]->Take(Wrap(0)), [1]) : {Count:i8, Dof:r8, Mean:r8, P2:r8, PL:r8, PR:r8, Stderr:r8, T:r8, Var:r8}
BndKind:Call, Type:{Count:i8, Dof:r8, Mean:r8, P2:r8, PL:r8, PR:r8, Stderr:r8, T:r8, Var:r8}, Bnd:(Call(∂.TTest.Paired(Call(∂.ForEach([map:1] Call(∂.Take([Opt<i8?>(1:i8), null:i8?]:i8?*, Call(∂.Test.Wrap(0:i8):i8)):i8?*), Call(∂.Guard([guard:2] Scope(1), Num<r8>(Scope(2))):r8?)):r8?*), [1:r8]:r8*)))
Func sig: (<ctx>:x) to {Count:i8, Dof:r8, Mean:r8, P2:r8, PL:r8, PR:r8, Stderr:r8, T:r8, Var:r8}
Type: {i8,r8,r8,r8,r8,r8,r8,r8,r8}, Value: { Count: 0, Dof: NaN, Mean: NaN, P2: NaN, PL: NaN, PR: NaN, Stderr: NaN, T: NaN, Var: NaN }
*** Ctx ping count: 0
###
> TTest.Paired([ 1, null ], [ 1 ]->Take(Wrap(0)))
TTest.Paired([1, null], [1]->Take(Wrap(0))) : {Count:i8, Dof:r8, Mean:r8, P2:r8, PL:r8, PR:r8, Stderr:r8, T:r8, Var:r8}
BndKind:Call, Type:{Count:i8, Dof:r8, Mean:r8, P2:r8, PL:r8, PR:r8, Stderr:r8, T:r8, Var:r8}, Bnd:(Call(∂.TTest.Paired([Opt<r8?>(1:r8), null:r8?]:r8?*, Call(∂.ForEach([map:1] Call(∂.Take([1:i8]:i8*, Call(∂.Test.Wrap(0:i8):i8)):i8*), Num<r8>(Scope(1))):r8*))))
Func sig: (<ctx>:x) to {Count:i8, Dof:r8, Mean:r8, P2:r8, PL:r8, PR:r8, Stderr:r8, T:r8, Var:r8}
Type: {i8,r8,r8,r8,r8,r8,r8,r8,r8}, Value: { Count: 0, Dof: NaN, Mean: NaN, P2: NaN, PL: NaN, PR: NaN, Stderr: NaN, T: NaN, Var: NaN }
*** Ctx ping count: 0
###
> TTest.Paired([ 1, null ]->Take(Wrap(0)), [ 1, null ])
TTest.Paired([1, null]->Take(Wrap(0)), [1, null]) : {Count:i8, Dof:r8, Mean:r8, P2:r8, PL:r8, PR:r8, Stderr:r8, T:r8, Var:r8}
BndKind:Call, Type:{Count:i8, Dof:r8, Mean:r8, P2:r8, PL:r8, PR:r8, Stderr:r8, T:r8, Var:r8}, Bnd:(Call(∂.TTest.Paired(Call(∂.ForEach([map:1] Call(∂.Take([Opt<i8?>(1:i8), null:i8?]:i8?*, Call(∂.Test.Wrap(0:i8):i8)):i8?*), Call(∂.Guard([guard:2] Scope(1), Num<r8>(Scope(2))):r8?)):r8?*), [Opt<r8?>(1:r8), null:r8?]:r8?*)))
Func sig: (<ctx>:x) to {Count:i8, Dof:r8, Mean:r8, P2:r8, PL:r8, PR:r8, Stderr:r8, T:r8, Var:r8}
Type: {i8,r8,r8,r8,r8,r8,r8,r8,r8}, Value: { Count: 0, Dof: NaN, Mean: NaN, P2: NaN, PL: NaN, PR: NaN, Stderr: NaN, T: NaN, Var: NaN }
*** Ctx ping count: 0
###
> TTest.Paired([ 1, null ], [ 1, null ]->Take(Wrap(0)))
TTest.Paired([1, null], [1, null]->Take(Wrap(0))) : {Count:i8, Dof:r8, Mean:r8, P2:r8, PL:r8, PR:r8, Stderr:r8, T:r8, Var:r8}
BndKind:Call, Type:{Count:i8, Dof:r8, Mean:r8, P2:r8, PL:r8, PR:r8, Stderr:r8, T:r8, Var:r8}, Bnd:(Call(∂.TTest.Paired([Opt<r8?>(1:r8), null:r8?]:r8?*, Call(∂.ForEach([map:1] Call(∂.Take([Opt<i8?>(1:i8), null:i8?]:i8?*, Call(∂.Test.Wrap(0:i8):i8)):i8?*), Call(∂.Guard([guard:2] Scope(1), Num<r8>(Scope(2))):r8?)):r8?*))))
Func sig: (<ctx>:x) to {Count:i8, Dof:r8, Mean:r8, P2:r8, PL:r8, PR:r8, Stderr:r8, T:r8, Var:r8}
Type: {i8,r8,r8,r8,r8,r8,r8,r8,r8}, Value: { Count: 0, Dof: NaN, Mean: NaN, P2: NaN, PL: NaN, PR: NaN, Stderr: NaN, T: NaN, Var: NaN }
*** Ctx ping count: 0
###
> TTest.Paired([ 1 ]->Take(Wrap(0)), it, it)
TTest.Paired([1]->Take(Wrap(0)), it, it) : {Count:i8, Dof:r8, Mean:r8, P2:r8, PL:r8, PR:r8, Stderr:r8, T:r8, Var:r8}
BndKind:Call, Type:{Count:i8, Dof:r8, Mean:r8, P2:r8, PL:r8, PR:r8, Stderr:r8, T:r8, Var:r8}, Bnd:(Call(∂.TTest.Paired([map:1] Call(∂.Take([1:i8]:i8*, Call(∂.Test.Wrap(0:i8):i8)):i8*), Num<r8>(Scope(1)), Num<r8>(Scope(1)))))
Func sig: (<ctx>:x) to {Count:i8, Dof:r8, Mean:r8, P2:r8, PL:r8, PR:r8, Stderr:r8, T:r8, Var:r8}
Type: {i8,r8,r8,r8,r8,r8,r8,r8,r8}, Value: { Count: 0, Dof: NaN, Mean: NaN, P2: NaN, PL: NaN, PR: NaN, Stderr: NaN, T: NaN, Var: NaN }
*** Ctx ping count: 0
###
> TTest.Paired([ 1 ]->Take(Wrap(0)), it, it if it > 10 else null)
TTest.Paired([1]->Take(Wrap(0)), it, it if it $> 10 else null) : {Count:i8, Dof:r8, Mean:r8, P2:r8, PL:r8, PR:r8, Stderr:r8, T:r8, Var:r8}
BndKind:Call, Type:{Count:i8, Dof:r8, Mean:r8, P2:r8, PL:r8, PR:r8, Stderr:r8, T:r8, Var:r8}, Bnd:(Call(∂.TTest.Paired([map:1] Call(∂.Take([1:i8]:i8*, Call(∂.Test.Wrap(0:i8):i8)):i8*), Num<r8>(Scope(1)), Call(∂.Guard([guard:2] If(Cmp(Scope(1) @> 10:i8), Opt<i8?>(Scope(1)), null:i8?), Num<r8>(Scope(2))):r8?))))
Func sig: (<ctx>:x) to {Count:i8, Dof:r8, Mean:r8, P2:r8, PL:r8, PR:r8, Stderr:r8, T:r8, Var:r8}
Type: {i8,r8,r8,r8,r8,r8,r8,r8,r8}, Value: { Count: 0, Dof: NaN, Mean: NaN, P2: NaN, PL: NaN, PR: NaN, Stderr: NaN, T: NaN, Var: NaN }
*** Ctx ping count: 0
###
> TTest.Paired([ 1 ]->Take(Wrap(0)), it if it > 10 else null, it)
TTest.Paired([1]->Take(Wrap(0)), it if it $> 10 else null, it) : {Count:i8, Dof:r8, Mean:r8, P2:r8, PL:r8, PR:r8, Stderr:r8, T:r8, Var:r8}
BndKind:Call, Type:{Count:i8, Dof:r8, Mean:r8, P2:r8, PL:r8, PR:r8, Stderr:r8, T:r8, Var:r8}, Bnd:(Call(∂.TTest.Paired([map:1] Call(∂.Take([1:i8]:i8*, Call(∂.Test.Wrap(0:i8):i8)):i8*), Call(∂.Guard([guard:2] If(Cmp(Scope(1) @> 10:i8), Opt<i8?>(Scope(1)), null:i8?), Num<r8>(Scope(2))):r8?), Num<r8>(Scope(1)))))
Func sig: (<ctx>:x) to {Count:i8, Dof:r8, Mean:r8, P2:r8, PL:r8, PR:r8, Stderr:r8, T:r8, Var:r8}
Type: {i8,r8,r8,r8,r8,r8,r8,r8,r8}, Value: { Count: 0, Dof: NaN, Mean: NaN, P2: NaN, PL: NaN, PR: NaN, Stderr: NaN, T: NaN, Var: NaN }
*** Ctx ping count: 0
###
> TTest.Paired([ 1 ]->Take(Wrap(0)), it if it > 10 else null, it if it > 10 else null)
TTest.Paired([1]->Take(Wrap(0)), it if it $> 10 else null, it if it $> 10 else null) : {Count:i8, Dof:r8, Mean:r8, P2:r8, PL:r8, PR:r8, Stderr:r8, T:r8, Var:r8}
BndKind:Call, Type:{Count:i8, Dof:r8, Mean:r8, P2:r8, PL:r8, PR:r8, Stderr:r8, T:r8, Var:r8}, Bnd:(Call(∂.TTest.Paired([map:1] Call(∂.Take([1:i8]:i8*, Call(∂.Test.Wrap(0:i8):i8)):i8*), Call(∂.Guard([guard:2] If(Cmp(Scope(1) @> 10:i8), Opt<i8?>(Scope(1)), null:i8?), Num<r8>(Scope(2))):r8?), Call(∂.Guard([guard:3] If(Cmp(Scope(1) @> 10:i8), Opt<i8?>(Scope(1)), null:i8?), Num<r8>(Scope(3))):r8?))))
Func sig: (<ctx>:x) to {Count:i8, Dof:r8, Mean:r8, P2:r8, PL:r8, PR:r8, Stderr:r8, T:r8, Var:r8}
Type: {i8,r8,r8,r8,r8,r8,r8,r8,r8}, Value: { Count: 0, Dof: NaN, Mean: NaN, P2: NaN, PL: NaN, PR: NaN, Stderr: NaN, T: NaN, Var: NaN }
*** Ctx ping count: 0
###
> TTest.Paired([ 1 ]->Take(Wrap(0)), #, it)
TTest.Paired([1]->Take(Wrap(0)), #, it) : {Count:i8, Dof:r8, Mean:r8, P2:r8, PL:r8, PR:r8, Stderr:r8, T:r8, Var:r8}
BndKind:Call, Type:{Count:i8, Dof:r8, Mean:r8, P2:r8, PL:r8, PR:r8, Stderr:r8, T:r8, Var:r8}, Bnd:(Call(∂.TTest.Paired([map:2] Call(∂.Take([1:i8]:i8*, Call(∂.Test.Wrap(0:i8):i8)):i8*), Num<r8>(Scope(1)), Num<r8>(Scope(2)))))
Func sig: (<ctx>:x) to {Count:i8, Dof:r8, Mean:r8, P2:r8, PL:r8, PR:r8, Stderr:r8, T:r8, Var:r8}
Type: {i8,r8,r8,r8,r8,r8,r8,r8,r8}, Value: { Count: 0, Dof: NaN, Mean: NaN, P2: NaN, PL: NaN, PR: NaN, Stderr: NaN, T: NaN, Var: NaN }
*** Ctx ping count: 0
###
> TTest.Paired([ 1 ]->Take(Wrap(0)), #, it if it > 10 else null)
TTest.Paired([1]->Take(Wrap(0)), #, it if it $> 10 else null) : {Count:i8, Dof:r8, Mean:r8, P2:r8, PL:r8, PR:r8, Stderr:r8, T:r8, Var:r8}
BndKind:Call, Type:{Count:i8, Dof:r8, Mean:r8, P2:r8, PL:r8, PR:r8, Stderr:r8, T:r8, Var:r8}, Bnd:(Call(∂.TTest.Paired([map:2] Call(∂.Take([1:i8]:i8*, Call(∂.Test.Wrap(0:i8):i8)):i8*), Num<r8>(Scope(1)), Call(∂.Guard([guard:3] If(Cmp(Scope(2) @> 10:i8), Opt<i8?>(Scope(2)), null:i8?), Num<r8>(Scope(3))):r8?))))
Func sig: (<ctx>:x) to {Count:i8, Dof:r8, Mean:r8, P2:r8, PL:r8, PR:r8, Stderr:r8, T:r8, Var:r8}
Type: {i8,r8,r8,r8,r8,r8,r8,r8,r8}, Value: { Count: 0, Dof: NaN, Mean: NaN, P2: NaN, PL: NaN, PR: NaN, Stderr: NaN, T: NaN, Var: NaN }
*** Ctx ping count: 0
###
> TTest.Paired([ 1 ]->Take(Wrap(0)), # if it > 10 else null, it)
TTest.Paired([1]->Take(Wrap(0)), # if it $> 10 else null, it) : {Count:i8, Dof:r8, Mean:r8, P2:r8, PL:r8, PR:r8, Stderr:r8, T:r8, Var:r8}
BndKind:Call, Type:{Count:i8, Dof:r8, Mean:r8, P2:r8, PL:r8, PR:r8, Stderr:r8, T:r8, Var:r8}, Bnd:(Call(∂.TTest.Paired([map:2] Call(∂.Take([1:i8]:i8*, Call(∂.Test.Wrap(0:i8):i8)):i8*), Call(∂.Guard([guard:3] If(Cmp(Scope(2) @> 10:i8), Opt<i8?>(Scope(1)), null:i8?), Num<r8>(Scope(3))):r8?), Num<r8>(Scope(2)))))
Func sig: (<ctx>:x) to {Count:i8, Dof:r8, Mean:r8, P2:r8, PL:r8, PR:r8, Stderr:r8, T:r8, Var:r8}
Type: {i8,r8,r8,r8,r8,r8,r8,r8,r8}, Value: { Count: 0, Dof: NaN, Mean: NaN, P2: NaN, PL: NaN, PR: NaN, Stderr: NaN, T: NaN, Var: NaN }
*** Ctx ping count: 0
###
> TTest.Paired([ 1 ]->Take(Wrap(0)), # if it > 10 else null, it if it > 10 else null)
TTest.Paired([1]->Take(Wrap(0)), # if it $> 10 else null, it if it $> 10 else null) : {Count:i8, Dof:r8, Mean:r8, P2:r8, PL:r8, PR:r8, Stderr:r8, T:r8, Var:r8}
BndKind:Call, Type:{Count:i8, Dof:r8, Mean:r8, P2:r8, PL:r8, PR:r8, Stderr:r8, T:r8, Var:r8}, Bnd:(Call(∂.TTest.Paired([map:2] Call(∂.Take([1:i8]:i8*, Call(∂.Test.Wrap(0:i8):i8)):i8*), Call(∂.Guard([guard:3] If(Cmp(Scope(2) @> 10:i8), Opt<i8?>(Scope(1)), null:i8?), Num<r8>(Scope(3))):r8?), Call(∂.Guard([guard:4] If(Cmp(Scope(2) @> 10:i8), Opt<i8?>(Scope(2)), null:i8?), Num<r8>(Scope(4))):r8?))))
Func sig: (<ctx>:x) to {Count:i8, Dof:r8, Mean:r8, P2:r8, PL:r8, PR:r8, Stderr:r8, T:r8, Var:r8}
Type: {i8,r8,r8,r8,r8,r8,r8,r8,r8}, Value: { Count: 0, Dof: NaN, Mean: NaN, P2: NaN, PL: NaN, PR: NaN, Stderr: NaN, T: NaN, Var: NaN }
*** Ctx ping count: 0
###
