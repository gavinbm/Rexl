**** New definitions: S, type: s*
**** New definitions: TA, type: {A:s, G:(s, i8), X:r8}*
**** New definitions: TB, type: {A:s, B:s, G:(i8, s), X:r8}*
**** New definitions: TC, type: {A:s, C:{D:s, E:s}*, G:i8}*

> S
S : s*
BndKind:Global, Type:s*, Bnd:(Global(S))
Func sig: (S:s*) to s*
Sequence: Seq<str>
 0) x
 1) xy
 2) <null>
 3) xyz
 4) hi
 5) adios
 6) hola
 7) guten morgen
###
> TA
TA : {A:s, G:(s, i8), X:r8}*
BndKind:Global, Type:{A:s, G:(s, i8), X:r8}*, Bnd:(Global(TA))
Func sig: (TA:{A:s, G:(s, i8), X:r8}*) to {A:s, G:(s, i8), X:r8}*
Sequence: Seq<{str,(str,i8),r8}>
 0) { A: x, G: (x, 0), X: 1 }
 1) { A: xy, G: (xy, 1), X: 2 }
 2) { A: <null>, G: (<null>, 2), X: 3 }
 3) { A: xyz, G: (xyz, 3), X: 4 }
 4) { A: hi, G: (hi, 4), X: 5 }
 5) { A: adios, G: (adios, 5), X: 6 }
 6) { A: hola, G: (hola, 6), X: 7 }
 7) { A: guten morgen, G: (guten morgen, 7), X: 8 }
###
> TB
TB : {A:s, B:s, G:(i8, s), X:r8}*
BndKind:Global, Type:{A:s, B:s, G:(i8, s), X:r8}*, Bnd:(Global(TB))
Func sig: (TB:{A:s, B:s, G:(i8, s), X:r8}*) to {A:s, B:s, G:(i8, s), X:r8}*
Sequence: Seq<{str,str,(i8,str),r8}>
 0) { A: x, B: x, G: (0, x), X: 1 }
 1) { A: <null>, B: xy, G: (1, xy), X: 2 }
 2) { A: <null>, B: <null>, G: (2, <null>), X: 3 }
 3) { A: xyz, B: xyz, G: (3, xyz), X: 4 }
 4) { A: <null>, B: hi, G: (4, hi), X: 5 }
 5) { A: adios, B: <null>, G: (5, adios), X: 6 }
 6) { A: hola, B: hola, G: (6, hola), X: 7 }
 7) { A: <null>, B: guten morgen, G: (7, guten morgen), X: 8 }
###
> TA->Chain([null])->MultiDGSMA() // Error.
TA->Chain([null])->MultiDGSMA() : {A:s, B:s*, G:(s, i8)}*
BndKind:Call, Type:{A:s, B:s*, G:(s, i8)}*, Bnd:(Call(∂.Test.MultiDGSMA.MergeSeq([with:1] Error(ErrBadType_Src_Dst), Scope(1), Scope(1))))
*** Error: (2,4) Node: TA->Chain([null]), Message: Invalid operand type: cannot convert type '{A:s, G:(s, i8), X:r8}?*' to '{A:s, G:(s, i8)}*'
###
> TA->MultiDGS_A()
TA->MultiDGS_A() : {B:s*}*
BndKind:Call, Type:{B:s*}*, Bnd:(Call(∂.Test.MultiDGS_A.Simple(Call(∂.ForEach([map:1] Global(TA), {A:GetField(Scope(1), A), G:GetField(Scope(1), G)})))))
Func sig: (<ctx>:x, TA:{A:s, G:(s, i8), X:r8}*) to {B:s*}*
Sequence: Seq<{Seq<str>}>
 1) { B: Sequence: Seq<str>
         0) A: [xy]
    }
 5) { B: Sequence: Seq<str>
         0) A: [adios]
    }
 3) { B: Sequence: Seq<str>
         0) A: [xyz]
    }
 7) { B: Sequence: Seq<str>
         0) A: [guten morgen]
    }
 0) { B: Sequence: Seq<str>
         0) A: [x]
    }
 4) { B: Sequence: Seq<str>
         0) A: [hi]
    }
 2) { B: Sequence: Seq<str>
         0) A: <null>
    }
 6) { B: Sequence: Seq<str>
         0) A: [hola]
    }
*** Ctx ping count: 0
###
> TA->MultiDGS_A()->Map(B->Text.Concat(", "))
TA->MultiDGS_A()->Map(B->Text.Concat(", ")) : s*
BndKind:Call, Type:s*, Bnd:(Call(∂.ForEach([map:2] Call(∂.Test.MultiDGS_A.Simple(Call(∂.ForEach([map:1] Global(TA), {A:GetField(Scope(1), A), G:GetField(Scope(1), G)})))), Call(∂.Text.Concat(GetField(Scope(2), B), str(, )):s)):s*))
Func sig: (<ctx>:x, TA:{A:s, G:(s, i8), X:r8}*) to s*
Sequence: Seq<str>
 0) A: [x]
 1) A: [xy]
 2) A: <null>
 3) A: [xyz]
 4) A: [hi]
 5) A: [adios]
 6) A: [hola]
 7) A: [guten morgen]
*** Ctx ping count: 16
    [0](16): Text.Concat(*1x.B, ", ")
###
> TB->MultiDGS_A()->Map(B->Text.Concat(", "))
TB->MultiDGS_A()->Map(B->Text.Concat(", ")) : s*
BndKind:Call, Type:s*, Bnd:(Call(∂.ForEach([map:2] Call(∂.Test.MultiDGS_A.Simple(Call(∂.ForEach([map:1] Global(TB), {A:GetField(Scope(1), A), G:GetField(Scope(1), G)})))), Call(∂.Text.Concat(GetField(Scope(2), B), str(, )):s)):s*))
Func sig: (<ctx>:x, TB:{A:s, B:s, G:(i8, s), X:r8}*) to s*
Sequence: Seq<str>
 0) A: [x]
 1) A: <null>
 2) A: <null>
 3) A: [xyz]
 4) A: <null>
 5) A: [adios]
 6) A: [hola]
 7) A: <null>
*** Ctx ping count: 16
    [0](16): Text.Concat(*1x.B, ", ")
###
> TB->MultiDGS_B()->Map(B->Text.Concat(", "))
TB->MultiDGS_B()->Map(B->Text.Concat(", ")) : s*
BndKind:Call, Type:s*, Bnd:(Call(∂.ForEach([map:2] Call(∂.Test.MultiDGS_B.Simple(Call(∂.ForEach([map:1] Global(TB), {A:GetField(Scope(1), A), B:GetField(Scope(1), B), G:GetField(Scope(1), G)})))), Call(∂.Text.Concat(GetField(Scope(2), B), str(, )):s)):s*))
Func sig: (<ctx>:x, TB:{A:s, B:s, G:(i8, s), X:r8}*) to s*
Sequence: Seq<str>
 0) A: [x], B: [x]
 1) A: <null>, B: [xy]
 2) A: <null>, B: <null>
 3) A: [xyz], B: [xyz]
 4) A: <null>, B: [hi]
 5) A: [adios], B: <null>
 6) A: [hola], B: [hola]
 7) A: <null>, B: [guten morgen]
*** Ctx ping count: 24
    [0](24): Text.Concat(*1x.B, ", ")
###
> S->MultiDGSMA(it    ,    it)->Map(B->Text.Concat(", "))
S->MultiDGSMA(it, it)->Map(B->Text.Concat(", ")) : s*
BndKind:Call, Type:s*, Bnd:(Call(∂.ForEach([map:2] Call(∂.Test.MultiDGSMA.Simple(Call(∂.ForEach([map:1] Global(S), {A:Scope(1), G:Scope(1)})))), Call(∂.Text.Concat(GetField(Scope(2), B), str(, )):s)):s*))
Func sig: (<ctx>:x, S:s*) to s*
Sequence: Seq<str>
 0) A: [x]
 1) A: [xy]
 2) A: <null>
 3) A: [xyz]
 4) A: [hi]
 5) A: [adios]
 6) A: [hola]
 7) A: [guten morgen]
*** Ctx ping count: 16
    [0](16): Text.Concat(*1x.B, ", ")
###
> S->MultiDGSMA(it    , A: it)->Map(B->Text.Concat(", "))
S->MultiDGSMA(it, A : it)->Map(B->Text.Concat(", ")) : s*
BndKind:Call, Type:s*, Bnd:(Call(∂.ForEach([map:2] Call(∂.Test.MultiDGSMA.Simple(Call(∂.ForEach([map:1] Global(S), {A:Scope(1), G:Scope(1)})))), Call(∂.Text.Concat(GetField(Scope(2), B), str(, )):s)):s*))
Func sig: (<ctx>:x, S:s*) to s*
Sequence: Seq<str>
 0) A: [x]
 1) A: [xy]
 2) A: <null>
 3) A: [xyz]
 4) A: [hi]
 5) A: [adios]
 6) A: [hola]
 7) A: [guten morgen]
*** Ctx ping count: 16
    [0](16): Text.Concat(*1x.B, ", ")
###
> S->MultiDGSMA(it.Len,    it & "-extra")->Map(B->Text.Concat(", "))
S->MultiDGSMA(it.Len, it & "-extra")->Map(B->Text.Concat(", ")) : s*
BndKind:Call, Type:s*, Bnd:(Call(∂.ForEach([map:2] Call(∂.Test.MultiDGSMA.Simple(Call(∂.ForEach([map:1] Global(S), {A:StrConcat(Scope(1), str(-extra)), G:Call(∂.Text.Len(Scope(1)):i8)})))), Call(∂.Text.Concat(GetField(Scope(2), B), str(, )):s)):s*))
Func sig: (<ctx>:x, S:s*) to s*
Sequence: Seq<str>
 0) A: [x-extra]
 1) A: [xy-extra]
 2) A: [-extra]
 3) A: [xyz-extra]
 4) A: [hi-extra]
 5) A: [adios-extra]
 6) A: [hola-extra]
 7) A: [guten morgen-extra]
*** Ctx ping count: 16
    [0](16): Text.Concat(*1x.B, ", ")
###
> S->MultiDGSMA(it.Len, A: it & "-extra")->Map(B->Text.Concat(", "))
S->MultiDGSMA(it.Len, A : it & "-extra")->Map(B->Text.Concat(", ")) : s*
BndKind:Call, Type:s*, Bnd:(Call(∂.ForEach([map:2] Call(∂.Test.MultiDGSMA.Simple(Call(∂.ForEach([map:1] Global(S), {A:StrConcat(Scope(1), str(-extra)), G:Call(∂.Text.Len(Scope(1)):i8)})))), Call(∂.Text.Concat(GetField(Scope(2), B), str(, )):s)):s*))
Func sig: (<ctx>:x, S:s*) to s*
Sequence: Seq<str>
 0) A: [x-extra]
 1) A: [xy-extra]
 2) A: [-extra]
 3) A: [xyz-extra]
 4) A: [hi-extra]
 5) A: [adios-extra]
 6) A: [hola-extra]
 7) A: [guten morgen-extra]
*** Ctx ping count: 16
    [0](16): Text.Concat(*1x.B, ", ")
###
> S->MultiDGSMB(it,    it)->Map(B->Text.Concat(", "))
S->MultiDGSMB(it, it)->Map(B->Text.Concat(", ")) : s*
BndKind:Call, Type:s*, Bnd:(Call(∂.ForEach([map:2] Call(∂.Test.MultiDGSMB.Simple(Call(∂.ForEach([map:1] Global(S), {A:str(A's default), B:Scope(1), G:Scope(1)})))), Call(∂.Text.Concat(GetField(Scope(2), B), str(, )):s)):s*))
Func sig: (<ctx>:x, S:s*) to s*
Sequence: Seq<str>
 0) A: [A's default], B: [x]
 1) A: [A's default], B: [xy]
 2) A: [A's default], B: <null>
 3) A: [A's default], B: [xyz]
 4) A: [A's default], B: [hi]
 5) A: [A's default], B: [adios]
 6) A: [A's default], B: [hola]
 7) A: [A's default], B: [guten morgen]
*** Ctx ping count: 24
    [0](24): Text.Concat(*1x.B, ", ")
###
> S->MultiDGSMB(it, B: it)->Map(B->Text.Concat(", "))
S->MultiDGSMB(it, B : it)->Map(B->Text.Concat(", ")) : s*
BndKind:Call, Type:s*, Bnd:(Call(∂.ForEach([map:2] Call(∂.Test.MultiDGSMB.Simple(Call(∂.ForEach([map:1] Global(S), {A:str(A's default), B:Scope(1), G:Scope(1)})))), Call(∂.Text.Concat(GetField(Scope(2), B), str(, )):s)):s*))
Func sig: (<ctx>:x, S:s*) to s*
Sequence: Seq<str>
 0) A: [A's default], B: [x]
 1) A: [A's default], B: [xy]
 2) A: [A's default], B: <null>
 3) A: [A's default], B: [xyz]
 4) A: [A's default], B: [hi]
 5) A: [A's default], B: [adios]
 6) A: [A's default], B: [hola]
 7) A: [A's default], B: [guten morgen]
*** Ctx ping count: 24
    [0](24): Text.Concat(*1x.B, ", ")
###
> S->MultiDGSMB(it, A: it)->Map(B->Text.Concat(", "))
S->MultiDGSMB(it, A : it)->Map(B->Text.Concat(", ")) : s*
BndKind:Call, Type:s*, Bnd:(Call(∂.ForEach([map:2] Call(∂.Test.MultiDGSMB.Simple(Call(∂.ForEach([map:1] Global(S), {A:Scope(1), B:str(B def), G:Scope(1)})))), Call(∂.Text.Concat(GetField(Scope(2), B), str(, )):s)):s*))
Func sig: (<ctx>:x, S:s*) to s*
Sequence: Seq<str>
 0) A: [x], B: [B def]
 1) A: [xy], B: [B def]
 2) A: <null>, B: [B def]
 3) A: [xyz], B: [B def]
 4) A: [hi], B: [B def]
 5) A: [adios], B: [B def]
 6) A: [hola], B: [B def]
 7) A: [guten morgen], B: [B def]
*** Ctx ping count: 24
    [0](24): Text.Concat(*1x.B, ", ")
###
> S->MultiDGSMB(it,    it & "-1st",    it & "-2nd")->Map(B->Text.Concat(", "))
S->MultiDGSMB(it, it & "-1st", it & "-2nd")->Map(B->Text.Concat(", ")) : s*
BndKind:Call, Type:s*, Bnd:(Call(∂.ForEach([map:2] Call(∂.Test.MultiDGSMB.Simple(Call(∂.ForEach([map:1] Global(S), {A:StrConcat(Scope(1), str(-2nd)), B:StrConcat(Scope(1), str(-1st)), G:Scope(1)})))), Call(∂.Text.Concat(GetField(Scope(2), B), str(, )):s)):s*))
Func sig: (<ctx>:x, S:s*) to s*
Sequence: Seq<str>
 0) A: [x-2nd], B: [x-1st]
 1) A: [xy-2nd], B: [xy-1st]
 2) A: [-2nd], B: [-1st]
 3) A: [xyz-2nd], B: [xyz-1st]
 4) A: [hi-2nd], B: [hi-1st]
 5) A: [adios-2nd], B: [adios-1st]
 6) A: [hola-2nd], B: [hola-1st]
 7) A: [guten morgen-2nd], B: [guten morgen-1st]
*** Ctx ping count: 24
    [0](24): Text.Concat(*1x.B, ", ")
###
> S->MultiDGSMB(it,    it & "-1st", A: it & "-2nd")->Map(B->Text.Concat(", "))
S->MultiDGSMB(it, it & "-1st", A : it & "-2nd")->Map(B->Text.Concat(", ")) : s*
BndKind:Call, Type:s*, Bnd:(Call(∂.ForEach([map:2] Call(∂.Test.MultiDGSMB.Simple(Call(∂.ForEach([map:1] Global(S), {A:StrConcat(Scope(1), str(-2nd)), B:StrConcat(Scope(1), str(-1st)), G:Scope(1)})))), Call(∂.Text.Concat(GetField(Scope(2), B), str(, )):s)):s*))
Func sig: (<ctx>:x, S:s*) to s*
Sequence: Seq<str>
 0) A: [x-2nd], B: [x-1st]
 1) A: [xy-2nd], B: [xy-1st]
 2) A: [-2nd], B: [-1st]
 3) A: [xyz-2nd], B: [xyz-1st]
 4) A: [hi-2nd], B: [hi-1st]
 5) A: [adios-2nd], B: [adios-1st]
 6) A: [hola-2nd], B: [hola-1st]
 7) A: [guten morgen-2nd], B: [guten morgen-1st]
*** Ctx ping count: 24
    [0](24): Text.Concat(*1x.B, ", ")
###
> S->MultiDGSMB(it,    it & "-1st", B: it & "-2nd")->Map(B->Text.Concat(", ")) // Error.
S->MultiDGSMB(it, it & "-1st", B : it & "-2nd")->Map(B->Text.Concat(", ")) : s*
BndKind:Call, Type:s*, Bnd:(Call(∂.ForEach([map:2] Call(∂.Test.MultiDGSMB*([map:1] Global(S), Scope(1), StrConcat(Scope(1), str(-1st)), B : StrConcat(Scope(1), str(-2nd)))), Call(∂.Text.Concat(GetField(Scope(2), B), str(, )):s)):s*))
*** Error: (1,3) Node: S->MultiDGSMB(it, it & "-1st", B : it & "-2nd"), Message: No overload can be found matching these names and directives.
*** Error: (34,35) Tok: 'B', Message: Parameter name 'B' already specified 1 position(s) prior
###
> S->MultiDGSMB(it, B: it & "-1st",    it & "-2nd")->Map(B->Text.Concat(", "))
S->MultiDGSMB(it, B : it & "-1st", it & "-2nd")->Map(B->Text.Concat(", ")) : s*
BndKind:Call, Type:s*, Bnd:(Call(∂.ForEach([map:2] Call(∂.Test.MultiDGSMB.Simple(Call(∂.ForEach([map:1] Global(S), {A:StrConcat(Scope(1), str(-2nd)), B:StrConcat(Scope(1), str(-1st)), G:Scope(1)})))), Call(∂.Text.Concat(GetField(Scope(2), B), str(, )):s)):s*))
Func sig: (<ctx>:x, S:s*) to s*
Sequence: Seq<str>
 0) A: [x-2nd], B: [x-1st]
 1) A: [xy-2nd], B: [xy-1st]
 2) A: [-2nd], B: [-1st]
 3) A: [xyz-2nd], B: [xyz-1st]
 4) A: [hi-2nd], B: [hi-1st]
 5) A: [adios-2nd], B: [adios-1st]
 6) A: [hola-2nd], B: [hola-1st]
 7) A: [guten morgen-2nd], B: [guten morgen-1st]
*** Ctx ping count: 24
    [0](24): Text.Concat(*1x.B, ", ")
###
> S->MultiDGSMB(it, B: it & "-1st", A: it & "-2nd")->Map(B->Text.Concat(", "))
S->MultiDGSMB(it, B : it & "-1st", A : it & "-2nd")->Map(B->Text.Concat(", ")) : s*
BndKind:Call, Type:s*, Bnd:(Call(∂.ForEach([map:2] Call(∂.Test.MultiDGSMB.Simple(Call(∂.ForEach([map:1] Global(S), {A:StrConcat(Scope(1), str(-2nd)), B:StrConcat(Scope(1), str(-1st)), G:Scope(1)})))), Call(∂.Text.Concat(GetField(Scope(2), B), str(, )):s)):s*))
Func sig: (<ctx>:x, S:s*) to s*
Sequence: Seq<str>
 0) A: [x-2nd], B: [x-1st]
 1) A: [xy-2nd], B: [xy-1st]
 2) A: [-2nd], B: [-1st]
 3) A: [xyz-2nd], B: [xyz-1st]
 4) A: [hi-2nd], B: [hi-1st]
 5) A: [adios-2nd], B: [adios-1st]
 6) A: [hola-2nd], B: [hola-1st]
 7) A: [guten morgen-2nd], B: [guten morgen-1st]
*** Ctx ping count: 24
    [0](24): Text.Concat(*1x.B, ", ")
###
> S->MultiDGSMB(it, A: it & "-1st",    it & "-2nd")->Map(B->Text.Concat(", ")) // Error.
S->MultiDGSMB(it, A : it & "-1st", it & "-2nd")->Map(B->Text.Concat(", ")) : s*
BndKind:Call, Type:s*, Bnd:(Call(∂.ForEach([map:2] Call(∂.Test.MultiDGSMB*([map:1] Global(S), Scope(1), A : StrConcat(Scope(1), str(-1st)), StrConcat(Scope(1), str(-2nd)))), Call(∂.Text.Concat(GetField(Scope(2), B), str(, )):s)):s*))
*** Error: (1,3) Node: S->MultiDGSMB(it, A : it & "-1st", it & "-2nd"), Message: No overload can be found matching these names and directives.
*** Error: (40,41) Node: it & "-2nd", Message: The argument in position 4 of 'MultiDGSMB' should include a field name
###
> S->MultiDGSMB(it, A: it & "-1st", B: it & "-2nd")->Map(B->Text.Concat(", "))
S->MultiDGSMB(it, A : it & "-1st", B : it & "-2nd")->Map(B->Text.Concat(", ")) : s*
BndKind:Call, Type:s*, Bnd:(Call(∂.ForEach([map:2] Call(∂.Test.MultiDGSMB.Simple(Call(∂.ForEach([map:1] Global(S), {A:StrConcat(Scope(1), str(-1st)), B:StrConcat(Scope(1), str(-2nd)), G:Scope(1)})))), Call(∂.Text.Concat(GetField(Scope(2), B), str(, )):s)):s*))
Func sig: (<ctx>:x, S:s*) to s*
Sequence: Seq<str>
 0) A: [x-1st], B: [x-2nd]
 1) A: [xy-1st], B: [xy-2nd]
 2) A: [-1st], B: [-2nd]
 3) A: [xyz-1st], B: [xyz-2nd]
 4) A: [hi-1st], B: [hi-2nd]
 5) A: [adios-1st], B: [adios-2nd]
 6) A: [hola-1st], B: [hola-2nd]
 7) A: [guten morgen-1st], B: [guten morgen-2nd]
*** Ctx ping count: 24
    [0](24): Text.Concat(*1x.B, ", ")
###
> S->MultiDGsMB(it) // Error.
S->MultiDGsMB(it) : {B:s*}*
BndKind:Call, Type:{B:s*}*, Bnd:(Call(∂.Test.MultiDGsMB.Simple(Call(∂.ForEach([map:1] Global(S), Error(ErrBadType_Src_Dst))))))
*** Error: (14,16) Node: it, Message: Invalid operand type: cannot convert type 's' to '{A:s, B:s, G:g}'
###
> S->MultiDGsMB({ G: "g-" & it, A: "a-" & it, B: "b-" & it })->Map(B->Text.Concat(", "))
S->MultiDGsMB({ G : "g-" & it, A : "a-" & it, B : "b-" & it })->Map(B->Text.Concat(", ")) : s*
BndKind:Call, Type:s*, Bnd:(Call(∂.ForEach([map:2] Call(∂.Test.MultiDGsMB.Simple(Call(∂.ForEach([map:1] Global(S), {A:StrConcat(str(a-), Scope(1)), B:StrConcat(str(b-), Scope(1)), G:StrConcat(str(g-), Scope(1))})))), Call(∂.Text.Concat(GetField(Scope(2), B), str(, )):s)):s*))
Func sig: (<ctx>:x, S:s*) to s*
Sequence: Seq<str>
 0) A: [a-x], B: [b-x]
 1) A: [a-xy], B: [b-xy]
 2) A: [a-], B: [b-]
 3) A: [a-xyz], B: [b-xyz]
 4) A: [a-hi], B: [b-hi]
 5) A: [a-adios], B: [b-adios]
 6) A: [a-hola], B: [b-hola]
 7) A: [a-guten morgen], B: [b-guten morgen]
*** Ctx ping count: 24
    [0](24): Text.Concat(*1x.B, ", ")
###
> TA->MultiDGSMA()
TA->MultiDGSMA() : {A:s, B:s*, G:(s, i8), X:r8}*
BndKind:Call, Type:{A:s, B:s*, G:(s, i8), X:r8}*, Bnd:(Call(∂.Test.MultiDGSMA.MergeSeq([with:1] Global(TA), Call(∂.ForEach([map:2] Scope(1), {A:GetField(Scope(2), A), G:GetField(Scope(2), G)})), Scope(1))))
Func sig: (<ctx>:x, TA:{A:s, G:(s, i8), X:r8}*) to {A:s, B:s*, G:(s, i8), X:r8}*
Sequence: Seq<{str,Seq<str>,(str,i8),r8}>
 1) { A: xy, 
      B: Sequence: Seq<str>
         0) A: [xy]
      G: (xy, 1), X: 2 }
 5) { A: adios, 
      B: Sequence: Seq<str>
         0) A: [adios]
      G: (adios, 5), X: 6 }
 3) { A: xyz, 
      B: Sequence: Seq<str>
         0) A: [xyz]
      G: (xyz, 3), X: 4 }
 7) { A: guten morgen, 
      B: Sequence: Seq<str>
         0) A: [guten morgen]
      G: (guten morgen, 7), X: 8 }
 0) { A: x, 
      B: Sequence: Seq<str>
         0) A: [x]
      G: (x, 0), X: 1 }
 4) { A: hi, 
      B: Sequence: Seq<str>
         0) A: [hi]
      G: (hi, 4), X: 5 }
 2) { A: <null>, 
      B: Sequence: Seq<str>
         0) A: <null>
      G: (<null>, 2), X: 3 }
 6) { A: hola, 
      B: Sequence: Seq<str>
         0) A: [hola]
      G: (hola, 6), X: 7 }
*** Ctx ping count: 0
###
> TA->MultiDGSMA(G, A)
TA->MultiDGSMA(G, A) : {A:s, B:s*, G:(s, i8), X:r8}*
BndKind:Call, Type:{A:s, B:s*, G:(s, i8), X:r8}*, Bnd:(Call(∂.Guard([guard:1] Global(TA), Call(∂.Test.MultiDGSMA.MergeSeq([with:2] Scope(1), Call(∂.ForEach([map:3] Scope(2), {A:GetField(Scope(3), A), G:GetField(Scope(3), G)})), Scope(2))))))
Func sig: (<ctx>:x, TA:{A:s, G:(s, i8), X:r8}*) to {A:s, B:s*, G:(s, i8), X:r8}*
Sequence: Seq<{str,Seq<str>,(str,i8),r8}>
 1) { A: xy, 
      B: Sequence: Seq<str>
         0) A: [xy]
      G: (xy, 1), X: 2 }
 5) { A: adios, 
      B: Sequence: Seq<str>
         0) A: [adios]
      G: (adios, 5), X: 6 }
 3) { A: xyz, 
      B: Sequence: Seq<str>
         0) A: [xyz]
      G: (xyz, 3), X: 4 }
 7) { A: guten morgen, 
      B: Sequence: Seq<str>
         0) A: [guten morgen]
      G: (guten morgen, 7), X: 8 }
 0) { A: x, 
      B: Sequence: Seq<str>
         0) A: [x]
      G: (x, 0), X: 1 }
 4) { A: hi, 
      B: Sequence: Seq<str>
         0) A: [hi]
      G: (hi, 4), X: 5 }
 2) { A: <null>, 
      B: Sequence: Seq<str>
         0) A: <null>
      G: (<null>, 2), X: 3 }
 6) { A: hola, 
      B: Sequence: Seq<str>
         0) A: [hola]
      G: (hola, 6), X: 7 }
*** Ctx ping count: 0
###
> TA->MultiDGSMA()->Map(it+>{ B: "[" & B->Text.Concat(", ") & "]" })
TA->MultiDGSMA()->Map(it+>{ B : "[" & B->Text.Concat(", ") & "]" }) : {A:s, B:s, G:(s, i8), X:r8}*
BndKind:Call, Type:{A:s, B:s, G:(s, i8), X:r8}*, Bnd:(Call(∂.ForEach([map:3] Call(∂.Test.MultiDGSMA.MergeSeq([with:1] Global(TA), Call(∂.ForEach([map:2] Scope(1), {A:GetField(Scope(2), A), G:GetField(Scope(2), G)})), Scope(1))), SetFields([with:4] Scope(3), B : StrConcat(str([), Call(∂.Text.Concat(GetField(Scope(4), B), str(, )):s), str(]))))))
Func sig: (<ctx>:x, TA:{A:s, G:(s, i8), X:r8}*) to {A:s, B:s, G:(s, i8), X:r8}*
Sequence: Seq<{str,str,(str,i8),r8}>
 0) { A: x, B: [A: [x]], G: (x, 0), X: 1 }
 1) { A: xy, B: [A: [xy]], G: (xy, 1), X: 2 }
 2) { A: <null>, B: [A: <null>], G: (<null>, 2), X: 3 }
 3) { A: xyz, B: [A: [xyz]], G: (xyz, 3), X: 4 }
 4) { A: hi, B: [A: [hi]], G: (hi, 4), X: 5 }
 5) { A: adios, B: [A: [adios]], G: (adios, 5), X: 6 }
 6) { A: hola, B: [A: [hola]], G: (hola, 6), X: 7 }
 7) { A: guten morgen, B: [A: [guten morgen]], G: (guten morgen, 7), X: 8 }
*** Ctx ping count: 16
    [0](16): Text.Concat(!1x.B, ", ")
###
> TA->MultiDGSMA(G, A)->Map(it+>{ B: "[" & B->Text.Concat(", ") & "]" })
TA->MultiDGSMA(G, A)->Map(it+>{ B : "[" & B->Text.Concat(", ") & "]" }) : {A:s, B:s, G:(s, i8), X:r8}*
BndKind:Call, Type:{A:s, B:s, G:(s, i8), X:r8}*, Bnd:(Call(∂.Guard([guard:1] Global(TA), Call(∂.ForEach([map:4] Call(∂.Test.MultiDGSMA.MergeSeq([with:2] Scope(1), Call(∂.ForEach([map:3] Scope(2), {A:GetField(Scope(3), A), G:GetField(Scope(3), G)})), Scope(2))), SetFields([with:5] Scope(4), B : StrConcat(str([), Call(∂.Text.Concat(GetField(Scope(5), B), str(, )):s), str(]))))))))
Func sig: (<ctx>:x, TA:{A:s, G:(s, i8), X:r8}*) to {A:s, B:s, G:(s, i8), X:r8}*
Sequence: Seq<{str,str,(str,i8),r8}>
 0) { A: x, B: [A: [x]], G: (x, 0), X: 1 }
 1) { A: xy, B: [A: [xy]], G: (xy, 1), X: 2 }
 2) { A: <null>, B: [A: <null>], G: (<null>, 2), X: 3 }
 3) { A: xyz, B: [A: [xyz]], G: (xyz, 3), X: 4 }
 4) { A: hi, B: [A: [hi]], G: (hi, 4), X: 5 }
 5) { A: adios, B: [A: [adios]], G: (adios, 5), X: 6 }
 6) { A: hola, B: [A: [hola]], G: (hola, 6), X: 7 }
 7) { A: guten morgen, B: [A: [guten morgen]], G: (guten morgen, 7), X: 8 }
*** Ctx ping count: 16
    [0](16): Text.Concat(!1x.B, ", ")
###
> TA->MultiDGSMAM()->Map(it+>{ B: "<null>" if IsNull(B) else "[" & B->Text.Concat(", ") & "]" })
TA->MultiDGSMAM()->Map(it+>{ B : "<null>" if IsNull(B) else "[" & B->Text.Concat(", ") & "]" }) : {A:s, B:s, G:(s, i8), X:r8}*
BndKind:Call, Type:{A:s, B:s, G:(s, i8), X:r8}*, Bnd:(Call(∂.ForEach([map:3] Call(∂.Test.MultiDGSMAM.MergeSeq([with:1] Global(TA), Call(∂.ForEach([map:2] Scope(1), {A:GetField(Scope(2), A), G:GetField(Scope(2), G)})), Scope(1))), SetFields([with:4] Scope(3), B : If(Call(∂.IsEmpty(GetField(Scope(4), B)):b), str(<null>), StrConcat(str([), Call(∂.Text.Concat(GetField(Scope(4), B), str(, )):s), str(])))))))
Func sig: (<ctx>:x, TA:{A:s, G:(s, i8), X:r8}*) to {A:s, B:s, G:(s, i8), X:r8}*
Sequence: Seq<{str,str,(str,i8),r8}>
 0) { A: x, B: <null>, G: (x, 0), X: 1 }
 1) { A: xy, B: [A: [xy]], G: (xy, 1), X: 2 }
 2) { A: xy, B: [A: [xy]], G: (xy, 1), X: 2 }
 3) { A: <null>, B: [A: <null>], G: (<null>, 2), X: 3 }
 4) { A: <null>, B: [A: <null>], G: (<null>, 2), X: 3 }
 5) { A: <null>, B: [A: <null>], G: (<null>, 2), X: 3 }
 6) { A: xyz, B: [A: [xyz]], G: (xyz, 3), X: 4 }
 7) { A: xyz, B: [A: [xyz]], G: (xyz, 3), X: 4 }
 8) { A: xyz, B: [A: [xyz]], G: (xyz, 3), X: 4 }
 9) { A: xyz, B: [A: [xyz]], G: (xyz, 3), X: 4 }
10) { A: hi, B: <null>, G: (hi, 4), X: 5 }
11) { A: adios, B: [A: [adios]], G: (adios, 5), X: 6 }
12) { A: adios, B: [A: [adios]], G: (adios, 5), X: 6 }
13) { A: adios, B: [A: [adios]], G: (adios, 5), X: 6 }
14) { A: adios, B: [A: [adios]], G: (adios, 5), X: 6 }
15) { A: adios, B: [A: [adios]], G: (adios, 5), X: 6 }
16) { A: adios, B: [A: [adios]], G: (adios, 5), X: 6 }
17) { A: hola, B: [A: [hola]], G: (hola, 6), X: 7 }
18) { A: hola, B: [A: [hola]], G: (hola, 6), X: 7 }
19) { A: hola, B: [A: [hola]], G: (hola, 6), X: 7 }
20) { A: hola, B: [A: [hola]], G: (hola, 6), X: 7 }
21) { A: hola, B: [A: [hola]], G: (hola, 6), X: 7 }
22) { A: hola, B: [A: [hola]], G: (hola, 6), X: 7 }
23) { A: hola, B: [A: [hola]], G: (hola, 6), X: 7 }
24) { A: guten morgen, B: [A: [guten morgen]], G: (guten morgen, 7), X: 8 }
25) { A: guten morgen, B: [A: [guten morgen]], G: (guten morgen, 7), X: 8 }
26) { A: guten morgen, B: [A: [guten morgen]], G: (guten morgen, 7), X: 8 }
27) { A: guten morgen, B: [A: [guten morgen]], G: (guten morgen, 7), X: 8 }
28) { A: guten morgen, B: [A: [guten morgen]], G: (guten morgen, 7), X: 8 }
29) { A: guten morgen, B: [A: [guten morgen]], G: (guten morgen, 7), X: 8 }
30) { A: guten morgen, B: [A: [guten morgen]], G: (guten morgen, 7), X: 8 }
31) { A: guten morgen, B: [A: [guten morgen]], G: (guten morgen, 7), X: 8 }
*** Ctx ping count: 60
    [0](60): Text.Concat(!1x.B, ", ")
###
> TA->MultiDGSMAM(G, A)->Map(it+>{ B: "<null>" if IsNull(B) else "[" & B->Text.Concat(", ") & "]" })
TA->MultiDGSMAM(G, A)->Map(it+>{ B : "<null>" if IsNull(B) else "[" & B->Text.Concat(", ") & "]" }) : {A:s, B:s, G:(s, i8), X:r8}*
BndKind:Call, Type:{A:s, B:s, G:(s, i8), X:r8}*, Bnd:(Call(∂.Guard([guard:1] Global(TA), Call(∂.ForEach([map:4] Call(∂.Test.MultiDGSMAM.MergeSeq([with:2] Scope(1), Call(∂.ForEach([map:3] Scope(2), {A:GetField(Scope(3), A), G:GetField(Scope(3), G)})), Scope(2))), SetFields([with:5] Scope(4), B : If(Call(∂.IsEmpty(GetField(Scope(5), B)):b), str(<null>), StrConcat(str([), Call(∂.Text.Concat(GetField(Scope(5), B), str(, )):s), str(])))))))))
Func sig: (<ctx>:x, TA:{A:s, G:(s, i8), X:r8}*) to {A:s, B:s, G:(s, i8), X:r8}*
Sequence: Seq<{str,str,(str,i8),r8}>
 0) { A: x, B: <null>, G: (x, 0), X: 1 }
 1) { A: xy, B: [A: [xy]], G: (xy, 1), X: 2 }
 2) { A: xy, B: [A: [xy]], G: (xy, 1), X: 2 }
 3) { A: <null>, B: [A: <null>], G: (<null>, 2), X: 3 }
 4) { A: <null>, B: [A: <null>], G: (<null>, 2), X: 3 }
 5) { A: <null>, B: [A: <null>], G: (<null>, 2), X: 3 }
 6) { A: xyz, B: [A: [xyz]], G: (xyz, 3), X: 4 }
 7) { A: xyz, B: [A: [xyz]], G: (xyz, 3), X: 4 }
 8) { A: xyz, B: [A: [xyz]], G: (xyz, 3), X: 4 }
 9) { A: xyz, B: [A: [xyz]], G: (xyz, 3), X: 4 }
10) { A: hi, B: <null>, G: (hi, 4), X: 5 }
11) { A: adios, B: [A: [adios]], G: (adios, 5), X: 6 }
12) { A: adios, B: [A: [adios]], G: (adios, 5), X: 6 }
13) { A: adios, B: [A: [adios]], G: (adios, 5), X: 6 }
14) { A: adios, B: [A: [adios]], G: (adios, 5), X: 6 }
15) { A: adios, B: [A: [adios]], G: (adios, 5), X: 6 }
16) { A: adios, B: [A: [adios]], G: (adios, 5), X: 6 }
17) { A: hola, B: [A: [hola]], G: (hola, 6), X: 7 }
18) { A: hola, B: [A: [hola]], G: (hola, 6), X: 7 }
19) { A: hola, B: [A: [hola]], G: (hola, 6), X: 7 }
20) { A: hola, B: [A: [hola]], G: (hola, 6), X: 7 }
21) { A: hola, B: [A: [hola]], G: (hola, 6), X: 7 }
22) { A: hola, B: [A: [hola]], G: (hola, 6), X: 7 }
23) { A: hola, B: [A: [hola]], G: (hola, 6), X: 7 }
24) { A: guten morgen, B: [A: [guten morgen]], G: (guten morgen, 7), X: 8 }
25) { A: guten morgen, B: [A: [guten morgen]], G: (guten morgen, 7), X: 8 }
26) { A: guten morgen, B: [A: [guten morgen]], G: (guten morgen, 7), X: 8 }
27) { A: guten morgen, B: [A: [guten morgen]], G: (guten morgen, 7), X: 8 }
28) { A: guten morgen, B: [A: [guten morgen]], G: (guten morgen, 7), X: 8 }
29) { A: guten morgen, B: [A: [guten morgen]], G: (guten morgen, 7), X: 8 }
30) { A: guten morgen, B: [A: [guten morgen]], G: (guten morgen, 7), X: 8 }
31) { A: guten morgen, B: [A: [guten morgen]], G: (guten morgen, 7), X: 8 }
*** Ctx ping count: 60
    [0](60): Text.Concat(!1x.B, ", ")
###
> TA->MultiDGSMAm()->Map(it+>{ B: "<null>" if IsNull(B) else "[" & B->Text.Concat(", ") & "]" })
TA->MultiDGSMAm()->Map(it+>{ B : "<null>" if IsNull(B) else "[" & B->Text.Concat(", ") & "]" }) : {A:s, B:s, G:(s, i8), X:r8}*
BndKind:Call, Type:{A:s, B:s, G:(s, i8), X:r8}*, Bnd:(Call(∂.ForEach([map:3] Call(∂.Test.MultiDGSMAm.MergeSeq([with:1] Global(TA), Call(∂.ForEach([map:2] Scope(1), {A:GetField(Scope(2), A), G:GetField(Scope(2), G)})), Scope(1))), SetFields([with:4] Scope(3), B : If(Call(∂.IsEmpty(GetField(Scope(4), B)):b), str(<null>), StrConcat(str([), Call(∂.Text.Concat(GetField(Scope(4), B), str(, )):s), str(])))))))
Func sig: (<ctx>:x, TA:{A:s, G:(s, i8), X:r8}*) to {A:s, B:s, G:(s, i8), X:r8}*
Sequence: Seq<{str,str,(str,i8),r8}>
 0) { A: xy, B: [A: [xy]], G: (xy, 1), X: 2 }
 1) { A: xy, B: [A: [xy]], G: (xy, 1), X: 2 }
 2) { A: <null>, B: [A: <null>], G: (<null>, 2), X: 3 }
 3) { A: <null>, B: [A: <null>], G: (<null>, 2), X: 3 }
 4) { A: <null>, B: [A: <null>], G: (<null>, 2), X: 3 }
 5) { A: xyz, B: [A: [xyz]], G: (xyz, 3), X: 4 }
 6) { A: xyz, B: [A: [xyz]], G: (xyz, 3), X: 4 }
 7) { A: xyz, B: [A: [xyz]], G: (xyz, 3), X: 4 }
 8) { A: xyz, B: [A: [xyz]], G: (xyz, 3), X: 4 }
 9) { A: adios, B: [A: [adios]], G: (adios, 5), X: 6 }
10) { A: adios, B: [A: [adios]], G: (adios, 5), X: 6 }
11) { A: adios, B: [A: [adios]], G: (adios, 5), X: 6 }
12) { A: adios, B: [A: [adios]], G: (adios, 5), X: 6 }
13) { A: adios, B: [A: [adios]], G: (adios, 5), X: 6 }
14) { A: adios, B: [A: [adios]], G: (adios, 5), X: 6 }
15) { A: hola, B: [A: [hola]], G: (hola, 6), X: 7 }
16) { A: hola, B: [A: [hola]], G: (hola, 6), X: 7 }
17) { A: hola, B: [A: [hola]], G: (hola, 6), X: 7 }
18) { A: hola, B: [A: [hola]], G: (hola, 6), X: 7 }
19) { A: hola, B: [A: [hola]], G: (hola, 6), X: 7 }
20) { A: hola, B: [A: [hola]], G: (hola, 6), X: 7 }
21) { A: hola, B: [A: [hola]], G: (hola, 6), X: 7 }
22) { A: guten morgen, B: [A: [guten morgen]], G: (guten morgen, 7), X: 8 }
23) { A: guten morgen, B: [A: [guten morgen]], G: (guten morgen, 7), X: 8 }
24) { A: guten morgen, B: [A: [guten morgen]], G: (guten morgen, 7), X: 8 }
25) { A: guten morgen, B: [A: [guten morgen]], G: (guten morgen, 7), X: 8 }
26) { A: guten morgen, B: [A: [guten morgen]], G: (guten morgen, 7), X: 8 }
27) { A: guten morgen, B: [A: [guten morgen]], G: (guten morgen, 7), X: 8 }
28) { A: guten morgen, B: [A: [guten morgen]], G: (guten morgen, 7), X: 8 }
29) { A: guten morgen, B: [A: [guten morgen]], G: (guten morgen, 7), X: 8 }
*** Ctx ping count: 60
    [0](60): Text.Concat(!1x.B, ", ")
###
> TA->MultiDGSMAm(G, A)->Map(it+>{ B: "<null>" if IsNull(B) else "[" & B->Text.Concat(", ") & "]" })
TA->MultiDGSMAm(G, A)->Map(it+>{ B : "<null>" if IsNull(B) else "[" & B->Text.Concat(", ") & "]" }) : {A:s, B:s, G:(s, i8), X:r8}*
BndKind:Call, Type:{A:s, B:s, G:(s, i8), X:r8}*, Bnd:(Call(∂.Guard([guard:1] Global(TA), Call(∂.ForEach([map:4] Call(∂.Test.MultiDGSMAm.MergeSeq([with:2] Scope(1), Call(∂.ForEach([map:3] Scope(2), {A:GetField(Scope(3), A), G:GetField(Scope(3), G)})), Scope(2))), SetFields([with:5] Scope(4), B : If(Call(∂.IsEmpty(GetField(Scope(5), B)):b), str(<null>), StrConcat(str([), Call(∂.Text.Concat(GetField(Scope(5), B), str(, )):s), str(])))))))))
Func sig: (<ctx>:x, TA:{A:s, G:(s, i8), X:r8}*) to {A:s, B:s, G:(s, i8), X:r8}*
Sequence: Seq<{str,str,(str,i8),r8}>
 0) { A: xy, B: [A: [xy]], G: (xy, 1), X: 2 }
 1) { A: xy, B: [A: [xy]], G: (xy, 1), X: 2 }
 2) { A: <null>, B: [A: <null>], G: (<null>, 2), X: 3 }
 3) { A: <null>, B: [A: <null>], G: (<null>, 2), X: 3 }
 4) { A: <null>, B: [A: <null>], G: (<null>, 2), X: 3 }
 5) { A: xyz, B: [A: [xyz]], G: (xyz, 3), X: 4 }
 6) { A: xyz, B: [A: [xyz]], G: (xyz, 3), X: 4 }
 7) { A: xyz, B: [A: [xyz]], G: (xyz, 3), X: 4 }
 8) { A: xyz, B: [A: [xyz]], G: (xyz, 3), X: 4 }
 9) { A: adios, B: [A: [adios]], G: (adios, 5), X: 6 }
10) { A: adios, B: [A: [adios]], G: (adios, 5), X: 6 }
11) { A: adios, B: [A: [adios]], G: (adios, 5), X: 6 }
12) { A: adios, B: [A: [adios]], G: (adios, 5), X: 6 }
13) { A: adios, B: [A: [adios]], G: (adios, 5), X: 6 }
14) { A: adios, B: [A: [adios]], G: (adios, 5), X: 6 }
15) { A: hola, B: [A: [hola]], G: (hola, 6), X: 7 }
16) { A: hola, B: [A: [hola]], G: (hola, 6), X: 7 }
17) { A: hola, B: [A: [hola]], G: (hola, 6), X: 7 }
18) { A: hola, B: [A: [hola]], G: (hola, 6), X: 7 }
19) { A: hola, B: [A: [hola]], G: (hola, 6), X: 7 }
20) { A: hola, B: [A: [hola]], G: (hola, 6), X: 7 }
21) { A: hola, B: [A: [hola]], G: (hola, 6), X: 7 }
22) { A: guten morgen, B: [A: [guten morgen]], G: (guten morgen, 7), X: 8 }
23) { A: guten morgen, B: [A: [guten morgen]], G: (guten morgen, 7), X: 8 }
24) { A: guten morgen, B: [A: [guten morgen]], G: (guten morgen, 7), X: 8 }
25) { A: guten morgen, B: [A: [guten morgen]], G: (guten morgen, 7), X: 8 }
26) { A: guten morgen, B: [A: [guten morgen]], G: (guten morgen, 7), X: 8 }
27) { A: guten morgen, B: [A: [guten morgen]], G: (guten morgen, 7), X: 8 }
28) { A: guten morgen, B: [A: [guten morgen]], G: (guten morgen, 7), X: 8 }
29) { A: guten morgen, B: [A: [guten morgen]], G: (guten morgen, 7), X: 8 }
*** Ctx ping count: 60
    [0](60): Text.Concat(!1x.B, ", ")
###
> TA->MultiDGSMB(G,    A)->Map(it+>{ B: "[" & B->Text.Concat(", ") & "]" })
TA->MultiDGSMB(G, A)->Map(it+>{ B : "[" & B->Text.Concat(", ") & "]" }) : {A:s, B:s, G:(s, i8), X:r8}*
BndKind:Call, Type:{A:s, B:s, G:(s, i8), X:r8}*, Bnd:(Call(∂.Guard([guard:1] Global(TA), Call(∂.ForEach([map:4] Call(∂.Test.MultiDGSMB.MergeSeq([with:2] Scope(1), Call(∂.ForEach([map:3] Scope(2), {A:str(A's default), B:GetField(Scope(3), A), G:GetField(Scope(3), G)})), Scope(2))), SetFields([with:5] Scope(4), B : StrConcat(str([), Call(∂.Text.Concat(GetField(Scope(5), B), str(, )):s), str(]))))))))
Func sig: (<ctx>:x, TA:{A:s, G:(s, i8), X:r8}*) to {A:s, B:s, G:(s, i8), X:r8}*
Sequence: Seq<{str,str,(str,i8),r8}>
 0) { A: x, B: [A: [A's default], B: [x]], G: (x, 0), X: 1 }
 1) { A: xy, B: [A: [A's default], B: [xy]], G: (xy, 1), X: 2 }
 2) { A: <null>, B: [A: [A's default], B: <null>], G: (<null>, 2), X: 3 }
 3) { A: xyz, B: [A: [A's default], B: [xyz]], G: (xyz, 3), X: 4 }
 4) { A: hi, B: [A: [A's default], B: [hi]], G: (hi, 4), X: 5 }
 5) { A: adios, B: [A: [A's default], B: [adios]], G: (adios, 5), X: 6 }
 6) { A: hola, B: [A: [A's default], B: [hola]], G: (hola, 6), X: 7 }
 7) { A: guten morgen, B: [A: [A's default], B: [guten morgen]], G: (guten morgen, 7), X: 8 }
*** Ctx ping count: 24
    [0](24): Text.Concat(!1x.B, ", ")
###
> TA->MultiDGSMB(G, A: A)->Map(it+>{ B: "[" & B->Text.Concat(", ") & "]" })
TA->MultiDGSMB(G, A : A)->Map(it+>{ B : "[" & B->Text.Concat(", ") & "]" }) : {A:s, B:s, G:(s, i8), X:r8}*
BndKind:Call, Type:{A:s, B:s, G:(s, i8), X:r8}*, Bnd:(Call(∂.Guard([guard:1] Global(TA), Call(∂.ForEach([map:4] Call(∂.Test.MultiDGSMB.MergeSeq([with:2] Scope(1), Call(∂.ForEach([map:3] Scope(2), {A:GetField(Scope(3), A), B:str(B def), G:GetField(Scope(3), G)})), Scope(2))), SetFields([with:5] Scope(4), B : StrConcat(str([), Call(∂.Text.Concat(GetField(Scope(5), B), str(, )):s), str(]))))))))
Func sig: (<ctx>:x, TA:{A:s, G:(s, i8), X:r8}*) to {A:s, B:s, G:(s, i8), X:r8}*
Sequence: Seq<{str,str,(str,i8),r8}>
 0) { A: x, B: [A: [x], B: [B def]], G: (x, 0), X: 1 }
 1) { A: xy, B: [A: [xy], B: [B def]], G: (xy, 1), X: 2 }
 2) { A: <null>, B: [A: <null>, B: [B def]], G: (<null>, 2), X: 3 }
 3) { A: xyz, B: [A: [xyz], B: [B def]], G: (xyz, 3), X: 4 }
 4) { A: hi, B: [A: [hi], B: [B def]], G: (hi, 4), X: 5 }
 5) { A: adios, B: [A: [adios], B: [B def]], G: (adios, 5), X: 6 }
 6) { A: hola, B: [A: [hola], B: [B def]], G: (hola, 6), X: 7 }
 7) { A: guten morgen, B: [A: [guten morgen], B: [B def]], G: (guten morgen, 7), X: 8 }
*** Ctx ping count: 24
    [0](24): Text.Concat(!1x.B, ", ")
###
> TA->MultiDGSMB(G, B: A)->Map(it+>{ B: "[" & B->Text.Concat(", ") & "]" })
TA->MultiDGSMB(G, B : A)->Map(it+>{ B : "[" & B->Text.Concat(", ") & "]" }) : {A:s, B:s, G:(s, i8), X:r8}*
BndKind:Call, Type:{A:s, B:s, G:(s, i8), X:r8}*, Bnd:(Call(∂.Guard([guard:1] Global(TA), Call(∂.ForEach([map:4] Call(∂.Test.MultiDGSMB.MergeSeq([with:2] Scope(1), Call(∂.ForEach([map:3] Scope(2), {A:str(A's default), B:GetField(Scope(3), A), G:GetField(Scope(3), G)})), Scope(2))), SetFields([with:5] Scope(4), B : StrConcat(str([), Call(∂.Text.Concat(GetField(Scope(5), B), str(, )):s), str(]))))))))
Func sig: (<ctx>:x, TA:{A:s, G:(s, i8), X:r8}*) to {A:s, B:s, G:(s, i8), X:r8}*
Sequence: Seq<{str,str,(str,i8),r8}>
 0) { A: x, B: [A: [A's default], B: [x]], G: (x, 0), X: 1 }
 1) { A: xy, B: [A: [A's default], B: [xy]], G: (xy, 1), X: 2 }
 2) { A: <null>, B: [A: [A's default], B: <null>], G: (<null>, 2), X: 3 }
 3) { A: xyz, B: [A: [A's default], B: [xyz]], G: (xyz, 3), X: 4 }
 4) { A: hi, B: [A: [A's default], B: [hi]], G: (hi, 4), X: 5 }
 5) { A: adios, B: [A: [A's default], B: [adios]], G: (adios, 5), X: 6 }
 6) { A: hola, B: [A: [A's default], B: [hola]], G: (hola, 6), X: 7 }
 7) { A: guten morgen, B: [A: [A's default], B: [guten morgen]], G: (guten morgen, 7), X: 8 }
*** Ctx ping count: 24
    [0](24): Text.Concat(!1x.B, ", ")
###
> TA->MultiDGsMB({ A, B: "b-" & A })->Map(it+>{ B: "[" & B->Text.Concat(", ") & "]" })
TA->MultiDGsMB({ A, B : "b-" & A })->Map(it+>{ B : "[" & B->Text.Concat(", ") & "]" }) : {A:s, B:s, G:(s, i8), X:r8}*
BndKind:Call, Type:{A:s, B:s, G:(s, i8), X:r8}*, Bnd:(Call(∂.Guard([guard:1] Global(TA), Call(∂.ForEach([map:4] Call(∂.Test.MultiDGsMB.MergeSeq([with:2] Scope(1), Call(∂.ForEach([map:3] Scope(2), {A:GetField(Scope(3), A), B:StrConcat(str(b-), GetField(Scope(3), A))[, G:null:g]})), Scope(2))), SetFields([with:5] Scope(4), B : StrConcat(str([), Call(∂.Text.Concat(GetField(Scope(5), B), str(, )):s), str(]))))))))
Func sig: (<ctx>:x, TA:{A:s, G:(s, i8), X:r8}*) to {A:s, B:s, G:(s, i8), X:r8}*
Sequence: Seq<{str,str,(str,i8),r8}>
 0) { A: x, B: [A: [x], B: [b-x]], G: (x, 0), X: 1 }
 1) { A: xy, B: [A: [xy], B: [b-xy]], G: (xy, 1), X: 2 }
 2) { A: <null>, B: [A: <null>, B: [b-]], G: (<null>, 2), X: 3 }
 3) { A: xyz, B: [A: [xyz], B: [b-xyz]], G: (xyz, 3), X: 4 }
 4) { A: hi, B: [A: [hi], B: [b-hi]], G: (hi, 4), X: 5 }
 5) { A: adios, B: [A: [adios], B: [b-adios]], G: (adios, 5), X: 6 }
 6) { A: hola, B: [A: [hola], B: [b-hola]], G: (hola, 6), X: 7 }
 7) { A: guten morgen, B: [A: [guten morgen], B: [b-guten morgen]], G: (guten morgen, 7), X: 8 }
*** Ctx ping count: 24
    [0](24): Text.Concat(!1x.B, ", ")
###
> TB->MultiDGSMA(G, A)
TB->MultiDGSMA(G, A) : {A:s, B:s, B2:s*, G:(i8, s), X:r8}*
BndKind:Call, Type:{A:s, B:s, B2:s*, G:(i8, s), X:r8}*, Bnd:(Call(∂.Guard([guard:1] Global(TB), Call(∂.Test.MultiDGSMA.MergeSeq([with:2] Scope(1), Call(∂.ForEach([map:3] Scope(2), {A:GetField(Scope(3), A), G:GetField(Scope(3), G)})), Scope(2))))))
Func sig: (<ctx>:x, TB:{A:s, B:s, G:(i8, s), X:r8}*) to {A:s, B:s, B2:s*, G:(i8, s), X:r8}*
Sequence: Seq<{str,str,Seq<str>,(i8,str),r8}>
 1) { A: <null>, B: xy, 
      B2: Sequence: Seq<str>
         0) A: <null>
      G: (1, xy), X: 2 }
 5) { A: adios, B: <null>, 
      B2: Sequence: Seq<str>
         0) A: [adios]
      G: (5, adios), X: 6 }
 3) { A: xyz, B: xyz, 
      B2: Sequence: Seq<str>
         0) A: [xyz]
      G: (3, xyz), X: 4 }
 7) { A: <null>, B: guten morgen, 
      B2: Sequence: Seq<str>
         0) A: <null>
      G: (7, guten morgen), X: 8 }
 0) { A: x, B: x, 
      B2: Sequence: Seq<str>
         0) A: [x]
      G: (0, x), X: 1 }
 4) { A: <null>, B: hi, 
      B2: Sequence: Seq<str>
         0) A: <null>
      G: (4, hi), X: 5 }
 2) { A: <null>, B: <null>, 
      B2: Sequence: Seq<str>
         0) A: <null>
      G: (2, <null>), X: 3 }
 6) { A: hola, B: hola, 
      B2: Sequence: Seq<str>
         0) A: [hola]
      G: (6, hola), X: 7 }
*** Ctx ping count: 0
###
> TB->MultiDGSMA(G, A)->Map(it+>{ B2: "[" & B2->Text.Concat(", ") & "]" })
TB->MultiDGSMA(G, A)->Map(it+>{ B2 : "[" & B2->Text.Concat(", ") & "]" }) : {A:s, B:s, B2:s, G:(i8, s), X:r8}*
BndKind:Call, Type:{A:s, B:s, B2:s, G:(i8, s), X:r8}*, Bnd:(Call(∂.Guard([guard:1] Global(TB), Call(∂.ForEach([map:4] Call(∂.Test.MultiDGSMA.MergeSeq([with:2] Scope(1), Call(∂.ForEach([map:3] Scope(2), {A:GetField(Scope(3), A), G:GetField(Scope(3), G)})), Scope(2))), SetFields([with:5] Scope(4), B2 : StrConcat(str([), Call(∂.Text.Concat(GetField(Scope(5), B2), str(, )):s), str(]))))))))
Func sig: (<ctx>:x, TB:{A:s, B:s, G:(i8, s), X:r8}*) to {A:s, B:s, B2:s, G:(i8, s), X:r8}*
Sequence: Seq<{str,str,str,(i8,str),r8}>
 0) { A: x, B: x, B2: [A: [x]], G: (0, x), X: 1 }
 1) { A: <null>, B: xy, B2: [A: <null>], G: (1, xy), X: 2 }
 2) { A: <null>, B: <null>, B2: [A: <null>], G: (2, <null>), X: 3 }
 3) { A: xyz, B: xyz, B2: [A: [xyz]], G: (3, xyz), X: 4 }
 4) { A: <null>, B: hi, B2: [A: <null>], G: (4, hi), X: 5 }
 5) { A: adios, B: <null>, B2: [A: [adios]], G: (5, adios), X: 6 }
 6) { A: hola, B: hola, B2: [A: [hola]], G: (6, hola), X: 7 }
 7) { A: <null>, B: guten morgen, B2: [A: <null>], G: (7, guten morgen), X: 8 }
*** Ctx ping count: 16
    [0](16): Text.Concat(!1x.B2, ", ")
###
> TB->MultiDGSMA(G, B)
TB->MultiDGSMA(G, B) : {A:s, B:s, B2:s*, G:(i8, s), X:r8}*
BndKind:Call, Type:{A:s, B:s, B2:s*, G:(i8, s), X:r8}*, Bnd:(Call(∂.Guard([guard:1] Global(TB), Call(∂.Test.MultiDGSMA.MergeSeq([with:2] Scope(1), Call(∂.ForEach([map:3] Scope(2), {A:GetField(Scope(3), B), G:GetField(Scope(3), G)})), Scope(2))))))
Func sig: (<ctx>:x, TB:{A:s, B:s, G:(i8, s), X:r8}*) to {A:s, B:s, B2:s*, G:(i8, s), X:r8}*
Sequence: Seq<{str,str,Seq<str>,(i8,str),r8}>
 1) { A: <null>, B: xy, 
      B2: Sequence: Seq<str>
         0) A: [xy]
      G: (1, xy), X: 2 }
 5) { A: adios, B: <null>, 
      B2: Sequence: Seq<str>
         0) A: <null>
      G: (5, adios), X: 6 }
 3) { A: xyz, B: xyz, 
      B2: Sequence: Seq<str>
         0) A: [xyz]
      G: (3, xyz), X: 4 }
 7) { A: <null>, B: guten morgen, 
      B2: Sequence: Seq<str>
         0) A: [guten morgen]
      G: (7, guten morgen), X: 8 }
 0) { A: x, B: x, 
      B2: Sequence: Seq<str>
         0) A: [x]
      G: (0, x), X: 1 }
 4) { A: <null>, B: hi, 
      B2: Sequence: Seq<str>
         0) A: [hi]
      G: (4, hi), X: 5 }
 2) { A: <null>, B: <null>, 
      B2: Sequence: Seq<str>
         0) A: <null>
      G: (2, <null>), X: 3 }
 6) { A: hola, B: hola, 
      B2: Sequence: Seq<str>
         0) A: [hola]
      G: (6, hola), X: 7 }
*** Ctx ping count: 0
###
> TB->MultiDGSMA(G, B)->Map(it+>{ B2: "[" & B2->Text.Concat(", ") & "]" })
TB->MultiDGSMA(G, B)->Map(it+>{ B2 : "[" & B2->Text.Concat(", ") & "]" }) : {A:s, B:s, B2:s, G:(i8, s), X:r8}*
BndKind:Call, Type:{A:s, B:s, B2:s, G:(i8, s), X:r8}*, Bnd:(Call(∂.Guard([guard:1] Global(TB), Call(∂.ForEach([map:4] Call(∂.Test.MultiDGSMA.MergeSeq([with:2] Scope(1), Call(∂.ForEach([map:3] Scope(2), {A:GetField(Scope(3), B), G:GetField(Scope(3), G)})), Scope(2))), SetFields([with:5] Scope(4), B2 : StrConcat(str([), Call(∂.Text.Concat(GetField(Scope(5), B2), str(, )):s), str(]))))))))
Func sig: (<ctx>:x, TB:{A:s, B:s, G:(i8, s), X:r8}*) to {A:s, B:s, B2:s, G:(i8, s), X:r8}*
Sequence: Seq<{str,str,str,(i8,str),r8}>
 0) { A: x, B: x, B2: [A: [x]], G: (0, x), X: 1 }
 1) { A: <null>, B: xy, B2: [A: [xy]], G: (1, xy), X: 2 }
 2) { A: <null>, B: <null>, B2: [A: <null>], G: (2, <null>), X: 3 }
 3) { A: xyz, B: xyz, B2: [A: [xyz]], G: (3, xyz), X: 4 }
 4) { A: <null>, B: hi, B2: [A: [hi]], G: (4, hi), X: 5 }
 5) { A: adios, B: <null>, B2: [A: <null>], G: (5, adios), X: 6 }
 6) { A: hola, B: hola, B2: [A: [hola]], G: (6, hola), X: 7 }
 7) { A: <null>, B: guten morgen, B2: [A: [guten morgen]], G: (7, guten morgen), X: 8 }
*** Ctx ping count: 16
    [0](16): Text.Concat(!1x.B2, ", ")
###
> TB->MultiDGSMB()
TB->MultiDGSMB() : {A:s, B:s, B2:s*, G:(i8, s), X:r8}*
BndKind:Call, Type:{A:s, B:s, B2:s*, G:(i8, s), X:r8}*, Bnd:(Call(∂.Test.MultiDGSMB.MergeSeq([with:1] Global(TB), Call(∂.ForEach([map:2] Scope(1), {A:GetField(Scope(2), A), B:GetField(Scope(2), B), G:GetField(Scope(2), G)})), Scope(1))))
Func sig: (<ctx>:x, TB:{A:s, B:s, G:(i8, s), X:r8}*) to {A:s, B:s, B2:s*, G:(i8, s), X:r8}*
Sequence: Seq<{str,str,Seq<str>,(i8,str),r8}>
 1) { A: <null>, B: xy, 
      B2: Sequence: Seq<str>
         0) A: <null>
         1) B: [xy]
      G: (1, xy), X: 2 }
 5) { A: adios, B: <null>, 
      B2: Sequence: Seq<str>
         0) A: [adios]
         1) B: <null>
      G: (5, adios), X: 6 }
 3) { A: xyz, B: xyz, 
      B2: Sequence: Seq<str>
         0) A: [xyz]
         1) B: [xyz]
      G: (3, xyz), X: 4 }
 7) { A: <null>, B: guten morgen, 
      B2: Sequence: Seq<str>
         0) A: <null>
         1) B: [guten morgen]
      G: (7, guten morgen), X: 8 }
 0) { A: x, B: x, 
      B2: Sequence: Seq<str>
         0) A: [x]
         1) B: [x]
      G: (0, x), X: 1 }
 4) { A: <null>, B: hi, 
      B2: Sequence: Seq<str>
         0) A: <null>
         1) B: [hi]
      G: (4, hi), X: 5 }
 2) { A: <null>, B: <null>, 
      B2: Sequence: Seq<str>
         0) A: <null>
         1) B: <null>
      G: (2, <null>), X: 3 }
 6) { A: hola, B: hola, 
      B2: Sequence: Seq<str>
         0) A: [hola]
         1) B: [hola]
      G: (6, hola), X: 7 }
*** Ctx ping count: 0
###
> TB->MultiDGSMB()->Map(it+>{ B2: "[" & B2->Text.Concat(", ") & "]" })
TB->MultiDGSMB()->Map(it+>{ B2 : "[" & B2->Text.Concat(", ") & "]" }) : {A:s, B:s, B2:s, G:(i8, s), X:r8}*
BndKind:Call, Type:{A:s, B:s, B2:s, G:(i8, s), X:r8}*, Bnd:(Call(∂.ForEach([map:3] Call(∂.Test.MultiDGSMB.MergeSeq([with:1] Global(TB), Call(∂.ForEach([map:2] Scope(1), {A:GetField(Scope(2), A), B:GetField(Scope(2), B), G:GetField(Scope(2), G)})), Scope(1))), SetFields([with:4] Scope(3), B2 : StrConcat(str([), Call(∂.Text.Concat(GetField(Scope(4), B2), str(, )):s), str(]))))))
Func sig: (<ctx>:x, TB:{A:s, B:s, G:(i8, s), X:r8}*) to {A:s, B:s, B2:s, G:(i8, s), X:r8}*
Sequence: Seq<{str,str,str,(i8,str),r8}>
 0) { A: x, B: x, B2: [A: [x], B: [x]], G: (0, x), X: 1 }
 1) { A: <null>, B: xy, B2: [A: <null>, B: [xy]], G: (1, xy), X: 2 }
 2) { A: <null>, B: <null>, B2: [A: <null>, B: <null>], G: (2, <null>), X: 3 }
 3) { A: xyz, B: xyz, B2: [A: [xyz], B: [xyz]], G: (3, xyz), X: 4 }
 4) { A: <null>, B: hi, B2: [A: <null>, B: [hi]], G: (4, hi), X: 5 }
 5) { A: adios, B: <null>, B2: [A: [adios], B: <null>], G: (5, adios), X: 6 }
 6) { A: hola, B: hola, B2: [A: [hola], B: [hola]], G: (6, hola), X: 7 }
 7) { A: <null>, B: guten morgen, B2: [A: <null>, B: [guten morgen]], G: (7, guten morgen), X: 8 }
*** Ctx ping count: 24
    [0](24): Text.Concat(!1x.B2, ", ")
###
> TB->MultiDGSMB(G,    A,    B)->Map(it+>{ B2: "[" & B2->Text.Concat(", ") & "]" })
TB->MultiDGSMB(G, A, B)->Map(it+>{ B2 : "[" & B2->Text.Concat(", ") & "]" }) : {A:s, B:s, B2:s, G:(i8, s), X:r8}*
BndKind:Call, Type:{A:s, B:s, B2:s, G:(i8, s), X:r8}*, Bnd:(Call(∂.Guard([guard:1] Global(TB), Call(∂.ForEach([map:4] Call(∂.Test.MultiDGSMB.MergeSeq([with:2] Scope(1), Call(∂.ForEach([map:3] Scope(2), {A:GetField(Scope(3), B), B:GetField(Scope(3), A), G:GetField(Scope(3), G)})), Scope(2))), SetFields([with:5] Scope(4), B2 : StrConcat(str([), Call(∂.Text.Concat(GetField(Scope(5), B2), str(, )):s), str(]))))))))
Func sig: (<ctx>:x, TB:{A:s, B:s, G:(i8, s), X:r8}*) to {A:s, B:s, B2:s, G:(i8, s), X:r8}*
Sequence: Seq<{str,str,str,(i8,str),r8}>
 0) { A: x, B: x, B2: [A: [x], B: [x]], G: (0, x), X: 1 }
 1) { A: <null>, B: xy, B2: [A: [xy], B: <null>], G: (1, xy), X: 2 }
 2) { A: <null>, B: <null>, B2: [A: <null>, B: <null>], G: (2, <null>), X: 3 }
 3) { A: xyz, B: xyz, B2: [A: [xyz], B: [xyz]], G: (3, xyz), X: 4 }
 4) { A: <null>, B: hi, B2: [A: [hi], B: <null>], G: (4, hi), X: 5 }
 5) { A: adios, B: <null>, B2: [A: <null>, B: [adios]], G: (5, adios), X: 6 }
 6) { A: hola, B: hola, B2: [A: [hola], B: [hola]], G: (6, hola), X: 7 }
 7) { A: <null>, B: guten morgen, B2: [A: [guten morgen], B: <null>], G: (7, guten morgen), X: 8 }
*** Ctx ping count: 24
    [0](24): Text.Concat(!1x.B2, ", ")
###
> TB->MultiDGSMB(G, A: A, B: B)->Map(it+>{ B2: "[" & B2->Text.Concat(", ") & "]" })
TB->MultiDGSMB(G, A : A, B : B)->Map(it+>{ B2 : "[" & B2->Text.Concat(", ") & "]" }) : {A:s, B:s, B2:s, G:(i8, s), X:r8}*
BndKind:Call, Type:{A:s, B:s, B2:s, G:(i8, s), X:r8}*, Bnd:(Call(∂.Guard([guard:1] Global(TB), Call(∂.ForEach([map:4] Call(∂.Test.MultiDGSMB.MergeSeq([with:2] Scope(1), Call(∂.ForEach([map:3] Scope(2), {A:GetField(Scope(3), A), B:GetField(Scope(3), B), G:GetField(Scope(3), G)})), Scope(2))), SetFields([with:5] Scope(4), B2 : StrConcat(str([), Call(∂.Text.Concat(GetField(Scope(5), B2), str(, )):s), str(]))))))))
Func sig: (<ctx>:x, TB:{A:s, B:s, G:(i8, s), X:r8}*) to {A:s, B:s, B2:s, G:(i8, s), X:r8}*
Sequence: Seq<{str,str,str,(i8,str),r8}>
 0) { A: x, B: x, B2: [A: [x], B: [x]], G: (0, x), X: 1 }
 1) { A: <null>, B: xy, B2: [A: <null>, B: [xy]], G: (1, xy), X: 2 }
 2) { A: <null>, B: <null>, B2: [A: <null>, B: <null>], G: (2, <null>), X: 3 }
 3) { A: xyz, B: xyz, B2: [A: [xyz], B: [xyz]], G: (3, xyz), X: 4 }
 4) { A: <null>, B: hi, B2: [A: <null>, B: [hi]], G: (4, hi), X: 5 }
 5) { A: adios, B: <null>, B2: [A: [adios], B: <null>], G: (5, adios), X: 6 }
 6) { A: hola, B: hola, B2: [A: [hola], B: [hola]], G: (6, hola), X: 7 }
 7) { A: <null>, B: guten morgen, B2: [A: <null>, B: [guten morgen]], G: (7, guten morgen), X: 8 }
*** Ctx ping count: 24
    [0](24): Text.Concat(!1x.B2, ", ")
###
> TB->MultiDGSMB(G, A: A,    B)->Map(it+>{ B2: "[" & B2->Text.Concat(", ") & "]" }) // Error.
TB->MultiDGSMB(G, A : A, B)->Map(it+>{ B2 : "[" & B2->Text.Concat(", ") & "]" }) : {A:s, B:s, B2:s, G:(i8, s), X:r8}*
BndKind:Call, Type:{A:s, B:s, B2:s, G:(i8, s), X:r8}*, Bnd:(Call(∂.ForEach([map:2] Call(∂.Test.MultiDGSMB*([map:1] Global(TB), GetField(Scope(1), G), A : GetField(Scope(1), A), GetField(Scope(1), B))), SetFields([with:3] Scope(2), B2 : StrConcat(str([), Call(∂.Text.Concat(GetField(Scope(3), B2), str(, )):s), str(]))))))
*** Error: (2,4) Node: TB->MultiDGSMB(G, A : A, B), Message: No overload can be found matching these names and directives.
*** Error: (27,28) Node: B, Message: The argument in position 4 of 'MultiDGSMB' should include a field name
###
> TB->MultiDGSMB(G, B: A, A: B)->Map(it+>{ B2: "[" & B2->Text.Concat(", ") & "]" })
TB->MultiDGSMB(G, B : A, A : B)->Map(it+>{ B2 : "[" & B2->Text.Concat(", ") & "]" }) : {A:s, B:s, B2:s, G:(i8, s), X:r8}*
BndKind:Call, Type:{A:s, B:s, B2:s, G:(i8, s), X:r8}*, Bnd:(Call(∂.Guard([guard:1] Global(TB), Call(∂.ForEach([map:4] Call(∂.Test.MultiDGSMB.MergeSeq([with:2] Scope(1), Call(∂.ForEach([map:3] Scope(2), {A:GetField(Scope(3), B), B:GetField(Scope(3), A), G:GetField(Scope(3), G)})), Scope(2))), SetFields([with:5] Scope(4), B2 : StrConcat(str([), Call(∂.Text.Concat(GetField(Scope(5), B2), str(, )):s), str(]))))))))
Func sig: (<ctx>:x, TB:{A:s, B:s, G:(i8, s), X:r8}*) to {A:s, B:s, B2:s, G:(i8, s), X:r8}*
Sequence: Seq<{str,str,str,(i8,str),r8}>
 0) { A: x, B: x, B2: [A: [x], B: [x]], G: (0, x), X: 1 }
 1) { A: <null>, B: xy, B2: [A: [xy], B: <null>], G: (1, xy), X: 2 }
 2) { A: <null>, B: <null>, B2: [A: <null>, B: <null>], G: (2, <null>), X: 3 }
 3) { A: xyz, B: xyz, B2: [A: [xyz], B: [xyz]], G: (3, xyz), X: 4 }
 4) { A: <null>, B: hi, B2: [A: [hi], B: <null>], G: (4, hi), X: 5 }
 5) { A: adios, B: <null>, B2: [A: <null>, B: [adios]], G: (5, adios), X: 6 }
 6) { A: hola, B: hola, B2: [A: [hola], B: [hola]], G: (6, hola), X: 7 }
 7) { A: <null>, B: guten morgen, B2: [A: [guten morgen], B: <null>], G: (7, guten morgen), X: 8 }
*** Ctx ping count: 24
    [0](24): Text.Concat(!1x.B2, ", ")
###
> TB->MultiDGSMB(G, B: A,    A)->Map(it+>{ B2: "[" & B2->Text.Concat(", ") & "]" })
TB->MultiDGSMB(G, B : A, A)->Map(it+>{ B2 : "[" & B2->Text.Concat(", ") & "]" }) : {A:s, B:s, B2:s, G:(i8, s), X:r8}*
BndKind:Call, Type:{A:s, B:s, B2:s, G:(i8, s), X:r8}*, Bnd:(Call(∂.Guard([guard:1] Global(TB), Call(∂.ForEach([map:4] Call(∂.Test.MultiDGSMB.MergeSeq([with:2] Scope(1), Call(∂.ForEach([map:3] Scope(2), {A:GetField(Scope(3), A), B:GetField(Scope(3), A), G:GetField(Scope(3), G)})), Scope(2))), SetFields([with:5] Scope(4), B2 : StrConcat(str([), Call(∂.Text.Concat(GetField(Scope(5), B2), str(, )):s), str(]))))))))
Func sig: (<ctx>:x, TB:{A:s, B:s, G:(i8, s), X:r8}*) to {A:s, B:s, B2:s, G:(i8, s), X:r8}*
Sequence: Seq<{str,str,str,(i8,str),r8}>
 0) { A: x, B: x, B2: [A: [x], B: [x]], G: (0, x), X: 1 }
 1) { A: <null>, B: xy, B2: [A: <null>, B: <null>], G: (1, xy), X: 2 }
 2) { A: <null>, B: <null>, B2: [A: <null>, B: <null>], G: (2, <null>), X: 3 }
 3) { A: xyz, B: xyz, B2: [A: [xyz], B: [xyz]], G: (3, xyz), X: 4 }
 4) { A: <null>, B: hi, B2: [A: <null>, B: <null>], G: (4, hi), X: 5 }
 5) { A: adios, B: <null>, B2: [A: [adios], B: [adios]], G: (5, adios), X: 6 }
 6) { A: hola, B: hola, B2: [A: [hola], B: [hola]], G: (6, hola), X: 7 }
 7) { A: <null>, B: guten morgen, B2: [A: <null>, B: <null>], G: (7, guten morgen), X: 8 }
*** Ctx ping count: 24
    [0](24): Text.Concat(!1x.B2, ", ")
###
> TB->Multi_GSMB() // Error.
TB->Multi_GSMB() : {A:s, B:s, B2:s*, G:(i8, s), X:r8}*
BndKind:Call, Type:{A:s, B:s, B2:s*, G:(i8, s), X:r8}*, Bnd:(Call(∂.Guard([guard:1] Global(TB), Call(∂.Test.Multi_GSMB.MergeSeq([with:2] Scope(1), Call(∂.ForEach([map:3] Scope(2), {A:str(A's default), B:str(B def), G:<missing>})), Scope(2))))))
*** Error: (2,4) Node: TB->Multi_GSMB(), Message: Too few arguments for Test.Multi_GSMB, expected 1 additional
###
> TB->Multi_GSMB(G) // OK - use defaults for A and B.
TB->Multi_GSMB(G) : {A:s, B:s, B2:s*, G:(i8, s), X:r8}*
BndKind:Call, Type:{A:s, B:s, B2:s*, G:(i8, s), X:r8}*, Bnd:(Call(∂.Guard([guard:1] Global(TB), Call(∂.Test.Multi_GSMB.MergeSeq([with:2] Scope(1), Call(∂.ForEach([map:3] Scope(2), {A:str(A's default), B:str(B def), G:GetField(Scope(3), G)})), Scope(2))))))
Func sig: (<ctx>:x, TB:{A:s, B:s, G:(i8, s), X:r8}*) to {A:s, B:s, B2:s*, G:(i8, s), X:r8}*
Sequence: Seq<{str,str,Seq<str>,(i8,str),r8}>
 1) { A: <null>, B: xy, 
      B2: Sequence: Seq<str>
         0) A: [A's default]
         1) B: [B def]
      G: (1, xy), X: 2 }
 5) { A: adios, B: <null>, 
      B2: Sequence: Seq<str>
         0) A: [A's default]
         1) B: [B def]
      G: (5, adios), X: 6 }
 3) { A: xyz, B: xyz, 
      B2: Sequence: Seq<str>
         0) A: [A's default]
         1) B: [B def]
      G: (3, xyz), X: 4 }
 7) { A: <null>, B: guten morgen, 
      B2: Sequence: Seq<str>
         0) A: [A's default]
         1) B: [B def]
      G: (7, guten morgen), X: 8 }
 0) { A: x, B: x, 
      B2: Sequence: Seq<str>
         0) A: [A's default]
         1) B: [B def]
      G: (0, x), X: 1 }
 4) { A: <null>, B: hi, 
      B2: Sequence: Seq<str>
         0) A: [A's default]
         1) B: [B def]
      G: (4, hi), X: 5 }
 2) { A: <null>, B: <null>, 
      B2: Sequence: Seq<str>
         0) A: [A's default]
         1) B: [B def]
      G: (2, <null>), X: 3 }
 6) { A: hola, B: hola, 
      B2: Sequence: Seq<str>
         0) A: [A's default]
         1) B: [B def]
      G: (6, hola), X: 7 }
*** Ctx ping count: 0
###
> TB->Multi_GSMB(G, A: A, B: B)->Map(it+>{ B2: "[" & B2->Text.Concat(", ") & "]" })
TB->Multi_GSMB(G, A : A, B : B)->Map(it+>{ B2 : "[" & B2->Text.Concat(", ") & "]" }) : {A:s, B:s, B2:s, G:(i8, s), X:r8}*
BndKind:Call, Type:{A:s, B:s, B2:s, G:(i8, s), X:r8}*, Bnd:(Call(∂.Guard([guard:1] Global(TB), Call(∂.ForEach([map:4] Call(∂.Test.Multi_GSMB.MergeSeq([with:2] Scope(1), Call(∂.ForEach([map:3] Scope(2), {A:GetField(Scope(3), A), B:GetField(Scope(3), B), G:GetField(Scope(3), G)})), Scope(2))), SetFields([with:5] Scope(4), B2 : StrConcat(str([), Call(∂.Text.Concat(GetField(Scope(5), B2), str(, )):s), str(]))))))))
Func sig: (<ctx>:x, TB:{A:s, B:s, G:(i8, s), X:r8}*) to {A:s, B:s, B2:s, G:(i8, s), X:r8}*
Sequence: Seq<{str,str,str,(i8,str),r8}>
 0) { A: x, B: x, B2: [A: [x], B: [x]], G: (0, x), X: 1 }
 1) { A: <null>, B: xy, B2: [A: <null>, B: [xy]], G: (1, xy), X: 2 }
 2) { A: <null>, B: <null>, B2: [A: <null>, B: <null>], G: (2, <null>), X: 3 }
 3) { A: xyz, B: xyz, B2: [A: [xyz], B: [xyz]], G: (3, xyz), X: 4 }
 4) { A: <null>, B: hi, B2: [A: <null>, B: [hi]], G: (4, hi), X: 5 }
 5) { A: adios, B: <null>, B2: [A: [adios], B: <null>], G: (5, adios), X: 6 }
 6) { A: hola, B: hola, B2: [A: [hola], B: [hola]], G: (6, hola), X: 7 }
 7) { A: <null>, B: guten morgen, B2: [A: <null>, B: [guten morgen]], G: (7, guten morgen), X: 8 }
*** Ctx ping count: 24
    [0](24): Text.Concat(!1x.B2, ", ")
###
> TB->MultiDGS_Bab()->Map(B->Text.Concat(", "))
TB->MultiDGS_Bab()->Map(B->Text.Concat(", ")) : s*
BndKind:Call, Type:s*, Bnd:(Call(∂.ForEach([map:2] Call(∂.Test.MultiDGS_Bab.Simple(Call(∂.ForEach([map:1] Global(TB), {A:GetField(Scope(1), A), B:GetField(Scope(1), B), G:GetField(Scope(1), G)})))), Call(∂.Text.Concat(GetField(Scope(2), B), str(, )):s)):s*))
Func sig: (<ctx>:x, TB:{A:s, B:s, G:(i8, s), X:r8}*) to s*
Sequence: Seq<str>
 0) A: [x], B: [x]
 1) A: <null>, B: [xy]
 2) A: <null>, B: <null>
 3) A: [xyz], B: [xyz]
 4) A: <null>, B: [hi]
 5) A: [adios], B: <null>
 6) A: [hola], B: [hola]
 7) A: <null>, B: [guten morgen]
*** Ctx ping count: 24
    [0](24): Text.Concat(*1x.B, ", ")
###
> S->MultiDGSMBab(it,   it) //->Map(B->Text.Concat(", ")) // Error
S->MultiDGSMBab(it, it) : {B:s*}*
BndKind:Call, Type:{B:s*}*, Bnd:(Call(∂.Test.MultiDGSMBab.Simple(Call(∂.ForEach([map:1] Global(S), {A:str(<null>), B:Scope(1), G:Scope(1)})))))
*** Error: (1,3) Node: S->MultiDGSMBab(it, it), Message: Too few arguments for Test.MultiDGSMBab, expected 1 additional
###
> S->MultiDGSMBab(it,   it & "-1st",    it & "-2nd")->Map(B->Text.Concat(", "))
S->MultiDGSMBab(it, it & "-1st", it & "-2nd")->Map(B->Text.Concat(", ")) : s*
BndKind:Call, Type:s*, Bnd:(Call(∂.ForEach([map:2] Call(∂.Test.MultiDGSMBab.Simple(Call(∂.ForEach([map:1] Global(S), {A:StrConcat(Scope(1), str(-2nd)), B:StrConcat(Scope(1), str(-1st)), G:Scope(1)})))), Call(∂.Text.Concat(GetField(Scope(2), B), str(, )):s)):s*))
Func sig: (<ctx>:x, S:s*) to s*
Sequence: Seq<str>
 0) A: [x-2nd], B: [x-1st]
 1) A: [xy-2nd], B: [xy-1st]
 2) A: [-2nd], B: [-1st]
 3) A: [xyz-2nd], B: [xyz-1st]
 4) A: [hi-2nd], B: [hi-1st]
 5) A: [adios-2nd], B: [adios-1st]
 6) A: [hola-2nd], B: [hola-1st]
 7) A: [guten morgen-2nd], B: [guten morgen-1st]
*** Ctx ping count: 24
    [0](24): Text.Concat(*1x.B, ", ")
###
> S->MultiDGSMBb(it,    it)->Map(B->Text.Concat(", "))
S->MultiDGSMBb(it, it)->Map(B->Text.Concat(", ")) : s*
BndKind:Call, Type:s*, Bnd:(Call(∂.ForEach([map:2] Call(∂.Test.MultiDGSMBb.Simple(Call(∂.ForEach([map:1] Global(S), {A:str(A's default), B:Scope(1), G:Scope(1)})))), Call(∂.Text.Concat(GetField(Scope(2), B), str(, )):s)):s*))
Func sig: (<ctx>:x, S:s*) to s*
Sequence: Seq<str>
 0) A: [A's default], B: [x]
 1) A: [A's default], B: [xy]
 2) A: [A's default], B: <null>
 3) A: [A's default], B: [xyz]
 4) A: [A's default], B: [hi]
 5) A: [A's default], B: [adios]
 6) A: [A's default], B: [hola]
 7) A: [A's default], B: [guten morgen]
*** Ctx ping count: 24
    [0](24): Text.Concat(*1x.B, ", ")
###
> S->MultiDGSMBb(it, A: it) //->Map(B->Text.Concat(", ")) // Error.
S->MultiDGSMBb(it, A : it) : {B:s*}*
BndKind:Call, Type:{B:s*}*, Bnd:(Call(∂.Test.MultiDGSMBb*([map:1] Global(S), Scope(1), A : Scope(1))))
*** Error: (1,3) Node: S->MultiDGSMBb(it, A : it), Message: No overload can be found matching these names and directives.
*** Error: (20,21) Node: A : it, Message: Missing argument: 'B'
###
> S->MultiDGSMC(it, A: it)->Map(B->Text.Concat(", "))
S->MultiDGSMC(it, A : it)->Map(B->Text.Concat(", ")) : s*
BndKind:Call, Type:s*, Bnd:(Call(∂.ForEach([map:2] Call(∂.Test.MultiDGSMC.Simple(Call(∂.ForEach([map:1] Global(S), {A:Scope(1), C:null:{D:s, E:s}*, G:Scope(1)})))), Call(∂.Text.Concat(GetField(Scope(2), B), str(, )):s)):s*))
Func sig: (<ctx>:x, S:s*) to s*
Sequence: Seq<str>
 0) A: [x], C: [0]
 1) A: [xy], C: [0]
 2) A: <null>, C: [0]
 3) A: [xyz], C: [0]
 4) A: [hi], C: [0]
 5) A: [adios], C: [0]
 6) A: [hola], C: [0]
 7) A: [guten morgen], C: [0]
*** Ctx ping count: 24
    [0](24): Text.Concat(*1x.B, ", ")
###
> TC->MultiDGSMCc(G, A: A, C: C)->Map(B->Text.Concat(", "))
TC->MultiDGSMCc(G, A : A, C : C)->Map(B->Text.Concat(", ")) : s*
BndKind:Call, Type:s*, Bnd:(Call(∂.Guard([guard:1] Global(TC), Call(∂.ForEach([map:4] Call(∂.Test.MultiDGSMCc.MergeSeq([with:2] Scope(1), Call(∂.ForEach([map:3] Scope(2), {A:GetField(Scope(3), A), C:GetField(Scope(3), C), G:GetField(Scope(3), G)})), Scope(2))), Call(∂.Text.Concat(GetField(Scope(4), B), str(, )):s)):s*)):s*))
Func sig: (<ctx>:x, TC:{A:s, C:{D:s, E:s}*, G:i8}*) to s*
Sequence: Seq<str>
 0) A: [x], C: [0]
 1) A: [xy], C: [2]
 2) A: <null>, C: [4]
 3) A: [xyz], C: [6]
 4) A: [hi], C: [8]
 5) A: [adios], C: [10]
 6) A: [hola], C: [12]
 7) A: [guten morgen], C: [14]
*** Ctx ping count: 24
    [0](24): Text.Concat(*1x.B, ", ")
###
> S->MultiDGSMB(it,    it & "-1st",    it & "-2nd")->Map(B->Text.Concat(", ")) // For comparison.
S->MultiDGSMB(it, it & "-1st", it & "-2nd")->Map(B->Text.Concat(", ")) : s*
BndKind:Call, Type:s*, Bnd:(Call(∂.ForEach([map:2] Call(∂.Test.MultiDGSMB.Simple(Call(∂.ForEach([map:1] Global(S), {A:StrConcat(Scope(1), str(-2nd)), B:StrConcat(Scope(1), str(-1st)), G:Scope(1)})))), Call(∂.Text.Concat(GetField(Scope(2), B), str(, )):s)):s*))
Func sig: (<ctx>:x, S:s*) to s*
Sequence: Seq<str>
 0) A: [x-2nd], B: [x-1st]
 1) A: [xy-2nd], B: [xy-1st]
 2) A: [-2nd], B: [-1st]
 3) A: [xyz-2nd], B: [xyz-1st]
 4) A: [hi-2nd], B: [hi-1st]
 5) A: [adios-2nd], B: [adios-1st]
 6) A: [hola-2nd], B: [hola-1st]
 7) A: [guten morgen-2nd], B: [guten morgen-1st]
*** Ctx ping count: 24
    [0](24): Text.Concat(*1x.B, ", ")
###
> S->MultiDGRMB(it,    it & "-1st",    it & "-2nd")->Map(B->Text.Concat(", "))
S->MultiDGRMB(it, it & "-1st", it & "-2nd")->Map(B->Text.Concat(", ")) : s*
BndKind:Call, Type:s*, Bnd:(Call(∂.ForEach([map:2] Call(∂.Test.MultiDGRMB.Simple({Mis:Call(∂.ForEach([map:1] Global(S), {A:StrConcat(Scope(1), str(-2nd)), B:StrConcat(Scope(1), str(-1st)), G:Scope(1)})), S1:str(/def), S2:3:i8})), Call(∂.Text.Concat(GetField(Scope(2), B), str(, )):s)):s*))
Func sig: (<ctx>:x, S:s*) to s*
Sequence: Seq<str>
 0) A: [x-2/def], B: [x-1/def]
 1) A: [xy-/def], B: [xy-/def]
 2) A: [-2n/def], B: [-1s/def]
 3) A: [xyz/def], B: [xyz/def]
 4) A: [hi-/def], B: [hi-/def]
 5) A: [adi/def], B: [adi/def]
 6) A: [hol/def], B: [hol/def]
 7) A: [gut/def], B: [gut/def]
*** Ctx ping count: 24
    [0](24): Text.Concat(*1x.B, ", ")
###
> S->MultiDGRMB(it,    it & "-1st",    it & "-2nd",     "/suf")->Map(B->Text.Concat(", "))
S->MultiDGRMB(it, it & "-1st", it & "-2nd", "/suf")->Map(B->Text.Concat(", ")) : s*
BndKind:Call, Type:s*, Bnd:(Call(∂.ForEach([map:2] Call(∂.Test.MultiDGRMB.Simple({Mis:Call(∂.ForEach([map:1] Global(S), {A:StrConcat(Scope(1), str(-2nd)), B:StrConcat(Scope(1), str(-1st)), G:Scope(1)})), S1:str(/suf), S2:3:i8})), Call(∂.Text.Concat(GetField(Scope(2), B), str(, )):s)):s*))
Func sig: (<ctx>:x, S:s*) to s*
Sequence: Seq<str>
 0) A: [x-2/suf], B: [x-1/suf]
 1) A: [xy-/suf], B: [xy-/suf]
 2) A: [-2n/suf], B: [-1s/suf]
 3) A: [xyz/suf], B: [xyz/suf]
 4) A: [hi-/suf], B: [hi-/suf]
 5) A: [adi/suf], B: [adi/suf]
 6) A: [hol/suf], B: [hol/suf]
 7) A: [gut/suf], B: [gut/suf]
*** Ctx ping count: 24
    [0](24): Text.Concat(*1x.B, ", ")
###
> S->MultiDGRMB(it,    it & "-1st",    it & "-2nd", S1: "/suf")->Map(B->Text.Concat(", "))
S->MultiDGRMB(it, it & "-1st", it & "-2nd", S1 : "/suf")->Map(B->Text.Concat(", ")) : s*
BndKind:Call, Type:s*, Bnd:(Call(∂.ForEach([map:2] Call(∂.Test.MultiDGRMB.Simple({Mis:Call(∂.ForEach([map:1] Global(S), {A:StrConcat(Scope(1), str(-2nd)), B:StrConcat(Scope(1), str(-1st)), G:Scope(1)})), S1:str(/suf), S2:3:i8})), Call(∂.Text.Concat(GetField(Scope(2), B), str(, )):s)):s*))
Func sig: (<ctx>:x, S:s*) to s*
Sequence: Seq<str>
 0) A: [x-2/suf], B: [x-1/suf]
 1) A: [xy-/suf], B: [xy-/suf]
 2) A: [-2n/suf], B: [-1s/suf]
 3) A: [xyz/suf], B: [xyz/suf]
 4) A: [hi-/suf], B: [hi-/suf]
 5) A: [adi/suf], B: [adi/suf]
 6) A: [hol/suf], B: [hol/suf]
 7) A: [gut/suf], B: [gut/suf]
*** Ctx ping count: 24
    [0](24): Text.Concat(*1x.B, ", ")
###
> S->MultiDGRMB(it,    it & "-1st",    it & "-2nd", S2: 7     )->Map(B->Text.Concat(", "))
S->MultiDGRMB(it, it & "-1st", it & "-2nd", S2 : 7)->Map(B->Text.Concat(", ")) : s*
BndKind:Call, Type:s*, Bnd:(Call(∂.ForEach([map:2] Call(∂.Test.MultiDGRMB.Simple({Mis:Call(∂.ForEach([map:1] Global(S), {A:StrConcat(Scope(1), str(-2nd)), B:StrConcat(Scope(1), str(-1st)), G:Scope(1)})), S1:str(/def), S2:7:i8})), Call(∂.Text.Concat(GetField(Scope(2), B), str(, )):s)):s*))
Func sig: (<ctx>:x, S:s*) to s*
Sequence: Seq<str>
 0) A: [x-2nd/def], B: [x-1st/def]
 1) A: [xy-2nd/def], B: [xy-1st/def]
 2) A: [-2nd/def], B: [-1st/def]
 3) A: [xyz-2nd/def], B: [xyz-1st/def]
 4) A: [hi-2nd/def], B: [hi-1st/def]
 5) A: [adios-2/def], B: [adios-1/def]
 6) A: [hola-2n/def], B: [hola-1s/def]
 7) A: [guten m/def], B: [guten m/def]
*** Ctx ping count: 24
    [0](24): Text.Concat(*1x.B, ", ")
###
> S->MultiDGRMB(it,    it & "-1st",    it & "-2nd",     "/suf",     7)->Map(B->Text.Concat(", "))
S->MultiDGRMB(it, it & "-1st", it & "-2nd", "/suf", 7)->Map(B->Text.Concat(", ")) : s*
BndKind:Call, Type:s*, Bnd:(Call(∂.ForEach([map:2] Call(∂.Test.MultiDGRMB.Simple({Mis:Call(∂.ForEach([map:1] Global(S), {A:StrConcat(Scope(1), str(-2nd)), B:StrConcat(Scope(1), str(-1st)), G:Scope(1)})), S1:str(/suf), S2:7:i8})), Call(∂.Text.Concat(GetField(Scope(2), B), str(, )):s)):s*))
Func sig: (<ctx>:x, S:s*) to s*
Sequence: Seq<str>
 0) A: [x-2nd/suf], B: [x-1st/suf]
 1) A: [xy-2nd/suf], B: [xy-1st/suf]
 2) A: [-2nd/suf], B: [-1st/suf]
 3) A: [xyz-2nd/suf], B: [xyz-1st/suf]
 4) A: [hi-2nd/suf], B: [hi-1st/suf]
 5) A: [adios-2/suf], B: [adios-1/suf]
 6) A: [hola-2n/suf], B: [hola-1s/suf]
 7) A: [guten m/suf], B: [guten m/suf]
*** Ctx ping count: 24
    [0](24): Text.Concat(*1x.B, ", ")
###
> S->MultiDGRMB(it,    it & "-1st",    it & "-2nd",     "/suf", S2: 7)->Map(B->Text.Concat(", "))
S->MultiDGRMB(it, it & "-1st", it & "-2nd", "/suf", S2 : 7)->Map(B->Text.Concat(", ")) : s*
BndKind:Call, Type:s*, Bnd:(Call(∂.ForEach([map:2] Call(∂.Test.MultiDGRMB.Simple({Mis:Call(∂.ForEach([map:1] Global(S), {A:StrConcat(Scope(1), str(-2nd)), B:StrConcat(Scope(1), str(-1st)), G:Scope(1)})), S1:str(/suf), S2:7:i8})), Call(∂.Text.Concat(GetField(Scope(2), B), str(, )):s)):s*))
Func sig: (<ctx>:x, S:s*) to s*
Sequence: Seq<str>
 0) A: [x-2nd/suf], B: [x-1st/suf]
 1) A: [xy-2nd/suf], B: [xy-1st/suf]
 2) A: [-2nd/suf], B: [-1st/suf]
 3) A: [xyz-2nd/suf], B: [xyz-1st/suf]
 4) A: [hi-2nd/suf], B: [hi-1st/suf]
 5) A: [adios-2/suf], B: [adios-1/suf]
 6) A: [hola-2n/suf], B: [hola-1s/suf]
 7) A: [guten m/suf], B: [guten m/suf]
*** Ctx ping count: 24
    [0](24): Text.Concat(*1x.B, ", ")
###
> S->MultiDGRMB(it,    it & "-1st",    it & "-2nd", S1: "/suf",     7)->Map(B->Text.Concat(", "))
S->MultiDGRMB(it, it & "-1st", it & "-2nd", S1 : "/suf", 7)->Map(B->Text.Concat(", ")) : s*
BndKind:Call, Type:s*, Bnd:(Call(∂.ForEach([map:2] Call(∂.Test.MultiDGRMB.Simple({Mis:Call(∂.ForEach([map:1] Global(S), {A:StrConcat(Scope(1), str(-2nd)), B:StrConcat(Scope(1), str(-1st)), G:Scope(1)})), S1:str(/suf), S2:7:i8})), Call(∂.Text.Concat(GetField(Scope(2), B), str(, )):s)):s*))
Func sig: (<ctx>:x, S:s*) to s*
Sequence: Seq<str>
 0) A: [x-2nd/suf], B: [x-1st/suf]
 1) A: [xy-2nd/suf], B: [xy-1st/suf]
 2) A: [-2nd/suf], B: [-1st/suf]
 3) A: [xyz-2nd/suf], B: [xyz-1st/suf]
 4) A: [hi-2nd/suf], B: [hi-1st/suf]
 5) A: [adios-2/suf], B: [adios-1/suf]
 6) A: [hola-2n/suf], B: [hola-1s/suf]
 7) A: [guten m/suf], B: [guten m/suf]
*** Ctx ping count: 24
    [0](24): Text.Concat(*1x.B, ", ")
###
> S->MultiDGRMB(it,    it & "-1st",    it & "-2nd", S1: "/suf", S2: 7)->Map(B->Text.Concat(", "))
S->MultiDGRMB(it, it & "-1st", it & "-2nd", S1 : "/suf", S2 : 7)->Map(B->Text.Concat(", ")) : s*
BndKind:Call, Type:s*, Bnd:(Call(∂.ForEach([map:2] Call(∂.Test.MultiDGRMB.Simple({Mis:Call(∂.ForEach([map:1] Global(S), {A:StrConcat(Scope(1), str(-2nd)), B:StrConcat(Scope(1), str(-1st)), G:Scope(1)})), S1:str(/suf), S2:7:i8})), Call(∂.Text.Concat(GetField(Scope(2), B), str(, )):s)):s*))
Func sig: (<ctx>:x, S:s*) to s*
Sequence: Seq<str>
 0) A: [x-2nd/suf], B: [x-1st/suf]
 1) A: [xy-2nd/suf], B: [xy-1st/suf]
 2) A: [-2nd/suf], B: [-1st/suf]
 3) A: [xyz-2nd/suf], B: [xyz-1st/suf]
 4) A: [hi-2nd/suf], B: [hi-1st/suf]
 5) A: [adios-2/suf], B: [adios-1/suf]
 6) A: [hola-2n/suf], B: [hola-1s/suf]
 7) A: [guten m/suf], B: [guten m/suf]
*** Ctx ping count: 24
    [0](24): Text.Concat(*1x.B, ", ")
###
> S->MultiDGRMB(it,    it & "-1st",    it & "-2nd", S2: 7,     "/suf")->Map(B->Text.Concat(", ")) // Error.
S->MultiDGRMB(it, it & "-1st", it & "-2nd", S2 : 7, "/suf")->Map(B->Text.Concat(", ")) : s*
BndKind:Call, Type:s*, Bnd:(Call(∂.ForEach([map:2] Call(∂.Test.MultiDGRMB*([map:1] Global(S), Scope(1), StrConcat(Scope(1), str(-1st)), StrConcat(Scope(1), str(-2nd)), S2 : 7:i8, Error(ErrBadType_Src_Dst))), Call(∂.Text.Concat(GetField(Scope(2), B), str(, )):s)):s*))
*** Error: (1,3) Node: S->MultiDGRMB(it, it & "-1st", it & "-2nd", S2 : 7, "/suf"), Message: No overload can be found matching these names and directives.
*** Error: (61,67) Node: "/suf", Message: The argument in position 6 of 'MultiDGRMB' should include a field name
*** Error: (61,67) Node: "/suf", Message: Invalid operand type: cannot convert type 's' to 'i8'
###
> S->MultiDGRMB(it,    it & "-1st",    it & "-2nd", S2: 7, S1: "/suf")->Map(B->Text.Concat(", "))
S->MultiDGRMB(it, it & "-1st", it & "-2nd", S2 : 7, S1 : "/suf")->Map(B->Text.Concat(", ")) : s*
BndKind:Call, Type:s*, Bnd:(Call(∂.ForEach([map:2] Call(∂.Test.MultiDGRMB.Simple({Mis:Call(∂.ForEach([map:1] Global(S), {A:StrConcat(Scope(1), str(-2nd)), B:StrConcat(Scope(1), str(-1st)), G:Scope(1)})), S1:str(/suf), S2:7:i8})), Call(∂.Text.Concat(GetField(Scope(2), B), str(, )):s)):s*))
Func sig: (<ctx>:x, S:s*) to s*
Sequence: Seq<str>
 0) A: [x-2nd/suf], B: [x-1st/suf]
 1) A: [xy-2nd/suf], B: [xy-1st/suf]
 2) A: [-2nd/suf], B: [-1st/suf]
 3) A: [xyz-2nd/suf], B: [xyz-1st/suf]
 4) A: [hi-2nd/suf], B: [hi-1st/suf]
 5) A: [adios-2/suf], B: [adios-1/suf]
 6) A: [hola-2n/suf], B: [hola-1s/suf]
 7) A: [guten m/suf], B: [guten m/suf]
*** Ctx ping count: 24
    [0](24): Text.Concat(*1x.B, ", ")
###
> S->MultiDGrMB({ B: "b-" & it, A: "a-" & it, G: "g-" & it }, S2: 7, S1: "/suf")->Map(B->Text.Concat(", "))
S->MultiDGrMB({ B : "b-" & it, A : "a-" & it, G : "g-" & it }, S2 : 7, S1 : "/suf")->Map(B->Text.Concat(", ")) : s*
BndKind:Call, Type:s*, Bnd:(Call(∂.ForEach([map:2] Call(∂.Test.MultiDGrMB.Simple({Mis:Call(∂.ForEach([map:1] Global(S), {A:StrConcat(str(a-), Scope(1)), B:StrConcat(str(b-), Scope(1)), G:StrConcat(str(g-), Scope(1))})), S1:str(/suf), S2:7:i8})), Call(∂.Text.Concat(GetField(Scope(2), B), str(, )):s)):s*))
Func sig: (<ctx>:x, S:s*) to s*
Sequence: Seq<str>
 0) A: [a-x/suf], B: [b-x/suf]
 1) A: [a-xy/suf], B: [b-xy/suf]
 2) A: [a-/suf], B: [b-/suf]
 3) A: [a-xyz/suf], B: [b-xyz/suf]
 4) A: [a-hi/suf], B: [b-hi/suf]
 5) A: [a-adios/suf], B: [b-adios/suf]
 6) A: [a-hola/suf], B: [b-hola/suf]
 7) A: [a-guten/suf], B: [b-guten/suf]
*** Ctx ping count: 24
    [0](24): Text.Concat(*1x.B, ", ")
###
> MultiDGfMB(S->Map({ B: "b-" & it, A: "a-" & it, G: "g-" & it }), S2: 7, S1: "/suf")->Map(B->Text.Concat(", "))
MultiDGfMB(S->Map({ B : "b-" & it, A : "a-" & it, G : "g-" & it }), S2 : 7, S1 : "/suf")->Map(B->Text.Concat(", ")) : s*
BndKind:Call, Type:s*, Bnd:(Call(∂.ForEach([map:2] Call(∂.Test.MultiDGfMB.Simple({Mis:Call(∂.ForEach([map:1] Global(S), {A:StrConcat(str(a-), Scope(1)), B:StrConcat(str(b-), Scope(1)), G:StrConcat(str(g-), Scope(1))})), S1:str(/suf), S2:7:i8})), Call(∂.Text.Concat(GetField(Scope(2), B), str(, )):s)):s*))
Func sig: (<ctx>:x, S:s*) to s*
Sequence: Seq<str>
 0) A: [a-x/suf], B: [b-x/suf]
 1) A: [a-xy/suf], B: [b-xy/suf]
 2) A: [a-/suf], B: [b-/suf]
 3) A: [a-xyz/suf], B: [b-xyz/suf]
 4) A: [a-hi/suf], B: [b-hi/suf]
 5) A: [a-adios/suf], B: [b-adios/suf]
 6) A: [a-hola/suf], B: [b-hola/suf]
 7) A: [a-guten/suf], B: [b-guten/suf]
*** Ctx ping count: 24
    [0](24): Text.Concat(*1x.B, ", ")
###
> MultiDGRMB({ Mis: TB, S1: "/pre", S2: 5 })->Map(B->Text.Concat(", "))
MultiDGRMB({ Mis : TB, S1 : "/pre", S2 : 5 })->Map(B->Text.Concat(", ")) : s*
BndKind:Call, Type:s*, Bnd:(Call(∂.ForEach([map:2] Call(∂.Test.MultiDGRMB.Simple({Mis:Call(∂.ForEach([map:1] Global(TB), {A:GetField(Scope(1), A), B:GetField(Scope(1), B), G:GetField(Scope(1), G)})), S1:str(/pre), S2:5:i8})), Call(∂.Text.Concat(GetField(Scope(2), B), str(, )):s)):s*))
Func sig: (<ctx>:x, TB:{A:s, B:s, G:(i8, s), X:r8}*) to s*
Sequence: Seq<str>
 0) A: [x/pre], B: [x/pre]
 1) A: <null>/pre, B: [xy/pre]
 2) A: <null>/pre, B: <null>/pre
 3) A: [xyz/pre], B: [xyz/pre]
 4) A: <null>/pre, B: [hi/pre]
 5) A: [adios/pre], B: <null>/pre
 6) A: [hola/pre], B: [hola/pre]
 7) A: <null>/pre, B: [guten/pre]
*** Ctx ping count: 24
    [0](24): Text.Concat(*1x.B, ", ")
###
> MultiDGfMB(  Mis: TB, S1: "/pre", S2: 5  )->Map(B->Text.Concat(", "))
MultiDGfMB(Mis : TB, S1 : "/pre", S2 : 5)->Map(B->Text.Concat(", ")) : s*
BndKind:Call, Type:s*, Bnd:(Call(∂.ForEach([map:2] Call(∂.Test.MultiDGfMB.Simple({Mis:Call(∂.ForEach([map:1] Global(TB), {A:GetField(Scope(1), A), B:GetField(Scope(1), B), G:GetField(Scope(1), G)})), S1:str(/pre), S2:5:i8})), Call(∂.Text.Concat(GetField(Scope(2), B), str(, )):s)):s*))
Func sig: (<ctx>:x, TB:{A:s, B:s, G:(i8, s), X:r8}*) to s*
Sequence: Seq<str>
 0) A: [x/pre], B: [x/pre]
 1) A: <null>/pre, B: [xy/pre]
 2) A: <null>/pre, B: <null>/pre
 3) A: [xyz/pre], B: [xyz/pre]
 4) A: <null>/pre, B: [hi/pre]
 5) A: [adios/pre], B: <null>/pre
 6) A: [hola/pre], B: [hola/pre]
 7) A: <null>/pre, B: [guten/pre]
*** Ctx ping count: 24
    [0](24): Text.Concat(*1x.B, ", ")
###
> TA->MultiDGRMB(G, A)->Map(it+>{ B: "[" & B->Text.Concat(", ") & "]" })
TA->MultiDGRMB(G, A)->Map(it+>{ B : "[" & B->Text.Concat(", ") & "]" }) : {A:s, B:s, G:(s, i8), X:r8}*
BndKind:Call, Type:{A:s, B:s, G:(s, i8), X:r8}*, Bnd:(Call(∂.Guard([guard:1] Global(TA), Call(∂.ForEach([map:4] Call(∂.Test.MultiDGRMB.MergeRec([with:2] Scope(1), {Mis:Call(∂.ForEach([map:3] Scope(2), {A:str(A's default), B:GetField(Scope(3), A), G:GetField(Scope(3), G)})), S1:str(/def), S2:3:i8}, Scope(2))), SetFields([with:5] Scope(4), B : StrConcat(str([), Call(∂.Text.Concat(GetField(Scope(5), B), str(, )):s), str(]))))))))
Func sig: (<ctx>:x, TA:{A:s, G:(s, i8), X:r8}*) to {A:s, B:s, G:(s, i8), X:r8}*
Sequence: Seq<{str,str,(str,i8),r8}>
 0) { A: x, B: [A: [A's/def], B: [x/def]], G: (x, 0), X: 1 }
 1) { A: xy, B: [A: [A's/def], B: [xy/def]], G: (xy, 1), X: 2 }
 2) { A: <null>, B: [A: [A's/def], B: <null>/def], G: (<null>, 2), X: 3 }
 3) { A: xyz, B: [A: [A's/def], B: [xyz/def]], G: (xyz, 3), X: 4 }
 4) { A: hi, B: [A: [A's/def], B: [hi/def]], G: (hi, 4), X: 5 }
 5) { A: adios, B: [A: [A's/def], B: [adi/def]], G: (adios, 5), X: 6 }
 6) { A: hola, B: [A: [A's/def], B: [hol/def]], G: (hola, 6), X: 7 }
 7) { A: guten morgen, B: [A: [A's/def], B: [gut/def]], G: (guten morgen, 7), X: 8 }
*** Ctx ping count: 24
    [0](24): Text.Concat(!1x.B, ", ")
###
> TB->MultiDGRMB(G, B, A)->Map(it+>{ B2: "[" & B2->Text.Concat(", ") & "]" })
TB->MultiDGRMB(G, B, A)->Map(it+>{ B2 : "[" & B2->Text.Concat(", ") & "]" }) : {A:s, B:s, B2:s, G:(i8, s), X:r8}*
BndKind:Call, Type:{A:s, B:s, B2:s, G:(i8, s), X:r8}*, Bnd:(Call(∂.Guard([guard:1] Global(TB), Call(∂.ForEach([map:4] Call(∂.Test.MultiDGRMB.MergeRec([with:2] Scope(1), {Mis:Call(∂.ForEach([map:3] Scope(2), {A:GetField(Scope(3), A), B:GetField(Scope(3), B), G:GetField(Scope(3), G)})), S1:str(/def), S2:3:i8}, Scope(2))), SetFields([with:5] Scope(4), B2 : StrConcat(str([), Call(∂.Text.Concat(GetField(Scope(5), B2), str(, )):s), str(]))))))))
Func sig: (<ctx>:x, TB:{A:s, B:s, G:(i8, s), X:r8}*) to {A:s, B:s, B2:s, G:(i8, s), X:r8}*
Sequence: Seq<{str,str,str,(i8,str),r8}>
 0) { A: x, B: x, B2: [A: [x/def], B: [x/def]], G: (0, x), X: 1 }
 1) { A: <null>, B: xy, B2: [A: <null>/def, B: [xy/def]], G: (1, xy), X: 2 }
 2) { A: <null>, B: <null>, B2: [A: <null>/def, B: <null>/def], G: (2, <null>), X: 3 }
 3) { A: xyz, B: xyz, B2: [A: [xyz/def], B: [xyz/def]], G: (3, xyz), X: 4 }
 4) { A: <null>, B: hi, B2: [A: <null>/def, B: [hi/def]], G: (4, hi), X: 5 }
 5) { A: adios, B: <null>, B2: [A: [adi/def], B: <null>/def], G: (5, adios), X: 6 }
 6) { A: hola, B: hola, B2: [A: [hol/def], B: [hol/def]], G: (6, hola), X: 7 }
 7) { A: <null>, B: guten morgen, B2: [A: <null>/def, B: [gut/def]], G: (7, guten morgen), X: 8 }
*** Ctx ping count: 24
    [0](24): Text.Concat(!1x.B2, ", ")
###
> TB->MultiDGRMB(G, B, A, "/suf")->Map(it+>{ B2: "[" & B2->Text.Concat(", ") & "]" })
TB->MultiDGRMB(G, B, A, "/suf")->Map(it+>{ B2 : "[" & B2->Text.Concat(", ") & "]" }) : {A:s, B:s, B2:s, G:(i8, s), X:r8}*
BndKind:Call, Type:{A:s, B:s, B2:s, G:(i8, s), X:r8}*, Bnd:(Call(∂.Guard([guard:1] Global(TB), Call(∂.ForEach([map:4] Call(∂.Test.MultiDGRMB.MergeRec([with:2] Scope(1), {Mis:Call(∂.ForEach([map:3] Scope(2), {A:GetField(Scope(3), A), B:GetField(Scope(3), B), G:GetField(Scope(3), G)})), S1:str(/suf), S2:3:i8}, Scope(2))), SetFields([with:5] Scope(4), B2 : StrConcat(str([), Call(∂.Text.Concat(GetField(Scope(5), B2), str(, )):s), str(]))))))))
Func sig: (<ctx>:x, TB:{A:s, B:s, G:(i8, s), X:r8}*) to {A:s, B:s, B2:s, G:(i8, s), X:r8}*
Sequence: Seq<{str,str,str,(i8,str),r8}>
 0) { A: x, B: x, B2: [A: [x/suf], B: [x/suf]], G: (0, x), X: 1 }
 1) { A: <null>, B: xy, B2: [A: <null>/suf, B: [xy/suf]], G: (1, xy), X: 2 }
 2) { A: <null>, B: <null>, B2: [A: <null>/suf, B: <null>/suf], G: (2, <null>), X: 3 }
 3) { A: xyz, B: xyz, B2: [A: [xyz/suf], B: [xyz/suf]], G: (3, xyz), X: 4 }
 4) { A: <null>, B: hi, B2: [A: <null>/suf, B: [hi/suf]], G: (4, hi), X: 5 }
 5) { A: adios, B: <null>, B2: [A: [adi/suf], B: <null>/suf], G: (5, adios), X: 6 }
 6) { A: hola, B: hola, B2: [A: [hol/suf], B: [hol/suf]], G: (6, hola), X: 7 }
 7) { A: <null>, B: guten morgen, B2: [A: <null>/suf, B: [gut/suf]], G: (7, guten morgen), X: 8 }
*** Ctx ping count: 24
    [0](24): Text.Concat(!1x.B2, ", ")
###
> TB->MultiDGRMB(G, B, A, "/suf", 5)->Map(it+>{ B2: "[" & B2->Text.Concat(", ") & "]" })
TB->MultiDGRMB(G, B, A, "/suf", 5)->Map(it+>{ B2 : "[" & B2->Text.Concat(", ") & "]" }) : {A:s, B:s, B2:s, G:(i8, s), X:r8}*
BndKind:Call, Type:{A:s, B:s, B2:s, G:(i8, s), X:r8}*, Bnd:(Call(∂.Guard([guard:1] Global(TB), Call(∂.ForEach([map:4] Call(∂.Test.MultiDGRMB.MergeRec([with:2] Scope(1), {Mis:Call(∂.ForEach([map:3] Scope(2), {A:GetField(Scope(3), A), B:GetField(Scope(3), B), G:GetField(Scope(3), G)})), S1:str(/suf), S2:5:i8}, Scope(2))), SetFields([with:5] Scope(4), B2 : StrConcat(str([), Call(∂.Text.Concat(GetField(Scope(5), B2), str(, )):s), str(]))))))))
Func sig: (<ctx>:x, TB:{A:s, B:s, G:(i8, s), X:r8}*) to {A:s, B:s, B2:s, G:(i8, s), X:r8}*
Sequence: Seq<{str,str,str,(i8,str),r8}>
 0) { A: x, B: x, B2: [A: [x/suf], B: [x/suf]], G: (0, x), X: 1 }
 1) { A: <null>, B: xy, B2: [A: <null>/suf, B: [xy/suf]], G: (1, xy), X: 2 }
 2) { A: <null>, B: <null>, B2: [A: <null>/suf, B: <null>/suf], G: (2, <null>), X: 3 }
 3) { A: xyz, B: xyz, B2: [A: [xyz/suf], B: [xyz/suf]], G: (3, xyz), X: 4 }
 4) { A: <null>, B: hi, B2: [A: <null>/suf, B: [hi/suf]], G: (4, hi), X: 5 }
 5) { A: adios, B: <null>, B2: [A: [adios/suf], B: <null>/suf], G: (5, adios), X: 6 }
 6) { A: hola, B: hola, B2: [A: [hola/suf], B: [hola/suf]], G: (6, hola), X: 7 }
 7) { A: <null>, B: guten morgen, B2: [A: <null>/suf, B: [guten/suf]], G: (7, guten morgen), X: 8 }
*** Ctx ping count: 24
    [0](24): Text.Concat(!1x.B2, ", ")
###
> TB->MultiDGrMB({ G, B, A }, "/suf", 5)->Map(it+>{ B2: "[" & B2->Text.Concat(", ") & "]" })
TB->MultiDGrMB({ G, B, A }, "/suf", 5)->Map(it+>{ B2 : "[" & B2->Text.Concat(", ") & "]" }) : {A:s, B:s, B2:s, G:(i8, s), X:r8}*
BndKind:Call, Type:{A:s, B:s, B2:s, G:(i8, s), X:r8}*, Bnd:(Call(∂.Guard([guard:1] Global(TB), Call(∂.ForEach([map:4] Call(∂.Test.MultiDGrMB.MergeRec([with:2] Scope(1), {Mis:Call(∂.ForEach([map:3] Scope(2), {A:GetField(Scope(3), A), B:GetField(Scope(3), B), G:GetField(Scope(3), G)})), S1:str(/suf), S2:5:i8}, Scope(2))), SetFields([with:5] Scope(4), B2 : StrConcat(str([), Call(∂.Text.Concat(GetField(Scope(5), B2), str(, )):s), str(]))))))))
Func sig: (<ctx>:x, TB:{A:s, B:s, G:(i8, s), X:r8}*) to {A:s, B:s, B2:s, G:(i8, s), X:r8}*
Sequence: Seq<{str,str,str,(i8,str),r8}>
 0) { A: x, B: x, B2: [A: [x/suf], B: [x/suf]], G: (0, x), X: 1 }
 1) { A: <null>, B: xy, B2: [A: <null>/suf, B: [xy/suf]], G: (1, xy), X: 2 }
 2) { A: <null>, B: <null>, B2: [A: <null>/suf, B: <null>/suf], G: (2, <null>), X: 3 }
 3) { A: xyz, B: xyz, B2: [A: [xyz/suf], B: [xyz/suf]], G: (3, xyz), X: 4 }
 4) { A: <null>, B: hi, B2: [A: <null>/suf, B: [hi/suf]], G: (4, hi), X: 5 }
 5) { A: adios, B: <null>, B2: [A: [adios/suf], B: <null>/suf], G: (5, adios), X: 6 }
 6) { A: hola, B: hola, B2: [A: [hola/suf], B: [hola/suf]], G: (6, hola), X: 7 }
 7) { A: <null>, B: guten morgen, B2: [A: <null>/suf, B: [guten/suf]], G: (7, guten morgen), X: 8 }
*** Ctx ping count: 24
    [0](24): Text.Concat(!1x.B2, ", ")
###
> TB->MultiDGrMB({ G, A, B }, "/suf", 5)->Map(it+>{ B2: "[" & B2->Text.Concat(", ") & "]" })
TB->MultiDGrMB({ G, A, B }, "/suf", 5)->Map(it+>{ B2 : "[" & B2->Text.Concat(", ") & "]" }) : {A:s, B:s, B2:s, G:(i8, s), X:r8}*
BndKind:Call, Type:{A:s, B:s, B2:s, G:(i8, s), X:r8}*, Bnd:(Call(∂.Guard([guard:1] Global(TB), Call(∂.ForEach([map:4] Call(∂.Test.MultiDGrMB.MergeRec([with:2] Scope(1), {Mis:Call(∂.ForEach([map:3] Scope(2), {A:GetField(Scope(3), A), B:GetField(Scope(3), B), G:GetField(Scope(3), G)})), S1:str(/suf), S2:5:i8}, Scope(2))), SetFields([with:5] Scope(4), B2 : StrConcat(str([), Call(∂.Text.Concat(GetField(Scope(5), B2), str(, )):s), str(]))))))))
Func sig: (<ctx>:x, TB:{A:s, B:s, G:(i8, s), X:r8}*) to {A:s, B:s, B2:s, G:(i8, s), X:r8}*
Sequence: Seq<{str,str,str,(i8,str),r8}>
 0) { A: x, B: x, B2: [A: [x/suf], B: [x/suf]], G: (0, x), X: 1 }
 1) { A: <null>, B: xy, B2: [A: <null>/suf, B: [xy/suf]], G: (1, xy), X: 2 }
 2) { A: <null>, B: <null>, B2: [A: <null>/suf, B: <null>/suf], G: (2, <null>), X: 3 }
 3) { A: xyz, B: xyz, B2: [A: [xyz/suf], B: [xyz/suf]], G: (3, xyz), X: 4 }
 4) { A: <null>, B: hi, B2: [A: <null>/suf, B: [hi/suf]], G: (4, hi), X: 5 }
 5) { A: adios, B: <null>, B2: [A: [adios/suf], B: <null>/suf], G: (5, adios), X: 6 }
 6) { A: hola, B: hola, B2: [A: [hola/suf], B: [hola/suf]], G: (6, hola), X: 7 }
 7) { A: <null>, B: guten morgen, B2: [A: <null>/suf, B: [guten/suf]], G: (7, guten morgen), X: 8 }
*** Ctx ping count: 24
    [0](24): Text.Concat(!1x.B2, ", ")
###
> TB->MultiDGS_BW()+>{ Mos: Mos->Map(it+>{ B: "[" & B->Text.Concat(", ") & "]" }) }
TB->MultiDGS_BW()+>{ Mos : Mos->Map(it+>{ B : "[" & B->Text.Concat(", ") & "]" }) } : {Mos:{B:s}*, S1:s, S2:i8}
BndKind:SetFields, Type:{Mos:{B:s}*, S1:s, S2:i8}, Bnd:(SetFields([with:2] Call(∂.Test.MultiDGS_BW.Simple(Call(∂.ForEach([map:1] Global(TB), {A:GetField(Scope(1), A), B:GetField(Scope(1), B), G:GetField(Scope(1), G)})))), Mos : Call(∂.ForEach([map:3] GetField(Scope(2), Mos), SetFields([with:4] Scope(3), B : StrConcat(str([), Call(∂.Text.Concat(GetField(Scope(4), B), str(, )):s), str(])))))))
Func sig: (<ctx>:x, TB:{A:s, B:s, G:(i8, s), X:r8}*) to {Mos:{B:s}*, S1:s, S2:i8}
Type: {Seq<{str}>,str,i8}, Value: { Mos: Sequence: Seq<{str}>
     0) { B: [A: [x], B: [x]] }
     1) { B: [A: <null>, B: [xy]] }
     2) { B: [A: <null>, B: <null>] }
     3) { B: [A: [xyz], B: [xyz]] }
     4) { B: [A: <null>, B: [hi]] }
     5) { B: [A: [adios], B: <null>] }
     6) { B: [A: [hola], B: [hola]] }
     7) { B: [A: <null>, B: [guten morgen]] }
  S1: , S2: 9223372036854775807 }
*** Ctx ping count: 24
    [0](24): Text.Concat(!1x.B, ", ")
###
> TB->MultiDGSMBW()+>{ Mos: Mos->Map(it+>{ B2: "[" & B2->Text.Concat(", ") & "]" }) }
TB->MultiDGSMBW()+>{ Mos : Mos->Map(it+>{ B2 : "[" & B2->Text.Concat(", ") & "]" }) } : {Mos:{A:s, B:s, B2:s, G:(i8, s), X:r8}*, S1:s, S2:i8}
BndKind:SetFields, Type:{Mos:{A:s, B:s, B2:s, G:(i8, s), X:r8}*, S1:s, S2:i8}, Bnd:(SetFields([with:3] Call(∂.Test.MultiDGSMBW.MergeSeq([with:1] Global(TB), Call(∂.ForEach([map:2] Scope(1), {A:GetField(Scope(2), A), B:GetField(Scope(2), B), G:GetField(Scope(2), G)})), Scope(1))), Mos : Call(∂.ForEach([map:4] GetField(Scope(3), Mos), SetFields([with:5] Scope(4), B2 : StrConcat(str([), Call(∂.Text.Concat(GetField(Scope(5), B2), str(, )):s), str(])))))))
Func sig: (<ctx>:x, TB:{A:s, B:s, G:(i8, s), X:r8}*) to {Mos:{A:s, B:s, B2:s, G:(i8, s), X:r8}*, S1:s, S2:i8}
Type: {Seq<{str,str,str,(i8,str),r8}>,str,i8}, Value: { Mos: Sequence: Seq<{str,str,str,(i8,str),r8}>
     0) { A: x, B: x, B2: [A: [x], B: [x]], G: (0, x), X: 1 }
     1) { A: <null>, B: xy, B2: [A: <null>, B: [xy]], G: (1, xy), X: 2 }
     2) { A: <null>, B: <null>, B2: [A: <null>, B: <null>], G: (2, <null>), X: 3 }
     3) { A: xyz, B: xyz, B2: [A: [xyz], B: [xyz]], G: (3, xyz), X: 4 }
     4) { A: <null>, B: hi, B2: [A: <null>, B: [hi]], G: (4, hi), X: 5 }
     5) { A: adios, B: <null>, B2: [A: [adios], B: <null>], G: (5, adios), X: 6 }
     6) { A: hola, B: hola, B2: [A: [hola], B: [hola]], G: (6, hola), X: 7 }
     7) { A: <null>, B: guten morgen, B2: [A: <null>, B: [guten morgen]], G: (7, guten morgen), X: 8 }
  S1: , S2: 9223372036854775807 }
*** Ctx ping count: 24
    [0](24): Text.Concat(!1x.B2, ", ")
###
> S ->MultiDGSMBW(it, B: it & "-1st", A: it & "-2nd")+>{ Mos: Mos->Map(it+>{ B: "[" & B->Text.Concat(", ") & "]" }) }
S->MultiDGSMBW(it, B : it & "-1st", A : it & "-2nd")+>{ Mos : Mos->Map(it+>{ B : "[" & B->Text.Concat(", ") & "]" }) } : {Mos:{B:s}*, S1:s, S2:i8}
BndKind:SetFields, Type:{Mos:{B:s}*, S1:s, S2:i8}, Bnd:(SetFields([with:2] Call(∂.Test.MultiDGSMBW.Simple(Call(∂.ForEach([map:1] Global(S), {A:StrConcat(Scope(1), str(-2nd)), B:StrConcat(Scope(1), str(-1st)), G:Scope(1)})))), Mos : Call(∂.ForEach([map:3] GetField(Scope(2), Mos), SetFields([with:4] Scope(3), B : StrConcat(str([), Call(∂.Text.Concat(GetField(Scope(4), B), str(, )):s), str(])))))))
Func sig: (<ctx>:x, S:s*) to {Mos:{B:s}*, S1:s, S2:i8}
Type: {Seq<{str}>,str,i8}, Value: { Mos: Sequence: Seq<{str}>
     0) { B: [A: [x-2nd], B: [x-1st]] }
     1) { B: [A: [xy-2nd], B: [xy-1st]] }
     2) { B: [A: [-2nd], B: [-1st]] }
     3) { B: [A: [xyz-2nd], B: [xyz-1st]] }
     4) { B: [A: [hi-2nd], B: [hi-1st]] }
     5) { B: [A: [adios-2nd], B: [adios-1st]] }
     6) { B: [A: [hola-2nd], B: [hola-1st]] }
     7) { B: [A: [guten morgen-2nd], B: [guten morgen-1st]] }
  S1: , S2: 9223372036854775807 }
*** Ctx ping count: 24
    [0](24): Text.Concat(!1x.B, ", ")
###
> TB->MultiDGSMBW(G, A, B)+>{ Mos: Mos->Map(it+>{ B2: "[" & B2->Text.Concat(", ") & "]" }) }
TB->MultiDGSMBW(G, A, B)+>{ Mos : Mos->Map(it+>{ B2 : "[" & B2->Text.Concat(", ") & "]" }) } : {Mos:{A:s, B:s, B2:s, G:(i8, s), X:r8}*, S1:s, S2:i8}
BndKind:SetFields, Type:{Mos:{A:s, B:s, B2:s, G:(i8, s), X:r8}*, S1:s, S2:i8}, Bnd:(SetFields([with:3] Call(∂.Test.MultiDGSMBW.MergeSeq([with:1] Global(TB), Call(∂.ForEach([map:2] Scope(1), {A:GetField(Scope(2), B), B:GetField(Scope(2), A), G:GetField(Scope(2), G)})), Scope(1))), Mos : Call(∂.ForEach([map:4] GetField(Scope(3), Mos), SetFields([with:5] Scope(4), B2 : StrConcat(str([), Call(∂.Text.Concat(GetField(Scope(5), B2), str(, )):s), str(])))))))
Func sig: (<ctx>:x, TB:{A:s, B:s, G:(i8, s), X:r8}*) to {Mos:{A:s, B:s, B2:s, G:(i8, s), X:r8}*, S1:s, S2:i8}
Type: {Seq<{str,str,str,(i8,str),r8}>,str,i8}, Value: { Mos: Sequence: Seq<{str,str,str,(i8,str),r8}>
     0) { A: x, B: x, B2: [A: [x], B: [x]], G: (0, x), X: 1 }
     1) { A: <null>, B: xy, B2: [A: [xy], B: <null>], G: (1, xy), X: 2 }
     2) { A: <null>, B: <null>, B2: [A: <null>, B: <null>], G: (2, <null>), X: 3 }
     3) { A: xyz, B: xyz, B2: [A: [xyz], B: [xyz]], G: (3, xyz), X: 4 }
     4) { A: <null>, B: hi, B2: [A: [hi], B: <null>], G: (4, hi), X: 5 }
     5) { A: adios, B: <null>, B2: [A: <null>, B: [adios]], G: (5, adios), X: 6 }
     6) { A: hola, B: hola, B2: [A: [hola], B: [hola]], G: (6, hola), X: 7 }
     7) { A: <null>, B: guten morgen, B2: [A: [guten morgen], B: <null>], G: (7, guten morgen), X: 8 }
  S1: , S2: 9223372036854775807 }
*** Ctx ping count: 24
    [0](24): Text.Concat(!1x.B2, ", ")
###
> S ->MultiDGRMBW(it, A: it & "-1st", B: it & "-2nd", S1: "/suf", S2: 7)+>{ Mos: Mos->Map(B->Text.Concat(", ")) }
S->MultiDGRMBW(it, A : it & "-1st", B : it & "-2nd", S1 : "/suf", S2 : 7)+>{ Mos : Mos->Map(B->Text.Concat(", ")) } : {Mos:s*, S1:s, S2:i8}
BndKind:SetFields, Type:{Mos:s*, S1:s, S2:i8}, Bnd:(SetFields([with:2] Call(∂.Test.MultiDGRMBW.Simple({Mis:Call(∂.ForEach([map:1] Global(S), {A:StrConcat(Scope(1), str(-1st)), B:StrConcat(Scope(1), str(-2nd)), G:Scope(1)})), S1:str(/suf), S2:7:i8})), Mos : Call(∂.ForEach([map:3] GetField(Scope(2), Mos), Call(∂.Text.Concat(GetField(Scope(3), B), str(, )):s)):s*)))
Func sig: (<ctx>:x, S:s*) to {Mos:s*, S1:s, S2:i8}
Type: {Seq<str>,str,i8}, Value: { Mos: Sequence: Seq<str>
     0) A: [x-1st/suf], B: [x-2nd/suf]
     1) A: [xy-1st/suf], B: [xy-2nd/suf]
     2) A: [-1st/suf], B: [-2nd/suf]
     3) A: [xyz-1st/suf], B: [xyz-2nd/suf]
     4) A: [hi-1st/suf], B: [hi-2nd/suf]
     5) A: [adios-1/suf], B: [adios-2/suf]
     6) A: [hola-1s/suf], B: [hola-2n/suf]
     7) A: [guten m/suf], B: [guten m/suf]
  S1: /suf, S2: 7 }
*** Ctx ping count: 24
    [0](24): Text.Concat(*1x.B, ", ")
###
> TB->MultiDGRMBW(G, B, A           )+>{ Mos: Mos->Map(it+>{ B2: "[" & B2->Text.Concat(", ") & "]" }) }
TB->MultiDGRMBW(G, B, A)+>{ Mos : Mos->Map(it+>{ B2 : "[" & B2->Text.Concat(", ") & "]" }) } : {Mos:{A:s, B:s, B2:s, G:(i8, s), X:r8}*, S1:s, S2:i8}
BndKind:SetFields, Type:{Mos:{A:s, B:s, B2:s, G:(i8, s), X:r8}*, S1:s, S2:i8}, Bnd:(SetFields([with:3] Call(∂.Test.MultiDGRMBW.MergeRec([with:1] Global(TB), {Mis:Call(∂.ForEach([map:2] Scope(1), {A:GetField(Scope(2), A), B:GetField(Scope(2), B), G:GetField(Scope(2), G)})), S1:str(/def), S2:3:i8}, Scope(1))), Mos : Call(∂.ForEach([map:4] GetField(Scope(3), Mos), SetFields([with:5] Scope(4), B2 : StrConcat(str([), Call(∂.Text.Concat(GetField(Scope(5), B2), str(, )):s), str(])))))))
Func sig: (<ctx>:x, TB:{A:s, B:s, G:(i8, s), X:r8}*) to {Mos:{A:s, B:s, B2:s, G:(i8, s), X:r8}*, S1:s, S2:i8}
Type: {Seq<{str,str,str,(i8,str),r8}>,str,i8}, Value: { Mos: Sequence: Seq<{str,str,str,(i8,str),r8}>
     0) { A: x, B: x, B2: [A: [x/def], B: [x/def]], G: (0, x), X: 1 }
     1) { A: <null>, B: xy, B2: [A: <null>/def, B: [xy/def]], G: (1, xy), X: 2 }
     2) { A: <null>, B: <null>, B2: [A: <null>/def, B: <null>/def], G: (2, <null>), X: 3 }
     3) { A: xyz, B: xyz, B2: [A: [xyz/def], B: [xyz/def]], G: (3, xyz), X: 4 }
     4) { A: <null>, B: hi, B2: [A: <null>/def, B: [hi/def]], G: (4, hi), X: 5 }
     5) { A: adios, B: <null>, B2: [A: [adi/def], B: <null>/def], G: (5, adios), X: 6 }
     6) { A: hola, B: hola, B2: [A: [hol/def], B: [hol/def]], G: (6, hola), X: 7 }
     7) { A: <null>, B: guten morgen, B2: [A: <null>/def, B: [gut/def]], G: (7, guten morgen), X: 8 }
  S1: /def, S2: 3 }
*** Ctx ping count: 24
    [0](24): Text.Concat(!1x.B2, ", ")
###
> TB->MultiDGRMBW(G, B, A, "/suf", 5)+>{ Mos: Mos->Map(it+>{ B2: "[" & B2->Text.Concat(", ") & "]" }) }
TB->MultiDGRMBW(G, B, A, "/suf", 5)+>{ Mos : Mos->Map(it+>{ B2 : "[" & B2->Text.Concat(", ") & "]" }) } : {Mos:{A:s, B:s, B2:s, G:(i8, s), X:r8}*, S1:s, S2:i8}
BndKind:SetFields, Type:{Mos:{A:s, B:s, B2:s, G:(i8, s), X:r8}*, S1:s, S2:i8}, Bnd:(SetFields([with:3] Call(∂.Test.MultiDGRMBW.MergeRec([with:1] Global(TB), {Mis:Call(∂.ForEach([map:2] Scope(1), {A:GetField(Scope(2), A), B:GetField(Scope(2), B), G:GetField(Scope(2), G)})), S1:str(/suf), S2:5:i8}, Scope(1))), Mos : Call(∂.ForEach([map:4] GetField(Scope(3), Mos), SetFields([with:5] Scope(4), B2 : StrConcat(str([), Call(∂.Text.Concat(GetField(Scope(5), B2), str(, )):s), str(])))))))
Func sig: (<ctx>:x, TB:{A:s, B:s, G:(i8, s), X:r8}*) to {Mos:{A:s, B:s, B2:s, G:(i8, s), X:r8}*, S1:s, S2:i8}
Type: {Seq<{str,str,str,(i8,str),r8}>,str,i8}, Value: { Mos: Sequence: Seq<{str,str,str,(i8,str),r8}>
     0) { A: x, B: x, B2: [A: [x/suf], B: [x/suf]], G: (0, x), X: 1 }
     1) { A: <null>, B: xy, B2: [A: <null>/suf, B: [xy/suf]], G: (1, xy), X: 2 }
     2) { A: <null>, B: <null>, B2: [A: <null>/suf, B: <null>/suf], G: (2, <null>), X: 3 }
     3) { A: xyz, B: xyz, B2: [A: [xyz/suf], B: [xyz/suf]], G: (3, xyz), X: 4 }
     4) { A: <null>, B: hi, B2: [A: <null>/suf, B: [hi/suf]], G: (4, hi), X: 5 }
     5) { A: adios, B: <null>, B2: [A: [adios/suf], B: <null>/suf], G: (5, adios), X: 6 }
     6) { A: hola, B: hola, B2: [A: [hola/suf], B: [hola/suf]], G: (6, hola), X: 7 }
     7) { A: <null>, B: guten morgen, B2: [A: <null>/suf, B: [guten/suf]], G: (7, guten morgen), X: 8 }
  S1: /suf, S2: 5 }
*** Ctx ping count: 24
    [0](24): Text.Concat(!1x.B2, ", ")
###

**** New definitions: F, type: b

> (TA if F else null)->MultiDGSMA()
(TA if F else null)->MultiDGSMA() : {A:s, B:s*, G:(s, i8), X:r8}*
BndKind:Call, Type:{A:s, B:s*, G:(s, i8), X:r8}*, Bnd:(Call(∂.Test.MultiDGSMA.MergeSeq([with:1] If(Global(F), Global(TA), null:{A:s, G:(s, i8), X:r8}*), Call(∂.ForEach([map:2] Scope(1), {A:GetField(Scope(2), A), G:GetField(Scope(2), G)})), Scope(1))))
Func sig: (<ctx>:x, F:b, TA:{A:s, G:(s, i8), X:r8}*) to {A:s, B:s*, G:(s, i8), X:r8}*
Type: <null>, Value: <null>
*** Ctx ping count: 0
###
> (S  if F else null)->MultiDGSMA(it, A: it & "-extra")
(S if F else null)->MultiDGSMA(it, A : it & "-extra") : {B:s*}*
BndKind:Call, Type:{B:s*}*, Bnd:(Call(∂.Test.MultiDGSMA.Simple(Call(∂.ForEach([map:1] If(Global(F), Global(S), null:s*), {A:StrConcat(Scope(1), str(-extra)), G:Scope(1)})))))
Func sig: (<ctx>:x, F:b, S:s*) to {B:s*}*
Type: <null>, Value: <null>
*** Ctx ping count: 0
###
> (S  if F else null)->MultiDGSMB(it, A: it & "-1st", B: it & "-2nd")
(S if F else null)->MultiDGSMB(it, A : it & "-1st", B : it & "-2nd") : {B:s*}*
BndKind:Call, Type:{B:s*}*, Bnd:(Call(∂.Test.MultiDGSMB.Simple(Call(∂.ForEach([map:1] If(Global(F), Global(S), null:s*), {A:StrConcat(Scope(1), str(-1st)), B:StrConcat(Scope(1), str(-2nd)), G:Scope(1)})))))
Func sig: (<ctx>:x, F:b, S:s*) to {B:s*}*
Type: <null>, Value: <null>
*** Ctx ping count: 0
###
> (S  if F else null)->MultiDGsMB({ G: it, A: "a-" & it, B: "b-" & it })
(S if F else null)->MultiDGsMB({ G : it, A : "a-" & it, B : "b-" & it }) : {B:s*}*
BndKind:Call, Type:{B:s*}*, Bnd:(Call(∂.Test.MultiDGsMB.Simple(Call(∂.ForEach([map:1] If(Global(F), Global(S), null:s*), {A:StrConcat(str(a-), Scope(1)), B:StrConcat(str(b-), Scope(1)), G:Scope(1)})))))
Func sig: (<ctx>:x, F:b, S:s*) to {B:s*}*
Type: <null>, Value: <null>
*** Ctx ping count: 0
###
> (TA if F else null)->MultiDGSMA(G, A)
(TA if F else null)->MultiDGSMA(G, A) : {A:s, B:s*, G:(s, i8), X:r8}*
BndKind:Call, Type:{A:s, B:s*, G:(s, i8), X:r8}*, Bnd:(Call(∂.Guard([guard:1] If(Global(F), Global(TA), null:{A:s, G:(s, i8), X:r8}*), Call(∂.Test.MultiDGSMA.MergeSeq([with:2] Scope(1), Call(∂.ForEach([map:3] Scope(2), {A:GetField(Scope(3), A), G:GetField(Scope(3), G)})), Scope(2))))))
Func sig: (<ctx>:x, F:b, TA:{A:s, G:(s, i8), X:r8}*) to {A:s, B:s*, G:(s, i8), X:r8}*
Type: <null>, Value: <null>
*** Ctx ping count: 0
###
> (TA if F else null)->MultiDGSMB(G, A: A)
(TA if F else null)->MultiDGSMB(G, A : A) : {A:s, B:s*, G:(s, i8), X:r8}*
BndKind:Call, Type:{A:s, B:s*, G:(s, i8), X:r8}*, Bnd:(Call(∂.Guard([guard:1] If(Global(F), Global(TA), null:{A:s, G:(s, i8), X:r8}*), Call(∂.Test.MultiDGSMB.MergeSeq([with:2] Scope(1), Call(∂.ForEach([map:3] Scope(2), {A:GetField(Scope(3), A), B:str(B def), G:GetField(Scope(3), G)})), Scope(2))))))
Func sig: (<ctx>:x, F:b, TA:{A:s, G:(s, i8), X:r8}*) to {A:s, B:s*, G:(s, i8), X:r8}*
Type: <null>, Value: <null>
*** Ctx ping count: 0
###
> (TA if F else null)->MultiDGSMB(G, B: A)
(TA if F else null)->MultiDGSMB(G, B : A) : {A:s, B:s*, G:(s, i8), X:r8}*
BndKind:Call, Type:{A:s, B:s*, G:(s, i8), X:r8}*, Bnd:(Call(∂.Guard([guard:1] If(Global(F), Global(TA), null:{A:s, G:(s, i8), X:r8}*), Call(∂.Test.MultiDGSMB.MergeSeq([with:2] Scope(1), Call(∂.ForEach([map:3] Scope(2), {A:str(A's default), B:GetField(Scope(3), A), G:GetField(Scope(3), G)})), Scope(2))))))
Func sig: (<ctx>:x, F:b, TA:{A:s, G:(s, i8), X:r8}*) to {A:s, B:s*, G:(s, i8), X:r8}*
Type: <null>, Value: <null>
*** Ctx ping count: 0
###
> (TA if F else null)->MultiDGsMB({ G, A, B: "b-" & A })
(TA if F else null)->MultiDGsMB({ G, A, B : "b-" & A }) : {A:s, B:s*, G:(s, i8), X:r8}*
BndKind:Call, Type:{A:s, B:s*, G:(s, i8), X:r8}*, Bnd:(Call(∂.Guard([guard:1] If(Global(F), Global(TA), null:{A:s, G:(s, i8), X:r8}*), Call(∂.Test.MultiDGsMB.MergeSeq([with:2] Scope(1), Call(∂.ForEach([map:3] Scope(2), {A:GetField(Scope(3), A), B:StrConcat(str(b-), GetField(Scope(3), A)), G:GetField(Scope(3), G)})), Scope(2))))))
Func sig: (<ctx>:x, F:b, TA:{A:s, G:(s, i8), X:r8}*) to {A:s, B:s*, G:(s, i8), X:r8}*
Type: <null>, Value: <null>
*** Ctx ping count: 0
###
> (TB if F else null)->MultiDGSMA(G, A)
(TB if F else null)->MultiDGSMA(G, A) : {A:s, B:s, B2:s*, G:(i8, s), X:r8}*
BndKind:Call, Type:{A:s, B:s, B2:s*, G:(i8, s), X:r8}*, Bnd:(Call(∂.Guard([guard:1] If(Global(F), Global(TB), null:{A:s, B:s, G:(i8, s), X:r8}*), Call(∂.Test.MultiDGSMA.MergeSeq([with:2] Scope(1), Call(∂.ForEach([map:3] Scope(2), {A:GetField(Scope(3), A), G:GetField(Scope(3), G)})), Scope(2))))))
Func sig: (<ctx>:x, F:b, TB:{A:s, B:s, G:(i8, s), X:r8}*) to {A:s, B:s, B2:s*, G:(i8, s), X:r8}*
Type: <null>, Value: <null>
*** Ctx ping count: 0
###
> (TB if F else null)->MultiDGSMA(G, B)
(TB if F else null)->MultiDGSMA(G, B) : {A:s, B:s, B2:s*, G:(i8, s), X:r8}*
BndKind:Call, Type:{A:s, B:s, B2:s*, G:(i8, s), X:r8}*, Bnd:(Call(∂.Guard([guard:1] If(Global(F), Global(TB), null:{A:s, B:s, G:(i8, s), X:r8}*), Call(∂.Test.MultiDGSMA.MergeSeq([with:2] Scope(1), Call(∂.ForEach([map:3] Scope(2), {A:GetField(Scope(3), B), G:GetField(Scope(3), G)})), Scope(2))))))
Func sig: (<ctx>:x, F:b, TB:{A:s, B:s, G:(i8, s), X:r8}*) to {A:s, B:s, B2:s*, G:(i8, s), X:r8}*
Type: <null>, Value: <null>
*** Ctx ping count: 0
###
> (TB if F else null)->MultiDGSMB(G, A: A, B: B)
(TB if F else null)->MultiDGSMB(G, A : A, B : B) : {A:s, B:s, B2:s*, G:(i8, s), X:r8}*
BndKind:Call, Type:{A:s, B:s, B2:s*, G:(i8, s), X:r8}*, Bnd:(Call(∂.Guard([guard:1] If(Global(F), Global(TB), null:{A:s, B:s, G:(i8, s), X:r8}*), Call(∂.Test.MultiDGSMB.MergeSeq([with:2] Scope(1), Call(∂.ForEach([map:3] Scope(2), {A:GetField(Scope(3), A), B:GetField(Scope(3), B), G:GetField(Scope(3), G)})), Scope(2))))))
Func sig: (<ctx>:x, F:b, TB:{A:s, B:s, G:(i8, s), X:r8}*) to {A:s, B:s, B2:s*, G:(i8, s), X:r8}*
Type: <null>, Value: <null>
*** Ctx ping count: 0
###
> (TB if F else null)->Multi_GSMB(G, A: A, B: B)
(TB if F else null)->Multi_GSMB(G, A : A, B : B) : {A:s, B:s, B2:s*, G:(i8, s), X:r8}*
BndKind:Call, Type:{A:s, B:s, B2:s*, G:(i8, s), X:r8}*, Bnd:(Call(∂.Guard([guard:1] If(Global(F), Global(TB), null:{A:s, B:s, G:(i8, s), X:r8}*), Call(∂.Test.Multi_GSMB.MergeSeq([with:2] Scope(1), Call(∂.ForEach([map:3] Scope(2), {A:GetField(Scope(3), A), B:GetField(Scope(3), B), G:GetField(Scope(3), G)})), Scope(2))))))
Func sig: (<ctx>:x, F:b, TB:{A:s, B:s, G:(i8, s), X:r8}*) to {A:s, B:s, B2:s*, G:(i8, s), X:r8}*
Type: <null>, Value: <null>
*** Ctx ping count: 0
###
> (TB if F else null)->MultiDGSMBab()
(TB if F else null)->MultiDGSMBab() : {A:s, B:s, B2:s*, G:(i8, s), X:r8}*
BndKind:Call, Type:{A:s, B:s, B2:s*, G:(i8, s), X:r8}*, Bnd:(Call(∂.Test.MultiDGSMBab.MergeSeq([with:1] If(Global(F), Global(TB), null:{A:s, B:s, G:(i8, s), X:r8}*), Call(∂.ForEach([map:2] Scope(1), {A:GetField(Scope(2), A), B:GetField(Scope(2), B), G:GetField(Scope(2), G)})), Scope(1))))
Func sig: (<ctx>:x, F:b, TB:{A:s, B:s, G:(i8, s), X:r8}*) to {A:s, B:s, B2:s*, G:(i8, s), X:r8}*
Type: <null>, Value: <null>
*** Ctx ping count: 0
###
> (S  if F else null)->MultiDGSMBab(it, it & "-1st",    it & "-2nd")
(S if F else null)->MultiDGSMBab(it, it & "-1st", it & "-2nd") : {B:s*}*
BndKind:Call, Type:{B:s*}*, Bnd:(Call(∂.Test.MultiDGSMBab.Simple(Call(∂.ForEach([map:1] If(Global(F), Global(S), null:s*), {A:StrConcat(Scope(1), str(-2nd)), B:StrConcat(Scope(1), str(-1st)), G:Scope(1)})))))
Func sig: (<ctx>:x, F:b, S:s*) to {B:s*}*
Type: <null>, Value: <null>
*** Ctx ping count: 0
###
> (S  if F else null)->MultiDGSMBb(it, it)
(S if F else null)->MultiDGSMBb(it, it) : {B:s*}*
BndKind:Call, Type:{B:s*}*, Bnd:(Call(∂.Test.MultiDGSMBb.Simple(Call(∂.ForEach([map:1] If(Global(F), Global(S), null:s*), {A:str(A's default), B:Scope(1), G:Scope(1)})))))
Func sig: (<ctx>:x, F:b, S:s*) to {B:s*}*
Type: <null>, Value: <null>
*** Ctx ping count: 0
###
> (S  if F else null)->MultiDGSMC(it, A: it)
(S if F else null)->MultiDGSMC(it, A : it) : {B:s*}*
BndKind:Call, Type:{B:s*}*, Bnd:(Call(∂.Test.MultiDGSMC.Simple(Call(∂.ForEach([map:1] If(Global(F), Global(S), null:s*), {A:Scope(1), C:null:{D:s, E:s}*, G:Scope(1)})))))
Func sig: (<ctx>:x, F:b, S:s*) to {B:s*}*
Type: <null>, Value: <null>
*** Ctx ping count: 0
###
> (TC if F else null)->MultiDGSMCc(G, A: A, C: C)
(TC if F else null)->MultiDGSMCc(G, A : A, C : C) : {A:s, B:s*, C:{D:s, E:s}*, G:i8}*
BndKind:Call, Type:{A:s, B:s*, C:{D:s, E:s}*, G:i8}*, Bnd:(Call(∂.Guard([guard:1] If(Global(F), Global(TC), null:{A:s, C:{D:s, E:s}*, G:i8}*), Call(∂.Test.MultiDGSMCc.MergeSeq([with:2] Scope(1), Call(∂.ForEach([map:3] Scope(2), {A:GetField(Scope(3), A), C:GetField(Scope(3), C), G:GetField(Scope(3), G)})), Scope(2))))))
Func sig: (<ctx>:x, F:b, TC:{A:s, C:{D:s, E:s}*, G:i8}*) to {A:s, B:s*, C:{D:s, E:s}*, G:i8}*
Type: <null>, Value: <null>
*** Ctx ping count: 0
###
> (S  if F else null)->MultiDGSMB(it,   it & "-1st",    it & "-2nd") // For comparison.
(S if F else null)->MultiDGSMB(it, it & "-1st", it & "-2nd") : {B:s*}*
BndKind:Call, Type:{B:s*}*, Bnd:(Call(∂.Test.MultiDGSMB.Simple(Call(∂.ForEach([map:1] If(Global(F), Global(S), null:s*), {A:StrConcat(Scope(1), str(-2nd)), B:StrConcat(Scope(1), str(-1st)), G:Scope(1)})))))
Func sig: (<ctx>:x, F:b, S:s*) to {B:s*}*
Type: <null>, Value: <null>
*** Ctx ping count: 0
###
> (S  if F else null)->MultiDGRMB(it,   it & "-1st",    it & "-2nd")
(S if F else null)->MultiDGRMB(it, it & "-1st", it & "-2nd") : {B:s*}*
BndKind:Call, Type:{B:s*}*, Bnd:(Call(∂.Test.MultiDGRMB.Simple({Mis:Call(∂.ForEach([map:1] If(Global(F), Global(S), null:s*), {A:StrConcat(Scope(1), str(-2nd)), B:StrConcat(Scope(1), str(-1st)), G:Scope(1)})), S1:str(/def), S2:3:i8})))
Func sig: (<ctx>:x, F:b, S:s*) to {B:s*}*
Type: <null>, Value: <null>
*** Ctx ping count: 0
###
> (S  if F else null)->MultiDGRMB(it,   it & "-1st",    it & "-2nd",     "/suf")
(S if F else null)->MultiDGRMB(it, it & "-1st", it & "-2nd", "/suf") : {B:s*}*
BndKind:Call, Type:{B:s*}*, Bnd:(Call(∂.Test.MultiDGRMB.Simple({Mis:Call(∂.ForEach([map:1] If(Global(F), Global(S), null:s*), {A:StrConcat(Scope(1), str(-2nd)), B:StrConcat(Scope(1), str(-1st)), G:Scope(1)})), S1:str(/suf), S2:3:i8})))
Func sig: (<ctx>:x, F:b, S:s*) to {B:s*}*
Type: <null>, Value: <null>
*** Ctx ping count: 0
###
> (S  if F else null)->MultiDGRMB(it,   it & "-1st",    it & "-2nd", S1: "/suf")
(S if F else null)->MultiDGRMB(it, it & "-1st", it & "-2nd", S1 : "/suf") : {B:s*}*
BndKind:Call, Type:{B:s*}*, Bnd:(Call(∂.Test.MultiDGRMB.Simple({Mis:Call(∂.ForEach([map:1] If(Global(F), Global(S), null:s*), {A:StrConcat(Scope(1), str(-2nd)), B:StrConcat(Scope(1), str(-1st)), G:Scope(1)})), S1:str(/suf), S2:3:i8})))
Func sig: (<ctx>:x, F:b, S:s*) to {B:s*}*
Type: <null>, Value: <null>
*** Ctx ping count: 0
###
> (S  if F else null)->MultiDGRMB(it,   it & "-1st",    it & "-2nd", S2: 7     )
(S if F else null)->MultiDGRMB(it, it & "-1st", it & "-2nd", S2 : 7) : {B:s*}*
BndKind:Call, Type:{B:s*}*, Bnd:(Call(∂.Test.MultiDGRMB.Simple({Mis:Call(∂.ForEach([map:1] If(Global(F), Global(S), null:s*), {A:StrConcat(Scope(1), str(-2nd)), B:StrConcat(Scope(1), str(-1st)), G:Scope(1)})), S1:str(/def), S2:7:i8})))
Func sig: (<ctx>:x, F:b, S:s*) to {B:s*}*
Type: <null>, Value: <null>
*** Ctx ping count: 0
###
> (S  if F else null)->MultiDGRMB(it,   it & "-1st",    it & "-2nd",     "/suf",     7)
(S if F else null)->MultiDGRMB(it, it & "-1st", it & "-2nd", "/suf", 7) : {B:s*}*
BndKind:Call, Type:{B:s*}*, Bnd:(Call(∂.Test.MultiDGRMB.Simple({Mis:Call(∂.ForEach([map:1] If(Global(F), Global(S), null:s*), {A:StrConcat(Scope(1), str(-2nd)), B:StrConcat(Scope(1), str(-1st)), G:Scope(1)})), S1:str(/suf), S2:7:i8})))
Func sig: (<ctx>:x, F:b, S:s*) to {B:s*}*
Type: <null>, Value: <null>
*** Ctx ping count: 0
###
> (S  if F else null)->MultiDGRMB(it,   it & "-1st",    it & "-2nd",     "/suf", S2: 7)
(S if F else null)->MultiDGRMB(it, it & "-1st", it & "-2nd", "/suf", S2 : 7) : {B:s*}*
BndKind:Call, Type:{B:s*}*, Bnd:(Call(∂.Test.MultiDGRMB.Simple({Mis:Call(∂.ForEach([map:1] If(Global(F), Global(S), null:s*), {A:StrConcat(Scope(1), str(-2nd)), B:StrConcat(Scope(1), str(-1st)), G:Scope(1)})), S1:str(/suf), S2:7:i8})))
Func sig: (<ctx>:x, F:b, S:s*) to {B:s*}*
Type: <null>, Value: <null>
*** Ctx ping count: 0
###
> (S  if F else null)->MultiDGRMB(it,   it & "-1st",    it & "-2nd", S1: "/suf",     7)
(S if F else null)->MultiDGRMB(it, it & "-1st", it & "-2nd", S1 : "/suf", 7) : {B:s*}*
BndKind:Call, Type:{B:s*}*, Bnd:(Call(∂.Test.MultiDGRMB.Simple({Mis:Call(∂.ForEach([map:1] If(Global(F), Global(S), null:s*), {A:StrConcat(Scope(1), str(-2nd)), B:StrConcat(Scope(1), str(-1st)), G:Scope(1)})), S1:str(/suf), S2:7:i8})))
Func sig: (<ctx>:x, F:b, S:s*) to {B:s*}*
Type: <null>, Value: <null>
*** Ctx ping count: 0
###
> (S  if F else null)->MultiDGRMB(it,   it & "-1st",    it & "-2nd", S1: "/suf", S2: 7)
(S if F else null)->MultiDGRMB(it, it & "-1st", it & "-2nd", S1 : "/suf", S2 : 7) : {B:s*}*
BndKind:Call, Type:{B:s*}*, Bnd:(Call(∂.Test.MultiDGRMB.Simple({Mis:Call(∂.ForEach([map:1] If(Global(F), Global(S), null:s*), {A:StrConcat(Scope(1), str(-2nd)), B:StrConcat(Scope(1), str(-1st)), G:Scope(1)})), S1:str(/suf), S2:7:i8})))
Func sig: (<ctx>:x, F:b, S:s*) to {B:s*}*
Type: <null>, Value: <null>
*** Ctx ping count: 0
###
> (S  if F else null)->MultiDGRMB(it,   it & "-1st",    it & "-2nd", S2: 7, S1: "/suf")
(S if F else null)->MultiDGRMB(it, it & "-1st", it & "-2nd", S2 : 7, S1 : "/suf") : {B:s*}*
BndKind:Call, Type:{B:s*}*, Bnd:(Call(∂.Test.MultiDGRMB.Simple({Mis:Call(∂.ForEach([map:1] If(Global(F), Global(S), null:s*), {A:StrConcat(Scope(1), str(-2nd)), B:StrConcat(Scope(1), str(-1st)), G:Scope(1)})), S1:str(/suf), S2:7:i8})))
Func sig: (<ctx>:x, F:b, S:s*) to {B:s*}*
Type: <null>, Value: <null>
*** Ctx ping count: 0
###
> (S  if F else null)->MultiDGrMB({ G: it, B: "b-" & it, A: "a-" & it }, S2: 7, S1: "/suf")
(S if F else null)->MultiDGrMB({ G : it, B : "b-" & it, A : "a-" & it }, S2 : 7, S1 : "/suf") : {B:s*}*
BndKind:Call, Type:{B:s*}*, Bnd:(Call(∂.Test.MultiDGrMB.Simple({Mis:Call(∂.ForEach([map:1] If(Global(F), Global(S), null:s*), {A:StrConcat(str(a-), Scope(1)), B:StrConcat(str(b-), Scope(1)), G:Scope(1)})), S1:str(/suf), S2:7:i8})))
Func sig: (<ctx>:x, F:b, S:s*) to {B:s*}*
Type: <null>, Value: <null>
*** Ctx ping count: 0
###
> (TA if F else null)->MultiDGRMB(G, A)
(TA if F else null)->MultiDGRMB(G, A) : {A:s, B:s*, G:(s, i8), X:r8}*
BndKind:Call, Type:{A:s, B:s*, G:(s, i8), X:r8}*, Bnd:(Call(∂.Guard([guard:1] If(Global(F), Global(TA), null:{A:s, G:(s, i8), X:r8}*), Call(∂.Test.MultiDGRMB.MergeRec([with:2] Scope(1), {Mis:Call(∂.ForEach([map:3] Scope(2), {A:str(A's default), B:GetField(Scope(3), A), G:GetField(Scope(3), G)})), S1:str(/def), S2:3:i8}, Scope(2))))))
Func sig: (<ctx>:x, F:b, TA:{A:s, G:(s, i8), X:r8}*) to {A:s, B:s*, G:(s, i8), X:r8}*
Type: <null>, Value: <null>
*** Ctx ping count: 0
###
> (TB if F else null)->MultiDGRMB(G, B, A)
(TB if F else null)->MultiDGRMB(G, B, A) : {A:s, B:s, B2:s*, G:(i8, s), X:r8}*
BndKind:Call, Type:{A:s, B:s, B2:s*, G:(i8, s), X:r8}*, Bnd:(Call(∂.Guard([guard:1] If(Global(F), Global(TB), null:{A:s, B:s, G:(i8, s), X:r8}*), Call(∂.Test.MultiDGRMB.MergeRec([with:2] Scope(1), {Mis:Call(∂.ForEach([map:3] Scope(2), {A:GetField(Scope(3), A), B:GetField(Scope(3), B), G:GetField(Scope(3), G)})), S1:str(/def), S2:3:i8}, Scope(2))))))
Func sig: (<ctx>:x, F:b, TB:{A:s, B:s, G:(i8, s), X:r8}*) to {A:s, B:s, B2:s*, G:(i8, s), X:r8}*
Type: <null>, Value: <null>
*** Ctx ping count: 0
###
> (TB if F else null)->MultiDGRMB(G, B, A, "/suf")
(TB if F else null)->MultiDGRMB(G, B, A, "/suf") : {A:s, B:s, B2:s*, G:(i8, s), X:r8}*
BndKind:Call, Type:{A:s, B:s, B2:s*, G:(i8, s), X:r8}*, Bnd:(Call(∂.Guard([guard:1] If(Global(F), Global(TB), null:{A:s, B:s, G:(i8, s), X:r8}*), Call(∂.Test.MultiDGRMB.MergeRec([with:2] Scope(1), {Mis:Call(∂.ForEach([map:3] Scope(2), {A:GetField(Scope(3), A), B:GetField(Scope(3), B), G:GetField(Scope(3), G)})), S1:str(/suf), S2:3:i8}, Scope(2))))))
Func sig: (<ctx>:x, F:b, TB:{A:s, B:s, G:(i8, s), X:r8}*) to {A:s, B:s, B2:s*, G:(i8, s), X:r8}*
Type: <null>, Value: <null>
*** Ctx ping count: 0
###
> (TB if F else null)->MultiDGRMB(G, B, A, "/suf", 5)
(TB if F else null)->MultiDGRMB(G, B, A, "/suf", 5) : {A:s, B:s, B2:s*, G:(i8, s), X:r8}*
BndKind:Call, Type:{A:s, B:s, B2:s*, G:(i8, s), X:r8}*, Bnd:(Call(∂.Guard([guard:1] If(Global(F), Global(TB), null:{A:s, B:s, G:(i8, s), X:r8}*), Call(∂.Test.MultiDGRMB.MergeRec([with:2] Scope(1), {Mis:Call(∂.ForEach([map:3] Scope(2), {A:GetField(Scope(3), A), B:GetField(Scope(3), B), G:GetField(Scope(3), G)})), S1:str(/suf), S2:5:i8}, Scope(2))))))
Func sig: (<ctx>:x, F:b, TB:{A:s, B:s, G:(i8, s), X:r8}*) to {A:s, B:s, B2:s*, G:(i8, s), X:r8}*
Type: <null>, Value: <null>
*** Ctx ping count: 0
###
> (TB if F else null)->MultiDGrMB({ G, B, A }, "/suf", 5)
(TB if F else null)->MultiDGrMB({ G, B, A }, "/suf", 5) : {A:s, B:s, B2:s*, G:(i8, s), X:r8}*
BndKind:Call, Type:{A:s, B:s, B2:s*, G:(i8, s), X:r8}*, Bnd:(Call(∂.Guard([guard:1] If(Global(F), Global(TB), null:{A:s, B:s, G:(i8, s), X:r8}*), Call(∂.Test.MultiDGrMB.MergeRec([with:2] Scope(1), {Mis:Call(∂.ForEach([map:3] Scope(2), {A:GetField(Scope(3), A), B:GetField(Scope(3), B), G:GetField(Scope(3), G)})), S1:str(/suf), S2:5:i8}, Scope(2))))))
Func sig: (<ctx>:x, F:b, TB:{A:s, B:s, G:(i8, s), X:r8}*) to {A:s, B:s, B2:s*, G:(i8, s), X:r8}*
Type: <null>, Value: <null>
*** Ctx ping count: 0
###
> (TB if F else null)->MultiDGrMB({ G, A, B }, "/suf", 5)
(TB if F else null)->MultiDGrMB({ G, A, B }, "/suf", 5) : {A:s, B:s, B2:s*, G:(i8, s), X:r8}*
BndKind:Call, Type:{A:s, B:s, B2:s*, G:(i8, s), X:r8}*, Bnd:(Call(∂.Guard([guard:1] If(Global(F), Global(TB), null:{A:s, B:s, G:(i8, s), X:r8}*), Call(∂.Test.MultiDGrMB.MergeRec([with:2] Scope(1), {Mis:Call(∂.ForEach([map:3] Scope(2), {A:GetField(Scope(3), A), B:GetField(Scope(3), B), G:GetField(Scope(3), G)})), S1:str(/suf), S2:5:i8}, Scope(2))))))
Func sig: (<ctx>:x, F:b, TB:{A:s, B:s, G:(i8, s), X:r8}*) to {A:s, B:s, B2:s*, G:(i8, s), X:r8}*
Type: <null>, Value: <null>
*** Ctx ping count: 0
###
> (TB if F else null)->MultiDGSMBW()
(TB if F else null)->MultiDGSMBW() : {Mos:{A:s, B:s, B2:s*, G:(i8, s), X:r8}*, S1:s, S2:i8}
BndKind:Call, Type:{Mos:{A:s, B:s, B2:s*, G:(i8, s), X:r8}*, S1:s, S2:i8}, Bnd:(Call(∂.Test.MultiDGSMBW.MergeSeq([with:1] If(Global(F), Global(TB), null:{A:s, B:s, G:(i8, s), X:r8}*), Call(∂.ForEach([map:2] Scope(1), {A:GetField(Scope(2), A), B:GetField(Scope(2), B), G:GetField(Scope(2), G)})), Scope(1))))
Func sig: (<ctx>:x, F:b, TB:{A:s, B:s, G:(i8, s), X:r8}*) to {Mos:{A:s, B:s, B2:s*, G:(i8, s), X:r8}*, S1:s, S2:i8}
Type: {Seq<{str,str,Seq<str>,(i8,str),r8}>,str,i8}, Value: { Mos: <null>, S1: , S2: 9223372036854775807 }
*** Ctx ping count: 0
###
> (S  if F else null)->MultiDGSMBW(it, B: it & "-1st", A: it & "-2nd")
(S if F else null)->MultiDGSMBW(it, B : it & "-1st", A : it & "-2nd") : {Mos:{B:s*}*, S1:s, S2:i8}
BndKind:Call, Type:{Mos:{B:s*}*, S1:s, S2:i8}, Bnd:(Call(∂.Test.MultiDGSMBW.Simple(Call(∂.ForEach([map:1] If(Global(F), Global(S), null:s*), {A:StrConcat(Scope(1), str(-2nd)), B:StrConcat(Scope(1), str(-1st)), G:Scope(1)})))))
Func sig: (<ctx>:x, F:b, S:s*) to {Mos:{B:s*}*, S1:s, S2:i8}
Type: {Seq<{Seq<str>}>,str,i8}, Value: { Mos: <null>, S1: , S2: 9223372036854775807 }
*** Ctx ping count: 0
###
> (TB if F else null)->MultiDGSMBW(G, A, B)
(TB if F else null)->MultiDGSMBW(G, A, B) : {Mos:{A:s, B:s, B2:s*, G:(i8, s), X:r8}*, S1:s, S2:i8}
BndKind:Call, Type:{Mos:{A:s, B:s, B2:s*, G:(i8, s), X:r8}*, S1:s, S2:i8}, Bnd:(Call(∂.Test.MultiDGSMBW.MergeSeq([with:1] If(Global(F), Global(TB), null:{A:s, B:s, G:(i8, s), X:r8}*), Call(∂.ForEach([map:2] Scope(1), {A:GetField(Scope(2), B), B:GetField(Scope(2), A), G:GetField(Scope(2), G)})), Scope(1))))
Func sig: (<ctx>:x, F:b, TB:{A:s, B:s, G:(i8, s), X:r8}*) to {Mos:{A:s, B:s, B2:s*, G:(i8, s), X:r8}*, S1:s, S2:i8}
Type: {Seq<{str,str,Seq<str>,(i8,str),r8}>,str,i8}, Value: { Mos: <null>, S1: , S2: 9223372036854775807 }
*** Ctx ping count: 0
###
> (S  if F else null)->MultiDGRMBW(it, A: it & "-1st", B: it & "-2nd", S1: "/suf", S2: 7)
(S if F else null)->MultiDGRMBW(it, A : it & "-1st", B : it & "-2nd", S1 : "/suf", S2 : 7) : {Mos:{B:s*}*, S1:s, S2:i8}
BndKind:Call, Type:{Mos:{B:s*}*, S1:s, S2:i8}, Bnd:(Call(∂.Test.MultiDGRMBW.Simple({Mis:Call(∂.ForEach([map:1] If(Global(F), Global(S), null:s*), {A:StrConcat(Scope(1), str(-1st)), B:StrConcat(Scope(1), str(-2nd)), G:Scope(1)})), S1:str(/suf), S2:7:i8})))
Func sig: (<ctx>:x, F:b, S:s*) to {Mos:{B:s*}*, S1:s, S2:i8}
Type: {Seq<{Seq<str>}>,str,i8}, Value: { Mos: <null>, S1: /suf, S2: 7 }
*** Ctx ping count: 0
###
> (TB if F else null)->MultiDGRMBW(G, B, A           )
(TB if F else null)->MultiDGRMBW(G, B, A) : {Mos:{A:s, B:s, B2:s*, G:(i8, s), X:r8}*, S1:s, S2:i8}
BndKind:Call, Type:{Mos:{A:s, B:s, B2:s*, G:(i8, s), X:r8}*, S1:s, S2:i8}, Bnd:(Call(∂.Test.MultiDGRMBW.MergeRec([with:1] If(Global(F), Global(TB), null:{A:s, B:s, G:(i8, s), X:r8}*), {Mis:Call(∂.ForEach([map:2] Scope(1), {A:GetField(Scope(2), A), B:GetField(Scope(2), B), G:GetField(Scope(2), G)})), S1:str(/def), S2:3:i8}, Scope(1))))
Func sig: (<ctx>:x, F:b, TB:{A:s, B:s, G:(i8, s), X:r8}*) to {Mos:{A:s, B:s, B2:s*, G:(i8, s), X:r8}*, S1:s, S2:i8}
Type: {Seq<{str,str,Seq<str>,(i8,str),r8}>,str,i8}, Value: { Mos: <null>, S1: /def, S2: 3 }
*** Ctx ping count: 0
###
> (TB if F else null)->MultiDGRMBW(G, B, A, "/suf", 5)
(TB if F else null)->MultiDGRMBW(G, B, A, "/suf", 5) : {Mos:{A:s, B:s, B2:s*, G:(i8, s), X:r8}*, S1:s, S2:i8}
BndKind:Call, Type:{Mos:{A:s, B:s, B2:s*, G:(i8, s), X:r8}*, S1:s, S2:i8}, Bnd:(Call(∂.Test.MultiDGRMBW.MergeRec([with:1] If(Global(F), Global(TB), null:{A:s, B:s, G:(i8, s), X:r8}*), {Mis:Call(∂.ForEach([map:2] Scope(1), {A:GetField(Scope(2), A), B:GetField(Scope(2), B), G:GetField(Scope(2), G)})), S1:str(/suf), S2:5:i8}, Scope(1))))
Func sig: (<ctx>:x, F:b, TB:{A:s, B:s, G:(i8, s), X:r8}*) to {Mos:{A:s, B:s, B2:s*, G:(i8, s), X:r8}*, S1:s, S2:i8}
Type: {Seq<{str,str,Seq<str>,(i8,str),r8}>,str,i8}, Value: { Mos: <null>, S1: /suf, S2: 5 }
*** Ctx ping count: 0
###
> (TA->TakeIf(F))->MultiDGSMA()
TA->TakeIf(F)->MultiDGSMA() : {A:s, B:s*, G:(s, i8), X:r8}*
BndKind:Call, Type:{A:s, B:s*, G:(s, i8), X:r8}*, Bnd:(Call(∂.Test.MultiDGSMA.MergeSeq([with:2] Call(∂.Take([map:1] Global(TA), [if] Global(F))), Call(∂.ForEach([map:3] Scope(2), {A:GetField(Scope(3), A), G:GetField(Scope(3), G)})), Scope(2))))
Func sig: (<ctx>:x, TA:{A:s, G:(s, i8), X:r8}*, F:b) to {A:s, B:s*, G:(s, i8), X:r8}*
Sequence: Seq<{str,Seq<str>,(str,i8),r8}>
*** Ctx ping count: 8
    [0](8): Take(*1: TA, [if] F)
###
> (S ->TakeIf(F))->MultiDGSMA(it, A: it & "-extra")
S->TakeIf(F)->MultiDGSMA(it, A : it & "-extra") : {B:s*}*
BndKind:Call, Type:{B:s*}*, Bnd:(Call(∂.Test.MultiDGSMA.Simple(Call(∂.ForEach([map:2] Call(∂.Take([map:1] Global(S), [if] Global(F)):s*), {A:StrConcat(Scope(2), str(-extra)), G:Scope(2)})))))
Func sig: (<ctx>:x, S:s*, F:b) to {B:s*}*
Sequence: Seq<{Seq<str>}>
*** Ctx ping count: 8
    [0](8): Take(*1: S, [if] F)
###
> (S ->TakeIf(F))->MultiDGSMB(it, A: it & "-1st", B: it & "-2nd")
S->TakeIf(F)->MultiDGSMB(it, A : it & "-1st", B : it & "-2nd") : {B:s*}*
BndKind:Call, Type:{B:s*}*, Bnd:(Call(∂.Test.MultiDGSMB.Simple(Call(∂.ForEach([map:2] Call(∂.Take([map:1] Global(S), [if] Global(F)):s*), {A:StrConcat(Scope(2), str(-1st)), B:StrConcat(Scope(2), str(-2nd)), G:Scope(2)})))))
Func sig: (<ctx>:x, S:s*, F:b) to {B:s*}*
Sequence: Seq<{Seq<str>}>
*** Ctx ping count: 8
    [0](8): Take(*1: S, [if] F)
###
> (S ->TakeIf(F))->MultiDGsMB({ G: it, A: "a-" & it, B: "b-" & it })
S->TakeIf(F)->MultiDGsMB({ G : it, A : "a-" & it, B : "b-" & it }) : {B:s*}*
BndKind:Call, Type:{B:s*}*, Bnd:(Call(∂.Test.MultiDGsMB.Simple(Call(∂.ForEach([map:2] Call(∂.Take([map:1] Global(S), [if] Global(F)):s*), {A:StrConcat(str(a-), Scope(2)), B:StrConcat(str(b-), Scope(2)), G:Scope(2)})))))
Func sig: (<ctx>:x, S:s*, F:b) to {B:s*}*
Sequence: Seq<{Seq<str>}>
*** Ctx ping count: 8
    [0](8): Take(*1: S, [if] F)
###
> (TA->TakeIf(F))->MultiDGSMA(G, A)
TA->TakeIf(F)->MultiDGSMA(G, A) : {A:s, B:s*, G:(s, i8), X:r8}*
BndKind:Call, Type:{A:s, B:s*, G:(s, i8), X:r8}*, Bnd:(Call(∂.Guard([guard:2] Call(∂.Take([map:1] Global(TA), [if] Global(F))), Call(∂.Test.MultiDGSMA.MergeSeq([with:3] Scope(2), Call(∂.ForEach([map:4] Scope(3), {A:GetField(Scope(4), A), G:GetField(Scope(4), G)})), Scope(3))))))
Func sig: (<ctx>:x, TA:{A:s, G:(s, i8), X:r8}*, F:b) to {A:s, B:s*, G:(s, i8), X:r8}*
Type: <null>, Value: <null>
*** Ctx ping count: 8
    [0](8): Take(*1: TA, [if] F)
###
> (TA->TakeIf(F))->MultiDGSMB(G, A: A)
TA->TakeIf(F)->MultiDGSMB(G, A : A) : {A:s, B:s*, G:(s, i8), X:r8}*
BndKind:Call, Type:{A:s, B:s*, G:(s, i8), X:r8}*, Bnd:(Call(∂.Guard([guard:2] Call(∂.Take([map:1] Global(TA), [if] Global(F))), Call(∂.Test.MultiDGSMB.MergeSeq([with:3] Scope(2), Call(∂.ForEach([map:4] Scope(3), {A:GetField(Scope(4), A), B:str(B def), G:GetField(Scope(4), G)})), Scope(3))))))
Func sig: (<ctx>:x, TA:{A:s, G:(s, i8), X:r8}*, F:b) to {A:s, B:s*, G:(s, i8), X:r8}*
Type: <null>, Value: <null>
*** Ctx ping count: 8
    [0](8): Take(*1: TA, [if] F)
###
> (TA->TakeIf(F))->MultiDGSMB(G, B: A)
TA->TakeIf(F)->MultiDGSMB(G, B : A) : {A:s, B:s*, G:(s, i8), X:r8}*
BndKind:Call, Type:{A:s, B:s*, G:(s, i8), X:r8}*, Bnd:(Call(∂.Guard([guard:2] Call(∂.Take([map:1] Global(TA), [if] Global(F))), Call(∂.Test.MultiDGSMB.MergeSeq([with:3] Scope(2), Call(∂.ForEach([map:4] Scope(3), {A:str(A's default), B:GetField(Scope(4), A), G:GetField(Scope(4), G)})), Scope(3))))))
Func sig: (<ctx>:x, TA:{A:s, G:(s, i8), X:r8}*, F:b) to {A:s, B:s*, G:(s, i8), X:r8}*
Type: <null>, Value: <null>
*** Ctx ping count: 8
    [0](8): Take(*1: TA, [if] F)
###
> (TA->TakeIf(F))->MultiDGsMB({ G, A, B: "b-" & A })
TA->TakeIf(F)->MultiDGsMB({ G, A, B : "b-" & A }) : {A:s, B:s*, G:(s, i8), X:r8}*
BndKind:Call, Type:{A:s, B:s*, G:(s, i8), X:r8}*, Bnd:(Call(∂.Guard([guard:2] Call(∂.Take([map:1] Global(TA), [if] Global(F))), Call(∂.Test.MultiDGsMB.MergeSeq([with:3] Scope(2), Call(∂.ForEach([map:4] Scope(3), {A:GetField(Scope(4), A), B:StrConcat(str(b-), GetField(Scope(4), A)), G:GetField(Scope(4), G)})), Scope(3))))))
Func sig: (<ctx>:x, TA:{A:s, G:(s, i8), X:r8}*, F:b) to {A:s, B:s*, G:(s, i8), X:r8}*
Type: <null>, Value: <null>
*** Ctx ping count: 8
    [0](8): Take(*1: TA, [if] F)
###
> (TB->TakeIf(F))->MultiDGSMA(G, A)
TB->TakeIf(F)->MultiDGSMA(G, A) : {A:s, B:s, B2:s*, G:(i8, s), X:r8}*
BndKind:Call, Type:{A:s, B:s, B2:s*, G:(i8, s), X:r8}*, Bnd:(Call(∂.Guard([guard:2] Call(∂.Take([map:1] Global(TB), [if] Global(F))), Call(∂.Test.MultiDGSMA.MergeSeq([with:3] Scope(2), Call(∂.ForEach([map:4] Scope(3), {A:GetField(Scope(4), A), G:GetField(Scope(4), G)})), Scope(3))))))
Func sig: (<ctx>:x, TB:{A:s, B:s, G:(i8, s), X:r8}*, F:b) to {A:s, B:s, B2:s*, G:(i8, s), X:r8}*
Type: <null>, Value: <null>
*** Ctx ping count: 8
    [0](8): Take(*1: TB, [if] F)
###
> (TB->TakeIf(F))->MultiDGSMA(G, B)
TB->TakeIf(F)->MultiDGSMA(G, B) : {A:s, B:s, B2:s*, G:(i8, s), X:r8}*
BndKind:Call, Type:{A:s, B:s, B2:s*, G:(i8, s), X:r8}*, Bnd:(Call(∂.Guard([guard:2] Call(∂.Take([map:1] Global(TB), [if] Global(F))), Call(∂.Test.MultiDGSMA.MergeSeq([with:3] Scope(2), Call(∂.ForEach([map:4] Scope(3), {A:GetField(Scope(4), B), G:GetField(Scope(4), G)})), Scope(3))))))
Func sig: (<ctx>:x, TB:{A:s, B:s, G:(i8, s), X:r8}*, F:b) to {A:s, B:s, B2:s*, G:(i8, s), X:r8}*
Type: <null>, Value: <null>
*** Ctx ping count: 8
    [0](8): Take(*1: TB, [if] F)
###
> (TB->TakeIf(F))->MultiDGSMB(G, A: A, B: B)
TB->TakeIf(F)->MultiDGSMB(G, A : A, B : B) : {A:s, B:s, B2:s*, G:(i8, s), X:r8}*
BndKind:Call, Type:{A:s, B:s, B2:s*, G:(i8, s), X:r8}*, Bnd:(Call(∂.Guard([guard:2] Call(∂.Take([map:1] Global(TB), [if] Global(F))), Call(∂.Test.MultiDGSMB.MergeSeq([with:3] Scope(2), Call(∂.ForEach([map:4] Scope(3), {A:GetField(Scope(4), A), B:GetField(Scope(4), B), G:GetField(Scope(4), G)})), Scope(3))))))
Func sig: (<ctx>:x, TB:{A:s, B:s, G:(i8, s), X:r8}*, F:b) to {A:s, B:s, B2:s*, G:(i8, s), X:r8}*
Type: <null>, Value: <null>
*** Ctx ping count: 8
    [0](8): Take(*1: TB, [if] F)
###
> (TB->TakeIf(F))->Multi_GSMB(G, A: A, B: B)
TB->TakeIf(F)->Multi_GSMB(G, A : A, B : B) : {A:s, B:s, B2:s*, G:(i8, s), X:r8}*
BndKind:Call, Type:{A:s, B:s, B2:s*, G:(i8, s), X:r8}*, Bnd:(Call(∂.Guard([guard:2] Call(∂.Take([map:1] Global(TB), [if] Global(F))), Call(∂.Test.Multi_GSMB.MergeSeq([with:3] Scope(2), Call(∂.ForEach([map:4] Scope(3), {A:GetField(Scope(4), A), B:GetField(Scope(4), B), G:GetField(Scope(4), G)})), Scope(3))))))
Func sig: (<ctx>:x, TB:{A:s, B:s, G:(i8, s), X:r8}*, F:b) to {A:s, B:s, B2:s*, G:(i8, s), X:r8}*
Type: <null>, Value: <null>
*** Ctx ping count: 8
    [0](8): Take(*1: TB, [if] F)
###
> (TB->TakeIf(F))->MultiDGSMBab()
TB->TakeIf(F)->MultiDGSMBab() : {A:s, B:s, B2:s*, G:(i8, s), X:r8}*
BndKind:Call, Type:{A:s, B:s, B2:s*, G:(i8, s), X:r8}*, Bnd:(Call(∂.Test.MultiDGSMBab.MergeSeq([with:2] Call(∂.Take([map:1] Global(TB), [if] Global(F))), Call(∂.ForEach([map:3] Scope(2), {A:GetField(Scope(3), A), B:GetField(Scope(3), B), G:GetField(Scope(3), G)})), Scope(2))))
Func sig: (<ctx>:x, TB:{A:s, B:s, G:(i8, s), X:r8}*, F:b) to {A:s, B:s, B2:s*, G:(i8, s), X:r8}*
Sequence: Seq<{str,str,Seq<str>,(i8,str),r8}>
*** Ctx ping count: 8
    [0](8): Take(*1: TB, [if] F)
###
> (S ->TakeIf(F))->MultiDGSMBab(it, it & "-1st",    it & "-2nd")
S->TakeIf(F)->MultiDGSMBab(it, it & "-1st", it & "-2nd") : {B:s*}*
BndKind:Call, Type:{B:s*}*, Bnd:(Call(∂.Test.MultiDGSMBab.Simple(Call(∂.ForEach([map:2] Call(∂.Take([map:1] Global(S), [if] Global(F)):s*), {A:StrConcat(Scope(2), str(-2nd)), B:StrConcat(Scope(2), str(-1st)), G:Scope(2)})))))
Func sig: (<ctx>:x, S:s*, F:b) to {B:s*}*
Sequence: Seq<{Seq<str>}>
*** Ctx ping count: 8
    [0](8): Take(*1: S, [if] F)
###
> (S ->TakeIf(F))->MultiDGSMBb(it, it)
S->TakeIf(F)->MultiDGSMBb(it, it) : {B:s*}*
BndKind:Call, Type:{B:s*}*, Bnd:(Call(∂.Test.MultiDGSMBb.Simple(Call(∂.ForEach([map:2] Call(∂.Take([map:1] Global(S), [if] Global(F)):s*), {A:str(A's default), B:Scope(2), G:Scope(2)})))))
Func sig: (<ctx>:x, S:s*, F:b) to {B:s*}*
Sequence: Seq<{Seq<str>}>
*** Ctx ping count: 8
    [0](8): Take(*1: S, [if] F)
###
> (S ->TakeIf(F))->MultiDGSMC(it, A: it)
S->TakeIf(F)->MultiDGSMC(it, A : it) : {B:s*}*
BndKind:Call, Type:{B:s*}*, Bnd:(Call(∂.Test.MultiDGSMC.Simple(Call(∂.ForEach([map:2] Call(∂.Take([map:1] Global(S), [if] Global(F)):s*), {A:Scope(2), C:null:{D:s, E:s}*, G:Scope(2)})))))
Func sig: (<ctx>:x, S:s*, F:b) to {B:s*}*
Sequence: Seq<{Seq<str>}>
*** Ctx ping count: 8
    [0](8): Take(*1: S, [if] F)
###
> (TC->TakeIf(F))->MultiDGSMCc(G, A: A, C: C)
TC->TakeIf(F)->MultiDGSMCc(G, A : A, C : C) : {A:s, B:s*, C:{D:s, E:s}*, G:i8}*
BndKind:Call, Type:{A:s, B:s*, C:{D:s, E:s}*, G:i8}*, Bnd:(Call(∂.Guard([guard:2] Call(∂.Take([map:1] Global(TC), [if] Global(F))), Call(∂.Test.MultiDGSMCc.MergeSeq([with:3] Scope(2), Call(∂.ForEach([map:4] Scope(3), {A:GetField(Scope(4), A), C:GetField(Scope(4), C), G:GetField(Scope(4), G)})), Scope(3))))))
Func sig: (<ctx>:x, TC:{A:s, C:{D:s, E:s}*, G:i8}*, F:b) to {A:s, B:s*, C:{D:s, E:s}*, G:i8}*
Type: <null>, Value: <null>
*** Ctx ping count: 8
    [0](8): Take(*1: TC, [if] F)
###
> (S ->TakeIf(F))->MultiDGSMB(it,   it & "-1st",    it & "-2nd") // For comparison.
S->TakeIf(F)->MultiDGSMB(it, it & "-1st", it & "-2nd") : {B:s*}*
BndKind:Call, Type:{B:s*}*, Bnd:(Call(∂.Test.MultiDGSMB.Simple(Call(∂.ForEach([map:2] Call(∂.Take([map:1] Global(S), [if] Global(F)):s*), {A:StrConcat(Scope(2), str(-2nd)), B:StrConcat(Scope(2), str(-1st)), G:Scope(2)})))))
Func sig: (<ctx>:x, S:s*, F:b) to {B:s*}*
Sequence: Seq<{Seq<str>}>
*** Ctx ping count: 8
    [0](8): Take(*1: S, [if] F)
###
> (S ->TakeIf(F))->MultiDGRMB(it,   it & "-1st",    it & "-2nd")
S->TakeIf(F)->MultiDGRMB(it, it & "-1st", it & "-2nd") : {B:s*}*
BndKind:Call, Type:{B:s*}*, Bnd:(Call(∂.Test.MultiDGRMB.Simple({Mis:Call(∂.ForEach([map:2] Call(∂.Take([map:1] Global(S), [if] Global(F)):s*), {A:StrConcat(Scope(2), str(-2nd)), B:StrConcat(Scope(2), str(-1st)), G:Scope(2)})), S1:str(/def), S2:3:i8})))
Func sig: (<ctx>:x, S:s*, F:b) to {B:s*}*
Sequence: Seq<{Seq<str>}>
*** Ctx ping count: 8
    [0](8): Take(*1: S, [if] F)
###
> (S ->TakeIf(F))->MultiDGRMB(it,   it & "-1st",    it & "-2nd",     "/suf")
S->TakeIf(F)->MultiDGRMB(it, it & "-1st", it & "-2nd", "/suf") : {B:s*}*
BndKind:Call, Type:{B:s*}*, Bnd:(Call(∂.Test.MultiDGRMB.Simple({Mis:Call(∂.ForEach([map:2] Call(∂.Take([map:1] Global(S), [if] Global(F)):s*), {A:StrConcat(Scope(2), str(-2nd)), B:StrConcat(Scope(2), str(-1st)), G:Scope(2)})), S1:str(/suf), S2:3:i8})))
Func sig: (<ctx>:x, S:s*, F:b) to {B:s*}*
Sequence: Seq<{Seq<str>}>
*** Ctx ping count: 8
    [0](8): Take(*1: S, [if] F)
###
> (S ->TakeIf(F))->MultiDGRMB(it,   it & "-1st",    it & "-2nd", S1: "/suf")
S->TakeIf(F)->MultiDGRMB(it, it & "-1st", it & "-2nd", S1 : "/suf") : {B:s*}*
BndKind:Call, Type:{B:s*}*, Bnd:(Call(∂.Test.MultiDGRMB.Simple({Mis:Call(∂.ForEach([map:2] Call(∂.Take([map:1] Global(S), [if] Global(F)):s*), {A:StrConcat(Scope(2), str(-2nd)), B:StrConcat(Scope(2), str(-1st)), G:Scope(2)})), S1:str(/suf), S2:3:i8})))
Func sig: (<ctx>:x, S:s*, F:b) to {B:s*}*
Sequence: Seq<{Seq<str>}>
*** Ctx ping count: 8
    [0](8): Take(*1: S, [if] F)
###
> (S ->TakeIf(F))->MultiDGRMB(it,   it & "-1st",    it & "-2nd", S2: 7     )
S->TakeIf(F)->MultiDGRMB(it, it & "-1st", it & "-2nd", S2 : 7) : {B:s*}*
BndKind:Call, Type:{B:s*}*, Bnd:(Call(∂.Test.MultiDGRMB.Simple({Mis:Call(∂.ForEach([map:2] Call(∂.Take([map:1] Global(S), [if] Global(F)):s*), {A:StrConcat(Scope(2), str(-2nd)), B:StrConcat(Scope(2), str(-1st)), G:Scope(2)})), S1:str(/def), S2:7:i8})))
Func sig: (<ctx>:x, S:s*, F:b) to {B:s*}*
Sequence: Seq<{Seq<str>}>
*** Ctx ping count: 8
    [0](8): Take(*1: S, [if] F)
###
> (S ->TakeIf(F))->MultiDGRMB(it,   it & "-1st",    it & "-2nd",     "/suf",     7)
S->TakeIf(F)->MultiDGRMB(it, it & "-1st", it & "-2nd", "/suf", 7) : {B:s*}*
BndKind:Call, Type:{B:s*}*, Bnd:(Call(∂.Test.MultiDGRMB.Simple({Mis:Call(∂.ForEach([map:2] Call(∂.Take([map:1] Global(S), [if] Global(F)):s*), {A:StrConcat(Scope(2), str(-2nd)), B:StrConcat(Scope(2), str(-1st)), G:Scope(2)})), S1:str(/suf), S2:7:i8})))
Func sig: (<ctx>:x, S:s*, F:b) to {B:s*}*
Sequence: Seq<{Seq<str>}>
*** Ctx ping count: 8
    [0](8): Take(*1: S, [if] F)
###
> (S ->TakeIf(F))->MultiDGRMB(it,   it & "-1st",    it & "-2nd",     "/suf", S2: 7)
S->TakeIf(F)->MultiDGRMB(it, it & "-1st", it & "-2nd", "/suf", S2 : 7) : {B:s*}*
BndKind:Call, Type:{B:s*}*, Bnd:(Call(∂.Test.MultiDGRMB.Simple({Mis:Call(∂.ForEach([map:2] Call(∂.Take([map:1] Global(S), [if] Global(F)):s*), {A:StrConcat(Scope(2), str(-2nd)), B:StrConcat(Scope(2), str(-1st)), G:Scope(2)})), S1:str(/suf), S2:7:i8})))
Func sig: (<ctx>:x, S:s*, F:b) to {B:s*}*
Sequence: Seq<{Seq<str>}>
*** Ctx ping count: 8
    [0](8): Take(*1: S, [if] F)
###
> (S ->TakeIf(F))->MultiDGRMB(it,   it & "-1st",    it & "-2nd", S1: "/suf",     7)
S->TakeIf(F)->MultiDGRMB(it, it & "-1st", it & "-2nd", S1 : "/suf", 7) : {B:s*}*
BndKind:Call, Type:{B:s*}*, Bnd:(Call(∂.Test.MultiDGRMB.Simple({Mis:Call(∂.ForEach([map:2] Call(∂.Take([map:1] Global(S), [if] Global(F)):s*), {A:StrConcat(Scope(2), str(-2nd)), B:StrConcat(Scope(2), str(-1st)), G:Scope(2)})), S1:str(/suf), S2:7:i8})))
Func sig: (<ctx>:x, S:s*, F:b) to {B:s*}*
Sequence: Seq<{Seq<str>}>
*** Ctx ping count: 8
    [0](8): Take(*1: S, [if] F)
###
> (S ->TakeIf(F))->MultiDGRMB(it,   it & "-1st",    it & "-2nd", S1: "/suf", S2: 7)
S->TakeIf(F)->MultiDGRMB(it, it & "-1st", it & "-2nd", S1 : "/suf", S2 : 7) : {B:s*}*
BndKind:Call, Type:{B:s*}*, Bnd:(Call(∂.Test.MultiDGRMB.Simple({Mis:Call(∂.ForEach([map:2] Call(∂.Take([map:1] Global(S), [if] Global(F)):s*), {A:StrConcat(Scope(2), str(-2nd)), B:StrConcat(Scope(2), str(-1st)), G:Scope(2)})), S1:str(/suf), S2:7:i8})))
Func sig: (<ctx>:x, S:s*, F:b) to {B:s*}*
Sequence: Seq<{Seq<str>}>
*** Ctx ping count: 8
    [0](8): Take(*1: S, [if] F)
###
> (S ->TakeIf(F))->MultiDGRMB(it,   it & "-1st",    it & "-2nd", S2: 7, S1: "/suf")
S->TakeIf(F)->MultiDGRMB(it, it & "-1st", it & "-2nd", S2 : 7, S1 : "/suf") : {B:s*}*
BndKind:Call, Type:{B:s*}*, Bnd:(Call(∂.Test.MultiDGRMB.Simple({Mis:Call(∂.ForEach([map:2] Call(∂.Take([map:1] Global(S), [if] Global(F)):s*), {A:StrConcat(Scope(2), str(-2nd)), B:StrConcat(Scope(2), str(-1st)), G:Scope(2)})), S1:str(/suf), S2:7:i8})))
Func sig: (<ctx>:x, S:s*, F:b) to {B:s*}*
Sequence: Seq<{Seq<str>}>
*** Ctx ping count: 8
    [0](8): Take(*1: S, [if] F)
###
> (S ->TakeIf(F))->MultiDGrMB({ G: it, B: "b-" & it, A: "a-" & it }, S2: 7, S1: "/suf")
S->TakeIf(F)->MultiDGrMB({ G : it, B : "b-" & it, A : "a-" & it }, S2 : 7, S1 : "/suf") : {B:s*}*
BndKind:Call, Type:{B:s*}*, Bnd:(Call(∂.Test.MultiDGrMB.Simple({Mis:Call(∂.ForEach([map:2] Call(∂.Take([map:1] Global(S), [if] Global(F)):s*), {A:StrConcat(str(a-), Scope(2)), B:StrConcat(str(b-), Scope(2)), G:Scope(2)})), S1:str(/suf), S2:7:i8})))
Func sig: (<ctx>:x, S:s*, F:b) to {B:s*}*
Sequence: Seq<{Seq<str>}>
*** Ctx ping count: 8
    [0](8): Take(*1: S, [if] F)
###
> (TA->TakeIf(F))->MultiDGRMB(G, A)
TA->TakeIf(F)->MultiDGRMB(G, A) : {A:s, B:s*, G:(s, i8), X:r8}*
BndKind:Call, Type:{A:s, B:s*, G:(s, i8), X:r8}*, Bnd:(Call(∂.Guard([guard:2] Call(∂.Take([map:1] Global(TA), [if] Global(F))), Call(∂.Test.MultiDGRMB.MergeRec([with:3] Scope(2), {Mis:Call(∂.ForEach([map:4] Scope(3), {A:str(A's default), B:GetField(Scope(4), A), G:GetField(Scope(4), G)})), S1:str(/def), S2:3:i8}, Scope(3))))))
Func sig: (<ctx>:x, TA:{A:s, G:(s, i8), X:r8}*, F:b) to {A:s, B:s*, G:(s, i8), X:r8}*
Type: <null>, Value: <null>
*** Ctx ping count: 8
    [0](8): Take(*1: TA, [if] F)
###
> (TB->TakeIf(F))->MultiDGRMB(G, B, A)
TB->TakeIf(F)->MultiDGRMB(G, B, A) : {A:s, B:s, B2:s*, G:(i8, s), X:r8}*
BndKind:Call, Type:{A:s, B:s, B2:s*, G:(i8, s), X:r8}*, Bnd:(Call(∂.Guard([guard:2] Call(∂.Take([map:1] Global(TB), [if] Global(F))), Call(∂.Test.MultiDGRMB.MergeRec([with:3] Scope(2), {Mis:Call(∂.ForEach([map:4] Scope(3), {A:GetField(Scope(4), A), B:GetField(Scope(4), B), G:GetField(Scope(4), G)})), S1:str(/def), S2:3:i8}, Scope(3))))))
Func sig: (<ctx>:x, TB:{A:s, B:s, G:(i8, s), X:r8}*, F:b) to {A:s, B:s, B2:s*, G:(i8, s), X:r8}*
Type: <null>, Value: <null>
*** Ctx ping count: 8
    [0](8): Take(*1: TB, [if] F)
###
> (TB->TakeIf(F))->MultiDGRMB(G, B, A, "/suf")
TB->TakeIf(F)->MultiDGRMB(G, B, A, "/suf") : {A:s, B:s, B2:s*, G:(i8, s), X:r8}*
BndKind:Call, Type:{A:s, B:s, B2:s*, G:(i8, s), X:r8}*, Bnd:(Call(∂.Guard([guard:2] Call(∂.Take([map:1] Global(TB), [if] Global(F))), Call(∂.Test.MultiDGRMB.MergeRec([with:3] Scope(2), {Mis:Call(∂.ForEach([map:4] Scope(3), {A:GetField(Scope(4), A), B:GetField(Scope(4), B), G:GetField(Scope(4), G)})), S1:str(/suf), S2:3:i8}, Scope(3))))))
Func sig: (<ctx>:x, TB:{A:s, B:s, G:(i8, s), X:r8}*, F:b) to {A:s, B:s, B2:s*, G:(i8, s), X:r8}*
Type: <null>, Value: <null>
*** Ctx ping count: 8
    [0](8): Take(*1: TB, [if] F)
###
> (TB->TakeIf(F))->MultiDGRMB(G, B, A, "/suf", 5)
TB->TakeIf(F)->MultiDGRMB(G, B, A, "/suf", 5) : {A:s, B:s, B2:s*, G:(i8, s), X:r8}*
BndKind:Call, Type:{A:s, B:s, B2:s*, G:(i8, s), X:r8}*, Bnd:(Call(∂.Guard([guard:2] Call(∂.Take([map:1] Global(TB), [if] Global(F))), Call(∂.Test.MultiDGRMB.MergeRec([with:3] Scope(2), {Mis:Call(∂.ForEach([map:4] Scope(3), {A:GetField(Scope(4), A), B:GetField(Scope(4), B), G:GetField(Scope(4), G)})), S1:str(/suf), S2:5:i8}, Scope(3))))))
Func sig: (<ctx>:x, TB:{A:s, B:s, G:(i8, s), X:r8}*, F:b) to {A:s, B:s, B2:s*, G:(i8, s), X:r8}*
Type: <null>, Value: <null>
*** Ctx ping count: 8
    [0](8): Take(*1: TB, [if] F)
###
> (TB->TakeIf(F))->MultiDGrMB({ G, B, A }, "/suf", 5)
TB->TakeIf(F)->MultiDGrMB({ G, B, A }, "/suf", 5) : {A:s, B:s, B2:s*, G:(i8, s), X:r8}*
BndKind:Call, Type:{A:s, B:s, B2:s*, G:(i8, s), X:r8}*, Bnd:(Call(∂.Guard([guard:2] Call(∂.Take([map:1] Global(TB), [if] Global(F))), Call(∂.Test.MultiDGrMB.MergeRec([with:3] Scope(2), {Mis:Call(∂.ForEach([map:4] Scope(3), {A:GetField(Scope(4), A), B:GetField(Scope(4), B), G:GetField(Scope(4), G)})), S1:str(/suf), S2:5:i8}, Scope(3))))))
Func sig: (<ctx>:x, TB:{A:s, B:s, G:(i8, s), X:r8}*, F:b) to {A:s, B:s, B2:s*, G:(i8, s), X:r8}*
Type: <null>, Value: <null>
*** Ctx ping count: 8
    [0](8): Take(*1: TB, [if] F)
###
> (TB->TakeIf(F))->MultiDGrMB({ G, A, B }, "/suf", 5)
TB->TakeIf(F)->MultiDGrMB({ G, A, B }, "/suf", 5) : {A:s, B:s, B2:s*, G:(i8, s), X:r8}*
BndKind:Call, Type:{A:s, B:s, B2:s*, G:(i8, s), X:r8}*, Bnd:(Call(∂.Guard([guard:2] Call(∂.Take([map:1] Global(TB), [if] Global(F))), Call(∂.Test.MultiDGrMB.MergeRec([with:3] Scope(2), {Mis:Call(∂.ForEach([map:4] Scope(3), {A:GetField(Scope(4), A), B:GetField(Scope(4), B), G:GetField(Scope(4), G)})), S1:str(/suf), S2:5:i8}, Scope(3))))))
Func sig: (<ctx>:x, TB:{A:s, B:s, G:(i8, s), X:r8}*, F:b) to {A:s, B:s, B2:s*, G:(i8, s), X:r8}*
Type: <null>, Value: <null>
*** Ctx ping count: 8
    [0](8): Take(*1: TB, [if] F)
###
> (TB->TakeIf(F))->MultiDGSMBW()
TB->TakeIf(F)->MultiDGSMBW() : {Mos:{A:s, B:s, B2:s*, G:(i8, s), X:r8}*, S1:s, S2:i8}
BndKind:Call, Type:{Mos:{A:s, B:s, B2:s*, G:(i8, s), X:r8}*, S1:s, S2:i8}, Bnd:(Call(∂.Test.MultiDGSMBW.MergeSeq([with:2] Call(∂.Take([map:1] Global(TB), [if] Global(F))), Call(∂.ForEach([map:3] Scope(2), {A:GetField(Scope(3), A), B:GetField(Scope(3), B), G:GetField(Scope(3), G)})), Scope(2))))
Func sig: (<ctx>:x, TB:{A:s, B:s, G:(i8, s), X:r8}*, F:b) to {Mos:{A:s, B:s, B2:s*, G:(i8, s), X:r8}*, S1:s, S2:i8}
Type: {Seq<{str,str,Seq<str>,(i8,str),r8}>,str,i8}, Value: { Mos: Sequence: Seq<{str,str,Seq<str>,(i8,str),r8}>
  S1: , S2: 9223372036854775807 }
*** Ctx ping count: 8
    [0](8): Take(*1: TB, [if] F)
###
> (S ->TakeIf(F))->MultiDGSMBW(it, B: it & "-1st", A: it & "-2nd")
S->TakeIf(F)->MultiDGSMBW(it, B : it & "-1st", A : it & "-2nd") : {Mos:{B:s*}*, S1:s, S2:i8}
BndKind:Call, Type:{Mos:{B:s*}*, S1:s, S2:i8}, Bnd:(Call(∂.Test.MultiDGSMBW.Simple(Call(∂.ForEach([map:2] Call(∂.Take([map:1] Global(S), [if] Global(F)):s*), {A:StrConcat(Scope(2), str(-2nd)), B:StrConcat(Scope(2), str(-1st)), G:Scope(2)})))))
Func sig: (<ctx>:x, S:s*, F:b) to {Mos:{B:s*}*, S1:s, S2:i8}
Type: {Seq<{Seq<str>}>,str,i8}, Value: { Mos: Sequence: Seq<{Seq<str>}>
  S1: , S2: 9223372036854775807 }
*** Ctx ping count: 8
    [0](8): Take(*1: S, [if] F)
###
> (TB->TakeIf(F))->MultiDGSMBW(G, A, B)
TB->TakeIf(F)->MultiDGSMBW(G, A, B) : {Mos:{A:s, B:s, B2:s*, G:(i8, s), X:r8}*, S1:s, S2:i8}
BndKind:Call, Type:{Mos:{A:s, B:s, B2:s*, G:(i8, s), X:r8}*, S1:s, S2:i8}, Bnd:(Call(∂.Test.MultiDGSMBW.MergeSeq([with:2] Call(∂.Take([map:1] Global(TB), [if] Global(F))), Call(∂.ForEach([map:3] Scope(2), {A:GetField(Scope(3), B), B:GetField(Scope(3), A), G:GetField(Scope(3), G)})), Scope(2))))
Func sig: (<ctx>:x, TB:{A:s, B:s, G:(i8, s), X:r8}*, F:b) to {Mos:{A:s, B:s, B2:s*, G:(i8, s), X:r8}*, S1:s, S2:i8}
Type: {Seq<{str,str,Seq<str>,(i8,str),r8}>,str,i8}, Value: { Mos: Sequence: Seq<{str,str,Seq<str>,(i8,str),r8}>
  S1: , S2: 9223372036854775807 }
*** Ctx ping count: 8
    [0](8): Take(*1: TB, [if] F)
###
> (S ->TakeIf(F))->MultiDGRMBW(it, A: it & "-1st", B: it & "-2nd", S1: "/suf", S2: 7)
S->TakeIf(F)->MultiDGRMBW(it, A : it & "-1st", B : it & "-2nd", S1 : "/suf", S2 : 7) : {Mos:{B:s*}*, S1:s, S2:i8}
BndKind:Call, Type:{Mos:{B:s*}*, S1:s, S2:i8}, Bnd:(Call(∂.Test.MultiDGRMBW.Simple({Mis:Call(∂.ForEach([map:2] Call(∂.Take([map:1] Global(S), [if] Global(F)):s*), {A:StrConcat(Scope(2), str(-1st)), B:StrConcat(Scope(2), str(-2nd)), G:Scope(2)})), S1:str(/suf), S2:7:i8})))
Func sig: (<ctx>:x, S:s*, F:b) to {Mos:{B:s*}*, S1:s, S2:i8}
Type: {Seq<{Seq<str>}>,str,i8}, Value: { Mos: Sequence: Seq<{Seq<str>}>
  S1: /suf, S2: 7 }
*** Ctx ping count: 8
    [0](8): Take(*1: S, [if] F)
###
> (TB->TakeIf(F))->MultiDGRMBW(G, B, A           )
TB->TakeIf(F)->MultiDGRMBW(G, B, A) : {Mos:{A:s, B:s, B2:s*, G:(i8, s), X:r8}*, S1:s, S2:i8}
BndKind:Call, Type:{Mos:{A:s, B:s, B2:s*, G:(i8, s), X:r8}*, S1:s, S2:i8}, Bnd:(Call(∂.Test.MultiDGRMBW.MergeRec([with:2] Call(∂.Take([map:1] Global(TB), [if] Global(F))), {Mis:Call(∂.ForEach([map:3] Scope(2), {A:GetField(Scope(3), A), B:GetField(Scope(3), B), G:GetField(Scope(3), G)})), S1:str(/def), S2:3:i8}, Scope(2))))
Func sig: (<ctx>:x, TB:{A:s, B:s, G:(i8, s), X:r8}*, F:b) to {Mos:{A:s, B:s, B2:s*, G:(i8, s), X:r8}*, S1:s, S2:i8}
Type: {Seq<{str,str,Seq<str>,(i8,str),r8}>,str,i8}, Value: { Mos: Sequence: Seq<{str,str,Seq<str>,(i8,str),r8}>
  S1: /def, S2: 3 }
*** Ctx ping count: 8
    [0](8): Take(*1: TB, [if] F)
###
> (TB->TakeIf(F))->MultiDGRMBW(G, B, A, "/suf", 5)
TB->TakeIf(F)->MultiDGRMBW(G, B, A, "/suf", 5) : {Mos:{A:s, B:s, B2:s*, G:(i8, s), X:r8}*, S1:s, S2:i8}
BndKind:Call, Type:{Mos:{A:s, B:s, B2:s*, G:(i8, s), X:r8}*, S1:s, S2:i8}, Bnd:(Call(∂.Test.MultiDGRMBW.MergeRec([with:2] Call(∂.Take([map:1] Global(TB), [if] Global(F))), {Mis:Call(∂.ForEach([map:3] Scope(2), {A:GetField(Scope(3), A), B:GetField(Scope(3), B), G:GetField(Scope(3), G)})), S1:str(/suf), S2:5:i8}, Scope(2))))
Func sig: (<ctx>:x, TB:{A:s, B:s, G:(i8, s), X:r8}*, F:b) to {Mos:{A:s, B:s, B2:s*, G:(i8, s), X:r8}*, S1:s, S2:i8}
Type: {Seq<{str,str,Seq<str>,(i8,str),r8}>,str,i8}, Value: { Mos: Sequence: Seq<{str,str,Seq<str>,(i8,str),r8}>
  S1: /suf, S2: 5 }
*** Ctx ping count: 8
    [0](8): Take(*1: TB, [if] F)
###
> MultiS_DGSMB_ABGD({A:S, B:Range(10)->ToText(), G:[(9,)]})
MultiS_DGSMB_ABGD({ A : S, B : Range(10)->ToText(), G : [(9,)] }) : {B:s*}*
BndKind:Call, Type:{B:s*}*, Bnd:(Call(∂.Test.MultiS_DGSMB_ABGD.Simple([{A:Global(S), B:Call(∂.ForEach([map:1] Call(∂.Range(10:i8):i8*), Call(∂.ToText(Scope(1)):s)):s*), G:[(9:i8,):(i8)]:(i8)*}]:{A:s*, B:s*, G:(i8)*}*)))
Func sig: (<ctx>:x, S:s*) to {B:s*}*
Sequence: Seq<{Seq<str>}>
 0) { B: Sequence: Seq<str>
         0) A: [x, xy, , xyz, hi, adios, hola, guten morgen]
         1) B: [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]
    }
*** Ctx ping count: 0
###
> MultiS_DGSMB_ABGD(TB, G, B)
MultiS_DGSMB_ABGD(TB, G, B) : {A:s, B:s, B2:s*, G:(i8, s), X:r8}*
BndKind:Call, Type:{A:s, B:s, B2:s*, G:(i8, s), X:r8}*, Bnd:(Call(∂.Guard([guard:1] Global(TB), Call(∂.Test.MultiS_DGSMB_ABGD.MergeSeq([with:2] Scope(1), Call(∂.ForEach([map:3] Scope(2), {A:null:s*, B:[GetField(Scope(3), B)]:s*, G:[GetField(Scope(3), G)]:(i8, s)*})), Scope(2))))))
Func sig: (<ctx>:x, TB:{A:s, B:s, G:(i8, s), X:r8}*) to {A:s, B:s, B2:s*, G:(i8, s), X:r8}*
Sequence: Seq<{str,str,Seq<str>,(i8,str),r8}>
 1) { A: <null>, B: xy, 
      B2: Sequence: Seq<str>
         0) A: []
         1) B: [xy]
      G: (1, xy), X: 2 }
 5) { A: adios, B: <null>, 
      B2: Sequence: Seq<str>
         0) A: []
         1) B: []
      G: (5, adios), X: 6 }
 3) { A: xyz, B: xyz, 
      B2: Sequence: Seq<str>
         0) A: []
         1) B: [xyz]
      G: (3, xyz), X: 4 }
 7) { A: <null>, B: guten morgen, 
      B2: Sequence: Seq<str>
         0) A: []
         1) B: [guten morgen]
      G: (7, guten morgen), X: 8 }
 0) { A: x, B: x, 
      B2: Sequence: Seq<str>
         0) A: []
         1) B: [x]
      G: (0, x), X: 1 }
 4) { A: <null>, B: hi, 
      B2: Sequence: Seq<str>
         0) A: []
         1) B: [hi]
      G: (4, hi), X: 5 }
 2) { A: <null>, B: <null>, 
      B2: Sequence: Seq<str>
         0) A: []
         1) B: []
      G: (2, <null>), X: 3 }
 6) { A: hola, B: hola, 
      B2: Sequence: Seq<str>
         0) A: []
         1) B: [hola]
      G: (6, hola), X: 7 }
*** Ctx ping count: 0
###
> MultiS_DGSMB_ABGD(TB, B: [B], G: G, A: A)
MultiS_DGSMB_ABGD(TB, B : [B], G : G, A : A) : {A:s, B:s, B2:s*, G:(i8, s), X:r8}*
BndKind:Call, Type:{A:s, B:s, B2:s*, G:(i8, s), X:r8}*, Bnd:(Call(∂.Guard([guard:1] Global(TB), Call(∂.Test.MultiS_DGSMB_ABGD.MergeSeq([with:2] Scope(1), Call(∂.ForEach([map:3] Scope(2), {A:[GetField(Scope(3), A)]:s*, B:[GetField(Scope(3), B)]:s*, G:[GetField(Scope(3), G)]:(i8, s)*})), Scope(2))))))
Func sig: (<ctx>:x, TB:{A:s, B:s, G:(i8, s), X:r8}*) to {A:s, B:s, B2:s*, G:(i8, s), X:r8}*
Sequence: Seq<{str,str,Seq<str>,(i8,str),r8}>
 1) { A: <null>, B: xy, 
      B2: Sequence: Seq<str>
         0) A: []
         1) B: [xy]
      G: (1, xy), X: 2 }
 5) { A: adios, B: <null>, 
      B2: Sequence: Seq<str>
         0) A: [adios]
         1) B: []
      G: (5, adios), X: 6 }
 3) { A: xyz, B: xyz, 
      B2: Sequence: Seq<str>
         0) A: [xyz]
         1) B: [xyz]
      G: (3, xyz), X: 4 }
 7) { A: <null>, B: guten morgen, 
      B2: Sequence: Seq<str>
         0) A: []
         1) B: [guten morgen]
      G: (7, guten morgen), X: 8 }
 0) { A: x, B: x, 
      B2: Sequence: Seq<str>
         0) A: [x]
         1) B: [x]
      G: (0, x), X: 1 }
 4) { A: <null>, B: hi, 
      B2: Sequence: Seq<str>
         0) A: []
         1) B: [hi]
      G: (4, hi), X: 5 }
 2) { A: <null>, B: <null>, 
      B2: Sequence: Seq<str>
         0) A: []
         1) B: []
      G: (2, <null>), X: 3 }
 6) { A: hola, B: hola, 
      B2: Sequence: Seq<str>
         0) A: [hola]
         1) B: [hola]
      G: (6, hola), X: 7 }
*** Ctx ping count: 0
###
> MultiS_DGRMB_ABGD12(TB, G, A, B, "hello", [17])
MultiS_DGRMB_ABGD12(TB, G, A, B, "hello", [17]) : {A:s, B:s, B2:s*, G:(i8, s), X:r8}*
BndKind:Call, Type:{A:s, B:s, B2:s*, G:(i8, s), X:r8}*, Bnd:(Call(∂.Guard([guard:1] Global(TB), Call(∂.Test.MultiS_DGRMB_ABGD12.MergeRec([with:2] Scope(1), {Mis:Call(∂.ForEach([map:3] Scope(2), {A:[GetField(Scope(3), B)]:s*, B:[GetField(Scope(3), A)]:s*, G:[GetField(Scope(3), G)]:(i8, s)*})), S1:[str(hello)]:s*, S2:[17:i8]:i8*}, Scope(2))))))
Func sig: (<ctx>:x, TB:{A:s, B:s, G:(i8, s), X:r8}*) to {A:s, B:s, B2:s*, G:(i8, s), X:r8}*
Sequence: Seq<{str,str,Seq<str>,(i8,str),r8}>
 1) { A: <null>, B: xy, 
      B2: Sequence: Seq<str>
         0) A: [xyhello]
         1) B: [hello]
      G: (1, xy), X: 2 }
 5) { A: adios, B: <null>, 
      B2: Sequence: Seq<str>
         0) A: [hello]
         1) B: [adioshello]
      G: (5, adios), X: 6 }
 3) { A: xyz, B: xyz, 
      B2: Sequence: Seq<str>
         0) A: [xyzhello]
         1) B: [xyzhello]
      G: (3, xyz), X: 4 }
 7) { A: <null>, B: guten morgen, 
      B2: Sequence: Seq<str>
         0) A: [guten morgenhello]
         1) B: [hello]
      G: (7, guten morgen), X: 8 }
 0) { A: x, B: x, 
      B2: Sequence: Seq<str>
         0) A: [xhello]
         1) B: [xhello]
      G: (0, x), X: 1 }
 4) { A: <null>, B: hi, 
      B2: Sequence: Seq<str>
         0) A: [hihello]
         1) B: [hello]
      G: (4, hi), X: 5 }
 2) { A: <null>, B: <null>, 
      B2: Sequence: Seq<str>
         0) A: [hello]
         1) B: [hello]
      G: (2, <null>), X: 3 }
 6) { A: hola, B: hola, 
      B2: Sequence: Seq<str>
         0) A: [holahello]
         1) B: [holahello]
      G: (6, hola), X: 7 }
*** Ctx ping count: 0
###
> MultiS_DGRMB_ABGD12(TB, B: [B], A: A, G: G, S1:["hello"], S2:17)
MultiS_DGRMB_ABGD12(TB, B : [B], A : A, G : G, S1 : ["hello"], S2 : 17) : {A:s, B:s, B2:s*, G:(i8, s), X:r8}*
BndKind:Call, Type:{A:s, B:s, B2:s*, G:(i8, s), X:r8}*, Bnd:(Call(∂.Guard([guard:1] Global(TB), Call(∂.Test.MultiS_DGRMB_ABGD12.MergeRec([with:2] Scope(1), {Mis:Call(∂.ForEach([map:3] Scope(2), {A:[GetField(Scope(3), A)]:s*, B:[GetField(Scope(3), B)]:s*, G:[GetField(Scope(3), G)]:(i8, s)*})), S1:[str(hello)]:s*, S2:[17:i8]:i8*}, Scope(2))))))
Func sig: (<ctx>:x, TB:{A:s, B:s, G:(i8, s), X:r8}*) to {A:s, B:s, B2:s*, G:(i8, s), X:r8}*
Sequence: Seq<{str,str,Seq<str>,(i8,str),r8}>
 1) { A: <null>, B: xy, 
      B2: Sequence: Seq<str>
         0) A: [hello]
         1) B: [xyhello]
      G: (1, xy), X: 2 }
 5) { A: adios, B: <null>, 
      B2: Sequence: Seq<str>
         0) A: [adioshello]
         1) B: [hello]
      G: (5, adios), X: 6 }
 3) { A: xyz, B: xyz, 
      B2: Sequence: Seq<str>
         0) A: [xyzhello]
         1) B: [xyzhello]
      G: (3, xyz), X: 4 }
 7) { A: <null>, B: guten morgen, 
      B2: Sequence: Seq<str>
         0) A: [hello]
         1) B: [guten morgenhello]
      G: (7, guten morgen), X: 8 }
 0) { A: x, B: x, 
      B2: Sequence: Seq<str>
         0) A: [xhello]
         1) B: [xhello]
      G: (0, x), X: 1 }
 4) { A: <null>, B: hi, 
      B2: Sequence: Seq<str>
         0) A: [hello]
         1) B: [hihello]
      G: (4, hi), X: 5 }
 2) { A: <null>, B: <null>, 
      B2: Sequence: Seq<str>
         0) A: [hello]
         1) B: [hello]
      G: (2, <null>), X: 3 }
 6) { A: hola, B: hola, 
      B2: Sequence: Seq<str>
         0) A: [holahello]
         1) B: [holahello]
      G: (6, hola), X: 7 }
*** Ctx ping count: 0
###
> MultiS_DGfMB_ABGDM12({A:["sA"], B:["sB"], G:[(9,)]}, "hello", 17)
MultiS_DGfMB_ABGDM12({ A : ["sA"], B : ["sB"], G : [(9,)] }, "hello", 17) : {B:s*}*
BndKind:Call, Type:{B:s*}*, Bnd:(Call(∂.Test.MultiS_DGfMB_ABGDM12.Simple({Mis:[{A:[str(sA)]:s*, B:[str(sB)]:s*, G:[(9:i8,):(i8)]:(i8)*}]:{A:s*, B:s*, G:(i8)*}*, S1:[str(hello)]:s*, S2:[17:i8]:i8*})))
Func sig: (<ctx>:x) to {B:s*}*
Sequence: Seq<{Seq<str>}>
 0) { B: Sequence: Seq<str>
         0) A: [sAhello]
         1) B: [sBhello]
    }
*** Ctx ping count: 0
###
> MultiS_DGsMB_ABGDM(TB, {A:["sA"], B:["sB"], G:[(9,)]})
MultiS_DGsMB_ABGDM(TB, { A : ["sA"], B : ["sB"], G : [(9,)] }) : {A:s, B:s, B2:s*, G:(i8, s), X:r8}*
BndKind:Call, Type:{A:s, B:s, B2:s*, G:(i8, s), X:r8}*, Bnd:(Call(∂.Guard([guard:1] Global(TB), [with:2] [{A:[str(sA)]:s*, B:[str(sB)]:s*, G:[(9:i8,):(i8)]:(i8)*}]:{A:s*, B:s*, G:(i8)*}*, Call(∂.Test.MultiS_DGsMB_ABGDM.MergeSeq([with:3] Scope(1), Call(∂.ForEach([map:4] Scope(3), Scope(2))), Scope(3))))))
Func sig: (<ctx>:x, TB:{A:s, B:s, G:(i8, s), X:r8}*) to {A:s, B:s, B2:s*, G:(i8, s), X:r8}*
Sequence: Seq<{str,str,Seq<str>,(i8,str),r8}>
 1) { A: <null>, B: xy, 
      B2: Sequence: Seq<str>
         0) A: [sA]
         1) B: [sB]
      G: (1, xy), X: 2 }
 5) { A: adios, B: <null>, 
      B2: Sequence: Seq<str>
         0) A: [sA]
         1) B: [sB]
      G: (5, adios), X: 6 }
 3) { A: xyz, B: xyz, 
      B2: Sequence: Seq<str>
         0) A: [sA]
         1) B: [sB]
      G: (3, xyz), X: 4 }
 7) { A: <null>, B: guten morgen, 
      B2: Sequence: Seq<str>
         0) A: [sA]
         1) B: [sB]
      G: (7, guten morgen), X: 8 }
 0) { A: x, B: x, 
      B2: Sequence: Seq<str>
         0) A: [sA]
         1) B: [sB]
      G: (0, x), X: 1 }
 4) { A: <null>, B: hi, 
      B2: Sequence: Seq<str>
         0) A: [sA]
         1) B: [sB]
      G: (4, hi), X: 5 }
 2) { A: <null>, B: <null>, 
      B2: Sequence: Seq<str>
         0) A: [sA]
         1) B: [sB]
      G: (2, <null>), X: 3 }
 6) { A: hola, B: hola, 
      B2: Sequence: Seq<str>
         0) A: [sA]
         1) B: [sB]
      G: (6, hola), X: 7 }
*** Ctx ping count: 0
###
> MultiS_DGrMB_ABGDM12(TB, {A:["sA"], B:["sB"], G:(9,)}, S2:17, S1:"sA")
MultiS_DGrMB_ABGDM12(TB, { A : ["sA"], B : ["sB"], G : (9,) }, S2 : 17, S1 : "sA") : {A:s, B:s, B2:s*, G:(i8, s), X:r8}*
BndKind:Call, Type:{A:s, B:s, B2:s*, G:(i8, s), X:r8}*, Bnd:(Call(∂.Guard([guard:1] Global(TB), Call(∂.Test.MultiS_DGrMB_ABGDM12.MergeRec([with:2] Scope(1), {Mis:Call(∂.ForEach([map:3] Scope(2), [Error(ErrBadType_Src_Dst)]:{A:s*, B:s*, G:(i8)*}*)), S1:[str(sA)]:s*, S2:[17:i8]:i8*}, Scope(2))))))
*** Error: (25,26) Node: { A : ["sA"], B : ["sB"], G : (9,) }, Message: Invalid operand type: cannot convert type '{A:s*, B:s*, G:(i8)}' to '{A:s*, B:s*, G:(i8)*}'
###
> MultiS_DGSMA_AGD(TA, null)
MultiS_DGSMA_AGD(TA, null) : {A:s, B:s*, G:(s, i8), X:r8}*
BndKind:Call, Type:{A:s, B:s*, G:(s, i8), X:r8}*, Bnd:(Call(∂.Guard([guard:1] Global(TA), [with:2] {A:null:s*, G:null:o*}, Call(∂.Test.MultiS_DGSMA_AGD.MergeSeq([with:3] Scope(1), Call(∂.ForEach([map:4] Scope(3), Scope(2))), Scope(3))))))
Func sig: (<ctx>:x, TA:{A:s, G:(s, i8), X:r8}*) to {A:s, B:s*, G:(s, i8), X:r8}*
Sequence: Seq<{str,Seq<str>,(str,i8),r8}>
 1) { A: xy, 
      B: Sequence: Seq<str>
         0) A: []
      G: (xy, 1), X: 2 }
 5) { A: adios, 
      B: Sequence: Seq<str>
         0) A: []
      G: (adios, 5), X: 6 }
 3) { A: xyz, 
      B: Sequence: Seq<str>
         0) A: []
      G: (xyz, 3), X: 4 }
 7) { A: guten morgen, 
      B: Sequence: Seq<str>
         0) A: []
      G: (guten morgen, 7), X: 8 }
 0) { A: x, 
      B: Sequence: Seq<str>
         0) A: []
      G: (x, 0), X: 1 }
 4) { A: hi, 
      B: Sequence: Seq<str>
         0) A: []
      G: (hi, 4), X: 5 }
 2) { A: <null>, 
      B: Sequence: Seq<str>
         0) A: []
      G: (<null>, 2), X: 3 }
 6) { A: hola, 
      B: Sequence: Seq<str>
         0) A: []
      G: (hola, 6), X: 7 }
*** Ctx ping count: 0
###
> MultiS_DGRMB_ABGD12(TB, null, null, null, null)
MultiS_DGRMB_ABGD12(TB, null, null, null, null) : {A:s, B:s, B2:s*, G:(i8, s), X:r8}*
BndKind:Call, Type:{A:s, B:s, B2:s*, G:(i8, s), X:r8}*, Bnd:(Call(∂.Guard([guard:1] Global(TB), [with:2] {A:null:s*, B:null:s*, G:null:o*}, Call(∂.Test.MultiS_DGRMB_ABGD12.MergeRec([with:3] Scope(1), {Mis:Call(∂.ForEach([map:4] Scope(3), Scope(2))), S1:null:s*, S2:null:i8*}, Scope(3))))))
Func sig: (<ctx>:x, TB:{A:s, B:s, G:(i8, s), X:r8}*) to {A:s, B:s, B2:s*, G:(i8, s), X:r8}*
Sequence: Seq<{str,str,Seq<str>,(i8,str),r8}>
 1) { A: <null>, B: xy, 
      B2: Sequence: Seq<str>
         0) A: []
         1) B: []
      G: (1, xy), X: 2 }
 5) { A: adios, B: <null>, 
      B2: Sequence: Seq<str>
         0) A: []
         1) B: []
      G: (5, adios), X: 6 }
 3) { A: xyz, B: xyz, 
      B2: Sequence: Seq<str>
         0) A: []
         1) B: []
      G: (3, xyz), X: 4 }
 7) { A: <null>, B: guten morgen, 
      B2: Sequence: Seq<str>
         0) A: []
         1) B: []
      G: (7, guten morgen), X: 8 }
 0) { A: x, B: x, 
      B2: Sequence: Seq<str>
         0) A: []
         1) B: []
      G: (0, x), X: 1 }
 4) { A: <null>, B: hi, 
      B2: Sequence: Seq<str>
         0) A: []
         1) B: []
      G: (4, hi), X: 5 }
 2) { A: <null>, B: <null>, 
      B2: Sequence: Seq<str>
         0) A: []
         1) B: []
      G: (2, <null>), X: 3 }
 6) { A: hola, B: hola, 
      B2: Sequence: Seq<str>
         0) A: []
         1) B: []
      G: (6, hola), X: 7 }
*** Ctx ping count: 0
###
> MultiS_DGfMB_ABGDM12({A:null, B:null}, null, 17)
MultiS_DGfMB_ABGDM12({ A : null, B : null }, null, 17) : {B:s*}*
BndKind:Call, Type:{B:s*}*, Bnd:(Call(∂.Test.MultiS_DGfMB_ABGDM12.Simple({Mis:[Error(ErrBadType_Src_Dst)]:{A:s*, B:s*, G:g*}*, S1:null:s*, S2:[17:i8]:i8*})))
*** Error: (21,22) Node: { A : null, B : null }, Message: Invalid operand type: cannot convert type '{A:o, B:o}' to '{A:s*, B:s*, G:g*}'
###
> MultiS_DGsMB_ABGDM(TB, {A:null, B:null, G:null})
MultiS_DGsMB_ABGDM(TB, { A : null, B : null, G : null }) : {A:s, B:s, B2:s*, G:(i8, s), X:r8}*
BndKind:Call, Type:{A:s, B:s, B2:s*, G:(i8, s), X:r8}*, Bnd:(Call(∂.Guard([guard:1] Global(TB), [with:2] [{A:null:s*, B:null:s*, G:null:o*}]:{A:s*, B:s*, G:o*}*, Call(∂.Test.MultiS_DGsMB_ABGDM.MergeSeq([with:3] Scope(1), Call(∂.ForEach([map:4] Scope(3), Scope(2))), Scope(3))))))
Func sig: (<ctx>:x, TB:{A:s, B:s, G:(i8, s), X:r8}*) to {A:s, B:s, B2:s*, G:(i8, s), X:r8}*
Sequence: Seq<{str,str,Seq<str>,(i8,str),r8}>
 1) { A: <null>, B: xy, 
      B2: Sequence: Seq<str>
         0) A: []
         1) B: []
      G: (1, xy), X: 2 }
 5) { A: adios, B: <null>, 
      B2: Sequence: Seq<str>
         0) A: []
         1) B: []
      G: (5, adios), X: 6 }
 3) { A: xyz, B: xyz, 
      B2: Sequence: Seq<str>
         0) A: []
         1) B: []
      G: (3, xyz), X: 4 }
 7) { A: <null>, B: guten morgen, 
      B2: Sequence: Seq<str>
         0) A: []
         1) B: []
      G: (7, guten morgen), X: 8 }
 0) { A: x, B: x, 
      B2: Sequence: Seq<str>
         0) A: []
         1) B: []
      G: (0, x), X: 1 }
 4) { A: <null>, B: hi, 
      B2: Sequence: Seq<str>
         0) A: []
         1) B: []
      G: (4, hi), X: 5 }
 2) { A: <null>, B: <null>, 
      B2: Sequence: Seq<str>
         0) A: []
         1) B: []
      G: (2, <null>), X: 3 }
 6) { A: hola, B: hola, 
      B2: Sequence: Seq<str>
         0) A: []
         1) B: []
      G: (6, hola), X: 7 }
*** Ctx ping count: 0
###
> MultiS_DGrMB_ABGDM12(TB, {A:null, B:null, G:null}, S2:17, S1:null)
MultiS_DGrMB_ABGDM12(TB, { A : null, B : null, G : null }, S2 : 17, S1 : null) : {A:s, B:s, B2:s*, G:(i8, s), X:r8}*
BndKind:Call, Type:{A:s, B:s, B2:s*, G:(i8, s), X:r8}*, Bnd:(Call(∂.Guard([guard:1] Global(TB), [with:2] [{A:null:s*, B:null:s*, G:null:o*}]:{A:s*, B:s*, G:o*}*, Call(∂.Test.MultiS_DGrMB_ABGDM12.MergeRec([with:3] Scope(1), {Mis:Call(∂.ForEach([map:4] Scope(3), Scope(2))), S1:null:s*, S2:[17:i8]:i8*}, Scope(3))))))
Func sig: (<ctx>:x, TB:{A:s, B:s, G:(i8, s), X:r8}*) to {A:s, B:s, B2:s*, G:(i8, s), X:r8}*
Sequence: Seq<{str,str,Seq<str>,(i8,str),r8}>
 1) { A: <null>, B: xy, 
      B2: Sequence: Seq<str>
         0) A: []
         1) B: []
      G: (1, xy), X: 2 }
 5) { A: adios, B: <null>, 
      B2: Sequence: Seq<str>
         0) A: []
         1) B: []
      G: (5, adios), X: 6 }
 3) { A: xyz, B: xyz, 
      B2: Sequence: Seq<str>
         0) A: []
         1) B: []
      G: (3, xyz), X: 4 }
 7) { A: <null>, B: guten morgen, 
      B2: Sequence: Seq<str>
         0) A: []
         1) B: []
      G: (7, guten morgen), X: 8 }
 0) { A: x, B: x, 
      B2: Sequence: Seq<str>
         0) A: []
         1) B: []
      G: (0, x), X: 1 }
 4) { A: <null>, B: hi, 
      B2: Sequence: Seq<str>
         0) A: []
         1) B: []
      G: (4, hi), X: 5 }
 2) { A: <null>, B: <null>, 
      B2: Sequence: Seq<str>
         0) A: []
         1) B: []
      G: (2, <null>), X: 3 }
 6) { A: hola, B: hola, 
      B2: Sequence: Seq<str>
         0) A: []
         1) B: []
      G: (6, hola), X: 7 }
*** Ctx ping count: 0
###
