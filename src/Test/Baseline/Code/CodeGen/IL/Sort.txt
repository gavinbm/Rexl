**** New definitions: Data, type: {A:i8, B:i8, C:i8}*
**** New definitions: DataInd, type: ({A:i8, B:i8}, i8)*
**** New definitions: G, type: i8

> Sort(Data, A)
Sort(Data, A) : {A:i8, B:i8, C:i8}*
BndKind:Call, Type:{A:i8, B:i8, C:i8}*, Bnd:(Call(∂.Sort([map:1] Global(Data), GetField(Scope(1), A))))
// (<ctx>, ∂.Data:{A:i8, B:i8, C:i8}*) : {A:i8, B:i8, C:i8}*
Sort_1(Arr<obj>, {i8,i8,i8}):i8
      1) ldarg.1 [{i8,i8,i8}]
      5) ldfld {i8,i8,i8}::_F0:i8
      1) ret
  Total Size: 7

top(Arr<obj>, Arr<obj>):obj
      1) ldarg.1 [Arr<obj>]
      1) ldc.i4.0
      1) ldelem.ref
      5) call static CodeGenUtil::ToRef(obj):ExecCtx
      1) stloc.0 [ExecCtx]
      1) ldarg.1 [Arr<obj>]
      1) ldc.i4.1
      1) ldelem.ref
      5) call static CodeGenUtil::ToRef(obj):Seq<{i8,i8,i8}>
      1) stloc.1 [Seq<{i8,i8,i8}>]
      1) ldloc.1 [Seq<{i8,i8,i8}>]
      1) dup
      1) ldloc.0 [ExecCtx]
      1) ldc.i4.0
      5) call static CodeGenUtil::EnumerableToPinging(Seq<{i8,i8,i8}>, ExecCtx, i4):Seq<{i8,i8,i8}>
      1) ldarg.0 [Arr<obj>]
      1) ldc.i4.0
      5) ldelem [Func<{i8,i8,i8},i8>]
      1) ldarg.0 [Arr<obj>]
      1) ldc.i4.1
      5) ldelem [Func<i8,i8,i4>]
      5) call static CodeGenUtil::Sort(Seq<{i8,i8,i8}>, Func<{i8,i8,i8},i8>, Func<i8,i8,i4>):Seq<{i8,i8,i8}>
      5) call static CodeGenUtil::WrapWithCounter(Seq<{i8,i8,i8}>, Seq<{i8,i8,i8}>):Seq<{i8,i8,i8}>
      5) call static CodeGenUtil::EnumerableToCaching(Seq<{i8,i8,i8}>):Seq<{i8,i8,i8}>
      1) ret
  Total Size: 57

Func sig: (<ctx>:x, Data:{A:i8, B:i8, C:i8}*) to {A:i8, B:i8, C:i8}*
Sequence: Seq<{i8,i8,i8}>
 0) { A: 9, B: 1, C: 17 }
 1) { A: 8, B: 0, C: 17 }
 2) { A: 7, B: 1, C: 17 }
 3) { A: 6, B: 0, C: 17 }
 4) { A: 5, B: 1, C: 17 }
 5) { A: 4, B: 0, C: 17 }
 6) { A: 3, B: 1, C: 17 }
 7) { A: 2, B: 0, C: 17 }
 8) { A: 1, B: 1, C: 17 }
 9) { A: 0, B: 0, C: 17 }
*** Ctx ping count: 11
    [0](11): Sort(*1: Data, *1.A)
###
> SortDown(Data, A)
SortDown(Data, A) : {A:i8, B:i8, C:i8}*
BndKind:Call, Type:{A:i8, B:i8, C:i8}*, Bnd:(Call(∂.SortDown([map:1] Global(Data), GetField(Scope(1), A))))
// (<ctx>, ∂.Data:{A:i8, B:i8, C:i8}*) : {A:i8, B:i8, C:i8}*
SortDown_1(Arr<obj>, {i8,i8,i8}):i8
      1) ldarg.1 [{i8,i8,i8}]
      5) ldfld {i8,i8,i8}::_F0:i8
      1) ret
  Total Size: 7

top(Arr<obj>, Arr<obj>):obj
      1) ldarg.1 [Arr<obj>]
      1) ldc.i4.0
      1) ldelem.ref
      5) call static CodeGenUtil::ToRef(obj):ExecCtx
      1) stloc.0 [ExecCtx]
      1) ldarg.1 [Arr<obj>]
      1) ldc.i4.1
      1) ldelem.ref
      5) call static CodeGenUtil::ToRef(obj):Seq<{i8,i8,i8}>
      1) stloc.1 [Seq<{i8,i8,i8}>]
      1) ldloc.1 [Seq<{i8,i8,i8}>]
      1) dup
      1) ldloc.0 [ExecCtx]
      1) ldc.i4.0
      5) call static CodeGenUtil::EnumerableToPinging(Seq<{i8,i8,i8}>, ExecCtx, i4):Seq<{i8,i8,i8}>
      1) ldarg.0 [Arr<obj>]
      1) ldc.i4.0
      5) ldelem [Func<{i8,i8,i8},i8>]
      1) ldarg.0 [Arr<obj>]
      1) ldc.i4.1
      5) ldelem [Func<i8,i8,i4>]
      5) call static CodeGenUtil::Sort(Seq<{i8,i8,i8}>, Func<{i8,i8,i8},i8>, Func<i8,i8,i4>):Seq<{i8,i8,i8}>
      5) call static CodeGenUtil::WrapWithCounter(Seq<{i8,i8,i8}>, Seq<{i8,i8,i8}>):Seq<{i8,i8,i8}>
      5) call static CodeGenUtil::EnumerableToCaching(Seq<{i8,i8,i8}>):Seq<{i8,i8,i8}>
      1) ret
  Total Size: 57

Func sig: (<ctx>:x, Data:{A:i8, B:i8, C:i8}*) to {A:i8, B:i8, C:i8}*
Sequence: Seq<{i8,i8,i8}>
 0) { A: 9, B: 1, C: 17 }
 1) { A: 8, B: 0, C: 17 }
 2) { A: 7, B: 1, C: 17 }
 3) { A: 6, B: 0, C: 17 }
 4) { A: 5, B: 1, C: 17 }
 5) { A: 4, B: 0, C: 17 }
 6) { A: 3, B: 1, C: 17 }
 7) { A: 2, B: 0, C: 17 }
 8) { A: 1, B: 1, C: 17 }
 9) { A: 0, B: 0, C: 17 }
*** Ctx ping count: 11
    [0](11): SortDown(*1: Data, *1.A)
###
> SortUp(Data, [>] A)
SortUp(Data, [>] A) : {A:i8, B:i8, C:i8}*
BndKind:Call, Type:{A:i8, B:i8, C:i8}*, Bnd:(Call(∂.SortUp([map:1] Global(Data), [>] GetField(Scope(1), A))))
// (<ctx>, ∂.Data:{A:i8, B:i8, C:i8}*) : {A:i8, B:i8, C:i8}*
SortUp_1(Arr<obj>, {i8,i8,i8}):i8
      1) ldarg.1 [{i8,i8,i8}]
      5) ldfld {i8,i8,i8}::_F0:i8
      1) ret
  Total Size: 7

top(Arr<obj>, Arr<obj>):obj
      1) ldarg.1 [Arr<obj>]
      1) ldc.i4.0
      1) ldelem.ref
      5) call static CodeGenUtil::ToRef(obj):ExecCtx
      1) stloc.0 [ExecCtx]
      1) ldarg.1 [Arr<obj>]
      1) ldc.i4.1
      1) ldelem.ref
      5) call static CodeGenUtil::ToRef(obj):Seq<{i8,i8,i8}>
      1) stloc.1 [Seq<{i8,i8,i8}>]
      1) ldloc.1 [Seq<{i8,i8,i8}>]
      1) dup
      1) ldloc.0 [ExecCtx]
      1) ldc.i4.0
      5) call static CodeGenUtil::EnumerableToPinging(Seq<{i8,i8,i8}>, ExecCtx, i4):Seq<{i8,i8,i8}>
      1) ldarg.0 [Arr<obj>]
      1) ldc.i4.0
      5) ldelem [Func<{i8,i8,i8},i8>]
      1) ldarg.0 [Arr<obj>]
      1) ldc.i4.1
      5) ldelem [Func<i8,i8,i4>]
      5) call static CodeGenUtil::Sort(Seq<{i8,i8,i8}>, Func<{i8,i8,i8},i8>, Func<i8,i8,i4>):Seq<{i8,i8,i8}>
      5) call static CodeGenUtil::WrapWithCounter(Seq<{i8,i8,i8}>, Seq<{i8,i8,i8}>):Seq<{i8,i8,i8}>
      5) call static CodeGenUtil::EnumerableToCaching(Seq<{i8,i8,i8}>):Seq<{i8,i8,i8}>
      1) ret
  Total Size: 57

Func sig: (<ctx>:x, Data:{A:i8, B:i8, C:i8}*) to {A:i8, B:i8, C:i8}*
Sequence: Seq<{i8,i8,i8}>
 0) { A: 9, B: 1, C: 17 }
 1) { A: 8, B: 0, C: 17 }
 2) { A: 7, B: 1, C: 17 }
 3) { A: 6, B: 0, C: 17 }
 4) { A: 5, B: 1, C: 17 }
 5) { A: 4, B: 0, C: 17 }
 6) { A: 3, B: 1, C: 17 }
 7) { A: 2, B: 0, C: 17 }
 8) { A: 1, B: 1, C: 17 }
 9) { A: 0, B: 0, C: 17 }
*** Ctx ping count: 11
    [0](11): SortUp(*1: Data, [>] *1.A)
###
> SortDown(Data, [<] A)
SortDown(Data, [<] A) : {A:i8, B:i8, C:i8}*
BndKind:Call, Type:{A:i8, B:i8, C:i8}*, Bnd:(Call(∂.SortDown([map:1] Global(Data), [<] GetField(Scope(1), A))))
// (<ctx>, ∂.Data:{A:i8, B:i8, C:i8}*) : {A:i8, B:i8, C:i8}*
SortDown_1(Arr<obj>, {i8,i8,i8}):i8
      1) ldarg.1 [{i8,i8,i8}]
      5) ldfld {i8,i8,i8}::_F0:i8
      1) ret
  Total Size: 7

top(Arr<obj>, Arr<obj>):obj
      1) ldarg.1 [Arr<obj>]
      1) ldc.i4.0
      1) ldelem.ref
      5) call static CodeGenUtil::ToRef(obj):ExecCtx
      1) stloc.0 [ExecCtx]
      1) ldarg.1 [Arr<obj>]
      1) ldc.i4.1
      1) ldelem.ref
      5) call static CodeGenUtil::ToRef(obj):Seq<{i8,i8,i8}>
      1) stloc.1 [Seq<{i8,i8,i8}>]
      1) ldloc.1 [Seq<{i8,i8,i8}>]
      1) dup
      1) ldloc.0 [ExecCtx]
      1) ldc.i4.0
      5) call static CodeGenUtil::EnumerableToPinging(Seq<{i8,i8,i8}>, ExecCtx, i4):Seq<{i8,i8,i8}>
      1) ldarg.0 [Arr<obj>]
      1) ldc.i4.0
      5) ldelem [Func<{i8,i8,i8},i8>]
      1) ldarg.0 [Arr<obj>]
      1) ldc.i4.1
      5) ldelem [Func<i8,i8,i4>]
      5) call static CodeGenUtil::Sort(Seq<{i8,i8,i8}>, Func<{i8,i8,i8},i8>, Func<i8,i8,i4>):Seq<{i8,i8,i8}>
      5) call static CodeGenUtil::WrapWithCounter(Seq<{i8,i8,i8}>, Seq<{i8,i8,i8}>):Seq<{i8,i8,i8}>
      5) call static CodeGenUtil::EnumerableToCaching(Seq<{i8,i8,i8}>):Seq<{i8,i8,i8}>
      1) ret
  Total Size: 57

Func sig: (<ctx>:x, Data:{A:i8, B:i8, C:i8}*) to {A:i8, B:i8, C:i8}*
Sequence: Seq<{i8,i8,i8}>
 0) { A: 0, B: 0, C: 17 }
 1) { A: 1, B: 1, C: 17 }
 2) { A: 2, B: 0, C: 17 }
 3) { A: 3, B: 1, C: 17 }
 4) { A: 4, B: 0, C: 17 }
 5) { A: 5, B: 1, C: 17 }
 6) { A: 6, B: 0, C: 17 }
 7) { A: 7, B: 1, C: 17 }
 8) { A: 8, B: 0, C: 17 }
 9) { A: 9, B: 1, C: 17 }
*** Ctx ping count: 11
    [0](11): SortDown(*1: Data, [<] *1.A)
###
> Sort(Data, [<] B, [<] A)
Sort(Data, [<] B, [<] A) : {A:i8, B:i8, C:i8}*
BndKind:Call, Type:{A:i8, B:i8, C:i8}*, Bnd:(Call(∂.Sort([map:1] Global(Data), [<] GetField(Scope(1), B), [<] GetField(Scope(1), A))))
// (<ctx>, ∂.Data:{A:i8, B:i8, C:i8}*) : {A:i8, B:i8, C:i8}*
SortCompare(Arr<obj>, {i8,i8,i8}, {i8,i8,i8}):i4
      1) ldarg.1 [{i8,i8,i8}]
      5) ldfld {i8,i8,i8}::_F1:i8
      1) ldarg.2 [{i8,i8,i8}]
      5) ldfld {i8,i8,i8}::_F1:i8
      5) call static Cmp::Compare(i8, i8):i4
      1) dup
      5) brtrue [0]
      1) pop
      1) ldarg.1 [{i8,i8,i8}]
      5) ldfld {i8,i8,i8}::_F0:i8
      1) ldarg.2 [{i8,i8,i8}]
      5) ldfld {i8,i8,i8}::_F0:i8
      5) call static Cmp::Compare(i8, i8):i4
  Label [0]:
      1) ret
  Total Size: 42

top(Arr<obj>, Arr<obj>):obj
      1) ldarg.1 [Arr<obj>]
      1) ldc.i4.0
      1) ldelem.ref
      5) call static CodeGenUtil::ToRef(obj):ExecCtx
      1) stloc.0 [ExecCtx]
      1) ldarg.1 [Arr<obj>]
      1) ldc.i4.1
      1) ldelem.ref
      5) call static CodeGenUtil::ToRef(obj):Seq<{i8,i8,i8}>
      1) stloc.1 [Seq<{i8,i8,i8}>]
      1) ldloc.1 [Seq<{i8,i8,i8}>]
      1) dup
      1) ldloc.0 [ExecCtx]
      1) ldc.i4.0
      5) call static CodeGenUtil::EnumerableToPinging(Seq<{i8,i8,i8}>, ExecCtx, i4):Seq<{i8,i8,i8}>
      1) ldarg.0 [Arr<obj>]
      1) ldc.i4.0
      5) ldelem [Func<{i8,i8,i8},{i8,i8,i8},i4>]
      5) call static CodeGenUtil::SortNoKey(Seq<{i8,i8,i8}>, Func<{i8,i8,i8},{i8,i8,i8},i4>):Seq<{i8,i8,i8}>
      5) call static CodeGenUtil::WrapWithCounter(Seq<{i8,i8,i8}>, Seq<{i8,i8,i8}>):Seq<{i8,i8,i8}>
      5) call static CodeGenUtil::EnumerableToCaching(Seq<{i8,i8,i8}>):Seq<{i8,i8,i8}>
      1) ret
  Total Size: 50

Func sig: (<ctx>:x, Data:{A:i8, B:i8, C:i8}*) to {A:i8, B:i8, C:i8}*
Sequence: Seq<{i8,i8,i8}>
 0) { A: 0, B: 0, C: 17 }
 1) { A: 2, B: 0, C: 17 }
 2) { A: 4, B: 0, C: 17 }
 3) { A: 6, B: 0, C: 17 }
 4) { A: 8, B: 0, C: 17 }
 5) { A: 1, B: 1, C: 17 }
 6) { A: 3, B: 1, C: 17 }
 7) { A: 5, B: 1, C: 17 }
 8) { A: 7, B: 1, C: 17 }
 9) { A: 9, B: 1, C: 17 }
*** Ctx ping count: 11
    [0](11): Sort(*1: Data, [<] *1.B, [<] *1.A)
###
> Sort(Data, [<] B, [>] A)
Sort(Data, [<] B, [>] A) : {A:i8, B:i8, C:i8}*
BndKind:Call, Type:{A:i8, B:i8, C:i8}*, Bnd:(Call(∂.Sort([map:1] Global(Data), [<] GetField(Scope(1), B), [>] GetField(Scope(1), A))))
// (<ctx>, ∂.Data:{A:i8, B:i8, C:i8}*) : {A:i8, B:i8, C:i8}*
SortCompare(Arr<obj>, {i8,i8,i8}, {i8,i8,i8}):i4
      1) ldarg.1 [{i8,i8,i8}]
      5) ldfld {i8,i8,i8}::_F1:i8
      1) ldarg.2 [{i8,i8,i8}]
      5) ldfld {i8,i8,i8}::_F1:i8
      5) call static Cmp::Compare(i8, i8):i4
      1) dup
      5) brtrue [0]
      1) pop
      1) ldarg.2 [{i8,i8,i8}]
      5) ldfld {i8,i8,i8}::_F0:i8
      1) ldarg.1 [{i8,i8,i8}]
      5) ldfld {i8,i8,i8}::_F0:i8
      5) call static Cmp::Compare(i8, i8):i4
  Label [0]:
      1) ret
  Total Size: 42

top(Arr<obj>, Arr<obj>):obj
      1) ldarg.1 [Arr<obj>]
      1) ldc.i4.0
      1) ldelem.ref
      5) call static CodeGenUtil::ToRef(obj):ExecCtx
      1) stloc.0 [ExecCtx]
      1) ldarg.1 [Arr<obj>]
      1) ldc.i4.1
      1) ldelem.ref
      5) call static CodeGenUtil::ToRef(obj):Seq<{i8,i8,i8}>
      1) stloc.1 [Seq<{i8,i8,i8}>]
      1) ldloc.1 [Seq<{i8,i8,i8}>]
      1) dup
      1) ldloc.0 [ExecCtx]
      1) ldc.i4.0
      5) call static CodeGenUtil::EnumerableToPinging(Seq<{i8,i8,i8}>, ExecCtx, i4):Seq<{i8,i8,i8}>
      1) ldarg.0 [Arr<obj>]
      1) ldc.i4.0
      5) ldelem [Func<{i8,i8,i8},{i8,i8,i8},i4>]
      5) call static CodeGenUtil::SortNoKey(Seq<{i8,i8,i8}>, Func<{i8,i8,i8},{i8,i8,i8},i4>):Seq<{i8,i8,i8}>
      5) call static CodeGenUtil::WrapWithCounter(Seq<{i8,i8,i8}>, Seq<{i8,i8,i8}>):Seq<{i8,i8,i8}>
      5) call static CodeGenUtil::EnumerableToCaching(Seq<{i8,i8,i8}>):Seq<{i8,i8,i8}>
      1) ret
  Total Size: 50

Func sig: (<ctx>:x, Data:{A:i8, B:i8, C:i8}*) to {A:i8, B:i8, C:i8}*
Sequence: Seq<{i8,i8,i8}>
 0) { A: 8, B: 0, C: 17 }
 1) { A: 6, B: 0, C: 17 }
 2) { A: 4, B: 0, C: 17 }
 3) { A: 2, B: 0, C: 17 }
 4) { A: 0, B: 0, C: 17 }
 5) { A: 9, B: 1, C: 17 }
 6) { A: 7, B: 1, C: 17 }
 7) { A: 5, B: 1, C: 17 }
 8) { A: 3, B: 1, C: 17 }
 9) { A: 1, B: 1, C: 17 }
*** Ctx ping count: 11
    [0](11): Sort(*1: Data, [<] *1.B, [>] *1.A)
###
> Sort(Data, [>] B, [<] A)
Sort(Data, [>] B, [<] A) : {A:i8, B:i8, C:i8}*
BndKind:Call, Type:{A:i8, B:i8, C:i8}*, Bnd:(Call(∂.Sort([map:1] Global(Data), [>] GetField(Scope(1), B), [<] GetField(Scope(1), A))))
// (<ctx>, ∂.Data:{A:i8, B:i8, C:i8}*) : {A:i8, B:i8, C:i8}*
SortCompare(Arr<obj>, {i8,i8,i8}, {i8,i8,i8}):i4
      1) ldarg.2 [{i8,i8,i8}]
      5) ldfld {i8,i8,i8}::_F1:i8
      1) ldarg.1 [{i8,i8,i8}]
      5) ldfld {i8,i8,i8}::_F1:i8
      5) call static Cmp::Compare(i8, i8):i4
      1) dup
      5) brtrue [0]
      1) pop
      1) ldarg.1 [{i8,i8,i8}]
      5) ldfld {i8,i8,i8}::_F0:i8
      1) ldarg.2 [{i8,i8,i8}]
      5) ldfld {i8,i8,i8}::_F0:i8
      5) call static Cmp::Compare(i8, i8):i4
  Label [0]:
      1) ret
  Total Size: 42

top(Arr<obj>, Arr<obj>):obj
      1) ldarg.1 [Arr<obj>]
      1) ldc.i4.0
      1) ldelem.ref
      5) call static CodeGenUtil::ToRef(obj):ExecCtx
      1) stloc.0 [ExecCtx]
      1) ldarg.1 [Arr<obj>]
      1) ldc.i4.1
      1) ldelem.ref
      5) call static CodeGenUtil::ToRef(obj):Seq<{i8,i8,i8}>
      1) stloc.1 [Seq<{i8,i8,i8}>]
      1) ldloc.1 [Seq<{i8,i8,i8}>]
      1) dup
      1) ldloc.0 [ExecCtx]
      1) ldc.i4.0
      5) call static CodeGenUtil::EnumerableToPinging(Seq<{i8,i8,i8}>, ExecCtx, i4):Seq<{i8,i8,i8}>
      1) ldarg.0 [Arr<obj>]
      1) ldc.i4.0
      5) ldelem [Func<{i8,i8,i8},{i8,i8,i8},i4>]
      5) call static CodeGenUtil::SortNoKey(Seq<{i8,i8,i8}>, Func<{i8,i8,i8},{i8,i8,i8},i4>):Seq<{i8,i8,i8}>
      5) call static CodeGenUtil::WrapWithCounter(Seq<{i8,i8,i8}>, Seq<{i8,i8,i8}>):Seq<{i8,i8,i8}>
      5) call static CodeGenUtil::EnumerableToCaching(Seq<{i8,i8,i8}>):Seq<{i8,i8,i8}>
      1) ret
  Total Size: 50

Func sig: (<ctx>:x, Data:{A:i8, B:i8, C:i8}*) to {A:i8, B:i8, C:i8}*
Sequence: Seq<{i8,i8,i8}>
 0) { A: 1, B: 1, C: 17 }
 1) { A: 3, B: 1, C: 17 }
 2) { A: 5, B: 1, C: 17 }
 3) { A: 7, B: 1, C: 17 }
 4) { A: 9, B: 1, C: 17 }
 5) { A: 0, B: 0, C: 17 }
 6) { A: 2, B: 0, C: 17 }
 7) { A: 4, B: 0, C: 17 }
 8) { A: 6, B: 0, C: 17 }
 9) { A: 8, B: 0, C: 17 }
*** Ctx ping count: 11
    [0](11): Sort(*1: Data, [>] *1.B, [<] *1.A)
###
> Sort(Data, [>] B, [>] A)
Sort(Data, [>] B, [>] A) : {A:i8, B:i8, C:i8}*
BndKind:Call, Type:{A:i8, B:i8, C:i8}*, Bnd:(Call(∂.Sort([map:1] Global(Data), [>] GetField(Scope(1), B), [>] GetField(Scope(1), A))))
// (<ctx>, ∂.Data:{A:i8, B:i8, C:i8}*) : {A:i8, B:i8, C:i8}*
SortCompare(Arr<obj>, {i8,i8,i8}, {i8,i8,i8}):i4
      1) ldarg.2 [{i8,i8,i8}]
      5) ldfld {i8,i8,i8}::_F1:i8
      1) ldarg.1 [{i8,i8,i8}]
      5) ldfld {i8,i8,i8}::_F1:i8
      5) call static Cmp::Compare(i8, i8):i4
      1) dup
      5) brtrue [0]
      1) pop
      1) ldarg.2 [{i8,i8,i8}]
      5) ldfld {i8,i8,i8}::_F0:i8
      1) ldarg.1 [{i8,i8,i8}]
      5) ldfld {i8,i8,i8}::_F0:i8
      5) call static Cmp::Compare(i8, i8):i4
  Label [0]:
      1) ret
  Total Size: 42

top(Arr<obj>, Arr<obj>):obj
      1) ldarg.1 [Arr<obj>]
      1) ldc.i4.0
      1) ldelem.ref
      5) call static CodeGenUtil::ToRef(obj):ExecCtx
      1) stloc.0 [ExecCtx]
      1) ldarg.1 [Arr<obj>]
      1) ldc.i4.1
      1) ldelem.ref
      5) call static CodeGenUtil::ToRef(obj):Seq<{i8,i8,i8}>
      1) stloc.1 [Seq<{i8,i8,i8}>]
      1) ldloc.1 [Seq<{i8,i8,i8}>]
      1) dup
      1) ldloc.0 [ExecCtx]
      1) ldc.i4.0
      5) call static CodeGenUtil::EnumerableToPinging(Seq<{i8,i8,i8}>, ExecCtx, i4):Seq<{i8,i8,i8}>
      1) ldarg.0 [Arr<obj>]
      1) ldc.i4.0
      5) ldelem [Func<{i8,i8,i8},{i8,i8,i8},i4>]
      5) call static CodeGenUtil::SortNoKey(Seq<{i8,i8,i8}>, Func<{i8,i8,i8},{i8,i8,i8},i4>):Seq<{i8,i8,i8}>
      5) call static CodeGenUtil::WrapWithCounter(Seq<{i8,i8,i8}>, Seq<{i8,i8,i8}>):Seq<{i8,i8,i8}>
      5) call static CodeGenUtil::EnumerableToCaching(Seq<{i8,i8,i8}>):Seq<{i8,i8,i8}>
      1) ret
  Total Size: 50

Func sig: (<ctx>:x, Data:{A:i8, B:i8, C:i8}*) to {A:i8, B:i8, C:i8}*
Sequence: Seq<{i8,i8,i8}>
 0) { A: 9, B: 1, C: 17 }
 1) { A: 7, B: 1, C: 17 }
 2) { A: 5, B: 1, C: 17 }
 3) { A: 3, B: 1, C: 17 }
 4) { A: 1, B: 1, C: 17 }
 5) { A: 8, B: 0, C: 17 }
 6) { A: 6, B: 0, C: 17 }
 7) { A: 4, B: 0, C: 17 }
 8) { A: 2, B: 0, C: 17 }
 9) { A: 0, B: 0, C: 17 }
*** Ctx ping count: 11
    [0](11): Sort(*1: Data, [>] *1.B, [>] *1.A)
###
> Sort(DataInd, [<] # + it[0].A + it[0].B)
Sort(DataInd, [<] # + it[0].A + it[0].B) : ({A:i8, B:i8}, i8)*
BndKind:Call, Type:({A:i8, B:i8}, i8)*, Bnd:(Call(∂.Sort([map:2] Global(DataInd), [<] Add(Scope(1), GetField(GetSlot(Scope(2), 0), A), GetField(GetSlot(Scope(2), 0), B))):({A:i8, B:i8}, i8)*))
// (<ctx>, ∂.DataInd:({A:i8, B:i8}, i8)*) : ({A:i8, B:i8}, i8)*
Sort_1(Arr<obj>, ({i8,i8},i8), i8):i8
      1) ldarg.2 [i8]
      1) ldarg.1 [({i8,i8},i8)]
      5) ldfld ({i8,i8},i8)::_F0:{i8,i8}
      5) ldfld {i8,i8}::_F0:i8
      1) add
      1) ldarg.1 [({i8,i8},i8)]
      5) ldfld ({i8,i8},i8)::_F0:{i8,i8}
      5) ldfld {i8,i8}::_F1:i8
      1) add
      1) ret
  Total Size: 26

top(Arr<obj>, Arr<obj>):obj
      1) ldarg.1 [Arr<obj>]
      1) ldc.i4.0
      1) ldelem.ref
      5) call static CodeGenUtil::ToRef(obj):ExecCtx
      1) stloc.0 [ExecCtx]
      1) ldarg.1 [Arr<obj>]
      1) ldc.i4.1
      1) ldelem.ref
      5) call static CodeGenUtil::ToRef(obj):Seq<({i8,i8},i8)>
      1) stloc.1 [Seq<({i8,i8},i8)>]
      1) ldloc.1 [Seq<({i8,i8},i8)>]
      1) dup
      1) ldloc.0 [ExecCtx]
      1) ldc.i4.0
      5) call static CodeGenUtil::EnumerableToPinging(Seq<({i8,i8},i8)>, ExecCtx, i4):Seq<({i8,i8},i8)>
      1) ldarg.0 [Arr<obj>]
      1) ldc.i4.0
      5) ldelem [Func<({i8,i8},i8),i8,i8>]
      1) ldarg.0 [Arr<obj>]
      1) ldc.i4.1
      5) ldelem [Func<i8,i8,i4>]
      5) call static CodeGenUtil::IndSort(Seq<({i8,i8},i8)>, Func<({i8,i8},i8),i8,i8>, Func<i8,i8,i4>):Seq<({i8,i8},i8)>
      5) call static CodeGenUtil::WrapWithCounter(Seq<({i8,i8},i8)>, Seq<({i8,i8},i8)>):Seq<({i8,i8},i8)>
      5) call static CodeGenUtil::EnumerableToCaching(Seq<({i8,i8},i8)>):Seq<({i8,i8},i8)>
      1) ret
  Total Size: 57

Func sig: (<ctx>:x, DataInd:({A:i8, B:i8}, i8)*) to ({A:i8, B:i8}, i8)*
Sequence: Seq<({i8,i8},i8)>
 0) ({ A: 1, B: 1 }, 4)
 1) ({ A: 3, B: 1 }, 3)
 2) ({ A: 5, B: 1 }, 2)
 3) ({ A: 7, B: 1 }, 1)
 4) ({ A: 0, B: 0 }, 9)
 5) ({ A: 9, B: 1 }, 0)
 6) ({ A: 2, B: 0 }, 8)
 7) ({ A: 4, B: 0 }, 7)
 8) ({ A: 6, B: 0 }, 6)
 9) ({ A: 8, B: 0 }, 5)
*** Ctx ping count: 11
    [0](11): Sort(*2: DataInd, [<] Add(#1, *2.0.A, *2.0.B))
###
> Sort(DataInd, [<] # + it[0].A + it[0].B, [>] #)
Sort(DataInd, [<] # + it[0].A + it[0].B, [>] #) : ({A:i8, B:i8}, i8)*
BndKind:Call, Type:({A:i8, B:i8}, i8)*, Bnd:(Call(∂.Sort([map:2] Global(DataInd), [<] Add(Scope(1), GetField(GetSlot(Scope(2), 0), A), GetField(GetSlot(Scope(2), 0), B)), [>] Scope(1)):({A:i8, B:i8}, i8)*))
// (<ctx>, ∂.DataInd:({A:i8, B:i8}, i8)*) : ({A:i8, B:i8}, i8)*
SortCompare(Arr<obj>, ({i8,i8},i8), i8, ({i8,i8},i8), i8):i4
      1) ldarg.2 [i8]
      1) ldarg.1 [({i8,i8},i8)]
      5) ldfld ({i8,i8},i8)::_F0:{i8,i8}
      5) ldfld {i8,i8}::_F0:i8
      1) add
      1) ldarg.1 [({i8,i8},i8)]
      5) ldfld ({i8,i8},i8)::_F0:{i8,i8}
      5) ldfld {i8,i8}::_F1:i8
      1) add
      2) ldarg.s [i8 (4)]
      1) ldarg.3 [({i8,i8},i8)]
      5) ldfld ({i8,i8},i8)::_F0:{i8,i8}
      5) ldfld {i8,i8}::_F0:i8
      1) add
      1) ldarg.3 [({i8,i8},i8)]
      5) ldfld ({i8,i8},i8)::_F0:{i8,i8}
      5) ldfld {i8,i8}::_F1:i8
      1) add
      5) call static Cmp::Compare(i8, i8):i4
      1) dup
      5) brtrue [0]
      1) pop
      2) ldarg.s [i8 (4)]
      1) ldarg.2 [i8]
      5) call static Cmp::Compare(i8, i8):i4
  Label [0]:
      1) ret
  Total Size: 72

top(Arr<obj>, Arr<obj>):obj
      1) ldarg.1 [Arr<obj>]
      1) ldc.i4.0
      1) ldelem.ref
      5) call static CodeGenUtil::ToRef(obj):ExecCtx
      1) stloc.0 [ExecCtx]
      1) ldarg.1 [Arr<obj>]
      1) ldc.i4.1
      1) ldelem.ref
      5) call static CodeGenUtil::ToRef(obj):Seq<({i8,i8},i8)>
      1) stloc.1 [Seq<({i8,i8},i8)>]
      1) ldloc.1 [Seq<({i8,i8},i8)>]
      1) dup
      1) ldloc.0 [ExecCtx]
      1) ldc.i4.0
      5) call static CodeGenUtil::EnumerableToPinging(Seq<({i8,i8},i8)>, ExecCtx, i4):Seq<({i8,i8},i8)>
      1) ldarg.0 [Arr<obj>]
      1) ldc.i4.0
      5) ldelem [Func<({i8,i8},i8),i8,({i8,i8},i8),i8,i4>]
      5) call static CodeGenUtil::IndSortNoKey(Seq<({i8,i8},i8)>, Func<({i8,i8},i8),i8,({i8,i8},i8),i8,i4>):Seq<({i8,i8},i8)>
      5) call static CodeGenUtil::WrapWithCounter(Seq<({i8,i8},i8)>, Seq<({i8,i8},i8)>):Seq<({i8,i8},i8)>
      5) call static CodeGenUtil::EnumerableToCaching(Seq<({i8,i8},i8)>):Seq<({i8,i8},i8)>
      1) ret
  Total Size: 50

Func sig: (<ctx>:x, DataInd:({A:i8, B:i8}, i8)*) to ({A:i8, B:i8}, i8)*
Sequence: Seq<({i8,i8},i8)>
 0) ({ A: 1, B: 1 }, 4)
 1) ({ A: 3, B: 1 }, 3)
 2) ({ A: 5, B: 1 }, 2)
 3) ({ A: 0, B: 0 }, 9)
 4) ({ A: 7, B: 1 }, 1)
 5) ({ A: 2, B: 0 }, 8)
 6) ({ A: 9, B: 1 }, 0)
 7) ({ A: 4, B: 0 }, 7)
 8) ({ A: 6, B: 0 }, 6)
 9) ({ A: 8, B: 0 }, 5)
*** Ctx ping count: 11
    [0](11): Sort(*2: DataInd, [<] Add(#1, *2.0.A, *2.0.B), [>] #1)
###
> Sort(DataInd, [>] # + it[0].A + it[0].B)
Sort(DataInd, [>] # + it[0].A + it[0].B) : ({A:i8, B:i8}, i8)*
BndKind:Call, Type:({A:i8, B:i8}, i8)*, Bnd:(Call(∂.Sort([map:2] Global(DataInd), [>] Add(Scope(1), GetField(GetSlot(Scope(2), 0), A), GetField(GetSlot(Scope(2), 0), B))):({A:i8, B:i8}, i8)*))
// (<ctx>, ∂.DataInd:({A:i8, B:i8}, i8)*) : ({A:i8, B:i8}, i8)*
Sort_1(Arr<obj>, ({i8,i8},i8), i8):i8
      1) ldarg.2 [i8]
      1) ldarg.1 [({i8,i8},i8)]
      5) ldfld ({i8,i8},i8)::_F0:{i8,i8}
      5) ldfld {i8,i8}::_F0:i8
      1) add
      1) ldarg.1 [({i8,i8},i8)]
      5) ldfld ({i8,i8},i8)::_F0:{i8,i8}
      5) ldfld {i8,i8}::_F1:i8
      1) add
      1) ret
  Total Size: 26

top(Arr<obj>, Arr<obj>):obj
      1) ldarg.1 [Arr<obj>]
      1) ldc.i4.0
      1) ldelem.ref
      5) call static CodeGenUtil::ToRef(obj):ExecCtx
      1) stloc.0 [ExecCtx]
      1) ldarg.1 [Arr<obj>]
      1) ldc.i4.1
      1) ldelem.ref
      5) call static CodeGenUtil::ToRef(obj):Seq<({i8,i8},i8)>
      1) stloc.1 [Seq<({i8,i8},i8)>]
      1) ldloc.1 [Seq<({i8,i8},i8)>]
      1) dup
      1) ldloc.0 [ExecCtx]
      1) ldc.i4.0
      5) call static CodeGenUtil::EnumerableToPinging(Seq<({i8,i8},i8)>, ExecCtx, i4):Seq<({i8,i8},i8)>
      1) ldarg.0 [Arr<obj>]
      1) ldc.i4.0
      5) ldelem [Func<({i8,i8},i8),i8,i8>]
      1) ldarg.0 [Arr<obj>]
      1) ldc.i4.1
      5) ldelem [Func<i8,i8,i4>]
      5) call static CodeGenUtil::IndSort(Seq<({i8,i8},i8)>, Func<({i8,i8},i8),i8,i8>, Func<i8,i8,i4>):Seq<({i8,i8},i8)>
      5) call static CodeGenUtil::WrapWithCounter(Seq<({i8,i8},i8)>, Seq<({i8,i8},i8)>):Seq<({i8,i8},i8)>
      5) call static CodeGenUtil::EnumerableToCaching(Seq<({i8,i8},i8)>):Seq<({i8,i8},i8)>
      1) ret
  Total Size: 57

Func sig: (<ctx>:x, DataInd:({A:i8, B:i8}, i8)*) to ({A:i8, B:i8}, i8)*
Sequence: Seq<({i8,i8},i8)>
 0) ({ A: 8, B: 0 }, 5)
 1) ({ A: 6, B: 0 }, 6)
 2) ({ A: 4, B: 0 }, 7)
 3) ({ A: 9, B: 1 }, 0)
 4) ({ A: 2, B: 0 }, 8)
 5) ({ A: 7, B: 1 }, 1)
 6) ({ A: 0, B: 0 }, 9)
 7) ({ A: 5, B: 1 }, 2)
 8) ({ A: 3, B: 1 }, 3)
 9) ({ A: 1, B: 1 }, 4)
*** Ctx ping count: 11
    [0](11): Sort(*2: DataInd, [>] Add(#1, *2.0.A, *2.0.B))
###
> Sort(DataInd, [>] # + it[0].A + it[0].B, [<] #)
Sort(DataInd, [>] # + it[0].A + it[0].B, [<] #) : ({A:i8, B:i8}, i8)*
BndKind:Call, Type:({A:i8, B:i8}, i8)*, Bnd:(Call(∂.Sort([map:2] Global(DataInd), [>] Add(Scope(1), GetField(GetSlot(Scope(2), 0), A), GetField(GetSlot(Scope(2), 0), B)), [<] Scope(1)):({A:i8, B:i8}, i8)*))
// (<ctx>, ∂.DataInd:({A:i8, B:i8}, i8)*) : ({A:i8, B:i8}, i8)*
SortCompare(Arr<obj>, ({i8,i8},i8), i8, ({i8,i8},i8), i8):i4
      2) ldarg.s [i8 (4)]
      1) ldarg.3 [({i8,i8},i8)]
      5) ldfld ({i8,i8},i8)::_F0:{i8,i8}
      5) ldfld {i8,i8}::_F0:i8
      1) add
      1) ldarg.3 [({i8,i8},i8)]
      5) ldfld ({i8,i8},i8)::_F0:{i8,i8}
      5) ldfld {i8,i8}::_F1:i8
      1) add
      1) ldarg.2 [i8]
      1) ldarg.1 [({i8,i8},i8)]
      5) ldfld ({i8,i8},i8)::_F0:{i8,i8}
      5) ldfld {i8,i8}::_F0:i8
      1) add
      1) ldarg.1 [({i8,i8},i8)]
      5) ldfld ({i8,i8},i8)::_F0:{i8,i8}
      5) ldfld {i8,i8}::_F1:i8
      1) add
      5) call static Cmp::Compare(i8, i8):i4
      1) dup
      5) brtrue [0]
      1) pop
      1) ldarg.2 [i8]
      2) ldarg.s [i8 (4)]
      5) call static Cmp::Compare(i8, i8):i4
  Label [0]:
      1) ret
  Total Size: 72

top(Arr<obj>, Arr<obj>):obj
      1) ldarg.1 [Arr<obj>]
      1) ldc.i4.0
      1) ldelem.ref
      5) call static CodeGenUtil::ToRef(obj):ExecCtx
      1) stloc.0 [ExecCtx]
      1) ldarg.1 [Arr<obj>]
      1) ldc.i4.1
      1) ldelem.ref
      5) call static CodeGenUtil::ToRef(obj):Seq<({i8,i8},i8)>
      1) stloc.1 [Seq<({i8,i8},i8)>]
      1) ldloc.1 [Seq<({i8,i8},i8)>]
      1) dup
      1) ldloc.0 [ExecCtx]
      1) ldc.i4.0
      5) call static CodeGenUtil::EnumerableToPinging(Seq<({i8,i8},i8)>, ExecCtx, i4):Seq<({i8,i8},i8)>
      1) ldarg.0 [Arr<obj>]
      1) ldc.i4.0
      5) ldelem [Func<({i8,i8},i8),i8,({i8,i8},i8),i8,i4>]
      5) call static CodeGenUtil::IndSortNoKey(Seq<({i8,i8},i8)>, Func<({i8,i8},i8),i8,({i8,i8},i8),i8,i4>):Seq<({i8,i8},i8)>
      5) call static CodeGenUtil::WrapWithCounter(Seq<({i8,i8},i8)>, Seq<({i8,i8},i8)>):Seq<({i8,i8},i8)>
      5) call static CodeGenUtil::EnumerableToCaching(Seq<({i8,i8},i8)>):Seq<({i8,i8},i8)>
      1) ret
  Total Size: 50

Func sig: (<ctx>:x, DataInd:({A:i8, B:i8}, i8)*) to ({A:i8, B:i8}, i8)*
Sequence: Seq<({i8,i8},i8)>
 0) ({ A: 8, B: 0 }, 5)
 1) ({ A: 6, B: 0 }, 6)
 2) ({ A: 4, B: 0 }, 7)
 3) ({ A: 9, B: 1 }, 0)
 4) ({ A: 2, B: 0 }, 8)
 5) ({ A: 7, B: 1 }, 1)
 6) ({ A: 0, B: 0 }, 9)
 7) ({ A: 5, B: 1 }, 2)
 8) ({ A: 3, B: 1 }, 3)
 9) ({ A: 1, B: 1 }, 4)
*** Ctx ping count: 11
    [0](11): Sort(*2: DataInd, [>] Add(#1, *2.0.A, *2.0.B), [<] #1)
###
> SortUp(Data, B, B + 1, A)
SortUp(Data, B, B + 1, A) : {A:i8, B:i8, C:i8}*
BndKind:Call, Type:{A:i8, B:i8, C:i8}*, Bnd:(Call(∂.SortUp([map:1] Global(Data), GetField(Scope(1), B), Add(GetField(Scope(1), B), 1:i8), GetField(Scope(1), A))))
// (<ctx>, ∂.Data:{A:i8, B:i8, C:i8}*) : {A:i8, B:i8, C:i8}*
SortUpCompare(Arr<obj>, {i8,i8,i8}, {i8,i8,i8}):i4
      1) ldarg.1 [{i8,i8,i8}]
      5) ldfld {i8,i8,i8}::_F1:i8
      1) ldarg.2 [{i8,i8,i8}]
      5) ldfld {i8,i8,i8}::_F1:i8
      5) call static Cmp::Compare(i8, i8):i4
      1) dup
      5) brtrue [0]
      1) pop
      1) ldarg.1 [{i8,i8,i8}]
      5) ldfld {i8,i8,i8}::_F1:i8
      1) ldc.i4.1
      1) conv.i8
      1) add
      1) ldarg.2 [{i8,i8,i8}]
      5) ldfld {i8,i8,i8}::_F1:i8
      1) ldc.i4.1
      1) conv.i8
      1) add
      5) call static Cmp::Compare(i8, i8):i4
      1) dup
      5) brtrue [0]
      1) pop
      1) ldarg.1 [{i8,i8,i8}]
      5) ldfld {i8,i8,i8}::_F0:i8
      1) ldarg.2 [{i8,i8,i8}]
      5) ldfld {i8,i8,i8}::_F0:i8
      5) call static Cmp::Compare(i8, i8):i4
  Label [0]:
      1) ret
  Total Size: 72

top(Arr<obj>, Arr<obj>):obj
      1) ldarg.1 [Arr<obj>]
      1) ldc.i4.0
      1) ldelem.ref
      5) call static CodeGenUtil::ToRef(obj):ExecCtx
      1) stloc.0 [ExecCtx]
      1) ldarg.1 [Arr<obj>]
      1) ldc.i4.1
      1) ldelem.ref
      5) call static CodeGenUtil::ToRef(obj):Seq<{i8,i8,i8}>
      1) stloc.1 [Seq<{i8,i8,i8}>]
      1) ldloc.1 [Seq<{i8,i8,i8}>]
      1) dup
      1) ldloc.0 [ExecCtx]
      1) ldc.i4.0
      5) call static CodeGenUtil::EnumerableToPinging(Seq<{i8,i8,i8}>, ExecCtx, i4):Seq<{i8,i8,i8}>
      1) ldarg.0 [Arr<obj>]
      1) ldc.i4.0
      5) ldelem [Func<{i8,i8,i8},{i8,i8,i8},i4>]
      5) call static CodeGenUtil::SortNoKey(Seq<{i8,i8,i8}>, Func<{i8,i8,i8},{i8,i8,i8},i4>):Seq<{i8,i8,i8}>
      5) call static CodeGenUtil::WrapWithCounter(Seq<{i8,i8,i8}>, Seq<{i8,i8,i8}>):Seq<{i8,i8,i8}>
      5) call static CodeGenUtil::EnumerableToCaching(Seq<{i8,i8,i8}>):Seq<{i8,i8,i8}>
      1) ret
  Total Size: 50

Func sig: (<ctx>:x, Data:{A:i8, B:i8, C:i8}*) to {A:i8, B:i8, C:i8}*
Sequence: Seq<{i8,i8,i8}>
 0) { A: 0, B: 0, C: 17 }
 1) { A: 2, B: 0, C: 17 }
 2) { A: 4, B: 0, C: 17 }
 3) { A: 6, B: 0, C: 17 }
 4) { A: 8, B: 0, C: 17 }
 5) { A: 1, B: 1, C: 17 }
 6) { A: 3, B: 1, C: 17 }
 7) { A: 5, B: 1, C: 17 }
 8) { A: 7, B: 1, C: 17 }
 9) { A: 9, B: 1, C: 17 }
*** Ctx ping count: 11
    [0](11): SortUp(*1: Data, *1.B, Add(*1.B, 1), *1.A)
###
> SortUp(Data, C, B, A)
SortUp(Data, C, B, A) : {A:i8, B:i8, C:i8}*
BndKind:Call, Type:{A:i8, B:i8, C:i8}*, Bnd:(Call(∂.SortUp([map:1] Global(Data), GetField(Scope(1), C), GetField(Scope(1), B), GetField(Scope(1), A))))
// (<ctx>, ∂.Data:{A:i8, B:i8, C:i8}*) : {A:i8, B:i8, C:i8}*
SortUpCompare(Arr<obj>, {i8,i8,i8}, {i8,i8,i8}):i4
      1) ldarg.1 [{i8,i8,i8}]
      5) ldfld {i8,i8,i8}::_F2:i8
      1) ldarg.2 [{i8,i8,i8}]
      5) ldfld {i8,i8,i8}::_F2:i8
      5) call static Cmp::Compare(i8, i8):i4
      1) dup
      5) brtrue [0]
      1) pop
      1) ldarg.1 [{i8,i8,i8}]
      5) ldfld {i8,i8,i8}::_F1:i8
      1) ldarg.2 [{i8,i8,i8}]
      5) ldfld {i8,i8,i8}::_F1:i8
      5) call static Cmp::Compare(i8, i8):i4
      1) dup
      5) brtrue [0]
      1) pop
      1) ldarg.1 [{i8,i8,i8}]
      5) ldfld {i8,i8,i8}::_F0:i8
      1) ldarg.2 [{i8,i8,i8}]
      5) ldfld {i8,i8,i8}::_F0:i8
      5) call static Cmp::Compare(i8, i8):i4
  Label [0]:
      1) ret
  Total Size: 66

top(Arr<obj>, Arr<obj>):obj
      1) ldarg.1 [Arr<obj>]
      1) ldc.i4.0
      1) ldelem.ref
      5) call static CodeGenUtil::ToRef(obj):ExecCtx
      1) stloc.0 [ExecCtx]
      1) ldarg.1 [Arr<obj>]
      1) ldc.i4.1
      1) ldelem.ref
      5) call static CodeGenUtil::ToRef(obj):Seq<{i8,i8,i8}>
      1) stloc.1 [Seq<{i8,i8,i8}>]
      1) ldloc.1 [Seq<{i8,i8,i8}>]
      1) dup
      1) ldloc.0 [ExecCtx]
      1) ldc.i4.0
      5) call static CodeGenUtil::EnumerableToPinging(Seq<{i8,i8,i8}>, ExecCtx, i4):Seq<{i8,i8,i8}>
      1) ldarg.0 [Arr<obj>]
      1) ldc.i4.0
      5) ldelem [Func<{i8,i8,i8},{i8,i8,i8},i4>]
      5) call static CodeGenUtil::SortNoKey(Seq<{i8,i8,i8}>, Func<{i8,i8,i8},{i8,i8,i8},i4>):Seq<{i8,i8,i8}>
      5) call static CodeGenUtil::WrapWithCounter(Seq<{i8,i8,i8}>, Seq<{i8,i8,i8}>):Seq<{i8,i8,i8}>
      5) call static CodeGenUtil::EnumerableToCaching(Seq<{i8,i8,i8}>):Seq<{i8,i8,i8}>
      1) ret
  Total Size: 50

Func sig: (<ctx>:x, Data:{A:i8, B:i8, C:i8}*) to {A:i8, B:i8, C:i8}*
Sequence: Seq<{i8,i8,i8}>
 0) { A: 0, B: 0, C: 17 }
 1) { A: 2, B: 0, C: 17 }
 2) { A: 4, B: 0, C: 17 }
 3) { A: 6, B: 0, C: 17 }
 4) { A: 8, B: 0, C: 17 }
 5) { A: 1, B: 1, C: 17 }
 6) { A: 3, B: 1, C: 17 }
 7) { A: 5, B: 1, C: 17 }
 8) { A: 7, B: 1, C: 17 }
 9) { A: 9, B: 1, C: 17 }
*** Ctx ping count: 11
    [0](11): SortUp(*1: Data, *1.C, *1.B, *1.A)
###
> SortUp(Data, C, C+1, B, A)
SortUp(Data, C, C + 1, B, A) : {A:i8, B:i8, C:i8}*
BndKind:Call, Type:{A:i8, B:i8, C:i8}*, Bnd:(Call(∂.SortUp([map:1] Global(Data), GetField(Scope(1), C), Add(GetField(Scope(1), C), 1:i8), GetField(Scope(1), B), GetField(Scope(1), A))))
// (<ctx>, ∂.Data:{A:i8, B:i8, C:i8}*) : {A:i8, B:i8, C:i8}*
SortUpCompare(Arr<obj>, {i8,i8,i8}, {i8,i8,i8}):i4
      1) ldarg.1 [{i8,i8,i8}]
      5) ldfld {i8,i8,i8}::_F2:i8
      1) ldarg.2 [{i8,i8,i8}]
      5) ldfld {i8,i8,i8}::_F2:i8
      5) call static Cmp::Compare(i8, i8):i4
      1) dup
      5) brtrue [0]
      1) pop
      1) ldarg.1 [{i8,i8,i8}]
      5) ldfld {i8,i8,i8}::_F2:i8
      1) ldc.i4.1
      1) conv.i8
      1) add
      1) ldarg.2 [{i8,i8,i8}]
      5) ldfld {i8,i8,i8}::_F2:i8
      1) ldc.i4.1
      1) conv.i8
      1) add
      5) call static Cmp::Compare(i8, i8):i4
      1) dup
      5) brtrue [0]
      1) pop
      1) ldarg.1 [{i8,i8,i8}]
      5) ldfld {i8,i8,i8}::_F1:i8
      1) ldarg.2 [{i8,i8,i8}]
      5) ldfld {i8,i8,i8}::_F1:i8
      5) call static Cmp::Compare(i8, i8):i4
      1) dup
      5) brtrue [0]
      1) pop
      1) ldarg.1 [{i8,i8,i8}]
      5) ldfld {i8,i8,i8}::_F0:i8
      1) ldarg.2 [{i8,i8,i8}]
      5) ldfld {i8,i8,i8}::_F0:i8
      5) call static Cmp::Compare(i8, i8):i4
  Label [0]:
      1) ret
  Total Size: 96

top(Arr<obj>, Arr<obj>):obj
      1) ldarg.1 [Arr<obj>]
      1) ldc.i4.0
      1) ldelem.ref
      5) call static CodeGenUtil::ToRef(obj):ExecCtx
      1) stloc.0 [ExecCtx]
      1) ldarg.1 [Arr<obj>]
      1) ldc.i4.1
      1) ldelem.ref
      5) call static CodeGenUtil::ToRef(obj):Seq<{i8,i8,i8}>
      1) stloc.1 [Seq<{i8,i8,i8}>]
      1) ldloc.1 [Seq<{i8,i8,i8}>]
      1) dup
      1) ldloc.0 [ExecCtx]
      1) ldc.i4.0
      5) call static CodeGenUtil::EnumerableToPinging(Seq<{i8,i8,i8}>, ExecCtx, i4):Seq<{i8,i8,i8}>
      1) ldarg.0 [Arr<obj>]
      1) ldc.i4.0
      5) ldelem [Func<{i8,i8,i8},{i8,i8,i8},i4>]
      5) call static CodeGenUtil::SortNoKey(Seq<{i8,i8,i8}>, Func<{i8,i8,i8},{i8,i8,i8},i4>):Seq<{i8,i8,i8}>
      5) call static CodeGenUtil::WrapWithCounter(Seq<{i8,i8,i8}>, Seq<{i8,i8,i8}>):Seq<{i8,i8,i8}>
      5) call static CodeGenUtil::EnumerableToCaching(Seq<{i8,i8,i8}>):Seq<{i8,i8,i8}>
      1) ret
  Total Size: 50

Func sig: (<ctx>:x, Data:{A:i8, B:i8, C:i8}*) to {A:i8, B:i8, C:i8}*
Sequence: Seq<{i8,i8,i8}>
 0) { A: 0, B: 0, C: 17 }
 1) { A: 2, B: 0, C: 17 }
 2) { A: 4, B: 0, C: 17 }
 3) { A: 6, B: 0, C: 17 }
 4) { A: 8, B: 0, C: 17 }
 5) { A: 1, B: 1, C: 17 }
 6) { A: 3, B: 1, C: 17 }
 7) { A: 5, B: 1, C: 17 }
 8) { A: 7, B: 1, C: 17 }
 9) { A: 9, B: 1, C: 17 }
*** Ctx ping count: 11
    [0](11): SortUp(*1: Data, *1.C, Add(*1.C, 1), *1.B, *1.A)
###
> SortUp(Data, C, C+1, C+2, C+3, C+4, C+5, C+6, C+7, C+8, C+9, C+10, C+11, C+12, C+13, C+14, C+15, C+16, C+17, C+18, C+19, C+20, C+21, C+22, C+23, C+24, C+25, C+26, C+27, C+28, C+29, C+30, C+31, C+32, C+33, C+34, C+35, C+36, C+37, C+38, C+39, B, A)
SortUp(Data, C, C + 1, C + 2, C + 3, C + 4, C + 5, C + 6, C + 7, C + 8, C + 9, C + 10, C + 11, C + 12, C + 13, C + 14, C + 15, C + 16, C + 17, C + 18, C + 19, C + 20, C + 21, C + 22, C + 23, C + 24, C + 25, C + 26, C + 27, C + 28, C + 29, C + 30, C + 31, C + 32, C + 33, C + 34, C + 35, C + 36, C + 37, C + 38, C + 39, B, A) : {A:i8, B:i8, C:i8}*
BndKind:Call, Type:{A:i8, B:i8, C:i8}*, Bnd:(Call(∂.SortUp([map:1] Global(Data), GetField(Scope(1), C), Add(GetField(Scope(1), C), 1:i8), Add(GetField(Scope(1), C), 2:i8), Add(GetField(Scope(1), C), 3:i8), Add(GetField(Scope(1), C), 4:i8), Add(GetField(Scope(1), C), 5:i8), Add(GetField(Scope(1), C), 6:i8), Add(GetField(Scope(1), C), 7:i8), Add(GetField(Scope(1), C), 8:i8), Add(GetField(Scope(1), C), 9:i8), Add(GetField(Scope(1), C), 10:i8), Add(GetField(Scope(1), C), 11:i8), Add(GetField(Scope(1), C), 12:i8), Add(GetField(Scope(1), C), 13:i8), Add(GetField(Scope(1), C), 14:i8), Add(GetField(Scope(1), C), 15:i8), Add(GetField(Scope(1), C), 16:i8), Add(GetField(Scope(1), C), 17:i8), Add(GetField(Scope(1), C), 18:i8), Add(GetField(Scope(1), C), 19:i8), Add(GetField(Scope(1), C), 20:i8), Add(GetField(Scope(1), C), 21:i8), Add(GetField(Scope(1), C), 22:i8), Add(GetField(Scope(1), C), 23:i8), Add(GetField(Scope(1), C), 24:i8), Add(GetField(Scope(1), C), 25:i8), Add(GetField(Scope(1), C), 26:i8), Add(GetField(Scope(1), C), 27:i8), Add(GetField(Scope(1), C), 28:i8), Add(GetField(Scope(1), C), 29:i8), Add(GetField(Scope(1), C), 30:i8), Add(GetField(Scope(1), C), 31:i8), Add(GetField(Scope(1), C), 32:i8), Add(GetField(Scope(1), C), 33:i8), Add(GetField(Scope(1), C), 34:i8), Add(GetField(Scope(1), C), 35:i8), Add(GetField(Scope(1), C), 36:i8), Add(GetField(Scope(1), C), 37:i8), Add(GetField(Scope(1), C), 38:i8), Add(GetField(Scope(1), C), 39:i8), GetField(Scope(1), B), GetField(Scope(1), A))))
// (<ctx>, ∂.Data:{A:i8, B:i8, C:i8}*) : {A:i8, B:i8, C:i8}*
SortUpCompare(Arr<obj>, {i8,i8,i8}, {i8,i8,i8}):i4
      1) ldarg.1 [{i8,i8,i8}]
      5) ldfld {i8,i8,i8}::_F2:i8
      1) ldarg.2 [{i8,i8,i8}]
      5) ldfld {i8,i8,i8}::_F2:i8
      5) call static Cmp::Compare(i8, i8):i4
      1) dup
      5) brtrue [0]
      1) pop
      1) ldarg.1 [{i8,i8,i8}]
      5) ldfld {i8,i8,i8}::_F2:i8
      1) ldc.i4.1
      1) conv.i8
      1) add
      1) ldarg.2 [{i8,i8,i8}]
      5) ldfld {i8,i8,i8}::_F2:i8
      1) ldc.i4.1
      1) conv.i8
      1) add
      5) call static Cmp::Compare(i8, i8):i4
      1) dup
      5) brtrue [0]
      1) pop
      1) ldarg.1 [{i8,i8,i8}]
      5) ldfld {i8,i8,i8}::_F2:i8
      1) ldc.i4.2
      1) conv.i8
      1) add
      1) ldarg.2 [{i8,i8,i8}]
      5) ldfld {i8,i8,i8}::_F2:i8
      1) ldc.i4.2
      1) conv.i8
      1) add
      5) call static Cmp::Compare(i8, i8):i4
      1) dup
      5) brtrue [0]
      1) pop
      1) ldarg.1 [{i8,i8,i8}]
      5) ldfld {i8,i8,i8}::_F2:i8
      1) ldc.i4.3
      1) conv.i8
      1) add
      1) ldarg.2 [{i8,i8,i8}]
      5) ldfld {i8,i8,i8}::_F2:i8
      1) ldc.i4.3
      1) conv.i8
      1) add
      5) call static Cmp::Compare(i8, i8):i4
      1) dup
      5) brtrue [0]
      1) pop
      1) ldarg.1 [{i8,i8,i8}]
      5) ldfld {i8,i8,i8}::_F2:i8
      1) ldc.i4.4
      1) conv.i8
      1) add
      1) ldarg.2 [{i8,i8,i8}]
      5) ldfld {i8,i8,i8}::_F2:i8
      1) ldc.i4.4
      1) conv.i8
      1) add
      5) call static Cmp::Compare(i8, i8):i4
      1) dup
      5) brtrue [0]
      1) pop
      1) ldarg.1 [{i8,i8,i8}]
      5) ldfld {i8,i8,i8}::_F2:i8
      1) ldc.i4.5
      1) conv.i8
      1) add
      1) ldarg.2 [{i8,i8,i8}]
      5) ldfld {i8,i8,i8}::_F2:i8
      1) ldc.i4.5
      1) conv.i8
      1) add
      5) call static Cmp::Compare(i8, i8):i4
      1) dup
      5) brtrue [0]
      1) pop
      1) ldarg.1 [{i8,i8,i8}]
      5) ldfld {i8,i8,i8}::_F2:i8
      1) ldc.i4.6
      1) conv.i8
      1) add
      1) ldarg.2 [{i8,i8,i8}]
      5) ldfld {i8,i8,i8}::_F2:i8
      1) ldc.i4.6
      1) conv.i8
      1) add
      5) call static Cmp::Compare(i8, i8):i4
      1) dup
      5) brtrue [0]
      1) pop
      1) ldarg.1 [{i8,i8,i8}]
      5) ldfld {i8,i8,i8}::_F2:i8
      1) ldc.i4.7
      1) conv.i8
      1) add
      1) ldarg.2 [{i8,i8,i8}]
      5) ldfld {i8,i8,i8}::_F2:i8
      1) ldc.i4.7
      1) conv.i8
      1) add
      5) call static Cmp::Compare(i8, i8):i4
      1) dup
      5) brtrue [0]
      1) pop
      1) ldarg.1 [{i8,i8,i8}]
      5) ldfld {i8,i8,i8}::_F2:i8
      1) ldc.i4.8
      1) conv.i8
      1) add
      1) ldarg.2 [{i8,i8,i8}]
      5) ldfld {i8,i8,i8}::_F2:i8
      1) ldc.i4.8
      1) conv.i8
      1) add
      5) call static Cmp::Compare(i8, i8):i4
      1) dup
      5) brtrue [0]
      1) pop
      1) ldarg.1 [{i8,i8,i8}]
      5) ldfld {i8,i8,i8}::_F2:i8
      2) ldc.i4.s [9]
      1) conv.i8
      1) add
      1) ldarg.2 [{i8,i8,i8}]
      5) ldfld {i8,i8,i8}::_F2:i8
      2) ldc.i4.s [9]
      1) conv.i8
      1) add
      5) call static Cmp::Compare(i8, i8):i4
      1) dup
      5) brtrue [0]
      1) pop
      1) ldarg.1 [{i8,i8,i8}]
      5) ldfld {i8,i8,i8}::_F2:i8
      2) ldc.i4.s [10]
      1) conv.i8
      1) add
      1) ldarg.2 [{i8,i8,i8}]
      5) ldfld {i8,i8,i8}::_F2:i8
      2) ldc.i4.s [10]
      1) conv.i8
      1) add
      5) call static Cmp::Compare(i8, i8):i4
      1) dup
      5) brtrue [0]
      1) pop
      1) ldarg.1 [{i8,i8,i8}]
      5) ldfld {i8,i8,i8}::_F2:i8
      2) ldc.i4.s [11]
      1) conv.i8
      1) add
      1) ldarg.2 [{i8,i8,i8}]
      5) ldfld {i8,i8,i8}::_F2:i8
      2) ldc.i4.s [11]
      1) conv.i8
      1) add
      5) call static Cmp::Compare(i8, i8):i4
      1) dup
      5) brtrue [0]
      1) pop
      1) ldarg.1 [{i8,i8,i8}]
      5) ldfld {i8,i8,i8}::_F2:i8
      2) ldc.i4.s [12]
      1) conv.i8
      1) add
      1) ldarg.2 [{i8,i8,i8}]
      5) ldfld {i8,i8,i8}::_F2:i8
      2) ldc.i4.s [12]
      1) conv.i8
      1) add
      5) call static Cmp::Compare(i8, i8):i4
      1) dup
      5) brtrue [0]
      1) pop
      1) ldarg.1 [{i8,i8,i8}]
      5) ldfld {i8,i8,i8}::_F2:i8
      2) ldc.i4.s [13]
      1) conv.i8
      1) add
      1) ldarg.2 [{i8,i8,i8}]
      5) ldfld {i8,i8,i8}::_F2:i8
      2) ldc.i4.s [13]
      1) conv.i8
      1) add
      5) call static Cmp::Compare(i8, i8):i4
      1) dup
      5) brtrue [0]
      1) pop
      1) ldarg.1 [{i8,i8,i8}]
      5) ldfld {i8,i8,i8}::_F2:i8
      2) ldc.i4.s [14]
      1) conv.i8
      1) add
      1) ldarg.2 [{i8,i8,i8}]
      5) ldfld {i8,i8,i8}::_F2:i8
      2) ldc.i4.s [14]
      1) conv.i8
      1) add
      5) call static Cmp::Compare(i8, i8):i4
      1) dup
      5) brtrue [0]
      1) pop
      1) ldarg.1 [{i8,i8,i8}]
      5) ldfld {i8,i8,i8}::_F2:i8
      2) ldc.i4.s [15]
      1) conv.i8
      1) add
      1) ldarg.2 [{i8,i8,i8}]
      5) ldfld {i8,i8,i8}::_F2:i8
      2) ldc.i4.s [15]
      1) conv.i8
      1) add
      5) call static Cmp::Compare(i8, i8):i4
      1) dup
      5) brtrue [0]
      1) pop
      1) ldarg.1 [{i8,i8,i8}]
      5) ldfld {i8,i8,i8}::_F2:i8
      2) ldc.i4.s [16]
      1) conv.i8
      1) add
      1) ldarg.2 [{i8,i8,i8}]
      5) ldfld {i8,i8,i8}::_F2:i8
      2) ldc.i4.s [16]
      1) conv.i8
      1) add
      5) call static Cmp::Compare(i8, i8):i4
      1) dup
      5) brtrue [0]
      1) pop
      1) ldarg.1 [{i8,i8,i8}]
      5) ldfld {i8,i8,i8}::_F2:i8
      2) ldc.i4.s [17]
      1) conv.i8
      1) add
      1) ldarg.2 [{i8,i8,i8}]
      5) ldfld {i8,i8,i8}::_F2:i8
      2) ldc.i4.s [17]
      1) conv.i8
      1) add
      5) call static Cmp::Compare(i8, i8):i4
      1) dup
      5) brtrue [0]
      1) pop
      1) ldarg.1 [{i8,i8,i8}]
      5) ldfld {i8,i8,i8}::_F2:i8
      2) ldc.i4.s [18]
      1) conv.i8
      1) add
      1) ldarg.2 [{i8,i8,i8}]
      5) ldfld {i8,i8,i8}::_F2:i8
      2) ldc.i4.s [18]
      1) conv.i8
      1) add
      5) call static Cmp::Compare(i8, i8):i4
      1) dup
      5) brtrue [0]
      1) pop
      1) ldarg.1 [{i8,i8,i8}]
      5) ldfld {i8,i8,i8}::_F2:i8
      2) ldc.i4.s [19]
      1) conv.i8
      1) add
      1) ldarg.2 [{i8,i8,i8}]
      5) ldfld {i8,i8,i8}::_F2:i8
      2) ldc.i4.s [19]
      1) conv.i8
      1) add
      5) call static Cmp::Compare(i8, i8):i4
      1) dup
      5) brtrue [0]
      1) pop
      1) ldarg.1 [{i8,i8,i8}]
      5) ldfld {i8,i8,i8}::_F2:i8
      2) ldc.i4.s [20]
      1) conv.i8
      1) add
      1) ldarg.2 [{i8,i8,i8}]
      5) ldfld {i8,i8,i8}::_F2:i8
      2) ldc.i4.s [20]
      1) conv.i8
      1) add
      5) call static Cmp::Compare(i8, i8):i4
      1) dup
      5) brtrue [0]
      1) pop
      1) ldarg.1 [{i8,i8,i8}]
      5) ldfld {i8,i8,i8}::_F2:i8
      2) ldc.i4.s [21]
      1) conv.i8
      1) add
      1) ldarg.2 [{i8,i8,i8}]
      5) ldfld {i8,i8,i8}::_F2:i8
      2) ldc.i4.s [21]
      1) conv.i8
      1) add
      5) call static Cmp::Compare(i8, i8):i4
      1) dup
      5) brtrue [0]
      1) pop
      1) ldarg.1 [{i8,i8,i8}]
      5) ldfld {i8,i8,i8}::_F2:i8
      2) ldc.i4.s [22]
      1) conv.i8
      1) add
      1) ldarg.2 [{i8,i8,i8}]
      5) ldfld {i8,i8,i8}::_F2:i8
      2) ldc.i4.s [22]
      1) conv.i8
      1) add
      5) call static Cmp::Compare(i8, i8):i4
      1) dup
      5) brtrue [0]
      1) pop
      1) ldarg.1 [{i8,i8,i8}]
      5) ldfld {i8,i8,i8}::_F2:i8
      2) ldc.i4.s [23]
      1) conv.i8
      1) add
      1) ldarg.2 [{i8,i8,i8}]
      5) ldfld {i8,i8,i8}::_F2:i8
      2) ldc.i4.s [23]
      1) conv.i8
      1) add
      5) call static Cmp::Compare(i8, i8):i4
      1) dup
      5) brtrue [0]
      1) pop
      1) ldarg.1 [{i8,i8,i8}]
      5) ldfld {i8,i8,i8}::_F2:i8
      2) ldc.i4.s [24]
      1) conv.i8
      1) add
      1) ldarg.2 [{i8,i8,i8}]
      5) ldfld {i8,i8,i8}::_F2:i8
      2) ldc.i4.s [24]
      1) conv.i8
      1) add
      5) call static Cmp::Compare(i8, i8):i4
      1) dup
      5) brtrue [0]
      1) pop
      1) ldarg.1 [{i8,i8,i8}]
      5) ldfld {i8,i8,i8}::_F2:i8
      2) ldc.i4.s [25]
      1) conv.i8
      1) add
      1) ldarg.2 [{i8,i8,i8}]
      5) ldfld {i8,i8,i8}::_F2:i8
      2) ldc.i4.s [25]
      1) conv.i8
      1) add
      5) call static Cmp::Compare(i8, i8):i4
      1) dup
      5) brtrue [0]
      1) pop
      1) ldarg.1 [{i8,i8,i8}]
      5) ldfld {i8,i8,i8}::_F2:i8
      2) ldc.i4.s [26]
      1) conv.i8
      1) add
      1) ldarg.2 [{i8,i8,i8}]
      5) ldfld {i8,i8,i8}::_F2:i8
      2) ldc.i4.s [26]
      1) conv.i8
      1) add
      5) call static Cmp::Compare(i8, i8):i4
      1) dup
      5) brtrue [0]
      1) pop
      1) ldarg.1 [{i8,i8,i8}]
      5) ldfld {i8,i8,i8}::_F2:i8
      2) ldc.i4.s [27]
      1) conv.i8
      1) add
      1) ldarg.2 [{i8,i8,i8}]
      5) ldfld {i8,i8,i8}::_F2:i8
      2) ldc.i4.s [27]
      1) conv.i8
      1) add
      5) call static Cmp::Compare(i8, i8):i4
      1) dup
      5) brtrue [0]
      1) pop
      1) ldarg.1 [{i8,i8,i8}]
      5) ldfld {i8,i8,i8}::_F2:i8
      2) ldc.i4.s [28]
      1) conv.i8
      1) add
      1) ldarg.2 [{i8,i8,i8}]
      5) ldfld {i8,i8,i8}::_F2:i8
      2) ldc.i4.s [28]
      1) conv.i8
      1) add
      5) call static Cmp::Compare(i8, i8):i4
      1) dup
      5) brtrue [0]
      1) pop
      1) ldarg.1 [{i8,i8,i8}]
      5) ldfld {i8,i8,i8}::_F2:i8
      2) ldc.i4.s [29]
      1) conv.i8
      1) add
      1) ldarg.2 [{i8,i8,i8}]
      5) ldfld {i8,i8,i8}::_F2:i8
      2) ldc.i4.s [29]
      1) conv.i8
      1) add
      5) call static Cmp::Compare(i8, i8):i4
      1) dup
      5) brtrue [0]
      1) pop
      1) ldarg.1 [{i8,i8,i8}]
      5) ldfld {i8,i8,i8}::_F2:i8
      2) ldc.i4.s [30]
      1) conv.i8
      1) add
      1) ldarg.2 [{i8,i8,i8}]
      5) ldfld {i8,i8,i8}::_F2:i8
      2) ldc.i4.s [30]
      1) conv.i8
      1) add
      5) call static Cmp::Compare(i8, i8):i4
      1) dup
      5) brtrue [0]
      1) pop
      1) ldarg.1 [{i8,i8,i8}]
      5) ldfld {i8,i8,i8}::_F2:i8
      2) ldc.i4.s [31]
      1) conv.i8
      1) add
      1) ldarg.2 [{i8,i8,i8}]
      5) ldfld {i8,i8,i8}::_F2:i8
      2) ldc.i4.s [31]
      1) conv.i8
      1) add
      5) call static Cmp::Compare(i8, i8):i4
      1) dup
      5) brtrue [0]
      1) pop
      1) ldarg.1 [{i8,i8,i8}]
      5) ldfld {i8,i8,i8}::_F2:i8
      2) ldc.i4.s [32]
      1) conv.i8
      1) add
      1) ldarg.2 [{i8,i8,i8}]
      5) ldfld {i8,i8,i8}::_F2:i8
      2) ldc.i4.s [32]
      1) conv.i8
      1) add
      5) call static Cmp::Compare(i8, i8):i4
      1) dup
      5) brtrue [0]
      1) pop
      1) ldarg.1 [{i8,i8,i8}]
      5) ldfld {i8,i8,i8}::_F2:i8
      2) ldc.i4.s [33]
      1) conv.i8
      1) add
      1) ldarg.2 [{i8,i8,i8}]
      5) ldfld {i8,i8,i8}::_F2:i8
      2) ldc.i4.s [33]
      1) conv.i8
      1) add
      5) call static Cmp::Compare(i8, i8):i4
      1) dup
      5) brtrue [0]
      1) pop
      1) ldarg.1 [{i8,i8,i8}]
      5) ldfld {i8,i8,i8}::_F2:i8
      2) ldc.i4.s [34]
      1) conv.i8
      1) add
      1) ldarg.2 [{i8,i8,i8}]
      5) ldfld {i8,i8,i8}::_F2:i8
      2) ldc.i4.s [34]
      1) conv.i8
      1) add
      5) call static Cmp::Compare(i8, i8):i4
      1) dup
      5) brtrue [0]
      1) pop
      1) ldarg.1 [{i8,i8,i8}]
      5) ldfld {i8,i8,i8}::_F2:i8
      2) ldc.i4.s [35]
      1) conv.i8
      1) add
      1) ldarg.2 [{i8,i8,i8}]
      5) ldfld {i8,i8,i8}::_F2:i8
      2) ldc.i4.s [35]
      1) conv.i8
      1) add
      5) call static Cmp::Compare(i8, i8):i4
      1) dup
      5) brtrue [0]
      1) pop
      1) ldarg.1 [{i8,i8,i8}]
      5) ldfld {i8,i8,i8}::_F2:i8
      2) ldc.i4.s [36]
      1) conv.i8
      1) add
      1) ldarg.2 [{i8,i8,i8}]
      5) ldfld {i8,i8,i8}::_F2:i8
      2) ldc.i4.s [36]
      1) conv.i8
      1) add
      5) call static Cmp::Compare(i8, i8):i4
      1) dup
      5) brtrue [0]
      1) pop
      1) ldarg.1 [{i8,i8,i8}]
      5) ldfld {i8,i8,i8}::_F2:i8
      2) ldc.i4.s [37]
      1) conv.i8
      1) add
      1) ldarg.2 [{i8,i8,i8}]
      5) ldfld {i8,i8,i8}::_F2:i8
      2) ldc.i4.s [37]
      1) conv.i8
      1) add
      5) call static Cmp::Compare(i8, i8):i4
      1) dup
      5) brtrue [0]
      1) pop
      1) ldarg.1 [{i8,i8,i8}]
      5) ldfld {i8,i8,i8}::_F2:i8
      2) ldc.i4.s [38]
      1) conv.i8
      1) add
      1) ldarg.2 [{i8,i8,i8}]
      5) ldfld {i8,i8,i8}::_F2:i8
      2) ldc.i4.s [38]
      1) conv.i8
      1) add
      5) call static Cmp::Compare(i8, i8):i4
      1) dup
      5) brtrue [0]
      1) pop
      1) ldarg.1 [{i8,i8,i8}]
      5) ldfld {i8,i8,i8}::_F2:i8
      2) ldc.i4.s [39]
      1) conv.i8
      1) add
      1) ldarg.2 [{i8,i8,i8}]
      5) ldfld {i8,i8,i8}::_F2:i8
      2) ldc.i4.s [39]
      1) conv.i8
      1) add
      5) call static Cmp::Compare(i8, i8):i4
      1) dup
      5) brtrue [0]
      1) pop
      1) ldarg.1 [{i8,i8,i8}]
      5) ldfld {i8,i8,i8}::_F1:i8
      1) ldarg.2 [{i8,i8,i8}]
      5) ldfld {i8,i8,i8}::_F1:i8
      5) call static Cmp::Compare(i8, i8):i4
      1) dup
      5) brtrue [0]
      1) pop
      1) ldarg.1 [{i8,i8,i8}]
      5) ldfld {i8,i8,i8}::_F0:i8
      1) ldarg.2 [{i8,i8,i8}]
      5) ldfld {i8,i8,i8}::_F0:i8
      5) call static Cmp::Compare(i8, i8):i4
  Label [0]:
      1) ret
  Total Size: 1298

top(Arr<obj>, Arr<obj>):obj
      1) ldarg.1 [Arr<obj>]
      1) ldc.i4.0
      1) ldelem.ref
      5) call static CodeGenUtil::ToRef(obj):ExecCtx
      1) stloc.0 [ExecCtx]
      1) ldarg.1 [Arr<obj>]
      1) ldc.i4.1
      1) ldelem.ref
      5) call static CodeGenUtil::ToRef(obj):Seq<{i8,i8,i8}>
      1) stloc.1 [Seq<{i8,i8,i8}>]
      1) ldloc.1 [Seq<{i8,i8,i8}>]
      1) dup
      1) ldloc.0 [ExecCtx]
      1) ldc.i4.0
      5) call static CodeGenUtil::EnumerableToPinging(Seq<{i8,i8,i8}>, ExecCtx, i4):Seq<{i8,i8,i8}>
      1) ldarg.0 [Arr<obj>]
      1) ldc.i4.0
      5) ldelem [Func<{i8,i8,i8},{i8,i8,i8},i4>]
      5) call static CodeGenUtil::SortNoKey(Seq<{i8,i8,i8}>, Func<{i8,i8,i8},{i8,i8,i8},i4>):Seq<{i8,i8,i8}>
      5) call static CodeGenUtil::WrapWithCounter(Seq<{i8,i8,i8}>, Seq<{i8,i8,i8}>):Seq<{i8,i8,i8}>
      5) call static CodeGenUtil::EnumerableToCaching(Seq<{i8,i8,i8}>):Seq<{i8,i8,i8}>
      1) ret
  Total Size: 50

Func sig: (<ctx>:x, Data:{A:i8, B:i8, C:i8}*) to {A:i8, B:i8, C:i8}*
Sequence: Seq<{i8,i8,i8}>
 0) { A: 0, B: 0, C: 17 }
 1) { A: 2, B: 0, C: 17 }
 2) { A: 4, B: 0, C: 17 }
 3) { A: 6, B: 0, C: 17 }
 4) { A: 8, B: 0, C: 17 }
 5) { A: 1, B: 1, C: 17 }
 6) { A: 3, B: 1, C: 17 }
 7) { A: 5, B: 1, C: 17 }
 8) { A: 7, B: 1, C: 17 }
 9) { A: 9, B: 1, C: 17 }
*** Ctx ping count: 11
    [0](11): SortUp(*1: Data, *1.C, Add(*1.C, 1), Add(*1.C, 2), Add(*1.C, 3), Add(*1.C, 4), Add(*1.C, 5), Add(*1.C, 6), Add(*1.C, 7), Add(*1.C, 8), Add(*1.C, 9), Add(*1.C, 10), Add(*1.C, 11), Add(*1.C, 12), Add(*1.C, 13), Add(*1.C, 14), Add(*1.C, 15), Add(*1.C, 16), Add(*1.C, 17), Add(*1.C, 18), Add(*1.C, 19), Add(*1.C, 20), Add(*1.C, 21), Add(*1.C, 22), Add(*1.C, 23), Add(*1.C, 24), Add(*1.C, 25), Add(*1.C, 26), Add(*1.C, 27), Add(*1.C, 28), Add(*1.C, 29), Add(*1.C, 30), Add(*1.C, 31), Add(*1.C, 32), Add(*1.C, 33), Add(*1.C, 34), Add(*1.C, 35), Add(*1.C, 36), Add(*1.C, 37), Add(*1.C, 38), Add(*1.C, 39), *1.B, *1.A)
###

**** New definitions: S, type: s*
**** New definitions: T, type: {i:i8, s:u8, t:s}*

> Sort(     S)
Sort(S) : s*
BndKind:Call, Type:s*, Bnd:(Call(∂.Sort(Global(S)):s*))
// (<ctx>, ∂.S:s*) : s*
top(Arr<obj>, Arr<obj>):obj
      1) ldarg.1 [Arr<obj>]
      1) ldc.i4.0
      1) ldelem.ref
      5) call static CodeGenUtil::ToRef(obj):ExecCtx
      1) stloc.0 [ExecCtx]
      1) ldarg.1 [Arr<obj>]
      1) ldc.i4.1
      1) ldelem.ref
      5) call static CodeGenUtil::ToRef(obj):Seq<str>
      1) stloc.1 [Seq<str>]
      1) ldloc.1 [Seq<str>]
      1) dup
      1) ldloc.0 [ExecCtx]
      1) ldc.i4.0
      5) call static CodeGenUtil::EnumerableToPinging(Seq<str>, ExecCtx, i4):Seq<str>
      1) ldarg.0 [Arr<obj>]
      1) ldc.i4.0
      5) ldelem [Func<str,str,i4>]
      5) call static CodeGenUtil::SortNoKey(Seq<str>, Func<str,str,i4>):Seq<str>
      5) call static CodeGenUtil::WrapWithCounter(Seq<str>, Seq<str>):Seq<str>
      5) call static CodeGenUtil::EnumerableToCaching(Seq<str>):Seq<str>
      1) ret
  Total Size: 50

Func sig: (<ctx>:x, S:s*) to s*
Sequence: Seq<str>
 0) <null>
 1) 
 2)  
 3) 0
 4) 9
 5) a
 6) A
 7) A
 8) á
 9) Á
10) à
11) À
12) az
13) az
14) aZ
15) Az
16) AZ
17) AZ
18) b
19) B
20) Ba
21) BA
22) Bz
23) BZ
24) ss
25) SS
26) ß
27) ß
28) st
29) st
30) St
31) ST
*** Ctx ping count: 33
    [0](33): Sort(S)
###
> Sort([<]  S)
Sort([<] S) : s*
BndKind:Call, Type:s*, Bnd:(Call(∂.Sort([<] Global(S)):s*))
// (<ctx>, ∂.S:s*) : s*
top(Arr<obj>, Arr<obj>):obj
      1) ldarg.1 [Arr<obj>]
      1) ldc.i4.0
      1) ldelem.ref
      5) call static CodeGenUtil::ToRef(obj):ExecCtx
      1) stloc.0 [ExecCtx]
      1) ldarg.1 [Arr<obj>]
      1) ldc.i4.1
      1) ldelem.ref
      5) call static CodeGenUtil::ToRef(obj):Seq<str>
      1) stloc.1 [Seq<str>]
      1) ldloc.1 [Seq<str>]
      1) dup
      1) ldloc.0 [ExecCtx]
      1) ldc.i4.0
      5) call static CodeGenUtil::EnumerableToPinging(Seq<str>, ExecCtx, i4):Seq<str>
      1) ldarg.0 [Arr<obj>]
      1) ldc.i4.0
      5) ldelem [Func<str,str,i4>]
      5) call static CodeGenUtil::SortNoKey(Seq<str>, Func<str,str,i4>):Seq<str>
      5) call static CodeGenUtil::WrapWithCounter(Seq<str>, Seq<str>):Seq<str>
      5) call static CodeGenUtil::EnumerableToCaching(Seq<str>):Seq<str>
      1) ret
  Total Size: 50

Func sig: (<ctx>:x, S:s*) to s*
Sequence: Seq<str>
 0) <null>
 1) 
 2)  
 3) 0
 4) 9
 5) a
 6) A
 7) A
 8) á
 9) Á
10) à
11) À
12) az
13) az
14) aZ
15) Az
16) AZ
17) AZ
18) b
19) B
20) Ba
21) BA
22) Bz
23) BZ
24) ss
25) SS
26) ß
27) ß
28) st
29) st
30) St
31) ST
*** Ctx ping count: 33
    [0](33): Sort([<] S)
###
> Sort([>]  S)
Sort([>] S) : s*
BndKind:Call, Type:s*, Bnd:(Call(∂.Sort([>] Global(S)):s*))
// (<ctx>, ∂.S:s*) : s*
top(Arr<obj>, Arr<obj>):obj
      1) ldarg.1 [Arr<obj>]
      1) ldc.i4.0
      1) ldelem.ref
      5) call static CodeGenUtil::ToRef(obj):ExecCtx
      1) stloc.0 [ExecCtx]
      1) ldarg.1 [Arr<obj>]
      1) ldc.i4.1
      1) ldelem.ref
      5) call static CodeGenUtil::ToRef(obj):Seq<str>
      1) stloc.1 [Seq<str>]
      1) ldloc.1 [Seq<str>]
      1) dup
      1) ldloc.0 [ExecCtx]
      1) ldc.i4.0
      5) call static CodeGenUtil::EnumerableToPinging(Seq<str>, ExecCtx, i4):Seq<str>
      1) ldarg.0 [Arr<obj>]
      1) ldc.i4.0
      5) ldelem [Func<str,str,i4>]
      5) call static CodeGenUtil::SortNoKey(Seq<str>, Func<str,str,i4>):Seq<str>
      5) call static CodeGenUtil::WrapWithCounter(Seq<str>, Seq<str>):Seq<str>
      5) call static CodeGenUtil::EnumerableToCaching(Seq<str>):Seq<str>
      1) ret
  Total Size: 50

Func sig: (<ctx>:x, S:s*) to s*
Sequence: Seq<str>
 0) ST
 1) St
 2) st
 3) st
 4) ß
 5) ß
 6) SS
 7) ss
 8) BZ
 9) Bz
10) BA
11) Ba
12) B
13) b
14) AZ
15) AZ
16) Az
17) aZ
18) az
19) az
20) À
21) à
22) Á
23) á
24) A
25) A
26) a
27) 9
28) 0
29)  
30) 
31) <null>
*** Ctx ping count: 33
    [0](33): Sort([>] S)
###
> Sort([~]  S)
Sort([~] S) : s*
BndKind:Call, Type:s*, Bnd:(Call(∂.Sort([~] Global(S)):s*))
// (<ctx>, ∂.S:s*) : s*
top(Arr<obj>, Arr<obj>):obj
      1) ldarg.1 [Arr<obj>]
      1) ldc.i4.0
      1) ldelem.ref
      5) call static CodeGenUtil::ToRef(obj):ExecCtx
      1) stloc.0 [ExecCtx]
      1) ldarg.1 [Arr<obj>]
      1) ldc.i4.1
      1) ldelem.ref
      5) call static CodeGenUtil::ToRef(obj):Seq<str>
      1) stloc.1 [Seq<str>]
      1) ldloc.1 [Seq<str>]
      1) dup
      1) ldloc.0 [ExecCtx]
      1) ldc.i4.0
      5) call static CodeGenUtil::EnumerableToPinging(Seq<str>, ExecCtx, i4):Seq<str>
      1) ldarg.0 [Arr<obj>]
      1) ldc.i4.0
      5) ldelem [Func<str,str,i4>]
      5) call static CodeGenUtil::SortNoKey(Seq<str>, Func<str,str,i4>):Seq<str>
      5) call static CodeGenUtil::WrapWithCounter(Seq<str>, Seq<str>):Seq<str>
      5) call static CodeGenUtil::EnumerableToCaching(Seq<str>):Seq<str>
      1) ret
  Total Size: 50

Func sig: (<ctx>:x, S:s*) to s*
Sequence: Seq<str>
 0) <null>
 1) 
 2)  
 3) 0
 4) 9
 5) A
 6) a
 7) A
 8) Á
 9) á
10) À
11) à
12) AZ
13) AZ
14) az
15) aZ
16) Az
17) az
18) B
19) b
20) Ba
21) BA
22) BZ
23) Bz
24) ss
25) SS
26) ß
27) ß
28) st
29) St
30) ST
31) st
*** Ctx ping count: 33
    [0](33): Sort([~] S)
###
> Sort([~<] S)
Sort([~<] S) : s*
BndKind:Call, Type:s*, Bnd:(Call(∂.Sort([~<] Global(S)):s*))
// (<ctx>, ∂.S:s*) : s*
top(Arr<obj>, Arr<obj>):obj
      1) ldarg.1 [Arr<obj>]
      1) ldc.i4.0
      1) ldelem.ref
      5) call static CodeGenUtil::ToRef(obj):ExecCtx
      1) stloc.0 [ExecCtx]
      1) ldarg.1 [Arr<obj>]
      1) ldc.i4.1
      1) ldelem.ref
      5) call static CodeGenUtil::ToRef(obj):Seq<str>
      1) stloc.1 [Seq<str>]
      1) ldloc.1 [Seq<str>]
      1) dup
      1) ldloc.0 [ExecCtx]
      1) ldc.i4.0
      5) call static CodeGenUtil::EnumerableToPinging(Seq<str>, ExecCtx, i4):Seq<str>
      1) ldarg.0 [Arr<obj>]
      1) ldc.i4.0
      5) ldelem [Func<str,str,i4>]
      5) call static CodeGenUtil::SortNoKey(Seq<str>, Func<str,str,i4>):Seq<str>
      5) call static CodeGenUtil::WrapWithCounter(Seq<str>, Seq<str>):Seq<str>
      5) call static CodeGenUtil::EnumerableToCaching(Seq<str>):Seq<str>
      1) ret
  Total Size: 50

Func sig: (<ctx>:x, S:s*) to s*
Sequence: Seq<str>
 0) <null>
 1) 
 2)  
 3) 0
 4) 9
 5) A
 6) a
 7) A
 8) Á
 9) á
10) À
11) à
12) AZ
13) AZ
14) az
15) aZ
16) Az
17) az
18) B
19) b
20) Ba
21) BA
22) BZ
23) Bz
24) ss
25) SS
26) ß
27) ß
28) st
29) St
30) ST
31) st
*** Ctx ping count: 33
    [0](33): Sort([~<] S)
###
> Sort([~>] S)
Sort([~>] S) : s*
BndKind:Call, Type:s*, Bnd:(Call(∂.Sort([~>] Global(S)):s*))
// (<ctx>, ∂.S:s*) : s*
top(Arr<obj>, Arr<obj>):obj
      1) ldarg.1 [Arr<obj>]
      1) ldc.i4.0
      1) ldelem.ref
      5) call static CodeGenUtil::ToRef(obj):ExecCtx
      1) stloc.0 [ExecCtx]
      1) ldarg.1 [Arr<obj>]
      1) ldc.i4.1
      1) ldelem.ref
      5) call static CodeGenUtil::ToRef(obj):Seq<str>
      1) stloc.1 [Seq<str>]
      1) ldloc.1 [Seq<str>]
      1) dup
      1) ldloc.0 [ExecCtx]
      1) ldc.i4.0
      5) call static CodeGenUtil::EnumerableToPinging(Seq<str>, ExecCtx, i4):Seq<str>
      1) ldarg.0 [Arr<obj>]
      1) ldc.i4.0
      5) ldelem [Func<str,str,i4>]
      5) call static CodeGenUtil::SortNoKey(Seq<str>, Func<str,str,i4>):Seq<str>
      5) call static CodeGenUtil::WrapWithCounter(Seq<str>, Seq<str>):Seq<str>
      5) call static CodeGenUtil::EnumerableToCaching(Seq<str>):Seq<str>
      1) ret
  Total Size: 50

Func sig: (<ctx>:x, S:s*) to s*
Sequence: Seq<str>
 0) st
 1) St
 2) ST
 3) st
 4) ß
 5) ß
 6) ss
 7) SS
 8) BZ
 9) Bz
10) Ba
11) BA
12) B
13) b
14) AZ
15) AZ
16) az
17) aZ
18) Az
19) az
20) À
21) à
22) Á
23) á
24) A
25) a
26) A
27) 9
28) 0
29)  
30) 
31) <null>
*** Ctx ping count: 33
    [0](33): Sort([~>] S)
###
> Sort(T,      t)
Sort(T, t) : {i:i8, s:u8, t:s}*
BndKind:Call, Type:{i:i8, s:u8, t:s}*, Bnd:(Call(∂.Sort([map:1] Global(T), GetField(Scope(1), t))))
// (<ctx>, ∂.T:{i:i8, s:u8, t:s}*) : {i:i8, s:u8, t:s}*
Sort_1(Arr<obj>, {i8,u8,str}):str
      1) ldarg.1 [{i8,u8,str}]
      5) ldfld {i8,u8,str}::_F2:str
      1) ret
  Total Size: 7

top(Arr<obj>, Arr<obj>):obj
      1) ldarg.1 [Arr<obj>]
      1) ldc.i4.0
      1) ldelem.ref
      5) call static CodeGenUtil::ToRef(obj):ExecCtx
      1) stloc.0 [ExecCtx]
      1) ldarg.1 [Arr<obj>]
      1) ldc.i4.1
      1) ldelem.ref
      5) call static CodeGenUtil::ToRef(obj):Seq<{i8,u8,str}>
      1) stloc.1 [Seq<{i8,u8,str}>]
      1) ldloc.1 [Seq<{i8,u8,str}>]
      1) dup
      1) ldloc.0 [ExecCtx]
      1) ldc.i4.0
      5) call static CodeGenUtil::EnumerableToPinging(Seq<{i8,u8,str}>, ExecCtx, i4):Seq<{i8,u8,str}>
      1) ldarg.0 [Arr<obj>]
      1) ldc.i4.0
      5) ldelem [Func<{i8,u8,str},str>]
      1) ldarg.0 [Arr<obj>]
      1) ldc.i4.1
      5) ldelem [Func<str,str,i4>]
      5) call static CodeGenUtil::Sort(Seq<{i8,u8,str}>, Func<{i8,u8,str},str>, Func<str,str,i4>):Seq<{i8,u8,str}>
      5) call static CodeGenUtil::WrapWithCounter(Seq<{i8,u8,str}>, Seq<{i8,u8,str}>):Seq<{i8,u8,str}>
      5) call static CodeGenUtil::EnumerableToCaching(Seq<{i8,u8,str}>):Seq<{i8,u8,str}>
      1) ret
  Total Size: 57

Func sig: (<ctx>:x, T:{i:i8, s:u8, t:s}*) to {i:i8, s:u8, t:s}*
Sequence: Seq<{i8,u8,str}>
 0) { i: 13, s: 0, t: <null> }
 1) { i: 12, s: 0, t:  }
 2) { i: 11, s: 1, t:   }
 3) { i: 9, s: 1, t: 0 }
 4) { i: 10, s: 1, t: 9 }
 5) { i: 2, s: 1, t: a }
 6) { i: 1, s: 1, t: A }
 7) { i: 3, s: 1, t: A }
 8) { i: 6, s: 1, t: á }
 9) { i: 5, s: 1, t: Á }
10) { i: 8, s: 1, t: à }
11) { i: 7, s: 1, t: À }
12) { i: 17, s: 2, t: az }
13) { i: 23, s: 2, t: az }
14) { i: 18, s: 2, t: aZ }
15) { i: 19, s: 2, t: Az }
16) { i: 14, s: 2, t: AZ }
17) { i: 16, s: 2, t: AZ }
18) { i: 4, s: 1, t: b }
19) { i: 0, s: 1, t: B }
20) { i: 21, s: 2, t: Ba }
21) { i: 22, s: 2, t: BA }
22) { i: 20, s: 2, t: Bz }
23) { i: 15, s: 2, t: BZ }
24) { i: 26, s: 2, t: ss }
25) { i: 27, s: 2, t: SS }
26) { i: 25, s: 1, t: ß }
27) { i: 30, s: 1, t: ß }
28) { i: 24, s: 2, t: st }
29) { i: 31, s: 2, t: st }
30) { i: 28, s: 2, t: St }
31) { i: 29, s: 2, t: ST }
*** Ctx ping count: 33
    [0](33): Sort(*1: T, *1.t)
###
> Sort(T, [<]  t)
Sort(T, [<] t) : {i:i8, s:u8, t:s}*
BndKind:Call, Type:{i:i8, s:u8, t:s}*, Bnd:(Call(∂.Sort([map:1] Global(T), [<] GetField(Scope(1), t))))
// (<ctx>, ∂.T:{i:i8, s:u8, t:s}*) : {i:i8, s:u8, t:s}*
Sort_1(Arr<obj>, {i8,u8,str}):str
      1) ldarg.1 [{i8,u8,str}]
      5) ldfld {i8,u8,str}::_F2:str
      1) ret
  Total Size: 7

top(Arr<obj>, Arr<obj>):obj
      1) ldarg.1 [Arr<obj>]
      1) ldc.i4.0
      1) ldelem.ref
      5) call static CodeGenUtil::ToRef(obj):ExecCtx
      1) stloc.0 [ExecCtx]
      1) ldarg.1 [Arr<obj>]
      1) ldc.i4.1
      1) ldelem.ref
      5) call static CodeGenUtil::ToRef(obj):Seq<{i8,u8,str}>
      1) stloc.1 [Seq<{i8,u8,str}>]
      1) ldloc.1 [Seq<{i8,u8,str}>]
      1) dup
      1) ldloc.0 [ExecCtx]
      1) ldc.i4.0
      5) call static CodeGenUtil::EnumerableToPinging(Seq<{i8,u8,str}>, ExecCtx, i4):Seq<{i8,u8,str}>
      1) ldarg.0 [Arr<obj>]
      1) ldc.i4.0
      5) ldelem [Func<{i8,u8,str},str>]
      1) ldarg.0 [Arr<obj>]
      1) ldc.i4.1
      5) ldelem [Func<str,str,i4>]
      5) call static CodeGenUtil::Sort(Seq<{i8,u8,str}>, Func<{i8,u8,str},str>, Func<str,str,i4>):Seq<{i8,u8,str}>
      5) call static CodeGenUtil::WrapWithCounter(Seq<{i8,u8,str}>, Seq<{i8,u8,str}>):Seq<{i8,u8,str}>
      5) call static CodeGenUtil::EnumerableToCaching(Seq<{i8,u8,str}>):Seq<{i8,u8,str}>
      1) ret
  Total Size: 57

Func sig: (<ctx>:x, T:{i:i8, s:u8, t:s}*) to {i:i8, s:u8, t:s}*
Sequence: Seq<{i8,u8,str}>
 0) { i: 13, s: 0, t: <null> }
 1) { i: 12, s: 0, t:  }
 2) { i: 11, s: 1, t:   }
 3) { i: 9, s: 1, t: 0 }
 4) { i: 10, s: 1, t: 9 }
 5) { i: 2, s: 1, t: a }
 6) { i: 1, s: 1, t: A }
 7) { i: 3, s: 1, t: A }
 8) { i: 6, s: 1, t: á }
 9) { i: 5, s: 1, t: Á }
10) { i: 8, s: 1, t: à }
11) { i: 7, s: 1, t: À }
12) { i: 17, s: 2, t: az }
13) { i: 23, s: 2, t: az }
14) { i: 18, s: 2, t: aZ }
15) { i: 19, s: 2, t: Az }
16) { i: 14, s: 2, t: AZ }
17) { i: 16, s: 2, t: AZ }
18) { i: 4, s: 1, t: b }
19) { i: 0, s: 1, t: B }
20) { i: 21, s: 2, t: Ba }
21) { i: 22, s: 2, t: BA }
22) { i: 20, s: 2, t: Bz }
23) { i: 15, s: 2, t: BZ }
24) { i: 26, s: 2, t: ss }
25) { i: 27, s: 2, t: SS }
26) { i: 25, s: 1, t: ß }
27) { i: 30, s: 1, t: ß }
28) { i: 24, s: 2, t: st }
29) { i: 31, s: 2, t: st }
30) { i: 28, s: 2, t: St }
31) { i: 29, s: 2, t: ST }
*** Ctx ping count: 33
    [0](33): Sort(*1: T, [<] *1.t)
###
> Sort(T, [>]  t)
Sort(T, [>] t) : {i:i8, s:u8, t:s}*
BndKind:Call, Type:{i:i8, s:u8, t:s}*, Bnd:(Call(∂.Sort([map:1] Global(T), [>] GetField(Scope(1), t))))
// (<ctx>, ∂.T:{i:i8, s:u8, t:s}*) : {i:i8, s:u8, t:s}*
Sort_1(Arr<obj>, {i8,u8,str}):str
      1) ldarg.1 [{i8,u8,str}]
      5) ldfld {i8,u8,str}::_F2:str
      1) ret
  Total Size: 7

top(Arr<obj>, Arr<obj>):obj
      1) ldarg.1 [Arr<obj>]
      1) ldc.i4.0
      1) ldelem.ref
      5) call static CodeGenUtil::ToRef(obj):ExecCtx
      1) stloc.0 [ExecCtx]
      1) ldarg.1 [Arr<obj>]
      1) ldc.i4.1
      1) ldelem.ref
      5) call static CodeGenUtil::ToRef(obj):Seq<{i8,u8,str}>
      1) stloc.1 [Seq<{i8,u8,str}>]
      1) ldloc.1 [Seq<{i8,u8,str}>]
      1) dup
      1) ldloc.0 [ExecCtx]
      1) ldc.i4.0
      5) call static CodeGenUtil::EnumerableToPinging(Seq<{i8,u8,str}>, ExecCtx, i4):Seq<{i8,u8,str}>
      1) ldarg.0 [Arr<obj>]
      1) ldc.i4.0
      5) ldelem [Func<{i8,u8,str},str>]
      1) ldarg.0 [Arr<obj>]
      1) ldc.i4.1
      5) ldelem [Func<str,str,i4>]
      5) call static CodeGenUtil::Sort(Seq<{i8,u8,str}>, Func<{i8,u8,str},str>, Func<str,str,i4>):Seq<{i8,u8,str}>
      5) call static CodeGenUtil::WrapWithCounter(Seq<{i8,u8,str}>, Seq<{i8,u8,str}>):Seq<{i8,u8,str}>
      5) call static CodeGenUtil::EnumerableToCaching(Seq<{i8,u8,str}>):Seq<{i8,u8,str}>
      1) ret
  Total Size: 57

Func sig: (<ctx>:x, T:{i:i8, s:u8, t:s}*) to {i:i8, s:u8, t:s}*
Sequence: Seq<{i8,u8,str}>
 0) { i: 29, s: 2, t: ST }
 1) { i: 28, s: 2, t: St }
 2) { i: 24, s: 2, t: st }
 3) { i: 31, s: 2, t: st }
 4) { i: 25, s: 1, t: ß }
 5) { i: 30, s: 1, t: ß }
 6) { i: 27, s: 2, t: SS }
 7) { i: 26, s: 2, t: ss }
 8) { i: 15, s: 2, t: BZ }
 9) { i: 20, s: 2, t: Bz }
10) { i: 22, s: 2, t: BA }
11) { i: 21, s: 2, t: Ba }
12) { i: 0, s: 1, t: B }
13) { i: 4, s: 1, t: b }
14) { i: 14, s: 2, t: AZ }
15) { i: 16, s: 2, t: AZ }
16) { i: 19, s: 2, t: Az }
17) { i: 18, s: 2, t: aZ }
18) { i: 17, s: 2, t: az }
19) { i: 23, s: 2, t: az }
20) { i: 7, s: 1, t: À }
21) { i: 8, s: 1, t: à }
22) { i: 5, s: 1, t: Á }
23) { i: 6, s: 1, t: á }
24) { i: 1, s: 1, t: A }
25) { i: 3, s: 1, t: A }
26) { i: 2, s: 1, t: a }
27) { i: 10, s: 1, t: 9 }
28) { i: 9, s: 1, t: 0 }
29) { i: 11, s: 1, t:   }
30) { i: 12, s: 0, t:  }
31) { i: 13, s: 0, t: <null> }
*** Ctx ping count: 33
    [0](33): Sort(*1: T, [>] *1.t)
###
> Sort(T, [~]  t)
Sort(T, [~] t) : {i:i8, s:u8, t:s}*
BndKind:Call, Type:{i:i8, s:u8, t:s}*, Bnd:(Call(∂.Sort([map:1] Global(T), [~] GetField(Scope(1), t))))
// (<ctx>, ∂.T:{i:i8, s:u8, t:s}*) : {i:i8, s:u8, t:s}*
Sort_1(Arr<obj>, {i8,u8,str}):str
      1) ldarg.1 [{i8,u8,str}]
      5) ldfld {i8,u8,str}::_F2:str
      1) ret
  Total Size: 7

top(Arr<obj>, Arr<obj>):obj
      1) ldarg.1 [Arr<obj>]
      1) ldc.i4.0
      1) ldelem.ref
      5) call static CodeGenUtil::ToRef(obj):ExecCtx
      1) stloc.0 [ExecCtx]
      1) ldarg.1 [Arr<obj>]
      1) ldc.i4.1
      1) ldelem.ref
      5) call static CodeGenUtil::ToRef(obj):Seq<{i8,u8,str}>
      1) stloc.1 [Seq<{i8,u8,str}>]
      1) ldloc.1 [Seq<{i8,u8,str}>]
      1) dup
      1) ldloc.0 [ExecCtx]
      1) ldc.i4.0
      5) call static CodeGenUtil::EnumerableToPinging(Seq<{i8,u8,str}>, ExecCtx, i4):Seq<{i8,u8,str}>
      1) ldarg.0 [Arr<obj>]
      1) ldc.i4.0
      5) ldelem [Func<{i8,u8,str},str>]
      1) ldarg.0 [Arr<obj>]
      1) ldc.i4.1
      5) ldelem [Func<str,str,i4>]
      5) call static CodeGenUtil::Sort(Seq<{i8,u8,str}>, Func<{i8,u8,str},str>, Func<str,str,i4>):Seq<{i8,u8,str}>
      5) call static CodeGenUtil::WrapWithCounter(Seq<{i8,u8,str}>, Seq<{i8,u8,str}>):Seq<{i8,u8,str}>
      5) call static CodeGenUtil::EnumerableToCaching(Seq<{i8,u8,str}>):Seq<{i8,u8,str}>
      1) ret
  Total Size: 57

Func sig: (<ctx>:x, T:{i:i8, s:u8, t:s}*) to {i:i8, s:u8, t:s}*
Sequence: Seq<{i8,u8,str}>
 0) { i: 13, s: 0, t: <null> }
 1) { i: 12, s: 0, t:  }
 2) { i: 11, s: 1, t:   }
 3) { i: 9, s: 1, t: 0 }
 4) { i: 10, s: 1, t: 9 }
 5) { i: 1, s: 1, t: A }
 6) { i: 2, s: 1, t: a }
 7) { i: 3, s: 1, t: A }
 8) { i: 5, s: 1, t: Á }
 9) { i: 6, s: 1, t: á }
10) { i: 7, s: 1, t: À }
11) { i: 8, s: 1, t: à }
12) { i: 14, s: 2, t: AZ }
13) { i: 16, s: 2, t: AZ }
14) { i: 17, s: 2, t: az }
15) { i: 18, s: 2, t: aZ }
16) { i: 19, s: 2, t: Az }
17) { i: 23, s: 2, t: az }
18) { i: 0, s: 1, t: B }
19) { i: 4, s: 1, t: b }
20) { i: 21, s: 2, t: Ba }
21) { i: 22, s: 2, t: BA }
22) { i: 15, s: 2, t: BZ }
23) { i: 20, s: 2, t: Bz }
24) { i: 26, s: 2, t: ss }
25) { i: 27, s: 2, t: SS }
26) { i: 25, s: 1, t: ß }
27) { i: 30, s: 1, t: ß }
28) { i: 24, s: 2, t: st }
29) { i: 28, s: 2, t: St }
30) { i: 29, s: 2, t: ST }
31) { i: 31, s: 2, t: st }
*** Ctx ping count: 33
    [0](33): Sort(*1: T, [~] *1.t)
###
> Sort(T, [~<] t)
Sort(T, [~<] t) : {i:i8, s:u8, t:s}*
BndKind:Call, Type:{i:i8, s:u8, t:s}*, Bnd:(Call(∂.Sort([map:1] Global(T), [~<] GetField(Scope(1), t))))
// (<ctx>, ∂.T:{i:i8, s:u8, t:s}*) : {i:i8, s:u8, t:s}*
Sort_1(Arr<obj>, {i8,u8,str}):str
      1) ldarg.1 [{i8,u8,str}]
      5) ldfld {i8,u8,str}::_F2:str
      1) ret
  Total Size: 7

top(Arr<obj>, Arr<obj>):obj
      1) ldarg.1 [Arr<obj>]
      1) ldc.i4.0
      1) ldelem.ref
      5) call static CodeGenUtil::ToRef(obj):ExecCtx
      1) stloc.0 [ExecCtx]
      1) ldarg.1 [Arr<obj>]
      1) ldc.i4.1
      1) ldelem.ref
      5) call static CodeGenUtil::ToRef(obj):Seq<{i8,u8,str}>
      1) stloc.1 [Seq<{i8,u8,str}>]
      1) ldloc.1 [Seq<{i8,u8,str}>]
      1) dup
      1) ldloc.0 [ExecCtx]
      1) ldc.i4.0
      5) call static CodeGenUtil::EnumerableToPinging(Seq<{i8,u8,str}>, ExecCtx, i4):Seq<{i8,u8,str}>
      1) ldarg.0 [Arr<obj>]
      1) ldc.i4.0
      5) ldelem [Func<{i8,u8,str},str>]
      1) ldarg.0 [Arr<obj>]
      1) ldc.i4.1
      5) ldelem [Func<str,str,i4>]
      5) call static CodeGenUtil::Sort(Seq<{i8,u8,str}>, Func<{i8,u8,str},str>, Func<str,str,i4>):Seq<{i8,u8,str}>
      5) call static CodeGenUtil::WrapWithCounter(Seq<{i8,u8,str}>, Seq<{i8,u8,str}>):Seq<{i8,u8,str}>
      5) call static CodeGenUtil::EnumerableToCaching(Seq<{i8,u8,str}>):Seq<{i8,u8,str}>
      1) ret
  Total Size: 57

Func sig: (<ctx>:x, T:{i:i8, s:u8, t:s}*) to {i:i8, s:u8, t:s}*
Sequence: Seq<{i8,u8,str}>
 0) { i: 13, s: 0, t: <null> }
 1) { i: 12, s: 0, t:  }
 2) { i: 11, s: 1, t:   }
 3) { i: 9, s: 1, t: 0 }
 4) { i: 10, s: 1, t: 9 }
 5) { i: 1, s: 1, t: A }
 6) { i: 2, s: 1, t: a }
 7) { i: 3, s: 1, t: A }
 8) { i: 5, s: 1, t: Á }
 9) { i: 6, s: 1, t: á }
10) { i: 7, s: 1, t: À }
11) { i: 8, s: 1, t: à }
12) { i: 14, s: 2, t: AZ }
13) { i: 16, s: 2, t: AZ }
14) { i: 17, s: 2, t: az }
15) { i: 18, s: 2, t: aZ }
16) { i: 19, s: 2, t: Az }
17) { i: 23, s: 2, t: az }
18) { i: 0, s: 1, t: B }
19) { i: 4, s: 1, t: b }
20) { i: 21, s: 2, t: Ba }
21) { i: 22, s: 2, t: BA }
22) { i: 15, s: 2, t: BZ }
23) { i: 20, s: 2, t: Bz }
24) { i: 26, s: 2, t: ss }
25) { i: 27, s: 2, t: SS }
26) { i: 25, s: 1, t: ß }
27) { i: 30, s: 1, t: ß }
28) { i: 24, s: 2, t: st }
29) { i: 28, s: 2, t: St }
30) { i: 29, s: 2, t: ST }
31) { i: 31, s: 2, t: st }
*** Ctx ping count: 33
    [0](33): Sort(*1: T, [~<] *1.t)
###
> Sort(T, [~>] t)
Sort(T, [~>] t) : {i:i8, s:u8, t:s}*
BndKind:Call, Type:{i:i8, s:u8, t:s}*, Bnd:(Call(∂.Sort([map:1] Global(T), [~>] GetField(Scope(1), t))))
// (<ctx>, ∂.T:{i:i8, s:u8, t:s}*) : {i:i8, s:u8, t:s}*
Sort_1(Arr<obj>, {i8,u8,str}):str
      1) ldarg.1 [{i8,u8,str}]
      5) ldfld {i8,u8,str}::_F2:str
      1) ret
  Total Size: 7

top(Arr<obj>, Arr<obj>):obj
      1) ldarg.1 [Arr<obj>]
      1) ldc.i4.0
      1) ldelem.ref
      5) call static CodeGenUtil::ToRef(obj):ExecCtx
      1) stloc.0 [ExecCtx]
      1) ldarg.1 [Arr<obj>]
      1) ldc.i4.1
      1) ldelem.ref
      5) call static CodeGenUtil::ToRef(obj):Seq<{i8,u8,str}>
      1) stloc.1 [Seq<{i8,u8,str}>]
      1) ldloc.1 [Seq<{i8,u8,str}>]
      1) dup
      1) ldloc.0 [ExecCtx]
      1) ldc.i4.0
      5) call static CodeGenUtil::EnumerableToPinging(Seq<{i8,u8,str}>, ExecCtx, i4):Seq<{i8,u8,str}>
      1) ldarg.0 [Arr<obj>]
      1) ldc.i4.0
      5) ldelem [Func<{i8,u8,str},str>]
      1) ldarg.0 [Arr<obj>]
      1) ldc.i4.1
      5) ldelem [Func<str,str,i4>]
      5) call static CodeGenUtil::Sort(Seq<{i8,u8,str}>, Func<{i8,u8,str},str>, Func<str,str,i4>):Seq<{i8,u8,str}>
      5) call static CodeGenUtil::WrapWithCounter(Seq<{i8,u8,str}>, Seq<{i8,u8,str}>):Seq<{i8,u8,str}>
      5) call static CodeGenUtil::EnumerableToCaching(Seq<{i8,u8,str}>):Seq<{i8,u8,str}>
      1) ret
  Total Size: 57

Func sig: (<ctx>:x, T:{i:i8, s:u8, t:s}*) to {i:i8, s:u8, t:s}*
Sequence: Seq<{i8,u8,str}>
 0) { i: 24, s: 2, t: st }
 1) { i: 28, s: 2, t: St }
 2) { i: 29, s: 2, t: ST }
 3) { i: 31, s: 2, t: st }
 4) { i: 25, s: 1, t: ß }
 5) { i: 30, s: 1, t: ß }
 6) { i: 26, s: 2, t: ss }
 7) { i: 27, s: 2, t: SS }
 8) { i: 15, s: 2, t: BZ }
 9) { i: 20, s: 2, t: Bz }
10) { i: 21, s: 2, t: Ba }
11) { i: 22, s: 2, t: BA }
12) { i: 0, s: 1, t: B }
13) { i: 4, s: 1, t: b }
14) { i: 14, s: 2, t: AZ }
15) { i: 16, s: 2, t: AZ }
16) { i: 17, s: 2, t: az }
17) { i: 18, s: 2, t: aZ }
18) { i: 19, s: 2, t: Az }
19) { i: 23, s: 2, t: az }
20) { i: 7, s: 1, t: À }
21) { i: 8, s: 1, t: à }
22) { i: 5, s: 1, t: Á }
23) { i: 6, s: 1, t: á }
24) { i: 1, s: 1, t: A }
25) { i: 2, s: 1, t: a }
26) { i: 3, s: 1, t: A }
27) { i: 10, s: 1, t: 9 }
28) { i: 9, s: 1, t: 0 }
29) { i: 11, s: 1, t:   }
30) { i: 12, s: 0, t:  }
31) { i: 13, s: 0, t: <null> }
*** Ctx ping count: 33
    [0](33): Sort(*1: T, [~>] *1.t)
###
> Sort(T,      t, [>] i)
Sort(T, t, [>] i) : {i:i8, s:u8, t:s}*
BndKind:Call, Type:{i:i8, s:u8, t:s}*, Bnd:(Call(∂.Sort([map:1] Global(T), GetField(Scope(1), t), [>] GetField(Scope(1), i))))
// (<ctx>, ∂.T:{i:i8, s:u8, t:s}*) : {i:i8, s:u8, t:s}*
SortCompare(Arr<obj>, {i8,u8,str}, {i8,u8,str}):i4
      1) ldarg.1 [{i8,u8,str}]
      5) ldfld {i8,u8,str}::_F2:str
      1) ldarg.2 [{i8,u8,str}]
      5) ldfld {i8,u8,str}::_F2:str
      5) call static Cmp::Compare(str, str):i4
      1) dup
      5) brtrue [0]
      1) pop
      1) ldarg.2 [{i8,u8,str}]
      5) ldfld {i8,u8,str}::_F0:i8
      1) ldarg.1 [{i8,u8,str}]
      5) ldfld {i8,u8,str}::_F0:i8
      5) call static Cmp::Compare(i8, i8):i4
  Label [0]:
      1) ret
  Total Size: 42

top(Arr<obj>, Arr<obj>):obj
      1) ldarg.1 [Arr<obj>]
      1) ldc.i4.0
      1) ldelem.ref
      5) call static CodeGenUtil::ToRef(obj):ExecCtx
      1) stloc.0 [ExecCtx]
      1) ldarg.1 [Arr<obj>]
      1) ldc.i4.1
      1) ldelem.ref
      5) call static CodeGenUtil::ToRef(obj):Seq<{i8,u8,str}>
      1) stloc.1 [Seq<{i8,u8,str}>]
      1) ldloc.1 [Seq<{i8,u8,str}>]
      1) dup
      1) ldloc.0 [ExecCtx]
      1) ldc.i4.0
      5) call static CodeGenUtil::EnumerableToPinging(Seq<{i8,u8,str}>, ExecCtx, i4):Seq<{i8,u8,str}>
      1) ldarg.0 [Arr<obj>]
      1) ldc.i4.0
      5) ldelem [Func<{i8,u8,str},{i8,u8,str},i4>]
      5) call static CodeGenUtil::SortNoKey(Seq<{i8,u8,str}>, Func<{i8,u8,str},{i8,u8,str},i4>):Seq<{i8,u8,str}>
      5) call static CodeGenUtil::WrapWithCounter(Seq<{i8,u8,str}>, Seq<{i8,u8,str}>):Seq<{i8,u8,str}>
      5) call static CodeGenUtil::EnumerableToCaching(Seq<{i8,u8,str}>):Seq<{i8,u8,str}>
      1) ret
  Total Size: 50

Func sig: (<ctx>:x, T:{i:i8, s:u8, t:s}*) to {i:i8, s:u8, t:s}*
Sequence: Seq<{i8,u8,str}>
 0) { i: 13, s: 0, t: <null> }
 1) { i: 12, s: 0, t:  }
 2) { i: 11, s: 1, t:   }
 3) { i: 9, s: 1, t: 0 }
 4) { i: 10, s: 1, t: 9 }
 5) { i: 2, s: 1, t: a }
 6) { i: 3, s: 1, t: A }
 7) { i: 1, s: 1, t: A }
 8) { i: 6, s: 1, t: á }
 9) { i: 5, s: 1, t: Á }
10) { i: 8, s: 1, t: à }
11) { i: 7, s: 1, t: À }
12) { i: 23, s: 2, t: az }
13) { i: 17, s: 2, t: az }
14) { i: 18, s: 2, t: aZ }
15) { i: 19, s: 2, t: Az }
16) { i: 16, s: 2, t: AZ }
17) { i: 14, s: 2, t: AZ }
18) { i: 4, s: 1, t: b }
19) { i: 0, s: 1, t: B }
20) { i: 21, s: 2, t: Ba }
21) { i: 22, s: 2, t: BA }
22) { i: 20, s: 2, t: Bz }
23) { i: 15, s: 2, t: BZ }
24) { i: 26, s: 2, t: ss }
25) { i: 27, s: 2, t: SS }
26) { i: 30, s: 1, t: ß }
27) { i: 25, s: 1, t: ß }
28) { i: 31, s: 2, t: st }
29) { i: 24, s: 2, t: st }
30) { i: 28, s: 2, t: St }
31) { i: 29, s: 2, t: ST }
*** Ctx ping count: 33
    [0](33): Sort(*1: T, *1.t, [>] *1.i)
###
> Sort(T, [<]  t, [>] i)
Sort(T, [<] t, [>] i) : {i:i8, s:u8, t:s}*
BndKind:Call, Type:{i:i8, s:u8, t:s}*, Bnd:(Call(∂.Sort([map:1] Global(T), [<] GetField(Scope(1), t), [>] GetField(Scope(1), i))))
// (<ctx>, ∂.T:{i:i8, s:u8, t:s}*) : {i:i8, s:u8, t:s}*
SortCompare(Arr<obj>, {i8,u8,str}, {i8,u8,str}):i4
      1) ldarg.1 [{i8,u8,str}]
      5) ldfld {i8,u8,str}::_F2:str
      1) ldarg.2 [{i8,u8,str}]
      5) ldfld {i8,u8,str}::_F2:str
      5) call static Cmp::Compare(str, str):i4
      1) dup
      5) brtrue [0]
      1) pop
      1) ldarg.2 [{i8,u8,str}]
      5) ldfld {i8,u8,str}::_F0:i8
      1) ldarg.1 [{i8,u8,str}]
      5) ldfld {i8,u8,str}::_F0:i8
      5) call static Cmp::Compare(i8, i8):i4
  Label [0]:
      1) ret
  Total Size: 42

top(Arr<obj>, Arr<obj>):obj
      1) ldarg.1 [Arr<obj>]
      1) ldc.i4.0
      1) ldelem.ref
      5) call static CodeGenUtil::ToRef(obj):ExecCtx
      1) stloc.0 [ExecCtx]
      1) ldarg.1 [Arr<obj>]
      1) ldc.i4.1
      1) ldelem.ref
      5) call static CodeGenUtil::ToRef(obj):Seq<{i8,u8,str}>
      1) stloc.1 [Seq<{i8,u8,str}>]
      1) ldloc.1 [Seq<{i8,u8,str}>]
      1) dup
      1) ldloc.0 [ExecCtx]
      1) ldc.i4.0
      5) call static CodeGenUtil::EnumerableToPinging(Seq<{i8,u8,str}>, ExecCtx, i4):Seq<{i8,u8,str}>
      1) ldarg.0 [Arr<obj>]
      1) ldc.i4.0
      5) ldelem [Func<{i8,u8,str},{i8,u8,str},i4>]
      5) call static CodeGenUtil::SortNoKey(Seq<{i8,u8,str}>, Func<{i8,u8,str},{i8,u8,str},i4>):Seq<{i8,u8,str}>
      5) call static CodeGenUtil::WrapWithCounter(Seq<{i8,u8,str}>, Seq<{i8,u8,str}>):Seq<{i8,u8,str}>
      5) call static CodeGenUtil::EnumerableToCaching(Seq<{i8,u8,str}>):Seq<{i8,u8,str}>
      1) ret
  Total Size: 50

Func sig: (<ctx>:x, T:{i:i8, s:u8, t:s}*) to {i:i8, s:u8, t:s}*
Sequence: Seq<{i8,u8,str}>
 0) { i: 13, s: 0, t: <null> }
 1) { i: 12, s: 0, t:  }
 2) { i: 11, s: 1, t:   }
 3) { i: 9, s: 1, t: 0 }
 4) { i: 10, s: 1, t: 9 }
 5) { i: 2, s: 1, t: a }
 6) { i: 3, s: 1, t: A }
 7) { i: 1, s: 1, t: A }
 8) { i: 6, s: 1, t: á }
 9) { i: 5, s: 1, t: Á }
10) { i: 8, s: 1, t: à }
11) { i: 7, s: 1, t: À }
12) { i: 23, s: 2, t: az }
13) { i: 17, s: 2, t: az }
14) { i: 18, s: 2, t: aZ }
15) { i: 19, s: 2, t: Az }
16) { i: 16, s: 2, t: AZ }
17) { i: 14, s: 2, t: AZ }
18) { i: 4, s: 1, t: b }
19) { i: 0, s: 1, t: B }
20) { i: 21, s: 2, t: Ba }
21) { i: 22, s: 2, t: BA }
22) { i: 20, s: 2, t: Bz }
23) { i: 15, s: 2, t: BZ }
24) { i: 26, s: 2, t: ss }
25) { i: 27, s: 2, t: SS }
26) { i: 30, s: 1, t: ß }
27) { i: 25, s: 1, t: ß }
28) { i: 31, s: 2, t: st }
29) { i: 24, s: 2, t: st }
30) { i: 28, s: 2, t: St }
31) { i: 29, s: 2, t: ST }
*** Ctx ping count: 33
    [0](33): Sort(*1: T, [<] *1.t, [>] *1.i)
###
> Sort(T, [>]  t, [>] i)
Sort(T, [>] t, [>] i) : {i:i8, s:u8, t:s}*
BndKind:Call, Type:{i:i8, s:u8, t:s}*, Bnd:(Call(∂.Sort([map:1] Global(T), [>] GetField(Scope(1), t), [>] GetField(Scope(1), i))))
// (<ctx>, ∂.T:{i:i8, s:u8, t:s}*) : {i:i8, s:u8, t:s}*
SortCompare(Arr<obj>, {i8,u8,str}, {i8,u8,str}):i4
      1) ldarg.2 [{i8,u8,str}]
      5) ldfld {i8,u8,str}::_F2:str
      1) ldarg.1 [{i8,u8,str}]
      5) ldfld {i8,u8,str}::_F2:str
      5) call static Cmp::Compare(str, str):i4
      1) dup
      5) brtrue [0]
      1) pop
      1) ldarg.2 [{i8,u8,str}]
      5) ldfld {i8,u8,str}::_F0:i8
      1) ldarg.1 [{i8,u8,str}]
      5) ldfld {i8,u8,str}::_F0:i8
      5) call static Cmp::Compare(i8, i8):i4
  Label [0]:
      1) ret
  Total Size: 42

top(Arr<obj>, Arr<obj>):obj
      1) ldarg.1 [Arr<obj>]
      1) ldc.i4.0
      1) ldelem.ref
      5) call static CodeGenUtil::ToRef(obj):ExecCtx
      1) stloc.0 [ExecCtx]
      1) ldarg.1 [Arr<obj>]
      1) ldc.i4.1
      1) ldelem.ref
      5) call static CodeGenUtil::ToRef(obj):Seq<{i8,u8,str}>
      1) stloc.1 [Seq<{i8,u8,str}>]
      1) ldloc.1 [Seq<{i8,u8,str}>]
      1) dup
      1) ldloc.0 [ExecCtx]
      1) ldc.i4.0
      5) call static CodeGenUtil::EnumerableToPinging(Seq<{i8,u8,str}>, ExecCtx, i4):Seq<{i8,u8,str}>
      1) ldarg.0 [Arr<obj>]
      1) ldc.i4.0
      5) ldelem [Func<{i8,u8,str},{i8,u8,str},i4>]
      5) call static CodeGenUtil::SortNoKey(Seq<{i8,u8,str}>, Func<{i8,u8,str},{i8,u8,str},i4>):Seq<{i8,u8,str}>
      5) call static CodeGenUtil::WrapWithCounter(Seq<{i8,u8,str}>, Seq<{i8,u8,str}>):Seq<{i8,u8,str}>
      5) call static CodeGenUtil::EnumerableToCaching(Seq<{i8,u8,str}>):Seq<{i8,u8,str}>
      1) ret
  Total Size: 50

Func sig: (<ctx>:x, T:{i:i8, s:u8, t:s}*) to {i:i8, s:u8, t:s}*
Sequence: Seq<{i8,u8,str}>
 0) { i: 29, s: 2, t: ST }
 1) { i: 28, s: 2, t: St }
 2) { i: 31, s: 2, t: st }
 3) { i: 24, s: 2, t: st }
 4) { i: 30, s: 1, t: ß }
 5) { i: 25, s: 1, t: ß }
 6) { i: 27, s: 2, t: SS }
 7) { i: 26, s: 2, t: ss }
 8) { i: 15, s: 2, t: BZ }
 9) { i: 20, s: 2, t: Bz }
10) { i: 22, s: 2, t: BA }
11) { i: 21, s: 2, t: Ba }
12) { i: 0, s: 1, t: B }
13) { i: 4, s: 1, t: b }
14) { i: 16, s: 2, t: AZ }
15) { i: 14, s: 2, t: AZ }
16) { i: 19, s: 2, t: Az }
17) { i: 18, s: 2, t: aZ }
18) { i: 23, s: 2, t: az }
19) { i: 17, s: 2, t: az }
20) { i: 7, s: 1, t: À }
21) { i: 8, s: 1, t: à }
22) { i: 5, s: 1, t: Á }
23) { i: 6, s: 1, t: á }
24) { i: 3, s: 1, t: A }
25) { i: 1, s: 1, t: A }
26) { i: 2, s: 1, t: a }
27) { i: 10, s: 1, t: 9 }
28) { i: 9, s: 1, t: 0 }
29) { i: 11, s: 1, t:   }
30) { i: 12, s: 0, t:  }
31) { i: 13, s: 0, t: <null> }
*** Ctx ping count: 33
    [0](33): Sort(*1: T, [>] *1.t, [>] *1.i)
###
> Sort(T, [~]  t, [>] i)
Sort(T, [~] t, [>] i) : {i:i8, s:u8, t:s}*
BndKind:Call, Type:{i:i8, s:u8, t:s}*, Bnd:(Call(∂.Sort([map:1] Global(T), [~] GetField(Scope(1), t), [>] GetField(Scope(1), i))))
// (<ctx>, ∂.T:{i:i8, s:u8, t:s}*) : {i:i8, s:u8, t:s}*
SortCompare(Arr<obj>, {i8,u8,str}, {i8,u8,str}):i4
      1) ldarg.1 [{i8,u8,str}]
      5) ldfld {i8,u8,str}::_F2:str
      1) ldarg.2 [{i8,u8,str}]
      5) ldfld {i8,u8,str}::_F2:str
      5) call static Cmp::CompareCi(str, str):i4
      1) dup
      5) brtrue [0]
      1) pop
      1) ldarg.2 [{i8,u8,str}]
      5) ldfld {i8,u8,str}::_F0:i8
      1) ldarg.1 [{i8,u8,str}]
      5) ldfld {i8,u8,str}::_F0:i8
      5) call static Cmp::Compare(i8, i8):i4
  Label [0]:
      1) ret
  Total Size: 42

top(Arr<obj>, Arr<obj>):obj
      1) ldarg.1 [Arr<obj>]
      1) ldc.i4.0
      1) ldelem.ref
      5) call static CodeGenUtil::ToRef(obj):ExecCtx
      1) stloc.0 [ExecCtx]
      1) ldarg.1 [Arr<obj>]
      1) ldc.i4.1
      1) ldelem.ref
      5) call static CodeGenUtil::ToRef(obj):Seq<{i8,u8,str}>
      1) stloc.1 [Seq<{i8,u8,str}>]
      1) ldloc.1 [Seq<{i8,u8,str}>]
      1) dup
      1) ldloc.0 [ExecCtx]
      1) ldc.i4.0
      5) call static CodeGenUtil::EnumerableToPinging(Seq<{i8,u8,str}>, ExecCtx, i4):Seq<{i8,u8,str}>
      1) ldarg.0 [Arr<obj>]
      1) ldc.i4.0
      5) ldelem [Func<{i8,u8,str},{i8,u8,str},i4>]
      5) call static CodeGenUtil::SortNoKey(Seq<{i8,u8,str}>, Func<{i8,u8,str},{i8,u8,str},i4>):Seq<{i8,u8,str}>
      5) call static CodeGenUtil::WrapWithCounter(Seq<{i8,u8,str}>, Seq<{i8,u8,str}>):Seq<{i8,u8,str}>
      5) call static CodeGenUtil::EnumerableToCaching(Seq<{i8,u8,str}>):Seq<{i8,u8,str}>
      1) ret
  Total Size: 50

Func sig: (<ctx>:x, T:{i:i8, s:u8, t:s}*) to {i:i8, s:u8, t:s}*
Sequence: Seq<{i8,u8,str}>
 0) { i: 13, s: 0, t: <null> }
 1) { i: 12, s: 0, t:  }
 2) { i: 11, s: 1, t:   }
 3) { i: 9, s: 1, t: 0 }
 4) { i: 10, s: 1, t: 9 }
 5) { i: 3, s: 1, t: A }
 6) { i: 2, s: 1, t: a }
 7) { i: 1, s: 1, t: A }
 8) { i: 6, s: 1, t: á }
 9) { i: 5, s: 1, t: Á }
10) { i: 8, s: 1, t: à }
11) { i: 7, s: 1, t: À }
12) { i: 23, s: 2, t: az }
13) { i: 19, s: 2, t: Az }
14) { i: 18, s: 2, t: aZ }
15) { i: 17, s: 2, t: az }
16) { i: 16, s: 2, t: AZ }
17) { i: 14, s: 2, t: AZ }
18) { i: 4, s: 1, t: b }
19) { i: 0, s: 1, t: B }
20) { i: 22, s: 2, t: BA }
21) { i: 21, s: 2, t: Ba }
22) { i: 20, s: 2, t: Bz }
23) { i: 15, s: 2, t: BZ }
24) { i: 27, s: 2, t: SS }
25) { i: 26, s: 2, t: ss }
26) { i: 30, s: 1, t: ß }
27) { i: 25, s: 1, t: ß }
28) { i: 31, s: 2, t: st }
29) { i: 29, s: 2, t: ST }
30) { i: 28, s: 2, t: St }
31) { i: 24, s: 2, t: st }
*** Ctx ping count: 33
    [0](33): Sort(*1: T, [~] *1.t, [>] *1.i)
###
> Sort(T, [~<] t, [>] i)
Sort(T, [~<] t, [>] i) : {i:i8, s:u8, t:s}*
BndKind:Call, Type:{i:i8, s:u8, t:s}*, Bnd:(Call(∂.Sort([map:1] Global(T), [~<] GetField(Scope(1), t), [>] GetField(Scope(1), i))))
// (<ctx>, ∂.T:{i:i8, s:u8, t:s}*) : {i:i8, s:u8, t:s}*
SortCompare(Arr<obj>, {i8,u8,str}, {i8,u8,str}):i4
      1) ldarg.1 [{i8,u8,str}]
      5) ldfld {i8,u8,str}::_F2:str
      1) ldarg.2 [{i8,u8,str}]
      5) ldfld {i8,u8,str}::_F2:str
      5) call static Cmp::CompareCi(str, str):i4
      1) dup
      5) brtrue [0]
      1) pop
      1) ldarg.2 [{i8,u8,str}]
      5) ldfld {i8,u8,str}::_F0:i8
      1) ldarg.1 [{i8,u8,str}]
      5) ldfld {i8,u8,str}::_F0:i8
      5) call static Cmp::Compare(i8, i8):i4
  Label [0]:
      1) ret
  Total Size: 42

top(Arr<obj>, Arr<obj>):obj
      1) ldarg.1 [Arr<obj>]
      1) ldc.i4.0
      1) ldelem.ref
      5) call static CodeGenUtil::ToRef(obj):ExecCtx
      1) stloc.0 [ExecCtx]
      1) ldarg.1 [Arr<obj>]
      1) ldc.i4.1
      1) ldelem.ref
      5) call static CodeGenUtil::ToRef(obj):Seq<{i8,u8,str}>
      1) stloc.1 [Seq<{i8,u8,str}>]
      1) ldloc.1 [Seq<{i8,u8,str}>]
      1) dup
      1) ldloc.0 [ExecCtx]
      1) ldc.i4.0
      5) call static CodeGenUtil::EnumerableToPinging(Seq<{i8,u8,str}>, ExecCtx, i4):Seq<{i8,u8,str}>
      1) ldarg.0 [Arr<obj>]
      1) ldc.i4.0
      5) ldelem [Func<{i8,u8,str},{i8,u8,str},i4>]
      5) call static CodeGenUtil::SortNoKey(Seq<{i8,u8,str}>, Func<{i8,u8,str},{i8,u8,str},i4>):Seq<{i8,u8,str}>
      5) call static CodeGenUtil::WrapWithCounter(Seq<{i8,u8,str}>, Seq<{i8,u8,str}>):Seq<{i8,u8,str}>
      5) call static CodeGenUtil::EnumerableToCaching(Seq<{i8,u8,str}>):Seq<{i8,u8,str}>
      1) ret
  Total Size: 50

Func sig: (<ctx>:x, T:{i:i8, s:u8, t:s}*) to {i:i8, s:u8, t:s}*
Sequence: Seq<{i8,u8,str}>
 0) { i: 13, s: 0, t: <null> }
 1) { i: 12, s: 0, t:  }
 2) { i: 11, s: 1, t:   }
 3) { i: 9, s: 1, t: 0 }
 4) { i: 10, s: 1, t: 9 }
 5) { i: 3, s: 1, t: A }
 6) { i: 2, s: 1, t: a }
 7) { i: 1, s: 1, t: A }
 8) { i: 6, s: 1, t: á }
 9) { i: 5, s: 1, t: Á }
10) { i: 8, s: 1, t: à }
11) { i: 7, s: 1, t: À }
12) { i: 23, s: 2, t: az }
13) { i: 19, s: 2, t: Az }
14) { i: 18, s: 2, t: aZ }
15) { i: 17, s: 2, t: az }
16) { i: 16, s: 2, t: AZ }
17) { i: 14, s: 2, t: AZ }
18) { i: 4, s: 1, t: b }
19) { i: 0, s: 1, t: B }
20) { i: 22, s: 2, t: BA }
21) { i: 21, s: 2, t: Ba }
22) { i: 20, s: 2, t: Bz }
23) { i: 15, s: 2, t: BZ }
24) { i: 27, s: 2, t: SS }
25) { i: 26, s: 2, t: ss }
26) { i: 30, s: 1, t: ß }
27) { i: 25, s: 1, t: ß }
28) { i: 31, s: 2, t: st }
29) { i: 29, s: 2, t: ST }
30) { i: 28, s: 2, t: St }
31) { i: 24, s: 2, t: st }
*** Ctx ping count: 33
    [0](33): Sort(*1: T, [~<] *1.t, [>] *1.i)
###
> Sort(T, [~>] t, [>] i)
Sort(T, [~>] t, [>] i) : {i:i8, s:u8, t:s}*
BndKind:Call, Type:{i:i8, s:u8, t:s}*, Bnd:(Call(∂.Sort([map:1] Global(T), [~>] GetField(Scope(1), t), [>] GetField(Scope(1), i))))
// (<ctx>, ∂.T:{i:i8, s:u8, t:s}*) : {i:i8, s:u8, t:s}*
SortCompare(Arr<obj>, {i8,u8,str}, {i8,u8,str}):i4
      1) ldarg.2 [{i8,u8,str}]
      5) ldfld {i8,u8,str}::_F2:str
      1) ldarg.1 [{i8,u8,str}]
      5) ldfld {i8,u8,str}::_F2:str
      5) call static Cmp::CompareCi(str, str):i4
      1) dup
      5) brtrue [0]
      1) pop
      1) ldarg.2 [{i8,u8,str}]
      5) ldfld {i8,u8,str}::_F0:i8
      1) ldarg.1 [{i8,u8,str}]
      5) ldfld {i8,u8,str}::_F0:i8
      5) call static Cmp::Compare(i8, i8):i4
  Label [0]:
      1) ret
  Total Size: 42

top(Arr<obj>, Arr<obj>):obj
      1) ldarg.1 [Arr<obj>]
      1) ldc.i4.0
      1) ldelem.ref
      5) call static CodeGenUtil::ToRef(obj):ExecCtx
      1) stloc.0 [ExecCtx]
      1) ldarg.1 [Arr<obj>]
      1) ldc.i4.1
      1) ldelem.ref
      5) call static CodeGenUtil::ToRef(obj):Seq<{i8,u8,str}>
      1) stloc.1 [Seq<{i8,u8,str}>]
      1) ldloc.1 [Seq<{i8,u8,str}>]
      1) dup
      1) ldloc.0 [ExecCtx]
      1) ldc.i4.0
      5) call static CodeGenUtil::EnumerableToPinging(Seq<{i8,u8,str}>, ExecCtx, i4):Seq<{i8,u8,str}>
      1) ldarg.0 [Arr<obj>]
      1) ldc.i4.0
      5) ldelem [Func<{i8,u8,str},{i8,u8,str},i4>]
      5) call static CodeGenUtil::SortNoKey(Seq<{i8,u8,str}>, Func<{i8,u8,str},{i8,u8,str},i4>):Seq<{i8,u8,str}>
      5) call static CodeGenUtil::WrapWithCounter(Seq<{i8,u8,str}>, Seq<{i8,u8,str}>):Seq<{i8,u8,str}>
      5) call static CodeGenUtil::EnumerableToCaching(Seq<{i8,u8,str}>):Seq<{i8,u8,str}>
      1) ret
  Total Size: 50

Func sig: (<ctx>:x, T:{i:i8, s:u8, t:s}*) to {i:i8, s:u8, t:s}*
Sequence: Seq<{i8,u8,str}>
 0) { i: 31, s: 2, t: st }
 1) { i: 29, s: 2, t: ST }
 2) { i: 28, s: 2, t: St }
 3) { i: 24, s: 2, t: st }
 4) { i: 30, s: 1, t: ß }
 5) { i: 25, s: 1, t: ß }
 6) { i: 27, s: 2, t: SS }
 7) { i: 26, s: 2, t: ss }
 8) { i: 20, s: 2, t: Bz }
 9) { i: 15, s: 2, t: BZ }
10) { i: 22, s: 2, t: BA }
11) { i: 21, s: 2, t: Ba }
12) { i: 4, s: 1, t: b }
13) { i: 0, s: 1, t: B }
14) { i: 23, s: 2, t: az }
15) { i: 19, s: 2, t: Az }
16) { i: 18, s: 2, t: aZ }
17) { i: 17, s: 2, t: az }
18) { i: 16, s: 2, t: AZ }
19) { i: 14, s: 2, t: AZ }
20) { i: 8, s: 1, t: à }
21) { i: 7, s: 1, t: À }
22) { i: 6, s: 1, t: á }
23) { i: 5, s: 1, t: Á }
24) { i: 3, s: 1, t: A }
25) { i: 2, s: 1, t: a }
26) { i: 1, s: 1, t: A }
27) { i: 10, s: 1, t: 9 }
28) { i: 9, s: 1, t: 0 }
29) { i: 11, s: 1, t:   }
30) { i: 12, s: 0, t:  }
31) { i: 13, s: 0, t: <null> }
*** Ctx ping count: 33
    [0](33): Sort(*1: T, [~>] *1.t, [>] *1.i)
###
> Sort(T, [<] s,      t)
Sort(T, [<] s, t) : {i:i8, s:u8, t:s}*
BndKind:Call, Type:{i:i8, s:u8, t:s}*, Bnd:(Call(∂.Sort([map:1] Global(T), [<] GetField(Scope(1), s), GetField(Scope(1), t))))
// (<ctx>, ∂.T:{i:i8, s:u8, t:s}*) : {i:i8, s:u8, t:s}*
SortCompare(Arr<obj>, {i8,u8,str}, {i8,u8,str}):i4
      1) ldarg.1 [{i8,u8,str}]
      5) ldfld {i8,u8,str}::_F1:u8
      1) ldarg.2 [{i8,u8,str}]
      5) ldfld {i8,u8,str}::_F1:u8
      5) call static Cmp::Compare(u8, u8):i4
      1) dup
      5) brtrue [0]
      1) pop
      1) ldarg.1 [{i8,u8,str}]
      5) ldfld {i8,u8,str}::_F2:str
      1) ldarg.2 [{i8,u8,str}]
      5) ldfld {i8,u8,str}::_F2:str
      5) call static Cmp::Compare(str, str):i4
  Label [0]:
      1) ret
  Total Size: 42

top(Arr<obj>, Arr<obj>):obj
      1) ldarg.1 [Arr<obj>]
      1) ldc.i4.0
      1) ldelem.ref
      5) call static CodeGenUtil::ToRef(obj):ExecCtx
      1) stloc.0 [ExecCtx]
      1) ldarg.1 [Arr<obj>]
      1) ldc.i4.1
      1) ldelem.ref
      5) call static CodeGenUtil::ToRef(obj):Seq<{i8,u8,str}>
      1) stloc.1 [Seq<{i8,u8,str}>]
      1) ldloc.1 [Seq<{i8,u8,str}>]
      1) dup
      1) ldloc.0 [ExecCtx]
      1) ldc.i4.0
      5) call static CodeGenUtil::EnumerableToPinging(Seq<{i8,u8,str}>, ExecCtx, i4):Seq<{i8,u8,str}>
      1) ldarg.0 [Arr<obj>]
      1) ldc.i4.0
      5) ldelem [Func<{i8,u8,str},{i8,u8,str},i4>]
      5) call static CodeGenUtil::SortNoKey(Seq<{i8,u8,str}>, Func<{i8,u8,str},{i8,u8,str},i4>):Seq<{i8,u8,str}>
      5) call static CodeGenUtil::WrapWithCounter(Seq<{i8,u8,str}>, Seq<{i8,u8,str}>):Seq<{i8,u8,str}>
      5) call static CodeGenUtil::EnumerableToCaching(Seq<{i8,u8,str}>):Seq<{i8,u8,str}>
      1) ret
  Total Size: 50

Func sig: (<ctx>:x, T:{i:i8, s:u8, t:s}*) to {i:i8, s:u8, t:s}*
Sequence: Seq<{i8,u8,str}>
 0) { i: 13, s: 0, t: <null> }
 1) { i: 12, s: 0, t:  }
 2) { i: 11, s: 1, t:   }
 3) { i: 9, s: 1, t: 0 }
 4) { i: 10, s: 1, t: 9 }
 5) { i: 2, s: 1, t: a }
 6) { i: 1, s: 1, t: A }
 7) { i: 3, s: 1, t: A }
 8) { i: 6, s: 1, t: á }
 9) { i: 5, s: 1, t: Á }
10) { i: 8, s: 1, t: à }
11) { i: 7, s: 1, t: À }
12) { i: 4, s: 1, t: b }
13) { i: 0, s: 1, t: B }
14) { i: 25, s: 1, t: ß }
15) { i: 30, s: 1, t: ß }
16) { i: 17, s: 2, t: az }
17) { i: 23, s: 2, t: az }
18) { i: 18, s: 2, t: aZ }
19) { i: 19, s: 2, t: Az }
20) { i: 14, s: 2, t: AZ }
21) { i: 16, s: 2, t: AZ }
22) { i: 21, s: 2, t: Ba }
23) { i: 22, s: 2, t: BA }
24) { i: 20, s: 2, t: Bz }
25) { i: 15, s: 2, t: BZ }
26) { i: 26, s: 2, t: ss }
27) { i: 27, s: 2, t: SS }
28) { i: 24, s: 2, t: st }
29) { i: 31, s: 2, t: st }
30) { i: 28, s: 2, t: St }
31) { i: 29, s: 2, t: ST }
*** Ctx ping count: 33
    [0](33): Sort(*1: T, [<] *1.s, *1.t)
###
> Sort(T, [<] s, [<]  t)
Sort(T, [<] s, [<] t) : {i:i8, s:u8, t:s}*
BndKind:Call, Type:{i:i8, s:u8, t:s}*, Bnd:(Call(∂.Sort([map:1] Global(T), [<] GetField(Scope(1), s), [<] GetField(Scope(1), t))))
// (<ctx>, ∂.T:{i:i8, s:u8, t:s}*) : {i:i8, s:u8, t:s}*
SortCompare(Arr<obj>, {i8,u8,str}, {i8,u8,str}):i4
      1) ldarg.1 [{i8,u8,str}]
      5) ldfld {i8,u8,str}::_F1:u8
      1) ldarg.2 [{i8,u8,str}]
      5) ldfld {i8,u8,str}::_F1:u8
      5) call static Cmp::Compare(u8, u8):i4
      1) dup
      5) brtrue [0]
      1) pop
      1) ldarg.1 [{i8,u8,str}]
      5) ldfld {i8,u8,str}::_F2:str
      1) ldarg.2 [{i8,u8,str}]
      5) ldfld {i8,u8,str}::_F2:str
      5) call static Cmp::Compare(str, str):i4
  Label [0]:
      1) ret
  Total Size: 42

top(Arr<obj>, Arr<obj>):obj
      1) ldarg.1 [Arr<obj>]
      1) ldc.i4.0
      1) ldelem.ref
      5) call static CodeGenUtil::ToRef(obj):ExecCtx
      1) stloc.0 [ExecCtx]
      1) ldarg.1 [Arr<obj>]
      1) ldc.i4.1
      1) ldelem.ref
      5) call static CodeGenUtil::ToRef(obj):Seq<{i8,u8,str}>
      1) stloc.1 [Seq<{i8,u8,str}>]
      1) ldloc.1 [Seq<{i8,u8,str}>]
      1) dup
      1) ldloc.0 [ExecCtx]
      1) ldc.i4.0
      5) call static CodeGenUtil::EnumerableToPinging(Seq<{i8,u8,str}>, ExecCtx, i4):Seq<{i8,u8,str}>
      1) ldarg.0 [Arr<obj>]
      1) ldc.i4.0
      5) ldelem [Func<{i8,u8,str},{i8,u8,str},i4>]
      5) call static CodeGenUtil::SortNoKey(Seq<{i8,u8,str}>, Func<{i8,u8,str},{i8,u8,str},i4>):Seq<{i8,u8,str}>
      5) call static CodeGenUtil::WrapWithCounter(Seq<{i8,u8,str}>, Seq<{i8,u8,str}>):Seq<{i8,u8,str}>
      5) call static CodeGenUtil::EnumerableToCaching(Seq<{i8,u8,str}>):Seq<{i8,u8,str}>
      1) ret
  Total Size: 50

Func sig: (<ctx>:x, T:{i:i8, s:u8, t:s}*) to {i:i8, s:u8, t:s}*
Sequence: Seq<{i8,u8,str}>
 0) { i: 13, s: 0, t: <null> }
 1) { i: 12, s: 0, t:  }
 2) { i: 11, s: 1, t:   }
 3) { i: 9, s: 1, t: 0 }
 4) { i: 10, s: 1, t: 9 }
 5) { i: 2, s: 1, t: a }
 6) { i: 1, s: 1, t: A }
 7) { i: 3, s: 1, t: A }
 8) { i: 6, s: 1, t: á }
 9) { i: 5, s: 1, t: Á }
10) { i: 8, s: 1, t: à }
11) { i: 7, s: 1, t: À }
12) { i: 4, s: 1, t: b }
13) { i: 0, s: 1, t: B }
14) { i: 25, s: 1, t: ß }
15) { i: 30, s: 1, t: ß }
16) { i: 17, s: 2, t: az }
17) { i: 23, s: 2, t: az }
18) { i: 18, s: 2, t: aZ }
19) { i: 19, s: 2, t: Az }
20) { i: 14, s: 2, t: AZ }
21) { i: 16, s: 2, t: AZ }
22) { i: 21, s: 2, t: Ba }
23) { i: 22, s: 2, t: BA }
24) { i: 20, s: 2, t: Bz }
25) { i: 15, s: 2, t: BZ }
26) { i: 26, s: 2, t: ss }
27) { i: 27, s: 2, t: SS }
28) { i: 24, s: 2, t: st }
29) { i: 31, s: 2, t: st }
30) { i: 28, s: 2, t: St }
31) { i: 29, s: 2, t: ST }
*** Ctx ping count: 33
    [0](33): Sort(*1: T, [<] *1.s, [<] *1.t)
###
> Sort(T, [<] s, [>]  t)
Sort(T, [<] s, [>] t) : {i:i8, s:u8, t:s}*
BndKind:Call, Type:{i:i8, s:u8, t:s}*, Bnd:(Call(∂.Sort([map:1] Global(T), [<] GetField(Scope(1), s), [>] GetField(Scope(1), t))))
// (<ctx>, ∂.T:{i:i8, s:u8, t:s}*) : {i:i8, s:u8, t:s}*
SortCompare(Arr<obj>, {i8,u8,str}, {i8,u8,str}):i4
      1) ldarg.1 [{i8,u8,str}]
      5) ldfld {i8,u8,str}::_F1:u8
      1) ldarg.2 [{i8,u8,str}]
      5) ldfld {i8,u8,str}::_F1:u8
      5) call static Cmp::Compare(u8, u8):i4
      1) dup
      5) brtrue [0]
      1) pop
      1) ldarg.2 [{i8,u8,str}]
      5) ldfld {i8,u8,str}::_F2:str
      1) ldarg.1 [{i8,u8,str}]
      5) ldfld {i8,u8,str}::_F2:str
      5) call static Cmp::Compare(str, str):i4
  Label [0]:
      1) ret
  Total Size: 42

top(Arr<obj>, Arr<obj>):obj
      1) ldarg.1 [Arr<obj>]
      1) ldc.i4.0
      1) ldelem.ref
      5) call static CodeGenUtil::ToRef(obj):ExecCtx
      1) stloc.0 [ExecCtx]
      1) ldarg.1 [Arr<obj>]
      1) ldc.i4.1
      1) ldelem.ref
      5) call static CodeGenUtil::ToRef(obj):Seq<{i8,u8,str}>
      1) stloc.1 [Seq<{i8,u8,str}>]
      1) ldloc.1 [Seq<{i8,u8,str}>]
      1) dup
      1) ldloc.0 [ExecCtx]
      1) ldc.i4.0
      5) call static CodeGenUtil::EnumerableToPinging(Seq<{i8,u8,str}>, ExecCtx, i4):Seq<{i8,u8,str}>
      1) ldarg.0 [Arr<obj>]
      1) ldc.i4.0
      5) ldelem [Func<{i8,u8,str},{i8,u8,str},i4>]
      5) call static CodeGenUtil::SortNoKey(Seq<{i8,u8,str}>, Func<{i8,u8,str},{i8,u8,str},i4>):Seq<{i8,u8,str}>
      5) call static CodeGenUtil::WrapWithCounter(Seq<{i8,u8,str}>, Seq<{i8,u8,str}>):Seq<{i8,u8,str}>
      5) call static CodeGenUtil::EnumerableToCaching(Seq<{i8,u8,str}>):Seq<{i8,u8,str}>
      1) ret
  Total Size: 50

Func sig: (<ctx>:x, T:{i:i8, s:u8, t:s}*) to {i:i8, s:u8, t:s}*
Sequence: Seq<{i8,u8,str}>
 0) { i: 12, s: 0, t:  }
 1) { i: 13, s: 0, t: <null> }
 2) { i: 25, s: 1, t: ß }
 3) { i: 30, s: 1, t: ß }
 4) { i: 0, s: 1, t: B }
 5) { i: 4, s: 1, t: b }
 6) { i: 7, s: 1, t: À }
 7) { i: 8, s: 1, t: à }
 8) { i: 5, s: 1, t: Á }
 9) { i: 6, s: 1, t: á }
10) { i: 1, s: 1, t: A }
11) { i: 3, s: 1, t: A }
12) { i: 2, s: 1, t: a }
13) { i: 10, s: 1, t: 9 }
14) { i: 9, s: 1, t: 0 }
15) { i: 11, s: 1, t:   }
16) { i: 29, s: 2, t: ST }
17) { i: 28, s: 2, t: St }
18) { i: 24, s: 2, t: st }
19) { i: 31, s: 2, t: st }
20) { i: 27, s: 2, t: SS }
21) { i: 26, s: 2, t: ss }
22) { i: 15, s: 2, t: BZ }
23) { i: 20, s: 2, t: Bz }
24) { i: 22, s: 2, t: BA }
25) { i: 21, s: 2, t: Ba }
26) { i: 14, s: 2, t: AZ }
27) { i: 16, s: 2, t: AZ }
28) { i: 19, s: 2, t: Az }
29) { i: 18, s: 2, t: aZ }
30) { i: 17, s: 2, t: az }
31) { i: 23, s: 2, t: az }
*** Ctx ping count: 33
    [0](33): Sort(*1: T, [<] *1.s, [>] *1.t)
###
> Sort(T, [<] s, [~]  t)
Sort(T, [<] s, [~] t) : {i:i8, s:u8, t:s}*
BndKind:Call, Type:{i:i8, s:u8, t:s}*, Bnd:(Call(∂.Sort([map:1] Global(T), [<] GetField(Scope(1), s), [~] GetField(Scope(1), t))))
// (<ctx>, ∂.T:{i:i8, s:u8, t:s}*) : {i:i8, s:u8, t:s}*
SortCompare(Arr<obj>, {i8,u8,str}, {i8,u8,str}):i4
      1) ldarg.1 [{i8,u8,str}]
      5) ldfld {i8,u8,str}::_F1:u8
      1) ldarg.2 [{i8,u8,str}]
      5) ldfld {i8,u8,str}::_F1:u8
      5) call static Cmp::Compare(u8, u8):i4
      1) dup
      5) brtrue [0]
      1) pop
      1) ldarg.1 [{i8,u8,str}]
      5) ldfld {i8,u8,str}::_F2:str
      1) ldarg.2 [{i8,u8,str}]
      5) ldfld {i8,u8,str}::_F2:str
      5) call static Cmp::CompareCi(str, str):i4
  Label [0]:
      1) ret
  Total Size: 42

top(Arr<obj>, Arr<obj>):obj
      1) ldarg.1 [Arr<obj>]
      1) ldc.i4.0
      1) ldelem.ref
      5) call static CodeGenUtil::ToRef(obj):ExecCtx
      1) stloc.0 [ExecCtx]
      1) ldarg.1 [Arr<obj>]
      1) ldc.i4.1
      1) ldelem.ref
      5) call static CodeGenUtil::ToRef(obj):Seq<{i8,u8,str}>
      1) stloc.1 [Seq<{i8,u8,str}>]
      1) ldloc.1 [Seq<{i8,u8,str}>]
      1) dup
      1) ldloc.0 [ExecCtx]
      1) ldc.i4.0
      5) call static CodeGenUtil::EnumerableToPinging(Seq<{i8,u8,str}>, ExecCtx, i4):Seq<{i8,u8,str}>
      1) ldarg.0 [Arr<obj>]
      1) ldc.i4.0
      5) ldelem [Func<{i8,u8,str},{i8,u8,str},i4>]
      5) call static CodeGenUtil::SortNoKey(Seq<{i8,u8,str}>, Func<{i8,u8,str},{i8,u8,str},i4>):Seq<{i8,u8,str}>
      5) call static CodeGenUtil::WrapWithCounter(Seq<{i8,u8,str}>, Seq<{i8,u8,str}>):Seq<{i8,u8,str}>
      5) call static CodeGenUtil::EnumerableToCaching(Seq<{i8,u8,str}>):Seq<{i8,u8,str}>
      1) ret
  Total Size: 50

Func sig: (<ctx>:x, T:{i:i8, s:u8, t:s}*) to {i:i8, s:u8, t:s}*
Sequence: Seq<{i8,u8,str}>
 0) { i: 13, s: 0, t: <null> }
 1) { i: 12, s: 0, t:  }
 2) { i: 11, s: 1, t:   }
 3) { i: 9, s: 1, t: 0 }
 4) { i: 10, s: 1, t: 9 }
 5) { i: 1, s: 1, t: A }
 6) { i: 2, s: 1, t: a }
 7) { i: 3, s: 1, t: A }
 8) { i: 5, s: 1, t: Á }
 9) { i: 6, s: 1, t: á }
10) { i: 7, s: 1, t: À }
11) { i: 8, s: 1, t: à }
12) { i: 0, s: 1, t: B }
13) { i: 4, s: 1, t: b }
14) { i: 25, s: 1, t: ß }
15) { i: 30, s: 1, t: ß }
16) { i: 14, s: 2, t: AZ }
17) { i: 16, s: 2, t: AZ }
18) { i: 17, s: 2, t: az }
19) { i: 18, s: 2, t: aZ }
20) { i: 19, s: 2, t: Az }
21) { i: 23, s: 2, t: az }
22) { i: 21, s: 2, t: Ba }
23) { i: 22, s: 2, t: BA }
24) { i: 15, s: 2, t: BZ }
25) { i: 20, s: 2, t: Bz }
26) { i: 26, s: 2, t: ss }
27) { i: 27, s: 2, t: SS }
28) { i: 24, s: 2, t: st }
29) { i: 28, s: 2, t: St }
30) { i: 29, s: 2, t: ST }
31) { i: 31, s: 2, t: st }
*** Ctx ping count: 33
    [0](33): Sort(*1: T, [<] *1.s, [~] *1.t)
###
> Sort(T, [<] s, [~<] t)
Sort(T, [<] s, [~<] t) : {i:i8, s:u8, t:s}*
BndKind:Call, Type:{i:i8, s:u8, t:s}*, Bnd:(Call(∂.Sort([map:1] Global(T), [<] GetField(Scope(1), s), [~<] GetField(Scope(1), t))))
// (<ctx>, ∂.T:{i:i8, s:u8, t:s}*) : {i:i8, s:u8, t:s}*
SortCompare(Arr<obj>, {i8,u8,str}, {i8,u8,str}):i4
      1) ldarg.1 [{i8,u8,str}]
      5) ldfld {i8,u8,str}::_F1:u8
      1) ldarg.2 [{i8,u8,str}]
      5) ldfld {i8,u8,str}::_F1:u8
      5) call static Cmp::Compare(u8, u8):i4
      1) dup
      5) brtrue [0]
      1) pop
      1) ldarg.1 [{i8,u8,str}]
      5) ldfld {i8,u8,str}::_F2:str
      1) ldarg.2 [{i8,u8,str}]
      5) ldfld {i8,u8,str}::_F2:str
      5) call static Cmp::CompareCi(str, str):i4
  Label [0]:
      1) ret
  Total Size: 42

top(Arr<obj>, Arr<obj>):obj
      1) ldarg.1 [Arr<obj>]
      1) ldc.i4.0
      1) ldelem.ref
      5) call static CodeGenUtil::ToRef(obj):ExecCtx
      1) stloc.0 [ExecCtx]
      1) ldarg.1 [Arr<obj>]
      1) ldc.i4.1
      1) ldelem.ref
      5) call static CodeGenUtil::ToRef(obj):Seq<{i8,u8,str}>
      1) stloc.1 [Seq<{i8,u8,str}>]
      1) ldloc.1 [Seq<{i8,u8,str}>]
      1) dup
      1) ldloc.0 [ExecCtx]
      1) ldc.i4.0
      5) call static CodeGenUtil::EnumerableToPinging(Seq<{i8,u8,str}>, ExecCtx, i4):Seq<{i8,u8,str}>
      1) ldarg.0 [Arr<obj>]
      1) ldc.i4.0
      5) ldelem [Func<{i8,u8,str},{i8,u8,str},i4>]
      5) call static CodeGenUtil::SortNoKey(Seq<{i8,u8,str}>, Func<{i8,u8,str},{i8,u8,str},i4>):Seq<{i8,u8,str}>
      5) call static CodeGenUtil::WrapWithCounter(Seq<{i8,u8,str}>, Seq<{i8,u8,str}>):Seq<{i8,u8,str}>
      5) call static CodeGenUtil::EnumerableToCaching(Seq<{i8,u8,str}>):Seq<{i8,u8,str}>
      1) ret
  Total Size: 50

Func sig: (<ctx>:x, T:{i:i8, s:u8, t:s}*) to {i:i8, s:u8, t:s}*
Sequence: Seq<{i8,u8,str}>
 0) { i: 13, s: 0, t: <null> }
 1) { i: 12, s: 0, t:  }
 2) { i: 11, s: 1, t:   }
 3) { i: 9, s: 1, t: 0 }
 4) { i: 10, s: 1, t: 9 }
 5) { i: 1, s: 1, t: A }
 6) { i: 2, s: 1, t: a }
 7) { i: 3, s: 1, t: A }
 8) { i: 5, s: 1, t: Á }
 9) { i: 6, s: 1, t: á }
10) { i: 7, s: 1, t: À }
11) { i: 8, s: 1, t: à }
12) { i: 0, s: 1, t: B }
13) { i: 4, s: 1, t: b }
14) { i: 25, s: 1, t: ß }
15) { i: 30, s: 1, t: ß }
16) { i: 14, s: 2, t: AZ }
17) { i: 16, s: 2, t: AZ }
18) { i: 17, s: 2, t: az }
19) { i: 18, s: 2, t: aZ }
20) { i: 19, s: 2, t: Az }
21) { i: 23, s: 2, t: az }
22) { i: 21, s: 2, t: Ba }
23) { i: 22, s: 2, t: BA }
24) { i: 15, s: 2, t: BZ }
25) { i: 20, s: 2, t: Bz }
26) { i: 26, s: 2, t: ss }
27) { i: 27, s: 2, t: SS }
28) { i: 24, s: 2, t: st }
29) { i: 28, s: 2, t: St }
30) { i: 29, s: 2, t: ST }
31) { i: 31, s: 2, t: st }
*** Ctx ping count: 33
    [0](33): Sort(*1: T, [<] *1.s, [~<] *1.t)
###
> Sort(T, [<] s, [~>] t)
Sort(T, [<] s, [~>] t) : {i:i8, s:u8, t:s}*
BndKind:Call, Type:{i:i8, s:u8, t:s}*, Bnd:(Call(∂.Sort([map:1] Global(T), [<] GetField(Scope(1), s), [~>] GetField(Scope(1), t))))
// (<ctx>, ∂.T:{i:i8, s:u8, t:s}*) : {i:i8, s:u8, t:s}*
SortCompare(Arr<obj>, {i8,u8,str}, {i8,u8,str}):i4
      1) ldarg.1 [{i8,u8,str}]
      5) ldfld {i8,u8,str}::_F1:u8
      1) ldarg.2 [{i8,u8,str}]
      5) ldfld {i8,u8,str}::_F1:u8
      5) call static Cmp::Compare(u8, u8):i4
      1) dup
      5) brtrue [0]
      1) pop
      1) ldarg.2 [{i8,u8,str}]
      5) ldfld {i8,u8,str}::_F2:str
      1) ldarg.1 [{i8,u8,str}]
      5) ldfld {i8,u8,str}::_F2:str
      5) call static Cmp::CompareCi(str, str):i4
  Label [0]:
      1) ret
  Total Size: 42

top(Arr<obj>, Arr<obj>):obj
      1) ldarg.1 [Arr<obj>]
      1) ldc.i4.0
      1) ldelem.ref
      5) call static CodeGenUtil::ToRef(obj):ExecCtx
      1) stloc.0 [ExecCtx]
      1) ldarg.1 [Arr<obj>]
      1) ldc.i4.1
      1) ldelem.ref
      5) call static CodeGenUtil::ToRef(obj):Seq<{i8,u8,str}>
      1) stloc.1 [Seq<{i8,u8,str}>]
      1) ldloc.1 [Seq<{i8,u8,str}>]
      1) dup
      1) ldloc.0 [ExecCtx]
      1) ldc.i4.0
      5) call static CodeGenUtil::EnumerableToPinging(Seq<{i8,u8,str}>, ExecCtx, i4):Seq<{i8,u8,str}>
      1) ldarg.0 [Arr<obj>]
      1) ldc.i4.0
      5) ldelem [Func<{i8,u8,str},{i8,u8,str},i4>]
      5) call static CodeGenUtil::SortNoKey(Seq<{i8,u8,str}>, Func<{i8,u8,str},{i8,u8,str},i4>):Seq<{i8,u8,str}>
      5) call static CodeGenUtil::WrapWithCounter(Seq<{i8,u8,str}>, Seq<{i8,u8,str}>):Seq<{i8,u8,str}>
      5) call static CodeGenUtil::EnumerableToCaching(Seq<{i8,u8,str}>):Seq<{i8,u8,str}>
      1) ret
  Total Size: 50

Func sig: (<ctx>:x, T:{i:i8, s:u8, t:s}*) to {i:i8, s:u8, t:s}*
Sequence: Seq<{i8,u8,str}>
 0) { i: 12, s: 0, t:  }
 1) { i: 13, s: 0, t: <null> }
 2) { i: 25, s: 1, t: ß }
 3) { i: 30, s: 1, t: ß }
 4) { i: 0, s: 1, t: B }
 5) { i: 4, s: 1, t: b }
 6) { i: 7, s: 1, t: À }
 7) { i: 8, s: 1, t: à }
 8) { i: 5, s: 1, t: Á }
 9) { i: 6, s: 1, t: á }
10) { i: 1, s: 1, t: A }
11) { i: 2, s: 1, t: a }
12) { i: 3, s: 1, t: A }
13) { i: 10, s: 1, t: 9 }
14) { i: 9, s: 1, t: 0 }
15) { i: 11, s: 1, t:   }
16) { i: 24, s: 2, t: st }
17) { i: 28, s: 2, t: St }
18) { i: 29, s: 2, t: ST }
19) { i: 31, s: 2, t: st }
20) { i: 26, s: 2, t: ss }
21) { i: 27, s: 2, t: SS }
22) { i: 15, s: 2, t: BZ }
23) { i: 20, s: 2, t: Bz }
24) { i: 21, s: 2, t: Ba }
25) { i: 22, s: 2, t: BA }
26) { i: 14, s: 2, t: AZ }
27) { i: 16, s: 2, t: AZ }
28) { i: 17, s: 2, t: az }
29) { i: 18, s: 2, t: aZ }
30) { i: 19, s: 2, t: Az }
31) { i: 23, s: 2, t: az }
*** Ctx ping count: 33
    [0](33): Sort(*1: T, [<] *1.s, [~>] *1.t)
###
> Sort(T,     s,      t)
Sort(T, s, t) : {i:i8, s:u8, t:s}*
BndKind:Call, Type:{i:i8, s:u8, t:s}*, Bnd:(Call(∂.Sort([map:1] Global(T), GetField(Scope(1), s), GetField(Scope(1), t))))
// (<ctx>, ∂.T:{i:i8, s:u8, t:s}*) : {i:i8, s:u8, t:s}*
SortCompare(Arr<obj>, {i8,u8,str}, {i8,u8,str}):i4
      1) ldarg.2 [{i8,u8,str}]
      5) ldfld {i8,u8,str}::_F1:u8
      1) ldarg.1 [{i8,u8,str}]
      5) ldfld {i8,u8,str}::_F1:u8
      5) call static Cmp::Compare(u8, u8):i4
      1) dup
      5) brtrue [0]
      1) pop
      1) ldarg.1 [{i8,u8,str}]
      5) ldfld {i8,u8,str}::_F2:str
      1) ldarg.2 [{i8,u8,str}]
      5) ldfld {i8,u8,str}::_F2:str
      5) call static Cmp::Compare(str, str):i4
  Label [0]:
      1) ret
  Total Size: 42

top(Arr<obj>, Arr<obj>):obj
      1) ldarg.1 [Arr<obj>]
      1) ldc.i4.0
      1) ldelem.ref
      5) call static CodeGenUtil::ToRef(obj):ExecCtx
      1) stloc.0 [ExecCtx]
      1) ldarg.1 [Arr<obj>]
      1) ldc.i4.1
      1) ldelem.ref
      5) call static CodeGenUtil::ToRef(obj):Seq<{i8,u8,str}>
      1) stloc.1 [Seq<{i8,u8,str}>]
      1) ldloc.1 [Seq<{i8,u8,str}>]
      1) dup
      1) ldloc.0 [ExecCtx]
      1) ldc.i4.0
      5) call static CodeGenUtil::EnumerableToPinging(Seq<{i8,u8,str}>, ExecCtx, i4):Seq<{i8,u8,str}>
      1) ldarg.0 [Arr<obj>]
      1) ldc.i4.0
      5) ldelem [Func<{i8,u8,str},{i8,u8,str},i4>]
      5) call static CodeGenUtil::SortNoKey(Seq<{i8,u8,str}>, Func<{i8,u8,str},{i8,u8,str},i4>):Seq<{i8,u8,str}>
      5) call static CodeGenUtil::WrapWithCounter(Seq<{i8,u8,str}>, Seq<{i8,u8,str}>):Seq<{i8,u8,str}>
      5) call static CodeGenUtil::EnumerableToCaching(Seq<{i8,u8,str}>):Seq<{i8,u8,str}>
      1) ret
  Total Size: 50

Func sig: (<ctx>:x, T:{i:i8, s:u8, t:s}*) to {i:i8, s:u8, t:s}*
Sequence: Seq<{i8,u8,str}>
 0) { i: 17, s: 2, t: az }
 1) { i: 23, s: 2, t: az }
 2) { i: 18, s: 2, t: aZ }
 3) { i: 19, s: 2, t: Az }
 4) { i: 14, s: 2, t: AZ }
 5) { i: 16, s: 2, t: AZ }
 6) { i: 21, s: 2, t: Ba }
 7) { i: 22, s: 2, t: BA }
 8) { i: 20, s: 2, t: Bz }
 9) { i: 15, s: 2, t: BZ }
10) { i: 26, s: 2, t: ss }
11) { i: 27, s: 2, t: SS }
12) { i: 24, s: 2, t: st }
13) { i: 31, s: 2, t: st }
14) { i: 28, s: 2, t: St }
15) { i: 29, s: 2, t: ST }
16) { i: 11, s: 1, t:   }
17) { i: 9, s: 1, t: 0 }
18) { i: 10, s: 1, t: 9 }
19) { i: 2, s: 1, t: a }
20) { i: 1, s: 1, t: A }
21) { i: 3, s: 1, t: A }
22) { i: 6, s: 1, t: á }
23) { i: 5, s: 1, t: Á }
24) { i: 8, s: 1, t: à }
25) { i: 7, s: 1, t: À }
26) { i: 4, s: 1, t: b }
27) { i: 0, s: 1, t: B }
28) { i: 25, s: 1, t: ß }
29) { i: 30, s: 1, t: ß }
30) { i: 13, s: 0, t: <null> }
31) { i: 12, s: 0, t:  }
*** Ctx ping count: 33
    [0](33): Sort(*1: T, *1.s, *1.t)
###
> Sort(T, [>] s, [<]  t)
Sort(T, [>] s, [<] t) : {i:i8, s:u8, t:s}*
BndKind:Call, Type:{i:i8, s:u8, t:s}*, Bnd:(Call(∂.Sort([map:1] Global(T), [>] GetField(Scope(1), s), [<] GetField(Scope(1), t))))
// (<ctx>, ∂.T:{i:i8, s:u8, t:s}*) : {i:i8, s:u8, t:s}*
SortCompare(Arr<obj>, {i8,u8,str}, {i8,u8,str}):i4
      1) ldarg.2 [{i8,u8,str}]
      5) ldfld {i8,u8,str}::_F1:u8
      1) ldarg.1 [{i8,u8,str}]
      5) ldfld {i8,u8,str}::_F1:u8
      5) call static Cmp::Compare(u8, u8):i4
      1) dup
      5) brtrue [0]
      1) pop
      1) ldarg.1 [{i8,u8,str}]
      5) ldfld {i8,u8,str}::_F2:str
      1) ldarg.2 [{i8,u8,str}]
      5) ldfld {i8,u8,str}::_F2:str
      5) call static Cmp::Compare(str, str):i4
  Label [0]:
      1) ret
  Total Size: 42

top(Arr<obj>, Arr<obj>):obj
      1) ldarg.1 [Arr<obj>]
      1) ldc.i4.0
      1) ldelem.ref
      5) call static CodeGenUtil::ToRef(obj):ExecCtx
      1) stloc.0 [ExecCtx]
      1) ldarg.1 [Arr<obj>]
      1) ldc.i4.1
      1) ldelem.ref
      5) call static CodeGenUtil::ToRef(obj):Seq<{i8,u8,str}>
      1) stloc.1 [Seq<{i8,u8,str}>]
      1) ldloc.1 [Seq<{i8,u8,str}>]
      1) dup
      1) ldloc.0 [ExecCtx]
      1) ldc.i4.0
      5) call static CodeGenUtil::EnumerableToPinging(Seq<{i8,u8,str}>, ExecCtx, i4):Seq<{i8,u8,str}>
      1) ldarg.0 [Arr<obj>]
      1) ldc.i4.0
      5) ldelem [Func<{i8,u8,str},{i8,u8,str},i4>]
      5) call static CodeGenUtil::SortNoKey(Seq<{i8,u8,str}>, Func<{i8,u8,str},{i8,u8,str},i4>):Seq<{i8,u8,str}>
      5) call static CodeGenUtil::WrapWithCounter(Seq<{i8,u8,str}>, Seq<{i8,u8,str}>):Seq<{i8,u8,str}>
      5) call static CodeGenUtil::EnumerableToCaching(Seq<{i8,u8,str}>):Seq<{i8,u8,str}>
      1) ret
  Total Size: 50

Func sig: (<ctx>:x, T:{i:i8, s:u8, t:s}*) to {i:i8, s:u8, t:s}*
Sequence: Seq<{i8,u8,str}>
 0) { i: 17, s: 2, t: az }
 1) { i: 23, s: 2, t: az }
 2) { i: 18, s: 2, t: aZ }
 3) { i: 19, s: 2, t: Az }
 4) { i: 14, s: 2, t: AZ }
 5) { i: 16, s: 2, t: AZ }
 6) { i: 21, s: 2, t: Ba }
 7) { i: 22, s: 2, t: BA }
 8) { i: 20, s: 2, t: Bz }
 9) { i: 15, s: 2, t: BZ }
10) { i: 26, s: 2, t: ss }
11) { i: 27, s: 2, t: SS }
12) { i: 24, s: 2, t: st }
13) { i: 31, s: 2, t: st }
14) { i: 28, s: 2, t: St }
15) { i: 29, s: 2, t: ST }
16) { i: 11, s: 1, t:   }
17) { i: 9, s: 1, t: 0 }
18) { i: 10, s: 1, t: 9 }
19) { i: 2, s: 1, t: a }
20) { i: 1, s: 1, t: A }
21) { i: 3, s: 1, t: A }
22) { i: 6, s: 1, t: á }
23) { i: 5, s: 1, t: Á }
24) { i: 8, s: 1, t: à }
25) { i: 7, s: 1, t: À }
26) { i: 4, s: 1, t: b }
27) { i: 0, s: 1, t: B }
28) { i: 25, s: 1, t: ß }
29) { i: 30, s: 1, t: ß }
30) { i: 13, s: 0, t: <null> }
31) { i: 12, s: 0, t:  }
*** Ctx ping count: 33
    [0](33): Sort(*1: T, [>] *1.s, [<] *1.t)
###
> Sort(T, [>] s, [>]  t)
Sort(T, [>] s, [>] t) : {i:i8, s:u8, t:s}*
BndKind:Call, Type:{i:i8, s:u8, t:s}*, Bnd:(Call(∂.Sort([map:1] Global(T), [>] GetField(Scope(1), s), [>] GetField(Scope(1), t))))
// (<ctx>, ∂.T:{i:i8, s:u8, t:s}*) : {i:i8, s:u8, t:s}*
SortCompare(Arr<obj>, {i8,u8,str}, {i8,u8,str}):i4
      1) ldarg.2 [{i8,u8,str}]
      5) ldfld {i8,u8,str}::_F1:u8
      1) ldarg.1 [{i8,u8,str}]
      5) ldfld {i8,u8,str}::_F1:u8
      5) call static Cmp::Compare(u8, u8):i4
      1) dup
      5) brtrue [0]
      1) pop
      1) ldarg.2 [{i8,u8,str}]
      5) ldfld {i8,u8,str}::_F2:str
      1) ldarg.1 [{i8,u8,str}]
      5) ldfld {i8,u8,str}::_F2:str
      5) call static Cmp::Compare(str, str):i4
  Label [0]:
      1) ret
  Total Size: 42

top(Arr<obj>, Arr<obj>):obj
      1) ldarg.1 [Arr<obj>]
      1) ldc.i4.0
      1) ldelem.ref
      5) call static CodeGenUtil::ToRef(obj):ExecCtx
      1) stloc.0 [ExecCtx]
      1) ldarg.1 [Arr<obj>]
      1) ldc.i4.1
      1) ldelem.ref
      5) call static CodeGenUtil::ToRef(obj):Seq<{i8,u8,str}>
      1) stloc.1 [Seq<{i8,u8,str}>]
      1) ldloc.1 [Seq<{i8,u8,str}>]
      1) dup
      1) ldloc.0 [ExecCtx]
      1) ldc.i4.0
      5) call static CodeGenUtil::EnumerableToPinging(Seq<{i8,u8,str}>, ExecCtx, i4):Seq<{i8,u8,str}>
      1) ldarg.0 [Arr<obj>]
      1) ldc.i4.0
      5) ldelem [Func<{i8,u8,str},{i8,u8,str},i4>]
      5) call static CodeGenUtil::SortNoKey(Seq<{i8,u8,str}>, Func<{i8,u8,str},{i8,u8,str},i4>):Seq<{i8,u8,str}>
      5) call static CodeGenUtil::WrapWithCounter(Seq<{i8,u8,str}>, Seq<{i8,u8,str}>):Seq<{i8,u8,str}>
      5) call static CodeGenUtil::EnumerableToCaching(Seq<{i8,u8,str}>):Seq<{i8,u8,str}>
      1) ret
  Total Size: 50

Func sig: (<ctx>:x, T:{i:i8, s:u8, t:s}*) to {i:i8, s:u8, t:s}*
Sequence: Seq<{i8,u8,str}>
 0) { i: 29, s: 2, t: ST }
 1) { i: 28, s: 2, t: St }
 2) { i: 24, s: 2, t: st }
 3) { i: 31, s: 2, t: st }
 4) { i: 27, s: 2, t: SS }
 5) { i: 26, s: 2, t: ss }
 6) { i: 15, s: 2, t: BZ }
 7) { i: 20, s: 2, t: Bz }
 8) { i: 22, s: 2, t: BA }
 9) { i: 21, s: 2, t: Ba }
10) { i: 14, s: 2, t: AZ }
11) { i: 16, s: 2, t: AZ }
12) { i: 19, s: 2, t: Az }
13) { i: 18, s: 2, t: aZ }
14) { i: 17, s: 2, t: az }
15) { i: 23, s: 2, t: az }
16) { i: 25, s: 1, t: ß }
17) { i: 30, s: 1, t: ß }
18) { i: 0, s: 1, t: B }
19) { i: 4, s: 1, t: b }
20) { i: 7, s: 1, t: À }
21) { i: 8, s: 1, t: à }
22) { i: 5, s: 1, t: Á }
23) { i: 6, s: 1, t: á }
24) { i: 1, s: 1, t: A }
25) { i: 3, s: 1, t: A }
26) { i: 2, s: 1, t: a }
27) { i: 10, s: 1, t: 9 }
28) { i: 9, s: 1, t: 0 }
29) { i: 11, s: 1, t:   }
30) { i: 12, s: 0, t:  }
31) { i: 13, s: 0, t: <null> }
*** Ctx ping count: 33
    [0](33): Sort(*1: T, [>] *1.s, [>] *1.t)
###
> Sort(T, [>] s, [~]  t)
Sort(T, [>] s, [~] t) : {i:i8, s:u8, t:s}*
BndKind:Call, Type:{i:i8, s:u8, t:s}*, Bnd:(Call(∂.Sort([map:1] Global(T), [>] GetField(Scope(1), s), [~] GetField(Scope(1), t))))
// (<ctx>, ∂.T:{i:i8, s:u8, t:s}*) : {i:i8, s:u8, t:s}*
SortCompare(Arr<obj>, {i8,u8,str}, {i8,u8,str}):i4
      1) ldarg.2 [{i8,u8,str}]
      5) ldfld {i8,u8,str}::_F1:u8
      1) ldarg.1 [{i8,u8,str}]
      5) ldfld {i8,u8,str}::_F1:u8
      5) call static Cmp::Compare(u8, u8):i4
      1) dup
      5) brtrue [0]
      1) pop
      1) ldarg.1 [{i8,u8,str}]
      5) ldfld {i8,u8,str}::_F2:str
      1) ldarg.2 [{i8,u8,str}]
      5) ldfld {i8,u8,str}::_F2:str
      5) call static Cmp::CompareCi(str, str):i4
  Label [0]:
      1) ret
  Total Size: 42

top(Arr<obj>, Arr<obj>):obj
      1) ldarg.1 [Arr<obj>]
      1) ldc.i4.0
      1) ldelem.ref
      5) call static CodeGenUtil::ToRef(obj):ExecCtx
      1) stloc.0 [ExecCtx]
      1) ldarg.1 [Arr<obj>]
      1) ldc.i4.1
      1) ldelem.ref
      5) call static CodeGenUtil::ToRef(obj):Seq<{i8,u8,str}>
      1) stloc.1 [Seq<{i8,u8,str}>]
      1) ldloc.1 [Seq<{i8,u8,str}>]
      1) dup
      1) ldloc.0 [ExecCtx]
      1) ldc.i4.0
      5) call static CodeGenUtil::EnumerableToPinging(Seq<{i8,u8,str}>, ExecCtx, i4):Seq<{i8,u8,str}>
      1) ldarg.0 [Arr<obj>]
      1) ldc.i4.0
      5) ldelem [Func<{i8,u8,str},{i8,u8,str},i4>]
      5) call static CodeGenUtil::SortNoKey(Seq<{i8,u8,str}>, Func<{i8,u8,str},{i8,u8,str},i4>):Seq<{i8,u8,str}>
      5) call static CodeGenUtil::WrapWithCounter(Seq<{i8,u8,str}>, Seq<{i8,u8,str}>):Seq<{i8,u8,str}>
      5) call static CodeGenUtil::EnumerableToCaching(Seq<{i8,u8,str}>):Seq<{i8,u8,str}>
      1) ret
  Total Size: 50

Func sig: (<ctx>:x, T:{i:i8, s:u8, t:s}*) to {i:i8, s:u8, t:s}*
Sequence: Seq<{i8,u8,str}>
 0) { i: 14, s: 2, t: AZ }
 1) { i: 16, s: 2, t: AZ }
 2) { i: 17, s: 2, t: az }
 3) { i: 18, s: 2, t: aZ }
 4) { i: 19, s: 2, t: Az }
 5) { i: 23, s: 2, t: az }
 6) { i: 21, s: 2, t: Ba }
 7) { i: 22, s: 2, t: BA }
 8) { i: 15, s: 2, t: BZ }
 9) { i: 20, s: 2, t: Bz }
10) { i: 26, s: 2, t: ss }
11) { i: 27, s: 2, t: SS }
12) { i: 24, s: 2, t: st }
13) { i: 28, s: 2, t: St }
14) { i: 29, s: 2, t: ST }
15) { i: 31, s: 2, t: st }
16) { i: 11, s: 1, t:   }
17) { i: 9, s: 1, t: 0 }
18) { i: 10, s: 1, t: 9 }
19) { i: 1, s: 1, t: A }
20) { i: 2, s: 1, t: a }
21) { i: 3, s: 1, t: A }
22) { i: 5, s: 1, t: Á }
23) { i: 6, s: 1, t: á }
24) { i: 7, s: 1, t: À }
25) { i: 8, s: 1, t: à }
26) { i: 0, s: 1, t: B }
27) { i: 4, s: 1, t: b }
28) { i: 25, s: 1, t: ß }
29) { i: 30, s: 1, t: ß }
30) { i: 13, s: 0, t: <null> }
31) { i: 12, s: 0, t:  }
*** Ctx ping count: 33
    [0](33): Sort(*1: T, [>] *1.s, [~] *1.t)
###
> Sort(T, [>] s, [~<] t)
Sort(T, [>] s, [~<] t) : {i:i8, s:u8, t:s}*
BndKind:Call, Type:{i:i8, s:u8, t:s}*, Bnd:(Call(∂.Sort([map:1] Global(T), [>] GetField(Scope(1), s), [~<] GetField(Scope(1), t))))
// (<ctx>, ∂.T:{i:i8, s:u8, t:s}*) : {i:i8, s:u8, t:s}*
SortCompare(Arr<obj>, {i8,u8,str}, {i8,u8,str}):i4
      1) ldarg.2 [{i8,u8,str}]
      5) ldfld {i8,u8,str}::_F1:u8
      1) ldarg.1 [{i8,u8,str}]
      5) ldfld {i8,u8,str}::_F1:u8
      5) call static Cmp::Compare(u8, u8):i4
      1) dup
      5) brtrue [0]
      1) pop
      1) ldarg.1 [{i8,u8,str}]
      5) ldfld {i8,u8,str}::_F2:str
      1) ldarg.2 [{i8,u8,str}]
      5) ldfld {i8,u8,str}::_F2:str
      5) call static Cmp::CompareCi(str, str):i4
  Label [0]:
      1) ret
  Total Size: 42

top(Arr<obj>, Arr<obj>):obj
      1) ldarg.1 [Arr<obj>]
      1) ldc.i4.0
      1) ldelem.ref
      5) call static CodeGenUtil::ToRef(obj):ExecCtx
      1) stloc.0 [ExecCtx]
      1) ldarg.1 [Arr<obj>]
      1) ldc.i4.1
      1) ldelem.ref
      5) call static CodeGenUtil::ToRef(obj):Seq<{i8,u8,str}>
      1) stloc.1 [Seq<{i8,u8,str}>]
      1) ldloc.1 [Seq<{i8,u8,str}>]
      1) dup
      1) ldloc.0 [ExecCtx]
      1) ldc.i4.0
      5) call static CodeGenUtil::EnumerableToPinging(Seq<{i8,u8,str}>, ExecCtx, i4):Seq<{i8,u8,str}>
      1) ldarg.0 [Arr<obj>]
      1) ldc.i4.0
      5) ldelem [Func<{i8,u8,str},{i8,u8,str},i4>]
      5) call static CodeGenUtil::SortNoKey(Seq<{i8,u8,str}>, Func<{i8,u8,str},{i8,u8,str},i4>):Seq<{i8,u8,str}>
      5) call static CodeGenUtil::WrapWithCounter(Seq<{i8,u8,str}>, Seq<{i8,u8,str}>):Seq<{i8,u8,str}>
      5) call static CodeGenUtil::EnumerableToCaching(Seq<{i8,u8,str}>):Seq<{i8,u8,str}>
      1) ret
  Total Size: 50

Func sig: (<ctx>:x, T:{i:i8, s:u8, t:s}*) to {i:i8, s:u8, t:s}*
Sequence: Seq<{i8,u8,str}>
 0) { i: 14, s: 2, t: AZ }
 1) { i: 16, s: 2, t: AZ }
 2) { i: 17, s: 2, t: az }
 3) { i: 18, s: 2, t: aZ }
 4) { i: 19, s: 2, t: Az }
 5) { i: 23, s: 2, t: az }
 6) { i: 21, s: 2, t: Ba }
 7) { i: 22, s: 2, t: BA }
 8) { i: 15, s: 2, t: BZ }
 9) { i: 20, s: 2, t: Bz }
10) { i: 26, s: 2, t: ss }
11) { i: 27, s: 2, t: SS }
12) { i: 24, s: 2, t: st }
13) { i: 28, s: 2, t: St }
14) { i: 29, s: 2, t: ST }
15) { i: 31, s: 2, t: st }
16) { i: 11, s: 1, t:   }
17) { i: 9, s: 1, t: 0 }
18) { i: 10, s: 1, t: 9 }
19) { i: 1, s: 1, t: A }
20) { i: 2, s: 1, t: a }
21) { i: 3, s: 1, t: A }
22) { i: 5, s: 1, t: Á }
23) { i: 6, s: 1, t: á }
24) { i: 7, s: 1, t: À }
25) { i: 8, s: 1, t: à }
26) { i: 0, s: 1, t: B }
27) { i: 4, s: 1, t: b }
28) { i: 25, s: 1, t: ß }
29) { i: 30, s: 1, t: ß }
30) { i: 13, s: 0, t: <null> }
31) { i: 12, s: 0, t:  }
*** Ctx ping count: 33
    [0](33): Sort(*1: T, [>] *1.s, [~<] *1.t)
###
> Sort(T, [>] s, [~>] t)
Sort(T, [>] s, [~>] t) : {i:i8, s:u8, t:s}*
BndKind:Call, Type:{i:i8, s:u8, t:s}*, Bnd:(Call(∂.Sort([map:1] Global(T), [>] GetField(Scope(1), s), [~>] GetField(Scope(1), t))))
// (<ctx>, ∂.T:{i:i8, s:u8, t:s}*) : {i:i8, s:u8, t:s}*
SortCompare(Arr<obj>, {i8,u8,str}, {i8,u8,str}):i4
      1) ldarg.2 [{i8,u8,str}]
      5) ldfld {i8,u8,str}::_F1:u8
      1) ldarg.1 [{i8,u8,str}]
      5) ldfld {i8,u8,str}::_F1:u8
      5) call static Cmp::Compare(u8, u8):i4
      1) dup
      5) brtrue [0]
      1) pop
      1) ldarg.2 [{i8,u8,str}]
      5) ldfld {i8,u8,str}::_F2:str
      1) ldarg.1 [{i8,u8,str}]
      5) ldfld {i8,u8,str}::_F2:str
      5) call static Cmp::CompareCi(str, str):i4
  Label [0]:
      1) ret
  Total Size: 42

top(Arr<obj>, Arr<obj>):obj
      1) ldarg.1 [Arr<obj>]
      1) ldc.i4.0
      1) ldelem.ref
      5) call static CodeGenUtil::ToRef(obj):ExecCtx
      1) stloc.0 [ExecCtx]
      1) ldarg.1 [Arr<obj>]
      1) ldc.i4.1
      1) ldelem.ref
      5) call static CodeGenUtil::ToRef(obj):Seq<{i8,u8,str}>
      1) stloc.1 [Seq<{i8,u8,str}>]
      1) ldloc.1 [Seq<{i8,u8,str}>]
      1) dup
      1) ldloc.0 [ExecCtx]
      1) ldc.i4.0
      5) call static CodeGenUtil::EnumerableToPinging(Seq<{i8,u8,str}>, ExecCtx, i4):Seq<{i8,u8,str}>
      1) ldarg.0 [Arr<obj>]
      1) ldc.i4.0
      5) ldelem [Func<{i8,u8,str},{i8,u8,str},i4>]
      5) call static CodeGenUtil::SortNoKey(Seq<{i8,u8,str}>, Func<{i8,u8,str},{i8,u8,str},i4>):Seq<{i8,u8,str}>
      5) call static CodeGenUtil::WrapWithCounter(Seq<{i8,u8,str}>, Seq<{i8,u8,str}>):Seq<{i8,u8,str}>
      5) call static CodeGenUtil::EnumerableToCaching(Seq<{i8,u8,str}>):Seq<{i8,u8,str}>
      1) ret
  Total Size: 50

Func sig: (<ctx>:x, T:{i:i8, s:u8, t:s}*) to {i:i8, s:u8, t:s}*
Sequence: Seq<{i8,u8,str}>
 0) { i: 24, s: 2, t: st }
 1) { i: 28, s: 2, t: St }
 2) { i: 29, s: 2, t: ST }
 3) { i: 31, s: 2, t: st }
 4) { i: 26, s: 2, t: ss }
 5) { i: 27, s: 2, t: SS }
 6) { i: 15, s: 2, t: BZ }
 7) { i: 20, s: 2, t: Bz }
 8) { i: 21, s: 2, t: Ba }
 9) { i: 22, s: 2, t: BA }
10) { i: 14, s: 2, t: AZ }
11) { i: 16, s: 2, t: AZ }
12) { i: 17, s: 2, t: az }
13) { i: 18, s: 2, t: aZ }
14) { i: 19, s: 2, t: Az }
15) { i: 23, s: 2, t: az }
16) { i: 25, s: 1, t: ß }
17) { i: 30, s: 1, t: ß }
18) { i: 0, s: 1, t: B }
19) { i: 4, s: 1, t: b }
20) { i: 7, s: 1, t: À }
21) { i: 8, s: 1, t: à }
22) { i: 5, s: 1, t: Á }
23) { i: 6, s: 1, t: á }
24) { i: 1, s: 1, t: A }
25) { i: 2, s: 1, t: a }
26) { i: 3, s: 1, t: A }
27) { i: 10, s: 1, t: 9 }
28) { i: 9, s: 1, t: 0 }
29) { i: 11, s: 1, t:   }
30) { i: 12, s: 0, t:  }
31) { i: 13, s: 0, t: <null> }
*** Ctx ping count: 33
    [0](33): Sort(*1: T, [>] *1.s, [~>] *1.t)
###
> Sort(T, t) ++ Sort(T, [>] t)
Sort(T, t) ++ Sort(T, [>] t) : {i:i8, s:u8, t:s}*
BndKind:VariadicOp, Type:{i:i8, s:u8, t:s}*, Bnd:(SeqConcat(Call(∂.Sort([map:1] Global(T), GetField(Scope(1), t))), Call(∂.Sort([map:2] Global(T), [>] GetField(Scope(2), t)))))
// (<ctx>, ∂.T:{i:i8, s:u8, t:s}*) : {i:i8, s:u8, t:s}*
Sort_1(Arr<obj>, {i8,u8,str}):str
      1) ldarg.1 [{i8,u8,str}]
      5) ldfld {i8,u8,str}::_F2:str
      1) ret
  Total Size: 7

Sort_1(Arr<obj>, {i8,u8,str}):str
      1) ldarg.1 [{i8,u8,str}]
      5) ldfld {i8,u8,str}::_F2:str
      1) ret
  Total Size: 7

top(Arr<obj>, Arr<obj>):obj
      1) ldarg.1 [Arr<obj>]
      1) ldc.i4.0
      1) ldelem.ref
      5) call static CodeGenUtil::ToRef(obj):ExecCtx
      1) stloc.0 [ExecCtx]
      1) ldarg.1 [Arr<obj>]
      1) ldc.i4.1
      1) ldelem.ref
      5) call static CodeGenUtil::ToRef(obj):Seq<{i8,u8,str}>
      1) stloc.1 [Seq<{i8,u8,str}>]
      1) ldloc.1 [Seq<{i8,u8,str}>]
      1) dup
      1) ldloc.0 [ExecCtx]
      1) ldc.i4.0
      5) call static CodeGenUtil::EnumerableToPinging(Seq<{i8,u8,str}>, ExecCtx, i4):Seq<{i8,u8,str}>
      1) ldarg.0 [Arr<obj>]
      1) ldc.i4.0
      5) ldelem [Func<{i8,u8,str},str>]
      1) ldarg.0 [Arr<obj>]
      1) ldc.i4.1
      5) ldelem [Func<str,str,i4>]
      5) call static CodeGenUtil::Sort(Seq<{i8,u8,str}>, Func<{i8,u8,str},str>, Func<str,str,i4>):Seq<{i8,u8,str}>
      5) call static CodeGenUtil::WrapWithCounter(Seq<{i8,u8,str}>, Seq<{i8,u8,str}>):Seq<{i8,u8,str}>
      5) call static CodeGenUtil::EnumerableToCaching(Seq<{i8,u8,str}>):Seq<{i8,u8,str}>
      1) ldloc.1 [Seq<{i8,u8,str}>]
      1) dup
      1) ldloc.0 [ExecCtx]
      1) ldc.i4.1
      5) call static CodeGenUtil::EnumerableToPinging(Seq<{i8,u8,str}>, ExecCtx, i4):Seq<{i8,u8,str}>
      1) ldarg.0 [Arr<obj>]
      1) ldc.i4.2
      5) ldelem [Func<{i8,u8,str},str>]
      1) ldarg.0 [Arr<obj>]
      1) ldc.i4.3
      5) ldelem [Func<str,str,i4>]
      5) call static CodeGenUtil::Sort(Seq<{i8,u8,str}>, Func<{i8,u8,str},str>, Func<str,str,i4>):Seq<{i8,u8,str}>
      5) call static CodeGenUtil::WrapWithCounter(Seq<{i8,u8,str}>, Seq<{i8,u8,str}>):Seq<{i8,u8,str}>
      5) call static CodeGenUtil::EnumerableToCaching(Seq<{i8,u8,str}>):Seq<{i8,u8,str}>
      5) call static CodeGenUtil::SeqConcat(Seq<{i8,u8,str}>, Seq<{i8,u8,str}>):Seq<{i8,u8,str}>
      5) call static CodeGenUtil::EnumerableToCaching(Seq<{i8,u8,str}>):Seq<{i8,u8,str}>
      1) ret
  Total Size: 105

Func sig: (<ctx>:x, T:{i:i8, s:u8, t:s}*) to {i:i8, s:u8, t:s}*
Sequence: Seq<{i8,u8,str}>
 0) { i: 13, s: 0, t: <null> }
 1) { i: 12, s: 0, t:  }
 2) { i: 11, s: 1, t:   }
 3) { i: 9, s: 1, t: 0 }
 4) { i: 10, s: 1, t: 9 }
 5) { i: 2, s: 1, t: a }
 6) { i: 1, s: 1, t: A }
 7) { i: 3, s: 1, t: A }
 8) { i: 6, s: 1, t: á }
 9) { i: 5, s: 1, t: Á }
10) { i: 8, s: 1, t: à }
11) { i: 7, s: 1, t: À }
12) { i: 17, s: 2, t: az }
13) { i: 23, s: 2, t: az }
14) { i: 18, s: 2, t: aZ }
15) { i: 19, s: 2, t: Az }
16) { i: 14, s: 2, t: AZ }
17) { i: 16, s: 2, t: AZ }
18) { i: 4, s: 1, t: b }
19) { i: 0, s: 1, t: B }
20) { i: 21, s: 2, t: Ba }
21) { i: 22, s: 2, t: BA }
22) { i: 20, s: 2, t: Bz }
23) { i: 15, s: 2, t: BZ }
24) { i: 26, s: 2, t: ss }
25) { i: 27, s: 2, t: SS }
26) { i: 25, s: 1, t: ß }
27) { i: 30, s: 1, t: ß }
28) { i: 24, s: 2, t: st }
29) { i: 31, s: 2, t: st }
30) { i: 28, s: 2, t: St }
31) { i: 29, s: 2, t: ST }
32) { i: 29, s: 2, t: ST }
33) { i: 28, s: 2, t: St }
34) { i: 24, s: 2, t: st }
35) { i: 31, s: 2, t: st }
36) { i: 25, s: 1, t: ß }
37) { i: 30, s: 1, t: ß }
38) { i: 27, s: 2, t: SS }
39) { i: 26, s: 2, t: ss }
40) { i: 15, s: 2, t: BZ }
41) { i: 20, s: 2, t: Bz }
42) { i: 22, s: 2, t: BA }
43) { i: 21, s: 2, t: Ba }
44) { i: 0, s: 1, t: B }
45) { i: 4, s: 1, t: b }
46) { i: 14, s: 2, t: AZ }
47) { i: 16, s: 2, t: AZ }
48) { i: 19, s: 2, t: Az }
49) { i: 18, s: 2, t: aZ }
50) { i: 17, s: 2, t: az }
51) { i: 23, s: 2, t: az }
52) { i: 7, s: 1, t: À }
53) { i: 8, s: 1, t: à }
54) { i: 5, s: 1, t: Á }
55) { i: 6, s: 1, t: á }
56) { i: 1, s: 1, t: A }
57) { i: 3, s: 1, t: A }
58) { i: 2, s: 1, t: a }
59) { i: 10, s: 1, t: 9 }
60) { i: 9, s: 1, t: 0 }
61) { i: 11, s: 1, t:   }
62) { i: 12, s: 0, t:  }
63) { i: 13, s: 0, t: <null> }
*** Ctx ping count: 66
    [0](33): Sort(*1: T, *1.t)
    [1](33): Sort(*1: T, [>] *1.t)
###
> Sort(S) ++ Sort([>] S)
Sort(S) ++ Sort([>] S) : s*
BndKind:VariadicOp, Type:s*, Bnd:(SeqConcat(Call(∂.Sort(Global(S)):s*), Call(∂.Sort([>] Global(S)):s*)))
// (<ctx>, ∂.S:s*) : s*
top(Arr<obj>, Arr<obj>):obj
      1) ldarg.1 [Arr<obj>]
      1) ldc.i4.0
      1) ldelem.ref
      5) call static CodeGenUtil::ToRef(obj):ExecCtx
      1) stloc.0 [ExecCtx]
      1) ldarg.1 [Arr<obj>]
      1) ldc.i4.1
      1) ldelem.ref
      5) call static CodeGenUtil::ToRef(obj):Seq<str>
      1) stloc.1 [Seq<str>]
      1) ldloc.1 [Seq<str>]
      1) dup
      1) ldloc.0 [ExecCtx]
      1) ldc.i4.0
      5) call static CodeGenUtil::EnumerableToPinging(Seq<str>, ExecCtx, i4):Seq<str>
      1) ldarg.0 [Arr<obj>]
      1) ldc.i4.0
      5) ldelem [Func<str,str,i4>]
      5) call static CodeGenUtil::SortNoKey(Seq<str>, Func<str,str,i4>):Seq<str>
      5) call static CodeGenUtil::WrapWithCounter(Seq<str>, Seq<str>):Seq<str>
      5) call static CodeGenUtil::EnumerableToCaching(Seq<str>):Seq<str>
      1) ldloc.1 [Seq<str>]
      1) dup
      1) ldloc.0 [ExecCtx]
      1) ldc.i4.1
      5) call static CodeGenUtil::EnumerableToPinging(Seq<str>, ExecCtx, i4):Seq<str>
      1) ldarg.0 [Arr<obj>]
      1) ldc.i4.1
      5) ldelem [Func<str,str,i4>]
      5) call static CodeGenUtil::SortNoKey(Seq<str>, Func<str,str,i4>):Seq<str>
      5) call static CodeGenUtil::WrapWithCounter(Seq<str>, Seq<str>):Seq<str>
      5) call static CodeGenUtil::EnumerableToCaching(Seq<str>):Seq<str>
      5) call static CodeGenUtil::SeqConcat(Seq<str>, Seq<str>):Seq<str>
      5) call static CodeGenUtil::EnumerableToCaching(Seq<str>):Seq<str>
      1) ret
  Total Size: 91

Func sig: (<ctx>:x, S:s*) to s*
Sequence: Seq<str>
 0) <null>
 1) 
 2)  
 3) 0
 4) 9
 5) a
 6) A
 7) A
 8) á
 9) Á
10) à
11) À
12) az
13) az
14) aZ
15) Az
16) AZ
17) AZ
18) b
19) B
20) Ba
21) BA
22) Bz
23) BZ
24) ss
25) SS
26) ß
27) ß
28) st
29) st
30) St
31) ST
32) ST
33) St
34) st
35) st
36) ß
37) ß
38) SS
39) ss
40) BZ
41) Bz
42) BA
43) Ba
44) B
45) b
46) AZ
47) AZ
48) Az
49) aZ
50) az
51) az
52) À
53) à
54) Á
55) á
56) A
57) A
58) a
59) 9
60) 0
61)  
62) 
63) <null>
*** Ctx ping count: 66
    [0](33): Sort(S)
    [1](33): Sort([>] S)
###
> Sort(Data, A + G)
Sort(Data, A + G) : {A:i8, B:i8, C:i8}*
BndKind:Call, Type:{A:i8, B:i8, C:i8}*, Bnd:(Call(∂.Sort([map:1] Global(Data), Add(GetField(Scope(1), A), Global(G)))))
// (<ctx>, ∂.Data:{A:i8, B:i8, C:i8}*, ∂.G:i8) : {A:i8, B:i8, C:i8}*
Sort_1(Arr<obj>, {i8,i8,i8}):i8
      1) ldarg.1 [{i8,i8,i8}]
      5) ldfld {i8,i8,i8}::_F0:i8
      1) ldarg.0 [Arr<obj>]
      1) ldc.i4.2
      5) ldelem [(i8)]
      5) ldfld (i8)::_F0:i8
      1) add
      1) ret
  Total Size: 20

top(Arr<obj>, Arr<obj>):obj
      1) ldarg.1 [Arr<obj>]
      1) ldc.i4.0
      1) ldelem.ref
      5) call static CodeGenUtil::ToRef(obj):ExecCtx
      1) stloc.0 [ExecCtx]
      1) ldarg.1 [Arr<obj>]
      1) ldc.i4.1
      1) ldelem.ref
      5) call static CodeGenUtil::ToRef(obj):Seq<{i8,i8,i8}>
      1) stloc.1 [Seq<{i8,i8,i8}>]
      1) ldarg.1 [Arr<obj>]
      1) ldc.i4.2
      1) ldelem.ref
      5) call static CodeGenUtil::ToVal(obj):i8
      1) stloc.2 [i8]
      5) newobj (i8)()
      1) stloc.3 [(i8)]
      1) ldloc.3 [(i8)]
      1) ldloc.2 [i8]
      5) stfld (i8)::_F0:i8
      1) ldloc.1 [Seq<{i8,i8,i8}>]
      1) dup
      1) ldloc.0 [ExecCtx]
      1) ldc.i4.0
      5) call static CodeGenUtil::EnumerableToPinging(Seq<{i8,i8,i8}>, ExecCtx, i4):Seq<{i8,i8,i8}>
      1) ldarg.0 [Arr<obj>]
      1) ldc.i4.0
      5) ldelem [MethodInfo]
      5) ldtoken [Func<{i8,i8,i8},i8>]
      5) call static Type::GetTypeFromHandle(RuntimeTypeHandle):Type
      1) ldc.i4.3
      5) newarr [obj]
      1) dup
      1) ldc.i4.2
      1) ldloc.3 [(i8)]
      5) stelem [(i8)]
      5) callvirt DynamicMethod::CreateDelegate(Type, obj):Delegate
      1) ldarg.0 [Arr<obj>]
      1) ldc.i4.1
      5) ldelem [Func<i8,i8,i4>]
      5) call static CodeGenUtil::Sort(Seq<{i8,i8,i8}>, Func<{i8,i8,i8},i8>, Func<i8,i8,i4>):Seq<{i8,i8,i8}>
      5) call static CodeGenUtil::WrapWithCounter(Seq<{i8,i8,i8}>, Seq<{i8,i8,i8}>):Seq<{i8,i8,i8}>
      5) call static CodeGenUtil::EnumerableToCaching(Seq<{i8,i8,i8}>):Seq<{i8,i8,i8}>
      1) ret
  Total Size: 108

Func sig: (<ctx>:x, Data:{A:i8, B:i8, C:i8}*, G:i8) to {A:i8, B:i8, C:i8}*
Sequence: Seq<{i8,i8,i8}>
 0) { A: 9, B: 1, C: 17 }
 1) { A: 8, B: 0, C: 17 }
 2) { A: 7, B: 1, C: 17 }
 3) { A: 6, B: 0, C: 17 }
 4) { A: 5, B: 1, C: 17 }
 5) { A: 4, B: 0, C: 17 }
 6) { A: 3, B: 1, C: 17 }
 7) { A: 2, B: 0, C: 17 }
 8) { A: 1, B: 1, C: 17 }
 9) { A: 0, B: 0, C: 17 }
*** Ctx ping count: 11
    [0](11): Sort(*1: Data, Add(*1.A, G))
###
> Sort(Data, Sum(Range(A)->TakeIf(it mod 3 = 0)))
Sort(Data, Sum(Range(A)->TakeIf(it mod 3 @= 0))) : {A:i8, B:i8, C:i8}*
BndKind:Call, Type:{A:i8, B:i8, C:i8}*, Bnd:(Call(∂.Sort([map:1] Global(Data), Call(∂.Sum(Call(∂.Take([map:2] Call(∂.Range(GetField(Scope(1), A)):i8*), [if] Cmp(IntMod(Scope(2), 3:i8) @= 0:i8)):i8*)):i8))))
// (<ctx>, ∂.Data:{A:i8, B:i8, C:i8}*) : {A:i8, B:i8, C:i8}*
Take_1(Arr<obj>, i8):bool
      1) ldarg.1 [i8]
      1) ldc.i4.3
      1) conv.i8
      1) rem
      1) ldc.i4.0
      1) conv.i8
      2) ceq
      1) ret
  Total Size: 9

Sort_1(Arr<obj>, {i8,i8,i8}):i8
      1) ldarg.1 [{i8,i8,i8}]
      5) ldfld {i8,i8,i8}::_F0:i8
      5) call static RangeGen::Exec(i8):ICachingEnumerable<i8>
      1) ldarg.0 [Arr<obj>]
      1) ldc.i4.0
      5) ldelem [Arr<obj>]
      1) ldc.i4.0
      5) ldelem [Func<i8,bool>]
      1) ldarg.0 [Arr<obj>]
      1) ldc.i4.1
      5) ldelem [ExecCtx]
      1) ldc.i4.1
      5) call static TakeDropGen::ExecTakeIf(Seq<i8>, Func<i8,bool>, ExecCtx, i4):Seq<i8>
      5) call static CodeGenUtil::EnumerableToCaching(Seq<i8>):Seq<i8>
      1) ldarg.0 [Arr<obj>]
      1) ldc.i4.1
      5) ldelem [ExecCtx]
      1) ldc.i4.2
      2) ldloca.s [i8 (0)]
      5) call static SumBaseGen::ExecS(Seq<i8>, ExecCtx, i4, out i8):i8
      1) ret
  Total Size: 58

top(Arr<obj>, Arr<obj>):obj
      1) ldarg.1 [Arr<obj>]
      1) ldc.i4.0
      1) ldelem.ref
      5) call static CodeGenUtil::ToRef(obj):ExecCtx
      1) stloc.0 [ExecCtx]
      1) ldarg.1 [Arr<obj>]
      1) ldc.i4.1
      1) ldelem.ref
      5) call static CodeGenUtil::ToRef(obj):Seq<{i8,i8,i8}>
      1) stloc.1 [Seq<{i8,i8,i8}>]
      1) ldloc.1 [Seq<{i8,i8,i8}>]
      1) dup
      1) ldloc.0 [ExecCtx]
      1) ldc.i4.0
      5) call static CodeGenUtil::EnumerableToPinging(Seq<{i8,i8,i8}>, ExecCtx, i4):Seq<{i8,i8,i8}>
      1) ldarg.0 [Arr<obj>]
      1) ldc.i4.0
      5) ldelem [MethodInfo]
      5) ldtoken [Func<{i8,i8,i8},i8>]
      5) call static Type::GetTypeFromHandle(RuntimeTypeHandle):Type
      1) ldc.i4.2
      5) newarr [obj]
      1) dup
      1) ldc.i4.0
      1) ldarg.0 [Arr<obj>]
      1) ldc.i4.1
      5) ldelem [Arr<obj>]
      5) stelem [Arr<obj>]
      1) dup
      1) ldc.i4.1
      1) ldloc.0 [ExecCtx]
      5) stelem [ExecCtx]
      5) callvirt DynamicMethod::CreateDelegate(Type, obj):Delegate
      1) ldarg.0 [Arr<obj>]
      1) ldc.i4.2
      5) ldelem [Func<i8,i8,i4>]
      5) call static CodeGenUtil::Sort(Seq<{i8,i8,i8}>, Func<{i8,i8,i8},i8>, Func<i8,i8,i4>):Seq<{i8,i8,i8}>
      5) call static CodeGenUtil::WrapWithCounter(Seq<{i8,i8,i8}>, Seq<{i8,i8,i8}>):Seq<{i8,i8,i8}>
      5) call static CodeGenUtil::EnumerableToCaching(Seq<{i8,i8,i8}>):Seq<{i8,i8,i8}>
      1) ret
  Total Size: 100

Func sig: (<ctx>:x, Data:{A:i8, B:i8, C:i8}*) to {A:i8, B:i8, C:i8}*
Sequence: Seq<{i8,i8,i8}>
 0) { A: 9, B: 1, C: 17 }
 1) { A: 7, B: 1, C: 17 }
 2) { A: 8, B: 0, C: 17 }
 3) { A: 5, B: 1, C: 17 }
 4) { A: 6, B: 0, C: 17 }
 5) { A: 4, B: 0, C: 17 }
 6) { A: 3, B: 1, C: 17 }
 7) { A: 1, B: 1, C: 17 }
 8) { A: 2, B: 0, C: 17 }
 9) { A: 0, B: 0, C: 17 }
*** Ctx ping count: 66
    [0](11): Sort(*1: Data, Sum(Take(*2: Range(*1.A), [if] IntMod(*2, 3) @= 0)))
    [1](27): Take(*2: Range(*1x.A), [if] IntMod(*2, 3) @= 0)
    [2](28): Sum(Take(*2: Range(*1x.A), [if] IntMod(*2, 3) @= 0))
###
> Sort(Data, Sum(Range(A)->TakeIf(it mod G = 0)))
Sort(Data, Sum(Range(A)->TakeIf(it mod G @= 0))) : {A:i8, B:i8, C:i8}*
BndKind:Call, Type:{A:i8, B:i8, C:i8}*, Bnd:(Call(∂.Sort([map:1] Global(Data), Call(∂.Sum(Call(∂.Take([map:2] Call(∂.Range(GetField(Scope(1), A)):i8*), [if] Cmp(IntMod(Scope(2), Global(G)) @= 0:i8)):i8*)):i8))))
// (<ctx>, ∂.Data:{A:i8, B:i8, C:i8}*, ∂.G:i8) : {A:i8, B:i8, C:i8}*
Take_1(Arr<obj>, i8):bool
      1) ldarg.0 [Arr<obj>]
      1) ldc.i4.2
      5) ldelem [(i8)]
      5) ldfld (i8)::_F0:i8
      1) dup
      1) stloc.0 [i8]
      1) ldc.i4.1
      1) conv.i8
      1) add
      1) ldc.i4.2
      1) conv.i8
      5) ble.un [0]
      1) ldarg.1 [i8]
      1) ldloc.0 [i8]
      1) rem
      5) br [1]
  Label [0]:
      1) ldc.i4.0
      1) conv.i8
  Label [1]:
      1) ldc.i4.0
      1) conv.i8
      2) ceq
      1) ret
  Total Size: 39

Sort_1(Arr<obj>, {i8,i8,i8}):i8
      1) ldarg.1 [{i8,i8,i8}]
      5) ldfld {i8,i8,i8}::_F0:i8
      5) call static RangeGen::Exec(i8):ICachingEnumerable<i8>
      1) ldarg.0 [Arr<obj>]
      1) ldc.i4.0
      5) ldelem [Arr<obj>]
      1) ldc.i4.0
      5) ldelem [MethodInfo]
      5) ldtoken [Func<i8,bool>]
      5) call static Type::GetTypeFromHandle(RuntimeTypeHandle):Type
      1) ldc.i4.3
      5) newarr [obj]
      1) dup
      1) ldc.i4.2
      1) ldarg.0 [Arr<obj>]
      1) ldc.i4.2
      5) ldelem [(i8)]
      5) stelem [(i8)]
      5) callvirt DynamicMethod::CreateDelegate(Type, obj):Delegate
      1) ldarg.0 [Arr<obj>]
      1) ldc.i4.1
      5) ldelem [ExecCtx]
      1) ldc.i4.1
      5) call static TakeDropGen::ExecTakeIf(Seq<i8>, Func<i8,bool>, ExecCtx, i4):Seq<i8>
      5) call static CodeGenUtil::EnumerableToCaching(Seq<i8>):Seq<i8>
      1) ldarg.0 [Arr<obj>]
      1) ldc.i4.1
      5) ldelem [ExecCtx]
      1) ldc.i4.2
      2) ldloca.s [i8 (0)]
      5) call static SumBaseGen::ExecS(Seq<i8>, ExecCtx, i4, out i8):i8
      1) ret
  Total Size: 93

top(Arr<obj>, Arr<obj>):obj
      1) ldarg.1 [Arr<obj>]
      1) ldc.i4.0
      1) ldelem.ref
      5) call static CodeGenUtil::ToRef(obj):ExecCtx
      1) stloc.0 [ExecCtx]
      1) ldarg.1 [Arr<obj>]
      1) ldc.i4.1
      1) ldelem.ref
      5) call static CodeGenUtil::ToRef(obj):Seq<{i8,i8,i8}>
      1) stloc.1 [Seq<{i8,i8,i8}>]
      1) ldarg.1 [Arr<obj>]
      1) ldc.i4.2
      1) ldelem.ref
      5) call static CodeGenUtil::ToVal(obj):i8
      1) stloc.2 [i8]
      5) newobj (i8)()
      1) stloc.3 [(i8)]
      1) ldloc.3 [(i8)]
      1) ldloc.2 [i8]
      5) stfld (i8)::_F0:i8
      1) ldloc.1 [Seq<{i8,i8,i8}>]
      1) dup
      1) ldloc.0 [ExecCtx]
      1) ldc.i4.0
      5) call static CodeGenUtil::EnumerableToPinging(Seq<{i8,i8,i8}>, ExecCtx, i4):Seq<{i8,i8,i8}>
      1) ldarg.0 [Arr<obj>]
      1) ldc.i4.0
      5) ldelem [MethodInfo]
      5) ldtoken [Func<{i8,i8,i8},i8>]
      5) call static Type::GetTypeFromHandle(RuntimeTypeHandle):Type
      1) ldc.i4.3
      5) newarr [obj]
      1) dup
      1) ldc.i4.0
      1) ldarg.0 [Arr<obj>]
      1) ldc.i4.1
      5) ldelem [Arr<obj>]
      5) stelem [Arr<obj>]
      1) dup
      1) ldc.i4.2
      1) ldloc.3 [(i8)]
      5) stelem [(i8)]
      1) dup
      1) ldc.i4.1
      1) ldloc.0 [ExecCtx]
      5) stelem [ExecCtx]
      5) callvirt DynamicMethod::CreateDelegate(Type, obj):Delegate
      1) ldarg.0 [Arr<obj>]
      1) ldc.i4.2
      5) ldelem [Func<i8,i8,i4>]
      5) call static CodeGenUtil::Sort(Seq<{i8,i8,i8}>, Func<{i8,i8,i8},i8>, Func<i8,i8,i4>):Seq<{i8,i8,i8}>
      5) call static CodeGenUtil::WrapWithCounter(Seq<{i8,i8,i8}>, Seq<{i8,i8,i8}>):Seq<{i8,i8,i8}>
      5) call static CodeGenUtil::EnumerableToCaching(Seq<{i8,i8,i8}>):Seq<{i8,i8,i8}>
      1) ret
  Total Size: 130

Func sig: (<ctx>:x, Data:{A:i8, B:i8, C:i8}*, G:i8) to {A:i8, B:i8, C:i8}*
Sequence: Seq<{i8,i8,i8}>
 0) { A: 9, B: 1, C: 17 }
 1) { A: 7, B: 1, C: 17 }
 2) { A: 8, B: 0, C: 17 }
 3) { A: 5, B: 1, C: 17 }
 4) { A: 6, B: 0, C: 17 }
 5) { A: 4, B: 0, C: 17 }
 6) { A: 3, B: 1, C: 17 }
 7) { A: 1, B: 1, C: 17 }
 8) { A: 2, B: 0, C: 17 }
 9) { A: 0, B: 0, C: 17 }
*** Ctx ping count: 66
    [0](11): Sort(*1: Data, Sum(Take(*2: Range(*1.A), [if] IntMod(*2, G) @= 0)))
    [1](27): Take(*2: Range(*1x.A), [if] IntMod(*2, G) @= 0)
    [2](28): Sum(Take(*2: Range(*1x.A), [if] IntMod(*2, G) @= 0))
###
> Range(2)->Map(Sort(Data, A, [<] A, it$1))
Range(2)->Map(Sort(Data, A, [<] A, it$1)) : {A:i8, B:i8, C:i8}**
BndKind:Call, Type:{A:i8, B:i8, C:i8}**, Bnd:(Call(∂.ForEach([map:1] Call(∂.Range(2:i8):i8*), Call(∂.Sort([map:2] Global(Data), GetField(Scope(2), A), [<] GetField(Scope(2), A), Scope(1))))))
// (<ctx>, ∂.Data:{A:i8, B:i8, C:i8}*) : {A:i8, B:i8, C:i8}**
SortCompare(Arr<obj>, {i8,i8,i8}, {i8,i8,i8}):i4
      1) ldarg.2 [{i8,i8,i8}]
      5) ldfld {i8,i8,i8}::_F0:i8
      1) ldarg.1 [{i8,i8,i8}]
      5) ldfld {i8,i8,i8}::_F0:i8
      5) call static Cmp::Compare(i8, i8):i4
      1) dup
      5) brtrue [0]
      1) pop
      1) ldarg.1 [{i8,i8,i8}]
      5) ldfld {i8,i8,i8}::_F0:i8
      1) ldarg.2 [{i8,i8,i8}]
      5) ldfld {i8,i8,i8}::_F0:i8
      5) call static Cmp::Compare(i8, i8):i4
      1) dup
      5) brtrue [0]
      1) pop
      1) ldarg.0 [Arr<obj>]
      1) ldc.i4.3
      5) ldelem [(i8)]
      5) ldfld (i8)::_F0:i8
      1) ldarg.0 [Arr<obj>]
      1) ldc.i4.3
      5) ldelem [(i8)]
      5) ldfld (i8)::_F0:i8
      5) call static Cmp::Compare(i8, i8):i4
  Label [0]:
      1) ret
  Total Size: 78

ForEach_1(Arr<obj>, i8):Seq<{i8,i8,i8}>
      1) ldarg.0 [Arr<obj>]
      1) ldc.i4.2
      5) ldelem [(Seq<{i8,i8,i8}>)]
      5) ldfld (Seq<{i8,i8,i8}>)::_F0:Seq<{i8,i8,i8}>
      1) dup
      1) ldarg.0 [Arr<obj>]
      1) ldc.i4.1
      5) ldelem [ExecCtx]
      1) ldc.i4.0
      5) call static CodeGenUtil::EnumerableToPinging(Seq<{i8,i8,i8}>, ExecCtx, i4):Seq<{i8,i8,i8}>
      1) ldarg.0 [Arr<obj>]
      1) ldc.i4.0
      5) ldelem [Arr<obj>]
      1) ldc.i4.0
      5) ldelem [MethodInfo]
      5) ldtoken [Func<{i8,i8,i8},{i8,i8,i8},i4>]
      5) call static Type::GetTypeFromHandle(RuntimeTypeHandle):Type
      1) ldc.i4.4
      5) newarr [obj]
      1) dup
      1) ldc.i4.3
      5) newobj (i8)()
      1) dup
      1) ldarg.1 [i8]
      5) stfld (i8)::_F0:i8
      5) stelem [(i8)]
      5) callvirt DynamicMethod::CreateDelegate(Type, obj):Delegate
      5) call static CodeGenUtil::SortNoKey(Seq<{i8,i8,i8}>, Func<{i8,i8,i8},{i8,i8,i8},i4>):Seq<{i8,i8,i8}>
      5) call static CodeGenUtil::WrapWithCounter(Seq<{i8,i8,i8}>, Seq<{i8,i8,i8}>):Seq<{i8,i8,i8}>
      5) call static CodeGenUtil::EnumerableToCaching(Seq<{i8,i8,i8}>):Seq<{i8,i8,i8}>
      1) ret
  Total Size: 95

top(Arr<obj>, Arr<obj>):obj
      1) ldarg.1 [Arr<obj>]
      1) ldc.i4.0
      1) ldelem.ref
      5) call static CodeGenUtil::ToRef(obj):ExecCtx
      1) stloc.0 [ExecCtx]
      1) ldarg.1 [Arr<obj>]
      1) ldc.i4.1
      1) ldelem.ref
      5) call static CodeGenUtil::ToRef(obj):Seq<{i8,i8,i8}>
      1) stloc.1 [Seq<{i8,i8,i8}>]
      5) newobj (Seq<{i8,i8,i8}>)()
      1) stloc.2 [(Seq<{i8,i8,i8}>)]
      1) ldloc.2 [(Seq<{i8,i8,i8}>)]
      1) ldloc.1 [Seq<{i8,i8,i8}>]
      5) stfld (Seq<{i8,i8,i8}>)::_F0:Seq<{i8,i8,i8}>
      1) ldc.i4.2
      1) conv.i8
      5) call static RangeGen::Exec(i8):ICachingEnumerable<i8>
      1) ldarg.0 [Arr<obj>]
      1) ldc.i4.0
      5) ldelem [MethodInfo]
      5) ldtoken [Func<i8,Seq<{i8,i8,i8}>>]
      5) call static Type::GetTypeFromHandle(RuntimeTypeHandle):Type
      1) ldc.i4.3
      5) newarr [obj]
      1) dup
      1) ldc.i4.0
      1) ldarg.0 [Arr<obj>]
      1) ldc.i4.1
      5) ldelem [Arr<obj>]
      5) stelem [Arr<obj>]
      1) dup
      1) ldc.i4.2
      1) ldloc.2 [(Seq<{i8,i8,i8}>)]
      5) stelem [(Seq<{i8,i8,i8}>)]
      1) dup
      1) ldc.i4.1
      1) ldloc.0 [ExecCtx]
      5) stelem [ExecCtx]
      5) callvirt DynamicMethod::CreateDelegate(Type, obj):Delegate
      5) call static ForEachGen::Exec(Seq<i8>, Func<i8,Seq<{i8,i8,i8}>>):Seq<Seq<{i8,i8,i8}>>
      5) call static CodeGenUtil::EnumerableToCaching(Seq<Seq<{i8,i8,i8}>>):Seq<Seq<{i8,i8,i8}>>
      1) ret
  Total Size: 107

Func sig: (<ctx>:x, Data:{A:i8, B:i8, C:i8}*) to {A:i8, B:i8, C:i8}**
Sequence: Seq<Seq<{i8,i8,i8}>>
 0) Sequence: Seq<{i8,i8,i8}>
     0) { A: 9, B: 1, C: 17 }
     1) { A: 8, B: 0, C: 17 }
     2) { A: 7, B: 1, C: 17 }
     3) { A: 6, B: 0, C: 17 }
     4) { A: 5, B: 1, C: 17 }
     5) { A: 4, B: 0, C: 17 }
     6) { A: 3, B: 1, C: 17 }
     7) { A: 2, B: 0, C: 17 }
     8) { A: 1, B: 1, C: 17 }
     9) { A: 0, B: 0, C: 17 }
 1) Sequence: Seq<{i8,i8,i8}>
     0) { A: 9, B: 1, C: 17 }
     1) { A: 8, B: 0, C: 17 }
     2) { A: 7, B: 1, C: 17 }
     3) { A: 6, B: 0, C: 17 }
     4) { A: 5, B: 1, C: 17 }
     5) { A: 4, B: 0, C: 17 }
     6) { A: 3, B: 1, C: 17 }
     7) { A: 2, B: 0, C: 17 }
     8) { A: 1, B: 1, C: 17 }
     9) { A: 0, B: 0, C: 17 }
*** Ctx ping count: 22
    [0](22): Sort(*1: Data, *1.A, [<] *1.A, *2x)
###

**** New definitions: D, type: i8*
**** New definitions: DB, type: b*
**** New definitions: DI1, type: i1*
**** New definitions: DU1, type: u1*
**** New definitions: DI2, type: i2*
**** New definitions: DU2, type: u2*
**** New definitions: DI4, type: i4*
**** New definitions: DU4, type: u4*

> Sort(DI1, Wrap(it))
Sort(DI1, Wrap(it)) : i1*
BndKind:Call, Type:i1*, Bnd:(Call(∂.Sort([map:1] Global(DI1), Call(∂.Test.Wrap(Scope(1)):i1)):i1*))
// (<ctx>, ∂.DI1:i1*) : i1*
Sort_1(Arr<obj>, i1):i1
      1) ldarg.1 [i1]
      5) call static WrapFuncGen::Exec(i1):i1
      1) ret
  Total Size: 7

CompareDec(Arr<obj>, i1, i1):i4
      1) ldarg.2 [i1]
      1) ldarg.1 [i1]
      1) sub
      1) ret
  Total Size: 4

top(Arr<obj>, Arr<obj>):obj
      1) ldarg.1 [Arr<obj>]
      1) ldc.i4.0
      1) ldelem.ref
      5) call static CodeGenUtil::ToRef(obj):ExecCtx
      1) stloc.0 [ExecCtx]
      1) ldarg.1 [Arr<obj>]
      1) ldc.i4.1
      1) ldelem.ref
      5) call static CodeGenUtil::ToRef(obj):Seq<i1>
      1) stloc.1 [Seq<i1>]
      1) ldloc.1 [Seq<i1>]
      1) dup
      1) ldloc.0 [ExecCtx]
      1) ldc.i4.0
      5) call static CodeGenUtil::EnumerableToPinging(Seq<i1>, ExecCtx, i4):Seq<i1>
      1) ldarg.0 [Arr<obj>]
      1) ldc.i4.0
      5) ldelem [Func<i1,i1>]
      1) ldarg.0 [Arr<obj>]
      1) ldc.i4.1
      5) ldelem [Func<i1,i1,i4>]
      5) call static CodeGenUtil::Sort(Seq<i1>, Func<i1,i1>, Func<i1,i1,i4>):Seq<i1>
      5) call static CodeGenUtil::WrapWithCounter(Seq<i1>, Seq<i1>):Seq<i1>
      5) call static CodeGenUtil::EnumerableToCaching(Seq<i1>):Seq<i1>
      1) ret
  Total Size: 57

Func sig: (<ctx>:x, DI1:i1*) to i1*
Sequence: Seq<i1>
 0) 9
 1) 8
 2) 7
 3) 6
 4) 5
 5) 4
 6) 3
 7) 2
 8) 1
 9) 0
*** Ctx ping count: 11
    [0](11): Sort(*1: DI1, Test.Wrap(*1))
###
> Sort(DU1, Wrap(it))
Sort(DU1, Wrap(it)) : u1*
BndKind:Call, Type:u1*, Bnd:(Call(∂.Sort([map:1] Global(DU1), Call(∂.Test.Wrap(Scope(1)):u1)):u1*))
// (<ctx>, ∂.DU1:u1*) : u1*
Sort_1(Arr<obj>, u1):u1
      1) ldarg.1 [u1]
      5) call static WrapFuncGen::Exec(u1):u1
      1) ret
  Total Size: 7

CompareDec(Arr<obj>, u1, u1):i4
      1) ldarg.2 [u1]
      1) ldarg.1 [u1]
      1) sub
      1) ret
  Total Size: 4

top(Arr<obj>, Arr<obj>):obj
      1) ldarg.1 [Arr<obj>]
      1) ldc.i4.0
      1) ldelem.ref
      5) call static CodeGenUtil::ToRef(obj):ExecCtx
      1) stloc.0 [ExecCtx]
      1) ldarg.1 [Arr<obj>]
      1) ldc.i4.1
      1) ldelem.ref
      5) call static CodeGenUtil::ToRef(obj):Seq<u1>
      1) stloc.1 [Seq<u1>]
      1) ldloc.1 [Seq<u1>]
      1) dup
      1) ldloc.0 [ExecCtx]
      1) ldc.i4.0
      5) call static CodeGenUtil::EnumerableToPinging(Seq<u1>, ExecCtx, i4):Seq<u1>
      1) ldarg.0 [Arr<obj>]
      1) ldc.i4.0
      5) ldelem [Func<u1,u1>]
      1) ldarg.0 [Arr<obj>]
      1) ldc.i4.1
      5) ldelem [Func<u1,u1,i4>]
      5) call static CodeGenUtil::Sort(Seq<u1>, Func<u1,u1>, Func<u1,u1,i4>):Seq<u1>
      5) call static CodeGenUtil::WrapWithCounter(Seq<u1>, Seq<u1>):Seq<u1>
      5) call static CodeGenUtil::EnumerableToCaching(Seq<u1>):Seq<u1>
      1) ret
  Total Size: 57

Func sig: (<ctx>:x, DU1:u1*) to u1*
Sequence: Seq<u1>
 0) 9
 1) 8
 2) 7
 3) 6
 4) 5
 5) 4
 6) 3
 7) 2
 8) 1
 9) 0
*** Ctx ping count: 11
    [0](11): Sort(*1: DU1, Test.Wrap(*1))
###
> Sort(DI2, Wrap(it))
Sort(DI2, Wrap(it)) : i2*
BndKind:Call, Type:i2*, Bnd:(Call(∂.Sort([map:1] Global(DI2), Call(∂.Test.Wrap(Scope(1)):i2)):i2*))
// (<ctx>, ∂.DI2:i2*) : i2*
Sort_1(Arr<obj>, i2):i2
      1) ldarg.1 [i2]
      5) call static WrapFuncGen::Exec(i2):i2
      1) ret
  Total Size: 7

CompareDec(Arr<obj>, i2, i2):i4
      1) ldarg.2 [i2]
      1) ldarg.1 [i2]
      1) sub
      1) ret
  Total Size: 4

top(Arr<obj>, Arr<obj>):obj
      1) ldarg.1 [Arr<obj>]
      1) ldc.i4.0
      1) ldelem.ref
      5) call static CodeGenUtil::ToRef(obj):ExecCtx
      1) stloc.0 [ExecCtx]
      1) ldarg.1 [Arr<obj>]
      1) ldc.i4.1
      1) ldelem.ref
      5) call static CodeGenUtil::ToRef(obj):Seq<i2>
      1) stloc.1 [Seq<i2>]
      1) ldloc.1 [Seq<i2>]
      1) dup
      1) ldloc.0 [ExecCtx]
      1) ldc.i4.0
      5) call static CodeGenUtil::EnumerableToPinging(Seq<i2>, ExecCtx, i4):Seq<i2>
      1) ldarg.0 [Arr<obj>]
      1) ldc.i4.0
      5) ldelem [Func<i2,i2>]
      1) ldarg.0 [Arr<obj>]
      1) ldc.i4.1
      5) ldelem [Func<i2,i2,i4>]
      5) call static CodeGenUtil::Sort(Seq<i2>, Func<i2,i2>, Func<i2,i2,i4>):Seq<i2>
      5) call static CodeGenUtil::WrapWithCounter(Seq<i2>, Seq<i2>):Seq<i2>
      5) call static CodeGenUtil::EnumerableToCaching(Seq<i2>):Seq<i2>
      1) ret
  Total Size: 57

Func sig: (<ctx>:x, DI2:i2*) to i2*
Sequence: Seq<i2>
 0) 9
 1) 8
 2) 7
 3) 6
 4) 5
 5) 4
 6) 3
 7) 2
 8) 1
 9) 0
*** Ctx ping count: 11
    [0](11): Sort(*1: DI2, Test.Wrap(*1))
###
> Sort(DU2, Wrap(it))
Sort(DU2, Wrap(it)) : u2*
BndKind:Call, Type:u2*, Bnd:(Call(∂.Sort([map:1] Global(DU2), Call(∂.Test.Wrap(Scope(1)):u2)):u2*))
// (<ctx>, ∂.DU2:u2*) : u2*
Sort_1(Arr<obj>, u2):u2
      1) ldarg.1 [u2]
      5) call static WrapFuncGen::Exec(u2):u2
      1) ret
  Total Size: 7

CompareDec(Arr<obj>, u2, u2):i4
      1) ldarg.2 [u2]
      1) ldarg.1 [u2]
      1) sub
      1) ret
  Total Size: 4

top(Arr<obj>, Arr<obj>):obj
      1) ldarg.1 [Arr<obj>]
      1) ldc.i4.0
      1) ldelem.ref
      5) call static CodeGenUtil::ToRef(obj):ExecCtx
      1) stloc.0 [ExecCtx]
      1) ldarg.1 [Arr<obj>]
      1) ldc.i4.1
      1) ldelem.ref
      5) call static CodeGenUtil::ToRef(obj):Seq<u2>
      1) stloc.1 [Seq<u2>]
      1) ldloc.1 [Seq<u2>]
      1) dup
      1) ldloc.0 [ExecCtx]
      1) ldc.i4.0
      5) call static CodeGenUtil::EnumerableToPinging(Seq<u2>, ExecCtx, i4):Seq<u2>
      1) ldarg.0 [Arr<obj>]
      1) ldc.i4.0
      5) ldelem [Func<u2,u2>]
      1) ldarg.0 [Arr<obj>]
      1) ldc.i4.1
      5) ldelem [Func<u2,u2,i4>]
      5) call static CodeGenUtil::Sort(Seq<u2>, Func<u2,u2>, Func<u2,u2,i4>):Seq<u2>
      5) call static CodeGenUtil::WrapWithCounter(Seq<u2>, Seq<u2>):Seq<u2>
      5) call static CodeGenUtil::EnumerableToCaching(Seq<u2>):Seq<u2>
      1) ret
  Total Size: 57

Func sig: (<ctx>:x, DU2:u2*) to u2*
Sequence: Seq<u2>
 0) 9
 1) 8
 2) 7
 3) 6
 4) 5
 5) 4
 6) 3
 7) 2
 8) 1
 9) 0
*** Ctx ping count: 11
    [0](11): Sort(*1: DU2, Test.Wrap(*1))
###
> Sort(DI4, Wrap(it))
Sort(DI4, Wrap(it)) : i4*
BndKind:Call, Type:i4*, Bnd:(Call(∂.Sort([map:1] Global(DI4), Call(∂.Test.Wrap(Scope(1)):i4)):i4*))
// (<ctx>, ∂.DI4:i4*) : i4*
Sort_1(Arr<obj>, i4):i4
      1) ldarg.1 [i4]
      5) call static WrapFuncGen::Exec(i4):i4
      1) ret
  Total Size: 7

CompareDec(Arr<obj>, i4, i4):i4
      1) ldarg.2 [i4]
      1) conv.i8
      1) ldarg.1 [i4]
      1) conv.i8
      1) sub
      1) dup
      1) ldc.i4.1
      1) conv.i8
      1) and
      1) ldc.i4.1
      1) shl
      1) or
      1) ldc.i4.1
      1) shr
      1) conv.i4
      1) ret
  Total Size: 16

top(Arr<obj>, Arr<obj>):obj
      1) ldarg.1 [Arr<obj>]
      1) ldc.i4.0
      1) ldelem.ref
      5) call static CodeGenUtil::ToRef(obj):ExecCtx
      1) stloc.0 [ExecCtx]
      1) ldarg.1 [Arr<obj>]
      1) ldc.i4.1
      1) ldelem.ref
      5) call static CodeGenUtil::ToRef(obj):Seq<i4>
      1) stloc.1 [Seq<i4>]
      1) ldloc.1 [Seq<i4>]
      1) dup
      1) ldloc.0 [ExecCtx]
      1) ldc.i4.0
      5) call static CodeGenUtil::EnumerableToPinging(Seq<i4>, ExecCtx, i4):Seq<i4>
      1) ldarg.0 [Arr<obj>]
      1) ldc.i4.0
      5) ldelem [Func<i4,i4>]
      1) ldarg.0 [Arr<obj>]
      1) ldc.i4.1
      5) ldelem [Func<i4,i4,i4>]
      5) call static CodeGenUtil::Sort(Seq<i4>, Func<i4,i4>, Func<i4,i4,i4>):Seq<i4>
      5) call static CodeGenUtil::WrapWithCounter(Seq<i4>, Seq<i4>):Seq<i4>
      5) call static CodeGenUtil::EnumerableToCaching(Seq<i4>):Seq<i4>
      1) ret
  Total Size: 57

Func sig: (<ctx>:x, DI4:i4*) to i4*
Sequence: Seq<i4>
 0) 9
 1) 8
 2) 7
 3) 6
 4) 5
 5) 4
 6) 3
 7) 2
 8) 1
 9) 0
*** Ctx ping count: 11
    [0](11): Sort(*1: DI4, Test.Wrap(*1))
###
> Sort(DU4, Wrap(it))
Sort(DU4, Wrap(it)) : u4*
BndKind:Call, Type:u4*, Bnd:(Call(∂.Sort([map:1] Global(DU4), Call(∂.Test.Wrap(Scope(1)):u4)):u4*))
// (<ctx>, ∂.DU4:u4*) : u4*
Sort_1(Arr<obj>, u4):u4
      1) ldarg.1 [u4]
      5) call static WrapFuncGen::Exec(u4):u4
      1) ret
  Total Size: 7

CompareDec(Arr<obj>, u4, u4):i4
      1) ldarg.2 [u4]
      1) conv.u8
      1) ldarg.1 [u4]
      1) conv.u8
      1) sub
      1) dup
      1) ldc.i4.1
      1) conv.i8
      1) and
      1) ldc.i4.1
      1) shl
      1) or
      1) ldc.i4.1
      1) shr
      1) conv.i4
      1) ret
  Total Size: 16

top(Arr<obj>, Arr<obj>):obj
      1) ldarg.1 [Arr<obj>]
      1) ldc.i4.0
      1) ldelem.ref
      5) call static CodeGenUtil::ToRef(obj):ExecCtx
      1) stloc.0 [ExecCtx]
      1) ldarg.1 [Arr<obj>]
      1) ldc.i4.1
      1) ldelem.ref
      5) call static CodeGenUtil::ToRef(obj):Seq<u4>
      1) stloc.1 [Seq<u4>]
      1) ldloc.1 [Seq<u4>]
      1) dup
      1) ldloc.0 [ExecCtx]
      1) ldc.i4.0
      5) call static CodeGenUtil::EnumerableToPinging(Seq<u4>, ExecCtx, i4):Seq<u4>
      1) ldarg.0 [Arr<obj>]
      1) ldc.i4.0
      5) ldelem [Func<u4,u4>]
      1) ldarg.0 [Arr<obj>]
      1) ldc.i4.1
      5) ldelem [Func<u4,u4,i4>]
      5) call static CodeGenUtil::Sort(Seq<u4>, Func<u4,u4>, Func<u4,u4,i4>):Seq<u4>
      5) call static CodeGenUtil::WrapWithCounter(Seq<u4>, Seq<u4>):Seq<u4>
      5) call static CodeGenUtil::EnumerableToCaching(Seq<u4>):Seq<u4>
      1) ret
  Total Size: 57

Func sig: (<ctx>:x, DU4:u4*) to u4*
Sequence: Seq<u4>
 0) 9
 1) 8
 2) 7
 3) 6
 4) 5
 5) 4
 6) 3
 7) 2
 8) 1
 9) 0
*** Ctx ping count: 11
    [0](11): Sort(*1: DU4, Test.Wrap(*1))
###
> Sort(DB, Wrap(it))
Sort(DB, Wrap(it)) : b*
BndKind:Call, Type:b*, Bnd:(Call(∂.Sort([map:1] Global(DB), Call(∂.Test.Wrap(Scope(1)):b)):b*))
// (<ctx>, ∂.DB:b*) : b*
Sort_1(Arr<obj>, bool):bool
      1) ldarg.1 [bool]
      5) call static WrapFuncGen::Exec(bool):bool
      1) ret
  Total Size: 7

CompareDec(Arr<obj>, bool, bool):i4
      1) ldarg.2 [bool]
      1) ldarg.1 [bool]
      1) sub
      1) ret
  Total Size: 4

top(Arr<obj>, Arr<obj>):obj
      1) ldarg.1 [Arr<obj>]
      1) ldc.i4.0
      1) ldelem.ref
      5) call static CodeGenUtil::ToRef(obj):ExecCtx
      1) stloc.0 [ExecCtx]
      1) ldarg.1 [Arr<obj>]
      1) ldc.i4.1
      1) ldelem.ref
      5) call static CodeGenUtil::ToRef(obj):Seq<bool>
      1) stloc.1 [Seq<bool>]
      1) ldloc.1 [Seq<bool>]
      1) dup
      1) ldloc.0 [ExecCtx]
      1) ldc.i4.0
      5) call static CodeGenUtil::EnumerableToPinging(Seq<bool>, ExecCtx, i4):Seq<bool>
      1) ldarg.0 [Arr<obj>]
      1) ldc.i4.0
      5) ldelem [Func<bool,bool>]
      1) ldarg.0 [Arr<obj>]
      1) ldc.i4.1
      5) ldelem [Func<bool,bool,i4>]
      5) call static CodeGenUtil::Sort(Seq<bool>, Func<bool,bool>, Func<bool,bool,i4>):Seq<bool>
      5) call static CodeGenUtil::WrapWithCounter(Seq<bool>, Seq<bool>):Seq<bool>
      5) call static CodeGenUtil::EnumerableToCaching(Seq<bool>):Seq<bool>
      1) ret
  Total Size: 57

Func sig: (<ctx>:x, DB:b*) to b*
Sequence: Seq<bool>
 0) true 
 1) true 
 2) true 
 3) true 
 4) true 
 5) false
 6) false
 7) false
 8) false
 9) false
*** Ctx ping count: 11
    [0](11): Sort(*1: DB, Test.Wrap(*1))
###
