**** New definitions: I_s, type: i*
**** New definitions: I8s, type: i8*
**** New definitions: I4s, type: i4*
**** New definitions: I2s, type: i2*
**** New definitions: I1s, type: i1*
**** New definitions: U8s, type: u8*
**** New definitions: U4s, type: u4*
**** New definitions: U2s, type: u2*
**** New definitions: U1s, type: u1*
**** New definitions: R8s, type: r8*
**** New definitions: R4s, type: r4*

> I_s->CastDate()->CastIA()
I_s->CastDate()->CastIA() : i*
BndKind:Call, Type:i*, Bnd:(Call(∂.ForEach([map:1] Global(I_s), Num<i>(Call(∂.Date.TotalTicks(Call(∂.CastDate(Scope(1)):d)):i8))):i*))
// (∂.I_s:i*) : i*
ForEach_1(Arr<obj>, ia):ia
      1) ldarg.1 [ia]
      5) call static CastChronoGen::ExecDate(ia):Date
      1) stloc.0 [Date]
      2) ldloca.s [Date (0)]
      5) call Date::get_Ticks():i8
      5) newobj ia(i8)
      1) ret
  Total Size: 20

top(Arr<obj>, Arr<obj>):obj
      1) ldarg.1 [Arr<obj>]
      1) ldc.i4.0
      1) ldelem.ref
      5) call static CodeGenUtil::ToRef(obj):Seq<ia>
      1) stloc.0 [Seq<ia>]
      1) ldloc.0 [Seq<ia>]
      1) ldarg.0 [Arr<obj>]
      1) ldc.i4.0
      5) ldelem [Func<ia,ia>]
      5) call static ForEachGen::Exec(Seq<ia>, Func<ia,ia>):Seq<ia>
      5) call static CodeGenUtil::EnumerableToCaching(Seq<ia>):Seq<ia>
      1) ret
  Total Size: 28

Func sig: (I_s:i*) to i*
Sequence: Seq<ia>
 0) 3
 1) 0
 2) 127
 3) 128
 4) 256
 5) 32767
 6) 32768
 7) 65536
 8) 2147483647
 9) 2147483648
10) 4294967296
11) 3155378975999999999
12) 0
13) 0
14) 0
15) 0
16) 0
###
> I_s->CastTime()->CastIA()
I_s->CastTime()->CastIA() : i*
BndKind:Call, Type:i*, Bnd:(Call(∂.ForEach([map:1] Global(I_s), Num<i>(Call(∂.Time.TotalTicks(Call(∂.CastTime(Scope(1)):t)):i8))):i*))
// (∂.I_s:i*) : i*
ForEach_1(Arr<obj>, ia):ia
      1) ldarg.1 [ia]
      5) call static CastChronoGen::ExecTime(ia):Time
      1) stloc.0 [Time]
      2) ldloca.s [Time (0)]
      5) call Time::get_Ticks():i8
      5) newobj ia(i8)
      1) ret
  Total Size: 20

top(Arr<obj>, Arr<obj>):obj
      1) ldarg.1 [Arr<obj>]
      1) ldc.i4.0
      1) ldelem.ref
      5) call static CodeGenUtil::ToRef(obj):Seq<ia>
      1) stloc.0 [Seq<ia>]
      1) ldloc.0 [Seq<ia>]
      1) ldarg.0 [Arr<obj>]
      1) ldc.i4.0
      5) ldelem [Func<ia,ia>]
      5) call static ForEachGen::Exec(Seq<ia>, Func<ia,ia>):Seq<ia>
      5) call static CodeGenUtil::EnumerableToCaching(Seq<ia>):Seq<ia>
      1) ret
  Total Size: 28

Func sig: (I_s:i*) to i*
Sequence: Seq<ia>
 0) 3
 1) -7
 2) 127
 3) 128
 4) 256
 5) 32767
 6) 32768
 7) 65536
 8) 2147483647
 9) 2147483648
10) 4294967296
11) 3155378975999999999
12) 3155378976000000000
13) 9223372036854775807
14) -9223372036854775808
15) 0
16) 0
###
> I8s->CastDate()->CastIA()
I8s->CastDate()->CastIA() : i*
BndKind:Call, Type:i*, Bnd:(Call(∂.ForEach([map:1] Global(I8s), Num<i>(Call(∂.Date.TotalTicks(Call(∂.CastDate(Scope(1)):d)):i8))):i*))
// (∂.I8s:i8*) : i*
ForEach_1(Arr<obj>, i8):ia
      1) ldarg.1 [i8]
      1) dup
      9) ldc.i8 [3155378975999999999]
      5) ble.un [0]
      1) dup
      1) xor
  Label [0]:
      5) call static Date::FromTicks(i8):Date
      1) stloc.0 [Date]
      2) ldloca.s [Date (0)]
      5) call Date::get_Ticks():i8
      5) newobj ia(i8)
      1) ret
  Total Size: 37

top(Arr<obj>, Arr<obj>):obj
      1) ldarg.1 [Arr<obj>]
      1) ldc.i4.0
      1) ldelem.ref
      5) call static CodeGenUtil::ToRef(obj):Seq<i8>
      1) stloc.0 [Seq<i8>]
      1) ldloc.0 [Seq<i8>]
      1) ldarg.0 [Arr<obj>]
      1) ldc.i4.0
      5) ldelem [Func<i8,ia>]
      5) call static ForEachGen::Exec(Seq<i8>, Func<i8,ia>):Seq<ia>
      5) call static CodeGenUtil::EnumerableToCaching(Seq<ia>):Seq<ia>
      1) ret
  Total Size: 28

Func sig: (I8s:i8*) to i*
Sequence: Seq<ia>
 0) 3
 1) 0
 2) 127
 3) 128
 4) 256
 5) 32767
 6) 32768
 7) 65536
 8) 2147483647
 9) 2147483648
10) 4294967296
11) 3155378975999999999
12) 0
13) 0
14) 0
###
> I8s->CastTime()->CastIA()
I8s->CastTime()->CastIA() : i*
BndKind:Call, Type:i*, Bnd:(Call(∂.ForEach([map:1] Global(I8s), Num<i>(Call(∂.Time.TotalTicks(Call(∂.CastTime(Scope(1)):t)):i8))):i*))
// (∂.I8s:i8*) : i*
ForEach_1(Arr<obj>, i8):ia
      1) ldarg.1 [i8]
      5) newobj Time(i8)
      1) stloc.0 [Time]
      2) ldloca.s [Time (0)]
      5) call Time::get_Ticks():i8
      5) newobj ia(i8)
      1) ret
  Total Size: 20

top(Arr<obj>, Arr<obj>):obj
      1) ldarg.1 [Arr<obj>]
      1) ldc.i4.0
      1) ldelem.ref
      5) call static CodeGenUtil::ToRef(obj):Seq<i8>
      1) stloc.0 [Seq<i8>]
      1) ldloc.0 [Seq<i8>]
      1) ldarg.0 [Arr<obj>]
      1) ldc.i4.0
      5) ldelem [Func<i8,ia>]
      5) call static ForEachGen::Exec(Seq<i8>, Func<i8,ia>):Seq<ia>
      5) call static CodeGenUtil::EnumerableToCaching(Seq<ia>):Seq<ia>
      1) ret
  Total Size: 28

Func sig: (I8s:i8*) to i*
Sequence: Seq<ia>
 0) 3
 1) -7
 2) 127
 3) 128
 4) 256
 5) 32767
 6) 32768
 7) 65536
 8) 2147483647
 9) 2147483648
10) 4294967296
11) 3155378975999999999
12) 3155378976000000000
13) 9223372036854775807
14) -9223372036854775808
###
> U8s->CastDate()->CastIA()
U8s->CastDate()->CastIA() : i*
BndKind:Call, Type:i*, Bnd:(Call(∂.ForEach([map:1] Global(U8s), Num<i>(Call(∂.Date.TotalTicks(Call(∂.CastDate(Scope(1)):d)):i8))):i*))
// (∂.U8s:u8*) : i*
ForEach_1(Arr<obj>, u8):ia
      1) ldarg.1 [u8]
      1) dup
      9) ldc.i8 [3155378975999999999]
      5) ble.un [0]
      1) dup
      1) xor
  Label [0]:
      5) call static Date::FromTicks(i8):Date
      1) stloc.0 [Date]
      2) ldloca.s [Date (0)]
      5) call Date::get_Ticks():i8
      5) newobj ia(i8)
      1) ret
  Total Size: 37

top(Arr<obj>, Arr<obj>):obj
      1) ldarg.1 [Arr<obj>]
      1) ldc.i4.0
      1) ldelem.ref
      5) call static CodeGenUtil::ToRef(obj):Seq<u8>
      1) stloc.0 [Seq<u8>]
      1) ldloc.0 [Seq<u8>]
      1) ldarg.0 [Arr<obj>]
      1) ldc.i4.0
      5) ldelem [Func<u8,ia>]
      5) call static ForEachGen::Exec(Seq<u8>, Func<u8,ia>):Seq<ia>
      5) call static CodeGenUtil::EnumerableToCaching(Seq<ia>):Seq<ia>
      1) ret
  Total Size: 28

Func sig: (U8s:u8*) to i*
Sequence: Seq<ia>
 0) 3
 1) 7
 2) 128
 3) 255
 4) 256
 5) 32768
 6) 65535
 7) 65536
 8) 2147483648
 9) 4294967295
10) 4294967296
11) 3155378975999999999
12) 0
13) 0
14) 0
###
> U8s->CastTime()->CastIA()
U8s->CastTime()->CastIA() : i*
BndKind:Call, Type:i*, Bnd:(Call(∂.ForEach([map:1] Global(U8s), Num<i>(Call(∂.Time.TotalTicks(Call(∂.CastTime(Scope(1)):t)):i8))):i*))
// (∂.U8s:u8*) : i*
ForEach_1(Arr<obj>, u8):ia
      1) ldarg.1 [u8]
      1) dup
      1) ldc.i4.0
      1) conv.i8
      5) bge [0]
      1) dup
      1) xor
  Label [0]:
      5) newobj Time(i8)
      1) stloc.0 [Time]
      2) ldloca.s [Time (0)]
      5) call Time::get_Ticks():i8
      5) newobj ia(i8)
      1) ret
  Total Size: 30

top(Arr<obj>, Arr<obj>):obj
      1) ldarg.1 [Arr<obj>]
      1) ldc.i4.0
      1) ldelem.ref
      5) call static CodeGenUtil::ToRef(obj):Seq<u8>
      1) stloc.0 [Seq<u8>]
      1) ldloc.0 [Seq<u8>]
      1) ldarg.0 [Arr<obj>]
      1) ldc.i4.0
      5) ldelem [Func<u8,ia>]
      5) call static ForEachGen::Exec(Seq<u8>, Func<u8,ia>):Seq<ia>
      5) call static CodeGenUtil::EnumerableToCaching(Seq<ia>):Seq<ia>
      1) ret
  Total Size: 28

Func sig: (U8s:u8*) to i*
Sequence: Seq<ia>
 0) 3
 1) 7
 2) 128
 3) 255
 4) 256
 5) 32768
 6) 65535
 7) 65536
 8) 2147483648
 9) 4294967295
10) 4294967296
11) 3155378975999999999
12) 3155378976000000000
13) 0
14) 0
###
> I4s->CastDate()->CastIA()
I4s->CastDate()->CastIA() : i*
BndKind:Call, Type:i*, Bnd:(Call(∂.ForEach([map:1] Global(I4s), Num<i>(Call(∂.Date.TotalTicks(Call(∂.CastDate(Scope(1)):d)):i8))):i*))
// (∂.I4s:i4*) : i*
ForEach_1(Arr<obj>, i4):ia
      1) ldarg.1 [i4]
      1) conv.i8
      1) dup
      1) ldc.i4.0
      1) conv.i8
      5) bge [0]
      1) dup
      1) xor
  Label [0]:
      5) call static Date::FromTicks(i8):Date
      1) stloc.0 [Date]
      2) ldloca.s [Date (0)]
      5) call Date::get_Ticks():i8
      5) newobj ia(i8)
      1) ret
  Total Size: 31

top(Arr<obj>, Arr<obj>):obj
      1) ldarg.1 [Arr<obj>]
      1) ldc.i4.0
      1) ldelem.ref
      5) call static CodeGenUtil::ToRef(obj):Seq<i4>
      1) stloc.0 [Seq<i4>]
      1) ldloc.0 [Seq<i4>]
      1) ldarg.0 [Arr<obj>]
      1) ldc.i4.0
      5) ldelem [Func<i4,ia>]
      5) call static ForEachGen::Exec(Seq<i4>, Func<i4,ia>):Seq<ia>
      5) call static CodeGenUtil::EnumerableToCaching(Seq<ia>):Seq<ia>
      1) ret
  Total Size: 28

Func sig: (I4s:i4*) to i*
Sequence: Seq<ia>
 0) 3
 1) 0
 2) 127
 3) 128
 4) 256
 5) 32767
 6) 32768
 7) 65536
 8) 2147483647
 9) 0
###
> I4s->CastTime()->CastIA()
I4s->CastTime()->CastIA() : i*
BndKind:Call, Type:i*, Bnd:(Call(∂.ForEach([map:1] Global(I4s), Num<i>(Call(∂.Time.TotalTicks(Call(∂.CastTime(Scope(1)):t)):i8))):i*))
// (∂.I4s:i4*) : i*
ForEach_1(Arr<obj>, i4):ia
      1) ldarg.1 [i4]
      1) conv.i8
      5) newobj Time(i8)
      1) stloc.0 [Time]
      2) ldloca.s [Time (0)]
      5) call Time::get_Ticks():i8
      5) newobj ia(i8)
      1) ret
  Total Size: 21

top(Arr<obj>, Arr<obj>):obj
      1) ldarg.1 [Arr<obj>]
      1) ldc.i4.0
      1) ldelem.ref
      5) call static CodeGenUtil::ToRef(obj):Seq<i4>
      1) stloc.0 [Seq<i4>]
      1) ldloc.0 [Seq<i4>]
      1) ldarg.0 [Arr<obj>]
      1) ldc.i4.0
      5) ldelem [Func<i4,ia>]
      5) call static ForEachGen::Exec(Seq<i4>, Func<i4,ia>):Seq<ia>
      5) call static CodeGenUtil::EnumerableToCaching(Seq<ia>):Seq<ia>
      1) ret
  Total Size: 28

Func sig: (I4s:i4*) to i*
Sequence: Seq<ia>
 0) 3
 1) -7
 2) 127
 3) 128
 4) 256
 5) 32767
 6) 32768
 7) 65536
 8) 2147483647
 9) -2147483648
###
> U4s->CastDate()->CastIA()
U4s->CastDate()->CastIA() : i*
BndKind:Call, Type:i*, Bnd:(Call(∂.ForEach([map:1] Global(U4s), Num<i>(Call(∂.Date.TotalTicks(Call(∂.CastDate(Scope(1)):d)):i8))):i*))
// (∂.U4s:u4*) : i*
ForEach_1(Arr<obj>, u4):ia
      1) ldarg.1 [u4]
      1) conv.u8
      5) call static Date::FromTicks(i8):Date
      1) stloc.0 [Date]
      2) ldloca.s [Date (0)]
      5) call Date::get_Ticks():i8
      5) newobj ia(i8)
      1) ret
  Total Size: 21

top(Arr<obj>, Arr<obj>):obj
      1) ldarg.1 [Arr<obj>]
      1) ldc.i4.0
      1) ldelem.ref
      5) call static CodeGenUtil::ToRef(obj):Seq<u4>
      1) stloc.0 [Seq<u4>]
      1) ldloc.0 [Seq<u4>]
      1) ldarg.0 [Arr<obj>]
      1) ldc.i4.0
      5) ldelem [Func<u4,ia>]
      5) call static ForEachGen::Exec(Seq<u4>, Func<u4,ia>):Seq<ia>
      5) call static CodeGenUtil::EnumerableToCaching(Seq<ia>):Seq<ia>
      1) ret
  Total Size: 28

Func sig: (U4s:u4*) to i*
Sequence: Seq<ia>
 0) 3
 1) 7
 2) 128
 3) 255
 4) 256
 5) 32768
 6) 65535
 7) 65536
 8) 2147483648
 9) 4294967295
###
> U4s->CastTime()->CastIA()
U4s->CastTime()->CastIA() : i*
BndKind:Call, Type:i*, Bnd:(Call(∂.ForEach([map:1] Global(U4s), Num<i>(Call(∂.Time.TotalTicks(Call(∂.CastTime(Scope(1)):t)):i8))):i*))
// (∂.U4s:u4*) : i*
ForEach_1(Arr<obj>, u4):ia
      1) ldarg.1 [u4]
      1) conv.u8
      5) newobj Time(i8)
      1) stloc.0 [Time]
      2) ldloca.s [Time (0)]
      5) call Time::get_Ticks():i8
      5) newobj ia(i8)
      1) ret
  Total Size: 21

top(Arr<obj>, Arr<obj>):obj
      1) ldarg.1 [Arr<obj>]
      1) ldc.i4.0
      1) ldelem.ref
      5) call static CodeGenUtil::ToRef(obj):Seq<u4>
      1) stloc.0 [Seq<u4>]
      1) ldloc.0 [Seq<u4>]
      1) ldarg.0 [Arr<obj>]
      1) ldc.i4.0
      5) ldelem [Func<u4,ia>]
      5) call static ForEachGen::Exec(Seq<u4>, Func<u4,ia>):Seq<ia>
      5) call static CodeGenUtil::EnumerableToCaching(Seq<ia>):Seq<ia>
      1) ret
  Total Size: 28

Func sig: (U4s:u4*) to i*
Sequence: Seq<ia>
 0) 3
 1) 7
 2) 128
 3) 255
 4) 256
 5) 32768
 6) 65535
 7) 65536
 8) 2147483648
 9) 4294967295
###
> I2s->CastDate()->CastIA()
I2s->CastDate()->CastIA() : i*
BndKind:Call, Type:i*, Bnd:(Call(∂.ForEach([map:1] Global(I2s), Num<i>(Call(∂.Date.TotalTicks(Call(∂.CastDate(Scope(1)):d)):i8))):i*))
// (∂.I2s:i2*) : i*
ForEach_1(Arr<obj>, i2):ia
      1) ldarg.1 [i2]
      1) conv.i8
      1) dup
      1) ldc.i4.0
      1) conv.i8
      5) bge [0]
      1) dup
      1) xor
  Label [0]:
      5) call static Date::FromTicks(i8):Date
      1) stloc.0 [Date]
      2) ldloca.s [Date (0)]
      5) call Date::get_Ticks():i8
      5) newobj ia(i8)
      1) ret
  Total Size: 31

top(Arr<obj>, Arr<obj>):obj
      1) ldarg.1 [Arr<obj>]
      1) ldc.i4.0
      1) ldelem.ref
      5) call static CodeGenUtil::ToRef(obj):Seq<i2>
      1) stloc.0 [Seq<i2>]
      1) ldloc.0 [Seq<i2>]
      1) ldarg.0 [Arr<obj>]
      1) ldc.i4.0
      5) ldelem [Func<i2,ia>]
      5) call static ForEachGen::Exec(Seq<i2>, Func<i2,ia>):Seq<ia>
      5) call static CodeGenUtil::EnumerableToCaching(Seq<ia>):Seq<ia>
      1) ret
  Total Size: 28

Func sig: (I2s:i2*) to i*
Sequence: Seq<ia>
 0) 3
 1) 0
 2) 127
 3) 128
 4) 256
 5) 32767
 6) 0
###
> I2s->CastTime()->CastIA()
I2s->CastTime()->CastIA() : i*
BndKind:Call, Type:i*, Bnd:(Call(∂.ForEach([map:1] Global(I2s), Num<i>(Call(∂.Time.TotalTicks(Call(∂.CastTime(Scope(1)):t)):i8))):i*))
// (∂.I2s:i2*) : i*
ForEach_1(Arr<obj>, i2):ia
      1) ldarg.1 [i2]
      1) conv.i8
      5) newobj Time(i8)
      1) stloc.0 [Time]
      2) ldloca.s [Time (0)]
      5) call Time::get_Ticks():i8
      5) newobj ia(i8)
      1) ret
  Total Size: 21

top(Arr<obj>, Arr<obj>):obj
      1) ldarg.1 [Arr<obj>]
      1) ldc.i4.0
      1) ldelem.ref
      5) call static CodeGenUtil::ToRef(obj):Seq<i2>
      1) stloc.0 [Seq<i2>]
      1) ldloc.0 [Seq<i2>]
      1) ldarg.0 [Arr<obj>]
      1) ldc.i4.0
      5) ldelem [Func<i2,ia>]
      5) call static ForEachGen::Exec(Seq<i2>, Func<i2,ia>):Seq<ia>
      5) call static CodeGenUtil::EnumerableToCaching(Seq<ia>):Seq<ia>
      1) ret
  Total Size: 28

Func sig: (I2s:i2*) to i*
Sequence: Seq<ia>
 0) 3
 1) -7
 2) 127
 3) 128
 4) 256
 5) 32767
 6) -32768
###
> U2s->CastDate()->CastIA()
U2s->CastDate()->CastIA() : i*
BndKind:Call, Type:i*, Bnd:(Call(∂.ForEach([map:1] Global(U2s), Num<i>(Call(∂.Date.TotalTicks(Call(∂.CastDate(Scope(1)):d)):i8))):i*))
// (∂.U2s:u2*) : i*
ForEach_1(Arr<obj>, u2):ia
      1) ldarg.1 [u2]
      1) conv.u8
      5) call static Date::FromTicks(i8):Date
      1) stloc.0 [Date]
      2) ldloca.s [Date (0)]
      5) call Date::get_Ticks():i8
      5) newobj ia(i8)
      1) ret
  Total Size: 21

top(Arr<obj>, Arr<obj>):obj
      1) ldarg.1 [Arr<obj>]
      1) ldc.i4.0
      1) ldelem.ref
      5) call static CodeGenUtil::ToRef(obj):Seq<u2>
      1) stloc.0 [Seq<u2>]
      1) ldloc.0 [Seq<u2>]
      1) ldarg.0 [Arr<obj>]
      1) ldc.i4.0
      5) ldelem [Func<u2,ia>]
      5) call static ForEachGen::Exec(Seq<u2>, Func<u2,ia>):Seq<ia>
      5) call static CodeGenUtil::EnumerableToCaching(Seq<ia>):Seq<ia>
      1) ret
  Total Size: 28

Func sig: (U2s:u2*) to i*
Sequence: Seq<ia>
 0) 3
 1) 7
 2) 128
 3) 255
 4) 256
 5) 32768
 6) 65535
###
> U2s->CastTime()->CastIA()
U2s->CastTime()->CastIA() : i*
BndKind:Call, Type:i*, Bnd:(Call(∂.ForEach([map:1] Global(U2s), Num<i>(Call(∂.Time.TotalTicks(Call(∂.CastTime(Scope(1)):t)):i8))):i*))
// (∂.U2s:u2*) : i*
ForEach_1(Arr<obj>, u2):ia
      1) ldarg.1 [u2]
      1) conv.u8
      5) newobj Time(i8)
      1) stloc.0 [Time]
      2) ldloca.s [Time (0)]
      5) call Time::get_Ticks():i8
      5) newobj ia(i8)
      1) ret
  Total Size: 21

top(Arr<obj>, Arr<obj>):obj
      1) ldarg.1 [Arr<obj>]
      1) ldc.i4.0
      1) ldelem.ref
      5) call static CodeGenUtil::ToRef(obj):Seq<u2>
      1) stloc.0 [Seq<u2>]
      1) ldloc.0 [Seq<u2>]
      1) ldarg.0 [Arr<obj>]
      1) ldc.i4.0
      5) ldelem [Func<u2,ia>]
      5) call static ForEachGen::Exec(Seq<u2>, Func<u2,ia>):Seq<ia>
      5) call static CodeGenUtil::EnumerableToCaching(Seq<ia>):Seq<ia>
      1) ret
  Total Size: 28

Func sig: (U2s:u2*) to i*
Sequence: Seq<ia>
 0) 3
 1) 7
 2) 128
 3) 255
 4) 256
 5) 32768
 6) 65535
###
> I1s->CastDate()->CastIA()
I1s->CastDate()->CastIA() : i*
BndKind:Call, Type:i*, Bnd:(Call(∂.ForEach([map:1] Global(I1s), Num<i>(Call(∂.Date.TotalTicks(Call(∂.CastDate(Scope(1)):d)):i8))):i*))
// (∂.I1s:i1*) : i*
ForEach_1(Arr<obj>, i1):ia
      1) ldarg.1 [i1]
      1) conv.i8
      1) dup
      1) ldc.i4.0
      1) conv.i8
      5) bge [0]
      1) dup
      1) xor
  Label [0]:
      5) call static Date::FromTicks(i8):Date
      1) stloc.0 [Date]
      2) ldloca.s [Date (0)]
      5) call Date::get_Ticks():i8
      5) newobj ia(i8)
      1) ret
  Total Size: 31

top(Arr<obj>, Arr<obj>):obj
      1) ldarg.1 [Arr<obj>]
      1) ldc.i4.0
      1) ldelem.ref
      5) call static CodeGenUtil::ToRef(obj):Seq<i1>
      1) stloc.0 [Seq<i1>]
      1) ldloc.0 [Seq<i1>]
      1) ldarg.0 [Arr<obj>]
      1) ldc.i4.0
      5) ldelem [Func<i1,ia>]
      5) call static ForEachGen::Exec(Seq<i1>, Func<i1,ia>):Seq<ia>
      5) call static CodeGenUtil::EnumerableToCaching(Seq<ia>):Seq<ia>
      1) ret
  Total Size: 28

Func sig: (I1s:i1*) to i*
Sequence: Seq<ia>
 0) 3
 1) 0
 2) 127
 3) 0
###
> I1s->CastTime()->CastIA()
I1s->CastTime()->CastIA() : i*
BndKind:Call, Type:i*, Bnd:(Call(∂.ForEach([map:1] Global(I1s), Num<i>(Call(∂.Time.TotalTicks(Call(∂.CastTime(Scope(1)):t)):i8))):i*))
// (∂.I1s:i1*) : i*
ForEach_1(Arr<obj>, i1):ia
      1) ldarg.1 [i1]
      1) conv.i8
      5) newobj Time(i8)
      1) stloc.0 [Time]
      2) ldloca.s [Time (0)]
      5) call Time::get_Ticks():i8
      5) newobj ia(i8)
      1) ret
  Total Size: 21

top(Arr<obj>, Arr<obj>):obj
      1) ldarg.1 [Arr<obj>]
      1) ldc.i4.0
      1) ldelem.ref
      5) call static CodeGenUtil::ToRef(obj):Seq<i1>
      1) stloc.0 [Seq<i1>]
      1) ldloc.0 [Seq<i1>]
      1) ldarg.0 [Arr<obj>]
      1) ldc.i4.0
      5) ldelem [Func<i1,ia>]
      5) call static ForEachGen::Exec(Seq<i1>, Func<i1,ia>):Seq<ia>
      5) call static CodeGenUtil::EnumerableToCaching(Seq<ia>):Seq<ia>
      1) ret
  Total Size: 28

Func sig: (I1s:i1*) to i*
Sequence: Seq<ia>
 0) 3
 1) -7
 2) 127
 3) -128
###
> U1s->CastDate()->CastIA()
U1s->CastDate()->CastIA() : i*
BndKind:Call, Type:i*, Bnd:(Call(∂.ForEach([map:1] Global(U1s), Num<i>(Call(∂.Date.TotalTicks(Call(∂.CastDate(Scope(1)):d)):i8))):i*))
// (∂.U1s:u1*) : i*
ForEach_1(Arr<obj>, u1):ia
      1) ldarg.1 [u1]
      1) conv.u8
      5) call static Date::FromTicks(i8):Date
      1) stloc.0 [Date]
      2) ldloca.s [Date (0)]
      5) call Date::get_Ticks():i8
      5) newobj ia(i8)
      1) ret
  Total Size: 21

top(Arr<obj>, Arr<obj>):obj
      1) ldarg.1 [Arr<obj>]
      1) ldc.i4.0
      1) ldelem.ref
      5) call static CodeGenUtil::ToRef(obj):Seq<u1>
      1) stloc.0 [Seq<u1>]
      1) ldloc.0 [Seq<u1>]
      1) ldarg.0 [Arr<obj>]
      1) ldc.i4.0
      5) ldelem [Func<u1,ia>]
      5) call static ForEachGen::Exec(Seq<u1>, Func<u1,ia>):Seq<ia>
      5) call static CodeGenUtil::EnumerableToCaching(Seq<ia>):Seq<ia>
      1) ret
  Total Size: 28

Func sig: (U1s:u1*) to i*
Sequence: Seq<ia>
 0) 3
 1) 7
 2) 128
 3) 255
###
> U1s->CastTime()->CastIA()
U1s->CastTime()->CastIA() : i*
BndKind:Call, Type:i*, Bnd:(Call(∂.ForEach([map:1] Global(U1s), Num<i>(Call(∂.Time.TotalTicks(Call(∂.CastTime(Scope(1)):t)):i8))):i*))
// (∂.U1s:u1*) : i*
ForEach_1(Arr<obj>, u1):ia
      1) ldarg.1 [u1]
      1) conv.u8
      5) newobj Time(i8)
      1) stloc.0 [Time]
      2) ldloca.s [Time (0)]
      5) call Time::get_Ticks():i8
      5) newobj ia(i8)
      1) ret
  Total Size: 21

top(Arr<obj>, Arr<obj>):obj
      1) ldarg.1 [Arr<obj>]
      1) ldc.i4.0
      1) ldelem.ref
      5) call static CodeGenUtil::ToRef(obj):Seq<u1>
      1) stloc.0 [Seq<u1>]
      1) ldloc.0 [Seq<u1>]
      1) ldarg.0 [Arr<obj>]
      1) ldc.i4.0
      5) ldelem [Func<u1,ia>]
      5) call static ForEachGen::Exec(Seq<u1>, Func<u1,ia>):Seq<ia>
      5) call static CodeGenUtil::EnumerableToCaching(Seq<ia>):Seq<ia>
      1) ret
  Total Size: 28

Func sig: (U1s:u1*) to i*
Sequence: Seq<ia>
 0) 3
 1) 7
 2) 128
 3) 255
###
> R8s->CastDate()->CastIA()
R8s->CastDate()->CastIA() : i*
BndKind:Call, Type:i*, Bnd:(Call(∂.ForEach([map:1] Global(R8s), Num<i>(Call(∂.Date.TotalTicks(Call(∂.CastDate(Scope(1)):d)):i8))):i*))
// (∂.R8s:r8*) : i*
ForEach_1(Arr<obj>, r8):ia
      1) ldarg.1 [r8]
      5) call static NumUtil::ToDateTicks(r8):i8
      1) dup
      1) ldc.i4.0
      1) conv.i8
      5) bge [0]
      1) dup
      1) xor
  Label [0]:
      5) call static Date::FromTicks(i8):Date
      1) stloc.0 [Date]
      2) ldloca.s [Date (0)]
      5) call Date::get_Ticks():i8
      5) newobj ia(i8)
      1) ret
  Total Size: 35

top(Arr<obj>, Arr<obj>):obj
      1) ldarg.1 [Arr<obj>]
      1) ldc.i4.0
      1) ldelem.ref
      5) call static CodeGenUtil::ToRef(obj):Seq<r8>
      1) stloc.0 [Seq<r8>]
      1) ldloc.0 [Seq<r8>]
      1) ldarg.0 [Arr<obj>]
      1) ldc.i4.0
      5) ldelem [Func<r8,ia>]
      5) call static ForEachGen::Exec(Seq<r8>, Func<r8,ia>):Seq<ia>
      5) call static CodeGenUtil::EnumerableToCaching(Seq<ia>):Seq<ia>
      1) ret
  Total Size: 28

Func sig: (R8s:r8*) to i*
Sequence: Seq<ia>
 0) 3
 1) 0
 2) 1000000000
 3) 3155378975999999488
 4) 0
 5) 0
 6) 0
 7) 0
###
> R8s->CastTime()->CastIA()
R8s->CastTime()->CastIA() : i*
BndKind:Call, Type:i*, Bnd:(Call(∂.ForEach([map:1] Global(R8s), Num<i>(Call(∂.Time.TotalTicks(Call(∂.CastTime(Scope(1)):t)):i8))):i*))
// (∂.R8s:r8*) : i*
ForEach_1(Arr<obj>, r8):ia
      1) ldarg.1 [r8]
      2) ldloca.s [i8 (0)]
      5) call static NumUtil::TryToI8(r8, out i8):bool
      1) pop
      1) ldloc.0 [i8]
      5) newobj Time(i8)
      1) stloc.1 [Time]
      2) ldloca.s [Time (1)]
      5) call Time::get_Ticks():i8
      5) newobj ia(i8)
      1) ret
  Total Size: 29

top(Arr<obj>, Arr<obj>):obj
      1) ldarg.1 [Arr<obj>]
      1) ldc.i4.0
      1) ldelem.ref
      5) call static CodeGenUtil::ToRef(obj):Seq<r8>
      1) stloc.0 [Seq<r8>]
      1) ldloc.0 [Seq<r8>]
      1) ldarg.0 [Arr<obj>]
      1) ldc.i4.0
      5) ldelem [Func<r8,ia>]
      5) call static ForEachGen::Exec(Seq<r8>, Func<r8,ia>):Seq<ia>
      5) call static CodeGenUtil::EnumerableToCaching(Seq<ia>):Seq<ia>
      1) ret
  Total Size: 28

Func sig: (R8s:r8*) to i*
Sequence: Seq<ia>
 0) 3
 1) -7
 2) 1000000000
 3) 3155378975999999488
 4) 3155378976000000000
 5) -9223372036854775808
 6) 0
 7) 0
###
> R4s->CastDate()->CastIA()
R4s->CastDate()->CastIA() : i*
BndKind:Call, Type:i*, Bnd:(Call(∂.ForEach([map:1] Global(R4s), Num<i>(Call(∂.Date.TotalTicks(Call(∂.CastDate(Scope(1)):d)):i8))):i*))
// (∂.R4s:r4*) : i*
ForEach_1(Arr<obj>, r4):ia
      1) ldarg.1 [r4]
      5) call static NumUtil::ToDateTicks(r4):i8
      1) dup
      1) ldc.i4.0
      1) conv.i8
      5) bge [0]
      1) dup
      1) xor
  Label [0]:
      5) call static Date::FromTicks(i8):Date
      1) stloc.0 [Date]
      2) ldloca.s [Date (0)]
      5) call Date::get_Ticks():i8
      5) newobj ia(i8)
      1) ret
  Total Size: 35

top(Arr<obj>, Arr<obj>):obj
      1) ldarg.1 [Arr<obj>]
      1) ldc.i4.0
      1) ldelem.ref
      5) call static CodeGenUtil::ToRef(obj):Seq<r4>
      1) stloc.0 [Seq<r4>]
      1) ldloc.0 [Seq<r4>]
      1) ldarg.0 [Arr<obj>]
      1) ldc.i4.0
      5) ldelem [Func<r4,ia>]
      5) call static ForEachGen::Exec(Seq<r4>, Func<r4,ia>):Seq<ia>
      5) call static CodeGenUtil::EnumerableToCaching(Seq<ia>):Seq<ia>
      1) ret
  Total Size: 28

Func sig: (R4s:r4*) to i*
Sequence: Seq<ia>
 0) 3
 1) 0
 2) 1000000000
 3) 3155378744269471744
 4) 0
 5) 0
 6) 0
 7) 0
###
> R4s->CastTime()->CastIA()
R4s->CastTime()->CastIA() : i*
BndKind:Call, Type:i*, Bnd:(Call(∂.ForEach([map:1] Global(R4s), Num<i>(Call(∂.Time.TotalTicks(Call(∂.CastTime(Scope(1)):t)):i8))):i*))
// (∂.R4s:r4*) : i*
ForEach_1(Arr<obj>, r4):ia
      1) ldarg.1 [r4]
      2) ldloca.s [i8 (0)]
      5) call static NumUtil::TryToI8(r4, out i8):bool
      1) pop
      1) ldloc.0 [i8]
      5) newobj Time(i8)
      1) stloc.1 [Time]
      2) ldloca.s [Time (1)]
      5) call Time::get_Ticks():i8
      5) newobj ia(i8)
      1) ret
  Total Size: 29

top(Arr<obj>, Arr<obj>):obj
      1) ldarg.1 [Arr<obj>]
      1) ldc.i4.0
      1) ldelem.ref
      5) call static CodeGenUtil::ToRef(obj):Seq<r4>
      1) stloc.0 [Seq<r4>]
      1) ldloc.0 [Seq<r4>]
      1) ldarg.0 [Arr<obj>]
      1) ldc.i4.0
      5) ldelem [Func<r4,ia>]
      5) call static ForEachGen::Exec(Seq<r4>, Func<r4,ia>):Seq<ia>
      5) call static CodeGenUtil::EnumerableToCaching(Seq<ia>):Seq<ia>
      1) ret
  Total Size: 28

Func sig: (R4s:r4*) to i*
Sequence: Seq<ia>
 0) 3
 1) -7
 2) 1000000000
 3) 3155378744269471744
 4) 3155379019147378688
 5) -9223372036854775808
 6) 0
 7) 0
###
> I_s->ToDate()->CastIA()
I_s->ToDate()->CastIA() : i?*
BndKind:Call, Type:i?*, Bnd:(Call(∂.ForEach([map:1] Global(I_s), Call(∂.Guard([guard:2] Call(∂.ToDate(Scope(1)):d?), Num<i>(Call(∂.Date.TotalTicks(Scope(2)):i8))):i?)):i?*))
// (∂.I_s:i*) : i?*
ForEach_1(Arr<obj>, ia):Opt<ia>
      1) ldarg.1 [ia]
      5) call static CastChronoGen::ExecDateOpt(ia):Opt<Date>
      1) stloc.1 [Opt<Date>]
      2) ldloca.s [Opt<Date> (1)]
      5) call Opt<Date>::get_HasValue():bool
      5) brfalse [0]
      2) ldloca.s [Opt<Date> (1)]
      5) call Opt<Date>::GetValueOrDefault():Date
      1) stloc.0 [Date]
      1) ldloc.0 [Date]
      1) stloc.2 [Date]
      2) ldloca.s [Date (2)]
      5) call Date::get_Ticks():i8
      5) newobj ia(i8)
      5) newobj Opt<ia>(ia)
      5) br [1]
  Label [0]:
      5) call static CodeGenUtil::GetDefault():Opt<ia>
  Label [1]:
      1) ret
  Total Size: 57

top(Arr<obj>, Arr<obj>):obj
      1) ldarg.1 [Arr<obj>]
      1) ldc.i4.0
      1) ldelem.ref
      5) call static CodeGenUtil::ToRef(obj):Seq<ia>
      1) stloc.0 [Seq<ia>]
      1) ldloc.0 [Seq<ia>]
      1) ldarg.0 [Arr<obj>]
      1) ldc.i4.0
      5) ldelem [Func<ia,Opt<ia>>]
      5) call static ForEachGen::Exec(Seq<ia>, Func<ia,Opt<ia>>):Seq<Opt<ia>>
      5) call static CodeGenUtil::EnumerableToCaching(Seq<Opt<ia>>):Seq<Opt<ia>>
      1) ret
  Total Size: 28

Func sig: (I_s:i*) to i?*
Sequence: Seq<Opt<ia>>
 0) 3
 1) <null>
 2) 127
 3) 128
 4) 256
 5) 32767
 6) 32768
 7) 65536
 8) 2147483647
 9) 2147483648
10) 4294967296
11) 3155378975999999999
12) <null>
13) <null>
14) <null>
15) <null>
16) <null>
###
> I_s->ToTime()->CastIA()
I_s->ToTime()->CastIA() : i?*
BndKind:Call, Type:i?*, Bnd:(Call(∂.ForEach([map:1] Global(I_s), Call(∂.Guard([guard:2] Call(∂.ToTime(Scope(1)):t?), Num<i>(Call(∂.Time.TotalTicks(Scope(2)):i8))):i?)):i?*))
// (∂.I_s:i*) : i?*
ForEach_1(Arr<obj>, ia):Opt<ia>
      1) ldarg.1 [ia]
      5) call static CastChronoGen::ExecTimeOpt(ia):Opt<Time>
      1) stloc.1 [Opt<Time>]
      2) ldloca.s [Opt<Time> (1)]
      5) call Opt<Time>::get_HasValue():bool
      5) brfalse [0]
      2) ldloca.s [Opt<Time> (1)]
      5) call Opt<Time>::GetValueOrDefault():Time
      1) stloc.0 [Time]
      1) ldloc.0 [Time]
      1) stloc.2 [Time]
      2) ldloca.s [Time (2)]
      5) call Time::get_Ticks():i8
      5) newobj ia(i8)
      5) newobj Opt<ia>(ia)
      5) br [1]
  Label [0]:
      5) call static CodeGenUtil::GetDefault():Opt<ia>
  Label [1]:
      1) ret
  Total Size: 57

top(Arr<obj>, Arr<obj>):obj
      1) ldarg.1 [Arr<obj>]
      1) ldc.i4.0
      1) ldelem.ref
      5) call static CodeGenUtil::ToRef(obj):Seq<ia>
      1) stloc.0 [Seq<ia>]
      1) ldloc.0 [Seq<ia>]
      1) ldarg.0 [Arr<obj>]
      1) ldc.i4.0
      5) ldelem [Func<ia,Opt<ia>>]
      5) call static ForEachGen::Exec(Seq<ia>, Func<ia,Opt<ia>>):Seq<Opt<ia>>
      5) call static CodeGenUtil::EnumerableToCaching(Seq<Opt<ia>>):Seq<Opt<ia>>
      1) ret
  Total Size: 28

Func sig: (I_s:i*) to i?*
Sequence: Seq<Opt<ia>>
 0) 3
 1) -7
 2) 127
 3) 128
 4) 256
 5) 32767
 6) 32768
 7) 65536
 8) 2147483647
 9) 2147483648
10) 4294967296
11) 3155378975999999999
12) 3155378976000000000
13) 9223372036854775807
14) -9223372036854775808
15) <null>
16) <null>
###
> I8s->ToDate()->CastIA()
I8s->ToDate()->CastIA() : i?*
BndKind:Call, Type:i?*, Bnd:(Call(∂.ForEach([map:1] Global(I8s), Call(∂.Guard([guard:2] Call(∂.ToDate(Scope(1)):d?), Num<i>(Call(∂.Date.TotalTicks(Scope(2)):i8))):i?)):i?*))
// (∂.I8s:i8*) : i?*
ForEach_1(Arr<obj>, i8):Opt<ia>
      1) ldarg.1 [i8]
      1) dup
      9) ldc.i8 [3155378975999999999]
      5) bgt.un [1]
      5) call static Date::FromTicks(i8):Date
      5) newobj Opt<Date>(Date)
      5) br [2]
  Label [1]:
      1) pop
      5) call static CodeGenUtil::GetDefault():Opt<Date>
  Label [2]:
      1) stloc.1 [Opt<Date>]
      2) ldloca.s [Opt<Date> (1)]
      5) call Opt<Date>::get_HasValue():bool
      5) brfalse [0]
      2) ldloca.s [Opt<Date> (1)]
      5) call Opt<Date>::GetValueOrDefault():Date
      1) stloc.0 [Date]
      1) ldloc.0 [Date]
      1) stloc.2 [Date]
      2) ldloca.s [Date (2)]
      5) call Date::get_Ticks():i8
      5) newobj ia(i8)
      5) newobj Opt<ia>(ia)
      5) br [3]
  Label [0]:
      5) call static CodeGenUtil::GetDefault():Opt<ia>
  Label [3]:
      1) ret
  Total Size: 88

top(Arr<obj>, Arr<obj>):obj
      1) ldarg.1 [Arr<obj>]
      1) ldc.i4.0
      1) ldelem.ref
      5) call static CodeGenUtil::ToRef(obj):Seq<i8>
      1) stloc.0 [Seq<i8>]
      1) ldloc.0 [Seq<i8>]
      1) ldarg.0 [Arr<obj>]
      1) ldc.i4.0
      5) ldelem [Func<i8,Opt<ia>>]
      5) call static ForEachGen::Exec(Seq<i8>, Func<i8,Opt<ia>>):Seq<Opt<ia>>
      5) call static CodeGenUtil::EnumerableToCaching(Seq<Opt<ia>>):Seq<Opt<ia>>
      1) ret
  Total Size: 28

Func sig: (I8s:i8*) to i?*
Sequence: Seq<Opt<ia>>
 0) 3
 1) <null>
 2) 127
 3) 128
 4) 256
 5) 32767
 6) 32768
 7) 65536
 8) 2147483647
 9) 2147483648
10) 4294967296
11) 3155378975999999999
12) <null>
13) <null>
14) <null>
###
> I8s->ToTime()->CastIA()
I8s->ToTime()->CastIA() : i?*
BndKind:Call, Type:i?*, Bnd:(Call(∂.ForEach([map:1] Global(I8s), Call(∂.Guard([guard:2] Call(∂.ToTime(Scope(1)):t?), Num<i>(Call(∂.Time.TotalTicks(Scope(2)):i8))):i?)):i?*))
// (∂.I8s:i8*) : i?*
ForEach_1(Arr<obj>, i8):Opt<ia>
      1) ldarg.1 [i8]
      5) newobj Time(i8)
      5) newobj Opt<Time>(Time)
      1) stloc.1 [Opt<Time>]
      2) ldloca.s [Opt<Time> (1)]
      5) call Opt<Time>::get_HasValue():bool
      5) brfalse [0]
      2) ldloca.s [Opt<Time> (1)]
      5) call Opt<Time>::GetValueOrDefault():Time
      1) stloc.0 [Time]
      1) ldloc.0 [Time]
      1) stloc.2 [Time]
      2) ldloca.s [Time (2)]
      5) call Time::get_Ticks():i8
      5) newobj ia(i8)
      5) newobj Opt<ia>(ia)
      5) br [1]
  Label [0]:
      5) call static CodeGenUtil::GetDefault():Opt<ia>
  Label [1]:
      1) ret
  Total Size: 62

top(Arr<obj>, Arr<obj>):obj
      1) ldarg.1 [Arr<obj>]
      1) ldc.i4.0
      1) ldelem.ref
      5) call static CodeGenUtil::ToRef(obj):Seq<i8>
      1) stloc.0 [Seq<i8>]
      1) ldloc.0 [Seq<i8>]
      1) ldarg.0 [Arr<obj>]
      1) ldc.i4.0
      5) ldelem [Func<i8,Opt<ia>>]
      5) call static ForEachGen::Exec(Seq<i8>, Func<i8,Opt<ia>>):Seq<Opt<ia>>
      5) call static CodeGenUtil::EnumerableToCaching(Seq<Opt<ia>>):Seq<Opt<ia>>
      1) ret
  Total Size: 28

Func sig: (I8s:i8*) to i?*
Sequence: Seq<Opt<ia>>
 0) 3
 1) -7
 2) 127
 3) 128
 4) 256
 5) 32767
 6) 32768
 7) 65536
 8) 2147483647
 9) 2147483648
10) 4294967296
11) 3155378975999999999
12) 3155378976000000000
13) 9223372036854775807
14) -9223372036854775808
###
> U8s->ToDate()->CastIA()
U8s->ToDate()->CastIA() : i?*
BndKind:Call, Type:i?*, Bnd:(Call(∂.ForEach([map:1] Global(U8s), Call(∂.Guard([guard:2] Call(∂.ToDate(Scope(1)):d?), Num<i>(Call(∂.Date.TotalTicks(Scope(2)):i8))):i?)):i?*))
// (∂.U8s:u8*) : i?*
ForEach_1(Arr<obj>, u8):Opt<ia>
      1) ldarg.1 [u8]
      1) dup
      9) ldc.i8 [3155378975999999999]
      5) bgt.un [1]
      5) call static Date::FromTicks(i8):Date
      5) newobj Opt<Date>(Date)
      5) br [2]
  Label [1]:
      1) pop
      5) call static CodeGenUtil::GetDefault():Opt<Date>
  Label [2]:
      1) stloc.1 [Opt<Date>]
      2) ldloca.s [Opt<Date> (1)]
      5) call Opt<Date>::get_HasValue():bool
      5) brfalse [0]
      2) ldloca.s [Opt<Date> (1)]
      5) call Opt<Date>::GetValueOrDefault():Date
      1) stloc.0 [Date]
      1) ldloc.0 [Date]
      1) stloc.2 [Date]
      2) ldloca.s [Date (2)]
      5) call Date::get_Ticks():i8
      5) newobj ia(i8)
      5) newobj Opt<ia>(ia)
      5) br [3]
  Label [0]:
      5) call static CodeGenUtil::GetDefault():Opt<ia>
  Label [3]:
      1) ret
  Total Size: 88

top(Arr<obj>, Arr<obj>):obj
      1) ldarg.1 [Arr<obj>]
      1) ldc.i4.0
      1) ldelem.ref
      5) call static CodeGenUtil::ToRef(obj):Seq<u8>
      1) stloc.0 [Seq<u8>]
      1) ldloc.0 [Seq<u8>]
      1) ldarg.0 [Arr<obj>]
      1) ldc.i4.0
      5) ldelem [Func<u8,Opt<ia>>]
      5) call static ForEachGen::Exec(Seq<u8>, Func<u8,Opt<ia>>):Seq<Opt<ia>>
      5) call static CodeGenUtil::EnumerableToCaching(Seq<Opt<ia>>):Seq<Opt<ia>>
      1) ret
  Total Size: 28

Func sig: (U8s:u8*) to i?*
Sequence: Seq<Opt<ia>>
 0) 3
 1) 7
 2) 128
 3) 255
 4) 256
 5) 32768
 6) 65535
 7) 65536
 8) 2147483648
 9) 4294967295
10) 4294967296
11) 3155378975999999999
12) <null>
13) <null>
14) <null>
###
> U8s->ToTime()->CastIA()
U8s->ToTime()->CastIA() : i?*
BndKind:Call, Type:i?*, Bnd:(Call(∂.ForEach([map:1] Global(U8s), Call(∂.Guard([guard:2] Call(∂.ToTime(Scope(1)):t?), Num<i>(Call(∂.Time.TotalTicks(Scope(2)):i8))):i?)):i?*))
// (∂.U8s:u8*) : i?*
ForEach_1(Arr<obj>, u8):Opt<ia>
      1) ldarg.1 [u8]
      1) dup
      1) ldc.i4.0
      1) conv.i8
      5) blt [1]
      5) newobj Time(i8)
      5) newobj Opt<Time>(Time)
      5) br [2]
  Label [1]:
      1) pop
      5) call static CodeGenUtil::GetDefault():Opt<Time>
  Label [2]:
      1) stloc.1 [Opt<Time>]
      2) ldloca.s [Opt<Time> (1)]
      5) call Opt<Time>::get_HasValue():bool
      5) brfalse [0]
      2) ldloca.s [Opt<Time> (1)]
      5) call Opt<Time>::GetValueOrDefault():Time
      1) stloc.0 [Time]
      1) ldloc.0 [Time]
      1) stloc.2 [Time]
      2) ldloca.s [Time (2)]
      5) call Time::get_Ticks():i8
      5) newobj ia(i8)
      5) newobj Opt<ia>(ia)
      5) br [3]
  Label [0]:
      5) call static CodeGenUtil::GetDefault():Opt<ia>
  Label [3]:
      1) ret
  Total Size: 81

top(Arr<obj>, Arr<obj>):obj
      1) ldarg.1 [Arr<obj>]
      1) ldc.i4.0
      1) ldelem.ref
      5) call static CodeGenUtil::ToRef(obj):Seq<u8>
      1) stloc.0 [Seq<u8>]
      1) ldloc.0 [Seq<u8>]
      1) ldarg.0 [Arr<obj>]
      1) ldc.i4.0
      5) ldelem [Func<u8,Opt<ia>>]
      5) call static ForEachGen::Exec(Seq<u8>, Func<u8,Opt<ia>>):Seq<Opt<ia>>
      5) call static CodeGenUtil::EnumerableToCaching(Seq<Opt<ia>>):Seq<Opt<ia>>
      1) ret
  Total Size: 28

Func sig: (U8s:u8*) to i?*
Sequence: Seq<Opt<ia>>
 0) 3
 1) 7
 2) 128
 3) 255
 4) 256
 5) 32768
 6) 65535
 7) 65536
 8) 2147483648
 9) 4294967295
10) 4294967296
11) 3155378975999999999
12) 3155378976000000000
13) <null>
14) <null>
###
> I4s->ToDate()->CastIA()
I4s->ToDate()->CastIA() : i?*
BndKind:Call, Type:i?*, Bnd:(Call(∂.ForEach([map:1] Global(I4s), Call(∂.Guard([guard:2] Call(∂.ToDate(Scope(1)):d?), Num<i>(Call(∂.Date.TotalTicks(Scope(2)):i8))):i?)):i?*))
// (∂.I4s:i4*) : i?*
ForEach_1(Arr<obj>, i4):Opt<ia>
      1) ldarg.1 [i4]
      1) conv.i8
      1) dup
      1) ldc.i4.0
      1) conv.i8
      5) blt [1]
      5) call static Date::FromTicks(i8):Date
      5) newobj Opt<Date>(Date)
      5) br [2]
  Label [1]:
      1) pop
      5) call static CodeGenUtil::GetDefault():Opt<Date>
  Label [2]:
      1) stloc.1 [Opt<Date>]
      2) ldloca.s [Opt<Date> (1)]
      5) call Opt<Date>::get_HasValue():bool
      5) brfalse [0]
      2) ldloca.s [Opt<Date> (1)]
      5) call Opt<Date>::GetValueOrDefault():Date
      1) stloc.0 [Date]
      1) ldloc.0 [Date]
      1) stloc.2 [Date]
      2) ldloca.s [Date (2)]
      5) call Date::get_Ticks():i8
      5) newobj ia(i8)
      5) newobj Opt<ia>(ia)
      5) br [3]
  Label [0]:
      5) call static CodeGenUtil::GetDefault():Opt<ia>
  Label [3]:
      1) ret
  Total Size: 82

top(Arr<obj>, Arr<obj>):obj
      1) ldarg.1 [Arr<obj>]
      1) ldc.i4.0
      1) ldelem.ref
      5) call static CodeGenUtil::ToRef(obj):Seq<i4>
      1) stloc.0 [Seq<i4>]
      1) ldloc.0 [Seq<i4>]
      1) ldarg.0 [Arr<obj>]
      1) ldc.i4.0
      5) ldelem [Func<i4,Opt<ia>>]
      5) call static ForEachGen::Exec(Seq<i4>, Func<i4,Opt<ia>>):Seq<Opt<ia>>
      5) call static CodeGenUtil::EnumerableToCaching(Seq<Opt<ia>>):Seq<Opt<ia>>
      1) ret
  Total Size: 28

Func sig: (I4s:i4*) to i?*
Sequence: Seq<Opt<ia>>
 0) 3
 1) <null>
 2) 127
 3) 128
 4) 256
 5) 32767
 6) 32768
 7) 65536
 8) 2147483647
 9) <null>
###
> I4s->ToTime()->CastIA()
I4s->ToTime()->CastIA() : i?*
BndKind:Call, Type:i?*, Bnd:(Call(∂.ForEach([map:1] Global(I4s), Call(∂.Guard([guard:2] Call(∂.ToTime(Scope(1)):t?), Num<i>(Call(∂.Time.TotalTicks(Scope(2)):i8))):i?)):i?*))
// (∂.I4s:i4*) : i?*
ForEach_1(Arr<obj>, i4):Opt<ia>
      1) ldarg.1 [i4]
      1) conv.i8
      5) newobj Time(i8)
      5) newobj Opt<Time>(Time)
      1) stloc.1 [Opt<Time>]
      2) ldloca.s [Opt<Time> (1)]
      5) call Opt<Time>::get_HasValue():bool
      5) brfalse [0]
      2) ldloca.s [Opt<Time> (1)]
      5) call Opt<Time>::GetValueOrDefault():Time
      1) stloc.0 [Time]
      1) ldloc.0 [Time]
      1) stloc.2 [Time]
      2) ldloca.s [Time (2)]
      5) call Time::get_Ticks():i8
      5) newobj ia(i8)
      5) newobj Opt<ia>(ia)
      5) br [1]
  Label [0]:
      5) call static CodeGenUtil::GetDefault():Opt<ia>
  Label [1]:
      1) ret
  Total Size: 63

top(Arr<obj>, Arr<obj>):obj
      1) ldarg.1 [Arr<obj>]
      1) ldc.i4.0
      1) ldelem.ref
      5) call static CodeGenUtil::ToRef(obj):Seq<i4>
      1) stloc.0 [Seq<i4>]
      1) ldloc.0 [Seq<i4>]
      1) ldarg.0 [Arr<obj>]
      1) ldc.i4.0
      5) ldelem [Func<i4,Opt<ia>>]
      5) call static ForEachGen::Exec(Seq<i4>, Func<i4,Opt<ia>>):Seq<Opt<ia>>
      5) call static CodeGenUtil::EnumerableToCaching(Seq<Opt<ia>>):Seq<Opt<ia>>
      1) ret
  Total Size: 28

Func sig: (I4s:i4*) to i?*
Sequence: Seq<Opt<ia>>
 0) 3
 1) -7
 2) 127
 3) 128
 4) 256
 5) 32767
 6) 32768
 7) 65536
 8) 2147483647
 9) -2147483648
###
> U4s->ToDate()->CastIA()
U4s->ToDate()->CastIA() : i?*
BndKind:Call, Type:i?*, Bnd:(Call(∂.ForEach([map:1] Global(U4s), Call(∂.Guard([guard:2] Call(∂.ToDate(Scope(1)):d?), Num<i>(Call(∂.Date.TotalTicks(Scope(2)):i8))):i?)):i?*))
// (∂.U4s:u4*) : i?*
ForEach_1(Arr<obj>, u4):Opt<ia>
      1) ldarg.1 [u4]
      1) conv.u8
      5) call static Date::FromTicks(i8):Date
      5) newobj Opt<Date>(Date)
      1) stloc.1 [Opt<Date>]
      2) ldloca.s [Opt<Date> (1)]
      5) call Opt<Date>::get_HasValue():bool
      5) brfalse [0]
      2) ldloca.s [Opt<Date> (1)]
      5) call Opt<Date>::GetValueOrDefault():Date
      1) stloc.0 [Date]
      1) ldloc.0 [Date]
      1) stloc.2 [Date]
      2) ldloca.s [Date (2)]
      5) call Date::get_Ticks():i8
      5) newobj ia(i8)
      5) newobj Opt<ia>(ia)
      5) br [1]
  Label [0]:
      5) call static CodeGenUtil::GetDefault():Opt<ia>
  Label [1]:
      1) ret
  Total Size: 63

top(Arr<obj>, Arr<obj>):obj
      1) ldarg.1 [Arr<obj>]
      1) ldc.i4.0
      1) ldelem.ref
      5) call static CodeGenUtil::ToRef(obj):Seq<u4>
      1) stloc.0 [Seq<u4>]
      1) ldloc.0 [Seq<u4>]
      1) ldarg.0 [Arr<obj>]
      1) ldc.i4.0
      5) ldelem [Func<u4,Opt<ia>>]
      5) call static ForEachGen::Exec(Seq<u4>, Func<u4,Opt<ia>>):Seq<Opt<ia>>
      5) call static CodeGenUtil::EnumerableToCaching(Seq<Opt<ia>>):Seq<Opt<ia>>
      1) ret
  Total Size: 28

Func sig: (U4s:u4*) to i?*
Sequence: Seq<Opt<ia>>
 0) 3
 1) 7
 2) 128
 3) 255
 4) 256
 5) 32768
 6) 65535
 7) 65536
 8) 2147483648
 9) 4294967295
###
> U4s->ToTime()->CastIA()
U4s->ToTime()->CastIA() : i?*
BndKind:Call, Type:i?*, Bnd:(Call(∂.ForEach([map:1] Global(U4s), Call(∂.Guard([guard:2] Call(∂.ToTime(Scope(1)):t?), Num<i>(Call(∂.Time.TotalTicks(Scope(2)):i8))):i?)):i?*))
// (∂.U4s:u4*) : i?*
ForEach_1(Arr<obj>, u4):Opt<ia>
      1) ldarg.1 [u4]
      1) conv.u8
      5) newobj Time(i8)
      5) newobj Opt<Time>(Time)
      1) stloc.1 [Opt<Time>]
      2) ldloca.s [Opt<Time> (1)]
      5) call Opt<Time>::get_HasValue():bool
      5) brfalse [0]
      2) ldloca.s [Opt<Time> (1)]
      5) call Opt<Time>::GetValueOrDefault():Time
      1) stloc.0 [Time]
      1) ldloc.0 [Time]
      1) stloc.2 [Time]
      2) ldloca.s [Time (2)]
      5) call Time::get_Ticks():i8
      5) newobj ia(i8)
      5) newobj Opt<ia>(ia)
      5) br [1]
  Label [0]:
      5) call static CodeGenUtil::GetDefault():Opt<ia>
  Label [1]:
      1) ret
  Total Size: 63

top(Arr<obj>, Arr<obj>):obj
      1) ldarg.1 [Arr<obj>]
      1) ldc.i4.0
      1) ldelem.ref
      5) call static CodeGenUtil::ToRef(obj):Seq<u4>
      1) stloc.0 [Seq<u4>]
      1) ldloc.0 [Seq<u4>]
      1) ldarg.0 [Arr<obj>]
      1) ldc.i4.0
      5) ldelem [Func<u4,Opt<ia>>]
      5) call static ForEachGen::Exec(Seq<u4>, Func<u4,Opt<ia>>):Seq<Opt<ia>>
      5) call static CodeGenUtil::EnumerableToCaching(Seq<Opt<ia>>):Seq<Opt<ia>>
      1) ret
  Total Size: 28

Func sig: (U4s:u4*) to i?*
Sequence: Seq<Opt<ia>>
 0) 3
 1) 7
 2) 128
 3) 255
 4) 256
 5) 32768
 6) 65535
 7) 65536
 8) 2147483648
 9) 4294967295
###
> I2s->ToDate()->CastIA()
I2s->ToDate()->CastIA() : i?*
BndKind:Call, Type:i?*, Bnd:(Call(∂.ForEach([map:1] Global(I2s), Call(∂.Guard([guard:2] Call(∂.ToDate(Scope(1)):d?), Num<i>(Call(∂.Date.TotalTicks(Scope(2)):i8))):i?)):i?*))
// (∂.I2s:i2*) : i?*
ForEach_1(Arr<obj>, i2):Opt<ia>
      1) ldarg.1 [i2]
      1) conv.i8
      1) dup
      1) ldc.i4.0
      1) conv.i8
      5) blt [1]
      5) call static Date::FromTicks(i8):Date
      5) newobj Opt<Date>(Date)
      5) br [2]
  Label [1]:
      1) pop
      5) call static CodeGenUtil::GetDefault():Opt<Date>
  Label [2]:
      1) stloc.1 [Opt<Date>]
      2) ldloca.s [Opt<Date> (1)]
      5) call Opt<Date>::get_HasValue():bool
      5) brfalse [0]
      2) ldloca.s [Opt<Date> (1)]
      5) call Opt<Date>::GetValueOrDefault():Date
      1) stloc.0 [Date]
      1) ldloc.0 [Date]
      1) stloc.2 [Date]
      2) ldloca.s [Date (2)]
      5) call Date::get_Ticks():i8
      5) newobj ia(i8)
      5) newobj Opt<ia>(ia)
      5) br [3]
  Label [0]:
      5) call static CodeGenUtil::GetDefault():Opt<ia>
  Label [3]:
      1) ret
  Total Size: 82

top(Arr<obj>, Arr<obj>):obj
      1) ldarg.1 [Arr<obj>]
      1) ldc.i4.0
      1) ldelem.ref
      5) call static CodeGenUtil::ToRef(obj):Seq<i2>
      1) stloc.0 [Seq<i2>]
      1) ldloc.0 [Seq<i2>]
      1) ldarg.0 [Arr<obj>]
      1) ldc.i4.0
      5) ldelem [Func<i2,Opt<ia>>]
      5) call static ForEachGen::Exec(Seq<i2>, Func<i2,Opt<ia>>):Seq<Opt<ia>>
      5) call static CodeGenUtil::EnumerableToCaching(Seq<Opt<ia>>):Seq<Opt<ia>>
      1) ret
  Total Size: 28

Func sig: (I2s:i2*) to i?*
Sequence: Seq<Opt<ia>>
 0) 3
 1) <null>
 2) 127
 3) 128
 4) 256
 5) 32767
 6) <null>
###
> I2s->ToTime()->CastIA()
I2s->ToTime()->CastIA() : i?*
BndKind:Call, Type:i?*, Bnd:(Call(∂.ForEach([map:1] Global(I2s), Call(∂.Guard([guard:2] Call(∂.ToTime(Scope(1)):t?), Num<i>(Call(∂.Time.TotalTicks(Scope(2)):i8))):i?)):i?*))
// (∂.I2s:i2*) : i?*
ForEach_1(Arr<obj>, i2):Opt<ia>
      1) ldarg.1 [i2]
      1) conv.i8
      5) newobj Time(i8)
      5) newobj Opt<Time>(Time)
      1) stloc.1 [Opt<Time>]
      2) ldloca.s [Opt<Time> (1)]
      5) call Opt<Time>::get_HasValue():bool
      5) brfalse [0]
      2) ldloca.s [Opt<Time> (1)]
      5) call Opt<Time>::GetValueOrDefault():Time
      1) stloc.0 [Time]
      1) ldloc.0 [Time]
      1) stloc.2 [Time]
      2) ldloca.s [Time (2)]
      5) call Time::get_Ticks():i8
      5) newobj ia(i8)
      5) newobj Opt<ia>(ia)
      5) br [1]
  Label [0]:
      5) call static CodeGenUtil::GetDefault():Opt<ia>
  Label [1]:
      1) ret
  Total Size: 63

top(Arr<obj>, Arr<obj>):obj
      1) ldarg.1 [Arr<obj>]
      1) ldc.i4.0
      1) ldelem.ref
      5) call static CodeGenUtil::ToRef(obj):Seq<i2>
      1) stloc.0 [Seq<i2>]
      1) ldloc.0 [Seq<i2>]
      1) ldarg.0 [Arr<obj>]
      1) ldc.i4.0
      5) ldelem [Func<i2,Opt<ia>>]
      5) call static ForEachGen::Exec(Seq<i2>, Func<i2,Opt<ia>>):Seq<Opt<ia>>
      5) call static CodeGenUtil::EnumerableToCaching(Seq<Opt<ia>>):Seq<Opt<ia>>
      1) ret
  Total Size: 28

Func sig: (I2s:i2*) to i?*
Sequence: Seq<Opt<ia>>
 0) 3
 1) -7
 2) 127
 3) 128
 4) 256
 5) 32767
 6) -32768
###
> U2s->ToDate()->CastIA()
U2s->ToDate()->CastIA() : i?*
BndKind:Call, Type:i?*, Bnd:(Call(∂.ForEach([map:1] Global(U2s), Call(∂.Guard([guard:2] Call(∂.ToDate(Scope(1)):d?), Num<i>(Call(∂.Date.TotalTicks(Scope(2)):i8))):i?)):i?*))
// (∂.U2s:u2*) : i?*
ForEach_1(Arr<obj>, u2):Opt<ia>
      1) ldarg.1 [u2]
      1) conv.u8
      5) call static Date::FromTicks(i8):Date
      5) newobj Opt<Date>(Date)
      1) stloc.1 [Opt<Date>]
      2) ldloca.s [Opt<Date> (1)]
      5) call Opt<Date>::get_HasValue():bool
      5) brfalse [0]
      2) ldloca.s [Opt<Date> (1)]
      5) call Opt<Date>::GetValueOrDefault():Date
      1) stloc.0 [Date]
      1) ldloc.0 [Date]
      1) stloc.2 [Date]
      2) ldloca.s [Date (2)]
      5) call Date::get_Ticks():i8
      5) newobj ia(i8)
      5) newobj Opt<ia>(ia)
      5) br [1]
  Label [0]:
      5) call static CodeGenUtil::GetDefault():Opt<ia>
  Label [1]:
      1) ret
  Total Size: 63

top(Arr<obj>, Arr<obj>):obj
      1) ldarg.1 [Arr<obj>]
      1) ldc.i4.0
      1) ldelem.ref
      5) call static CodeGenUtil::ToRef(obj):Seq<u2>
      1) stloc.0 [Seq<u2>]
      1) ldloc.0 [Seq<u2>]
      1) ldarg.0 [Arr<obj>]
      1) ldc.i4.0
      5) ldelem [Func<u2,Opt<ia>>]
      5) call static ForEachGen::Exec(Seq<u2>, Func<u2,Opt<ia>>):Seq<Opt<ia>>
      5) call static CodeGenUtil::EnumerableToCaching(Seq<Opt<ia>>):Seq<Opt<ia>>
      1) ret
  Total Size: 28

Func sig: (U2s:u2*) to i?*
Sequence: Seq<Opt<ia>>
 0) 3
 1) 7
 2) 128
 3) 255
 4) 256
 5) 32768
 6) 65535
###
> U2s->ToTime()->CastIA()
U2s->ToTime()->CastIA() : i?*
BndKind:Call, Type:i?*, Bnd:(Call(∂.ForEach([map:1] Global(U2s), Call(∂.Guard([guard:2] Call(∂.ToTime(Scope(1)):t?), Num<i>(Call(∂.Time.TotalTicks(Scope(2)):i8))):i?)):i?*))
// (∂.U2s:u2*) : i?*
ForEach_1(Arr<obj>, u2):Opt<ia>
      1) ldarg.1 [u2]
      1) conv.u8
      5) newobj Time(i8)
      5) newobj Opt<Time>(Time)
      1) stloc.1 [Opt<Time>]
      2) ldloca.s [Opt<Time> (1)]
      5) call Opt<Time>::get_HasValue():bool
      5) brfalse [0]
      2) ldloca.s [Opt<Time> (1)]
      5) call Opt<Time>::GetValueOrDefault():Time
      1) stloc.0 [Time]
      1) ldloc.0 [Time]
      1) stloc.2 [Time]
      2) ldloca.s [Time (2)]
      5) call Time::get_Ticks():i8
      5) newobj ia(i8)
      5) newobj Opt<ia>(ia)
      5) br [1]
  Label [0]:
      5) call static CodeGenUtil::GetDefault():Opt<ia>
  Label [1]:
      1) ret
  Total Size: 63

top(Arr<obj>, Arr<obj>):obj
      1) ldarg.1 [Arr<obj>]
      1) ldc.i4.0
      1) ldelem.ref
      5) call static CodeGenUtil::ToRef(obj):Seq<u2>
      1) stloc.0 [Seq<u2>]
      1) ldloc.0 [Seq<u2>]
      1) ldarg.0 [Arr<obj>]
      1) ldc.i4.0
      5) ldelem [Func<u2,Opt<ia>>]
      5) call static ForEachGen::Exec(Seq<u2>, Func<u2,Opt<ia>>):Seq<Opt<ia>>
      5) call static CodeGenUtil::EnumerableToCaching(Seq<Opt<ia>>):Seq<Opt<ia>>
      1) ret
  Total Size: 28

Func sig: (U2s:u2*) to i?*
Sequence: Seq<Opt<ia>>
 0) 3
 1) 7
 2) 128
 3) 255
 4) 256
 5) 32768
 6) 65535
###
> I1s->ToDate()->CastIA()
I1s->ToDate()->CastIA() : i?*
BndKind:Call, Type:i?*, Bnd:(Call(∂.ForEach([map:1] Global(I1s), Call(∂.Guard([guard:2] Call(∂.ToDate(Scope(1)):d?), Num<i>(Call(∂.Date.TotalTicks(Scope(2)):i8))):i?)):i?*))
// (∂.I1s:i1*) : i?*
ForEach_1(Arr<obj>, i1):Opt<ia>
      1) ldarg.1 [i1]
      1) conv.i8
      1) dup
      1) ldc.i4.0
      1) conv.i8
      5) blt [1]
      5) call static Date::FromTicks(i8):Date
      5) newobj Opt<Date>(Date)
      5) br [2]
  Label [1]:
      1) pop
      5) call static CodeGenUtil::GetDefault():Opt<Date>
  Label [2]:
      1) stloc.1 [Opt<Date>]
      2) ldloca.s [Opt<Date> (1)]
      5) call Opt<Date>::get_HasValue():bool
      5) brfalse [0]
      2) ldloca.s [Opt<Date> (1)]
      5) call Opt<Date>::GetValueOrDefault():Date
      1) stloc.0 [Date]
      1) ldloc.0 [Date]
      1) stloc.2 [Date]
      2) ldloca.s [Date (2)]
      5) call Date::get_Ticks():i8
      5) newobj ia(i8)
      5) newobj Opt<ia>(ia)
      5) br [3]
  Label [0]:
      5) call static CodeGenUtil::GetDefault():Opt<ia>
  Label [3]:
      1) ret
  Total Size: 82

top(Arr<obj>, Arr<obj>):obj
      1) ldarg.1 [Arr<obj>]
      1) ldc.i4.0
      1) ldelem.ref
      5) call static CodeGenUtil::ToRef(obj):Seq<i1>
      1) stloc.0 [Seq<i1>]
      1) ldloc.0 [Seq<i1>]
      1) ldarg.0 [Arr<obj>]
      1) ldc.i4.0
      5) ldelem [Func<i1,Opt<ia>>]
      5) call static ForEachGen::Exec(Seq<i1>, Func<i1,Opt<ia>>):Seq<Opt<ia>>
      5) call static CodeGenUtil::EnumerableToCaching(Seq<Opt<ia>>):Seq<Opt<ia>>
      1) ret
  Total Size: 28

Func sig: (I1s:i1*) to i?*
Sequence: Seq<Opt<ia>>
 0) 3
 1) <null>
 2) 127
 3) <null>
###
> I1s->ToTime()->CastIA()
I1s->ToTime()->CastIA() : i?*
BndKind:Call, Type:i?*, Bnd:(Call(∂.ForEach([map:1] Global(I1s), Call(∂.Guard([guard:2] Call(∂.ToTime(Scope(1)):t?), Num<i>(Call(∂.Time.TotalTicks(Scope(2)):i8))):i?)):i?*))
// (∂.I1s:i1*) : i?*
ForEach_1(Arr<obj>, i1):Opt<ia>
      1) ldarg.1 [i1]
      1) conv.i8
      5) newobj Time(i8)
      5) newobj Opt<Time>(Time)
      1) stloc.1 [Opt<Time>]
      2) ldloca.s [Opt<Time> (1)]
      5) call Opt<Time>::get_HasValue():bool
      5) brfalse [0]
      2) ldloca.s [Opt<Time> (1)]
      5) call Opt<Time>::GetValueOrDefault():Time
      1) stloc.0 [Time]
      1) ldloc.0 [Time]
      1) stloc.2 [Time]
      2) ldloca.s [Time (2)]
      5) call Time::get_Ticks():i8
      5) newobj ia(i8)
      5) newobj Opt<ia>(ia)
      5) br [1]
  Label [0]:
      5) call static CodeGenUtil::GetDefault():Opt<ia>
  Label [1]:
      1) ret
  Total Size: 63

top(Arr<obj>, Arr<obj>):obj
      1) ldarg.1 [Arr<obj>]
      1) ldc.i4.0
      1) ldelem.ref
      5) call static CodeGenUtil::ToRef(obj):Seq<i1>
      1) stloc.0 [Seq<i1>]
      1) ldloc.0 [Seq<i1>]
      1) ldarg.0 [Arr<obj>]
      1) ldc.i4.0
      5) ldelem [Func<i1,Opt<ia>>]
      5) call static ForEachGen::Exec(Seq<i1>, Func<i1,Opt<ia>>):Seq<Opt<ia>>
      5) call static CodeGenUtil::EnumerableToCaching(Seq<Opt<ia>>):Seq<Opt<ia>>
      1) ret
  Total Size: 28

Func sig: (I1s:i1*) to i?*
Sequence: Seq<Opt<ia>>
 0) 3
 1) -7
 2) 127
 3) -128
###
> U1s->ToDate()->CastIA()
U1s->ToDate()->CastIA() : i?*
BndKind:Call, Type:i?*, Bnd:(Call(∂.ForEach([map:1] Global(U1s), Call(∂.Guard([guard:2] Call(∂.ToDate(Scope(1)):d?), Num<i>(Call(∂.Date.TotalTicks(Scope(2)):i8))):i?)):i?*))
// (∂.U1s:u1*) : i?*
ForEach_1(Arr<obj>, u1):Opt<ia>
      1) ldarg.1 [u1]
      1) conv.u8
      5) call static Date::FromTicks(i8):Date
      5) newobj Opt<Date>(Date)
      1) stloc.1 [Opt<Date>]
      2) ldloca.s [Opt<Date> (1)]
      5) call Opt<Date>::get_HasValue():bool
      5) brfalse [0]
      2) ldloca.s [Opt<Date> (1)]
      5) call Opt<Date>::GetValueOrDefault():Date
      1) stloc.0 [Date]
      1) ldloc.0 [Date]
      1) stloc.2 [Date]
      2) ldloca.s [Date (2)]
      5) call Date::get_Ticks():i8
      5) newobj ia(i8)
      5) newobj Opt<ia>(ia)
      5) br [1]
  Label [0]:
      5) call static CodeGenUtil::GetDefault():Opt<ia>
  Label [1]:
      1) ret
  Total Size: 63

top(Arr<obj>, Arr<obj>):obj
      1) ldarg.1 [Arr<obj>]
      1) ldc.i4.0
      1) ldelem.ref
      5) call static CodeGenUtil::ToRef(obj):Seq<u1>
      1) stloc.0 [Seq<u1>]
      1) ldloc.0 [Seq<u1>]
      1) ldarg.0 [Arr<obj>]
      1) ldc.i4.0
      5) ldelem [Func<u1,Opt<ia>>]
      5) call static ForEachGen::Exec(Seq<u1>, Func<u1,Opt<ia>>):Seq<Opt<ia>>
      5) call static CodeGenUtil::EnumerableToCaching(Seq<Opt<ia>>):Seq<Opt<ia>>
      1) ret
  Total Size: 28

Func sig: (U1s:u1*) to i?*
Sequence: Seq<Opt<ia>>
 0) 3
 1) 7
 2) 128
 3) 255
###
> U1s->ToTime()->CastIA()
U1s->ToTime()->CastIA() : i?*
BndKind:Call, Type:i?*, Bnd:(Call(∂.ForEach([map:1] Global(U1s), Call(∂.Guard([guard:2] Call(∂.ToTime(Scope(1)):t?), Num<i>(Call(∂.Time.TotalTicks(Scope(2)):i8))):i?)):i?*))
// (∂.U1s:u1*) : i?*
ForEach_1(Arr<obj>, u1):Opt<ia>
      1) ldarg.1 [u1]
      1) conv.u8
      5) newobj Time(i8)
      5) newobj Opt<Time>(Time)
      1) stloc.1 [Opt<Time>]
      2) ldloca.s [Opt<Time> (1)]
      5) call Opt<Time>::get_HasValue():bool
      5) brfalse [0]
      2) ldloca.s [Opt<Time> (1)]
      5) call Opt<Time>::GetValueOrDefault():Time
      1) stloc.0 [Time]
      1) ldloc.0 [Time]
      1) stloc.2 [Time]
      2) ldloca.s [Time (2)]
      5) call Time::get_Ticks():i8
      5) newobj ia(i8)
      5) newobj Opt<ia>(ia)
      5) br [1]
  Label [0]:
      5) call static CodeGenUtil::GetDefault():Opt<ia>
  Label [1]:
      1) ret
  Total Size: 63

top(Arr<obj>, Arr<obj>):obj
      1) ldarg.1 [Arr<obj>]
      1) ldc.i4.0
      1) ldelem.ref
      5) call static CodeGenUtil::ToRef(obj):Seq<u1>
      1) stloc.0 [Seq<u1>]
      1) ldloc.0 [Seq<u1>]
      1) ldarg.0 [Arr<obj>]
      1) ldc.i4.0
      5) ldelem [Func<u1,Opt<ia>>]
      5) call static ForEachGen::Exec(Seq<u1>, Func<u1,Opt<ia>>):Seq<Opt<ia>>
      5) call static CodeGenUtil::EnumerableToCaching(Seq<Opt<ia>>):Seq<Opt<ia>>
      1) ret
  Total Size: 28

Func sig: (U1s:u1*) to i?*
Sequence: Seq<Opt<ia>>
 0) 3
 1) 7
 2) 128
 3) 255
###
> R8s->ToDate()->CastIA()
R8s->ToDate()->CastIA() : i?*
BndKind:Call, Type:i?*, Bnd:(Call(∂.ForEach([map:1] Global(R8s), Call(∂.Guard([guard:2] Call(∂.ToDate(Scope(1)):d?), Num<i>(Call(∂.Date.TotalTicks(Scope(2)):i8))):i?)):i?*))
// (∂.R8s:r8*) : i?*
ForEach_1(Arr<obj>, r8):Opt<ia>
      1) ldarg.1 [r8]
      5) call static NumUtil::ToDateTicks(r8):i8
      1) dup
      1) ldc.i4.0
      1) conv.i8
      5) blt [1]
      5) call static Date::FromTicks(i8):Date
      5) newobj Opt<Date>(Date)
      5) br [2]
  Label [1]:
      1) pop
      5) call static CodeGenUtil::GetDefault():Opt<Date>
  Label [2]:
      1) stloc.1 [Opt<Date>]
      2) ldloca.s [Opt<Date> (1)]
      5) call Opt<Date>::get_HasValue():bool
      5) brfalse [0]
      2) ldloca.s [Opt<Date> (1)]
      5) call Opt<Date>::GetValueOrDefault():Date
      1) stloc.0 [Date]
      1) ldloc.0 [Date]
      1) stloc.2 [Date]
      2) ldloca.s [Date (2)]
      5) call Date::get_Ticks():i8
      5) newobj ia(i8)
      5) newobj Opt<ia>(ia)
      5) br [3]
  Label [0]:
      5) call static CodeGenUtil::GetDefault():Opt<ia>
  Label [3]:
      1) ret
  Total Size: 86

top(Arr<obj>, Arr<obj>):obj
      1) ldarg.1 [Arr<obj>]
      1) ldc.i4.0
      1) ldelem.ref
      5) call static CodeGenUtil::ToRef(obj):Seq<r8>
      1) stloc.0 [Seq<r8>]
      1) ldloc.0 [Seq<r8>]
      1) ldarg.0 [Arr<obj>]
      1) ldc.i4.0
      5) ldelem [Func<r8,Opt<ia>>]
      5) call static ForEachGen::Exec(Seq<r8>, Func<r8,Opt<ia>>):Seq<Opt<ia>>
      5) call static CodeGenUtil::EnumerableToCaching(Seq<Opt<ia>>):Seq<Opt<ia>>
      1) ret
  Total Size: 28

Func sig: (R8s:r8*) to i?*
Sequence: Seq<Opt<ia>>
 0) 3
 1) <null>
 2) 1000000000
 3) 3155378975999999488
 4) <null>
 5) <null>
 6) <null>
 7) <null>
###
> R8s->ToTime()->CastIA()
R8s->ToTime()->CastIA() : i?*
BndKind:Call, Type:i?*, Bnd:(Call(∂.ForEach([map:1] Global(R8s), Call(∂.Guard([guard:2] Call(∂.ToTime(Scope(1)):t?), Num<i>(Call(∂.Time.TotalTicks(Scope(2)):i8))):i?)):i?*))
// (∂.R8s:r8*) : i?*
ForEach_1(Arr<obj>, r8):Opt<ia>
      1) ldarg.1 [r8]
      2) ldloca.s [i8 (0)]
      5) call static NumUtil::TryToI8(r8, out i8):bool
      5) brfalse [1]
      1) ldloc.0 [i8]
      5) newobj Time(i8)
      5) newobj Opt<Time>(Time)
      5) br [2]
  Label [1]:
      5) call static CodeGenUtil::GetDefault():Opt<Time>
  Label [2]:
      1) stloc.2 [Opt<Time>]
      2) ldloca.s [Opt<Time> (2)]
      5) call Opt<Time>::get_HasValue():bool
      5) brfalse [0]
      2) ldloca.s [Opt<Time> (2)]
      5) call Opt<Time>::GetValueOrDefault():Time
      1) stloc.1 [Time]
      1) ldloc.1 [Time]
      1) stloc.3 [Time]
      2) ldloca.s [Time (3)]
      5) call Time::get_Ticks():i8
      5) newobj ia(i8)
      5) newobj Opt<ia>(ia)
      5) br [3]
  Label [0]:
      5) call static CodeGenUtil::GetDefault():Opt<ia>
  Label [3]:
      1) ret
  Total Size: 85

top(Arr<obj>, Arr<obj>):obj
      1) ldarg.1 [Arr<obj>]
      1) ldc.i4.0
      1) ldelem.ref
      5) call static CodeGenUtil::ToRef(obj):Seq<r8>
      1) stloc.0 [Seq<r8>]
      1) ldloc.0 [Seq<r8>]
      1) ldarg.0 [Arr<obj>]
      1) ldc.i4.0
      5) ldelem [Func<r8,Opt<ia>>]
      5) call static ForEachGen::Exec(Seq<r8>, Func<r8,Opt<ia>>):Seq<Opt<ia>>
      5) call static CodeGenUtil::EnumerableToCaching(Seq<Opt<ia>>):Seq<Opt<ia>>
      1) ret
  Total Size: 28

Func sig: (R8s:r8*) to i?*
Sequence: Seq<Opt<ia>>
 0) 3
 1) -7
 2) 1000000000
 3) 3155378975999999488
 4) 3155378976000000000
 5) -9223372036854775808
 6) <null>
 7) <null>
###
> R4s->ToDate()->CastIA()
R4s->ToDate()->CastIA() : i?*
BndKind:Call, Type:i?*, Bnd:(Call(∂.ForEach([map:1] Global(R4s), Call(∂.Guard([guard:2] Call(∂.ToDate(Scope(1)):d?), Num<i>(Call(∂.Date.TotalTicks(Scope(2)):i8))):i?)):i?*))
// (∂.R4s:r4*) : i?*
ForEach_1(Arr<obj>, r4):Opt<ia>
      1) ldarg.1 [r4]
      5) call static NumUtil::ToDateTicks(r4):i8
      1) dup
      1) ldc.i4.0
      1) conv.i8
      5) blt [1]
      5) call static Date::FromTicks(i8):Date
      5) newobj Opt<Date>(Date)
      5) br [2]
  Label [1]:
      1) pop
      5) call static CodeGenUtil::GetDefault():Opt<Date>
  Label [2]:
      1) stloc.1 [Opt<Date>]
      2) ldloca.s [Opt<Date> (1)]
      5) call Opt<Date>::get_HasValue():bool
      5) brfalse [0]
      2) ldloca.s [Opt<Date> (1)]
      5) call Opt<Date>::GetValueOrDefault():Date
      1) stloc.0 [Date]
      1) ldloc.0 [Date]
      1) stloc.2 [Date]
      2) ldloca.s [Date (2)]
      5) call Date::get_Ticks():i8
      5) newobj ia(i8)
      5) newobj Opt<ia>(ia)
      5) br [3]
  Label [0]:
      5) call static CodeGenUtil::GetDefault():Opt<ia>
  Label [3]:
      1) ret
  Total Size: 86

top(Arr<obj>, Arr<obj>):obj
      1) ldarg.1 [Arr<obj>]
      1) ldc.i4.0
      1) ldelem.ref
      5) call static CodeGenUtil::ToRef(obj):Seq<r4>
      1) stloc.0 [Seq<r4>]
      1) ldloc.0 [Seq<r4>]
      1) ldarg.0 [Arr<obj>]
      1) ldc.i4.0
      5) ldelem [Func<r4,Opt<ia>>]
      5) call static ForEachGen::Exec(Seq<r4>, Func<r4,Opt<ia>>):Seq<Opt<ia>>
      5) call static CodeGenUtil::EnumerableToCaching(Seq<Opt<ia>>):Seq<Opt<ia>>
      1) ret
  Total Size: 28

Func sig: (R4s:r4*) to i?*
Sequence: Seq<Opt<ia>>
 0) 3
 1) <null>
 2) 1000000000
 3) 3155378744269471744
 4) <null>
 5) <null>
 6) <null>
 7) <null>
###
> R4s->ToTime()->CastIA()
R4s->ToTime()->CastIA() : i?*
BndKind:Call, Type:i?*, Bnd:(Call(∂.ForEach([map:1] Global(R4s), Call(∂.Guard([guard:2] Call(∂.ToTime(Scope(1)):t?), Num<i>(Call(∂.Time.TotalTicks(Scope(2)):i8))):i?)):i?*))
// (∂.R4s:r4*) : i?*
ForEach_1(Arr<obj>, r4):Opt<ia>
      1) ldarg.1 [r4]
      2) ldloca.s [i8 (0)]
      5) call static NumUtil::TryToI8(r4, out i8):bool
      5) brfalse [1]
      1) ldloc.0 [i8]
      5) newobj Time(i8)
      5) newobj Opt<Time>(Time)
      5) br [2]
  Label [1]:
      5) call static CodeGenUtil::GetDefault():Opt<Time>
  Label [2]:
      1) stloc.2 [Opt<Time>]
      2) ldloca.s [Opt<Time> (2)]
      5) call Opt<Time>::get_HasValue():bool
      5) brfalse [0]
      2) ldloca.s [Opt<Time> (2)]
      5) call Opt<Time>::GetValueOrDefault():Time
      1) stloc.1 [Time]
      1) ldloc.1 [Time]
      1) stloc.3 [Time]
      2) ldloca.s [Time (3)]
      5) call Time::get_Ticks():i8
      5) newobj ia(i8)
      5) newobj Opt<ia>(ia)
      5) br [3]
  Label [0]:
      5) call static CodeGenUtil::GetDefault():Opt<ia>
  Label [3]:
      1) ret
  Total Size: 85

top(Arr<obj>, Arr<obj>):obj
      1) ldarg.1 [Arr<obj>]
      1) ldc.i4.0
      1) ldelem.ref
      5) call static CodeGenUtil::ToRef(obj):Seq<r4>
      1) stloc.0 [Seq<r4>]
      1) ldloc.0 [Seq<r4>]
      1) ldarg.0 [Arr<obj>]
      1) ldc.i4.0
      5) ldelem [Func<r4,Opt<ia>>]
      5) call static ForEachGen::Exec(Seq<r4>, Func<r4,Opt<ia>>):Seq<Opt<ia>>
      5) call static CodeGenUtil::EnumerableToCaching(Seq<Opt<ia>>):Seq<Opt<ia>>
      1) ret
  Total Size: 28

Func sig: (R4s:r4*) to i?*
Sequence: Seq<Opt<ia>>
 0) 3
 1) -7
 2) 1000000000
 3) 3155378744269471744
 4) 3155379019147378688
 5) -9223372036854775808
 6) <null>
 7) <null>
###
> Map(x: I8s, Time(x))
Map(x : I8s, Time(x)) : t*
BndKind:Call, Type:t*, Bnd:(Call(∂.ForEach([map:1] Global(I8s), Call(∂.Time(Scope(1)):t)):t*))
// (∂.I8s:i8*) : t*
ForEach_1(Arr<obj>, i8):Time
      1) ldarg.1 [i8]
      5) call static TimeGen::Exec(i8):Time
      1) ret
  Total Size: 7

top(Arr<obj>, Arr<obj>):obj
      1) ldarg.1 [Arr<obj>]
      1) ldc.i4.0
      1) ldelem.ref
      5) call static CodeGenUtil::ToRef(obj):Seq<i8>
      1) stloc.0 [Seq<i8>]
      1) ldloc.0 [Seq<i8>]
      1) ldarg.0 [Arr<obj>]
      1) ldc.i4.0
      5) ldelem [Func<i8,Time>]
      5) call static ForEachGen::Exec(Seq<i8>, Func<i8,Time>):Seq<Time>
      5) call static CodeGenUtil::EnumerableToCaching(Seq<Time>):Seq<Time>
      1) ret
  Total Size: 28

Func sig: (I8s:i8*) to t*
Sequence: Seq<Time>
 0) 3.00:00:00
 1) -7.00:00:00
 2) 127.00:00:00
 3) 128.00:00:00
 4) 256.00:00:00
 5) 32767.00:00:00
 6) 32768.00:00:00
 7) 65536.00:00:00
 8) 00:00:00
 9) 00:00:00
10) 00:00:00
11) 00:00:00
12) 00:00:00
13) 00:00:00
14) 00:00:00
###
> Map(x: I8s, Time(x, x))
Map(x : I8s, Time(x, x)) : t*
BndKind:Call, Type:t*, Bnd:(Call(∂.ForEach([map:1] Global(I8s), Call(∂.Time(Scope(1), Scope(1)):t)):t*))
// (∂.I8s:i8*) : t*
ForEach_1(Arr<obj>, i8):Time
      1) ldarg.1 [i8]
      1) ldarg.1 [i8]
      5) call static TimeGen::Exec(i8, i8):Time
      1) ret
  Total Size: 8

top(Arr<obj>, Arr<obj>):obj
      1) ldarg.1 [Arr<obj>]
      1) ldc.i4.0
      1) ldelem.ref
      5) call static CodeGenUtil::ToRef(obj):Seq<i8>
      1) stloc.0 [Seq<i8>]
      1) ldloc.0 [Seq<i8>]
      1) ldarg.0 [Arr<obj>]
      1) ldc.i4.0
      5) ldelem [Func<i8,Time>]
      5) call static ForEachGen::Exec(Seq<i8>, Func<i8,Time>):Seq<Time>
      5) call static CodeGenUtil::EnumerableToCaching(Seq<Time>):Seq<Time>
      1) ret
  Total Size: 28

Func sig: (I8s:i8*) to t*
Sequence: Seq<Time>
 0) 3.03:00:00
 1) -7.07:00:00
 2) 132.07:00:00
 3) 133.08:00:00
 4) 266.16:00:00
 5) 34132.07:00:00
 6) 34133.08:00:00
 7) 68266.16:00:00
 8) 00:00:00
 9) 00:00:00
10) 00:00:00
11) 00:00:00
12) 00:00:00
13) 00:00:00
14) 00:00:00
###
> Map(x: I8s, Time(x, x, x))
Map(x : I8s, Time(x, x, x)) : t*
BndKind:Call, Type:t*, Bnd:(Call(∂.ForEach([map:1] Global(I8s), Call(∂.Time(Scope(1), Scope(1), Scope(1)):t)):t*))
// (∂.I8s:i8*) : t*
ForEach_1(Arr<obj>, i8):Time
      1) ldarg.1 [i8]
      1) ldarg.1 [i8]
      1) ldarg.1 [i8]
      5) call static TimeGen::Exec(i8, i8, i8):Time
      1) ret
  Total Size: 9

top(Arr<obj>, Arr<obj>):obj
      1) ldarg.1 [Arr<obj>]
      1) ldc.i4.0
      1) ldelem.ref
      5) call static CodeGenUtil::ToRef(obj):Seq<i8>
      1) stloc.0 [Seq<i8>]
      1) ldloc.0 [Seq<i8>]
      1) ldarg.0 [Arr<obj>]
      1) ldc.i4.0
      5) ldelem [Func<i8,Time>]
      5) call static ForEachGen::Exec(Seq<i8>, Func<i8,Time>):Seq<Time>
      5) call static CodeGenUtil::EnumerableToCaching(Seq<Time>):Seq<Time>
      1) ret
  Total Size: 28

Func sig: (I8s:i8*) to t*
Sequence: Seq<Time>
 0) 3.03:03:00
 1) -7.07:07:00
 2) 132.09:07:00
 3) 133.10:08:00
 4) 266.20:16:00
 5) 34155.01:07:00
 6) 34156.02:08:00
 7) 68312.04:16:00
 8) 00:00:00
 9) 00:00:00
10) 00:00:00
11) 00:00:00
12) 00:00:00
13) 00:00:00
14) 00:00:00
###
> Map(x: I8s, Time(x, x, x, x))
Map(x : I8s, Time(x, x, x, x)) : t*
BndKind:Call, Type:t*, Bnd:(Call(∂.ForEach([map:1] Global(I8s), Call(∂.Time(Scope(1), Scope(1), Scope(1), Scope(1)):t)):t*))
// (∂.I8s:i8*) : t*
ForEach_1(Arr<obj>, i8):Time
      1) ldarg.1 [i8]
      1) ldarg.1 [i8]
      1) ldarg.1 [i8]
      1) ldarg.1 [i8]
      5) call static TimeGen::Exec(i8, i8, i8, i8):Time
      1) ret
  Total Size: 10

top(Arr<obj>, Arr<obj>):obj
      1) ldarg.1 [Arr<obj>]
      1) ldc.i4.0
      1) ldelem.ref
      5) call static CodeGenUtil::ToRef(obj):Seq<i8>
      1) stloc.0 [Seq<i8>]
      1) ldloc.0 [Seq<i8>]
      1) ldarg.0 [Arr<obj>]
      1) ldc.i4.0
      5) ldelem [Func<i8,Time>]
      5) call static ForEachGen::Exec(Seq<i8>, Func<i8,Time>):Seq<Time>
      5) call static CodeGenUtil::EnumerableToCaching(Seq<Time>):Seq<Time>
      1) ret
  Total Size: 28

Func sig: (I8s:i8*) to t*
Sequence: Seq<Time>
 0) 3.03:03:03
 1) -7.07:07:07
 2) 132.09:09:07
 3) 133.10:10:08
 4) 266.20:20:16
 5) 34155.10:13:07
 6) 34156.11:14:08
 7) 68312.22:28:16
 8) 00:00:00
 9) 00:00:00
10) 00:00:00
11) 00:00:00
12) 00:00:00
13) 00:00:00
14) 00:00:00
###
> Map(x: I8s, Time(x, x, x, x, x))
Map(x : I8s, Time(x, x, x, x, x)) : t*
BndKind:Call, Type:t*, Bnd:(Call(∂.ForEach([map:1] Global(I8s), Call(∂.Time(Scope(1), Scope(1), Scope(1), Scope(1), Scope(1)):t)):t*))
// (∂.I8s:i8*) : t*
ForEach_1(Arr<obj>, i8):Time
      1) ldarg.1 [i8]
      1) ldarg.1 [i8]
      1) ldarg.1 [i8]
      1) ldarg.1 [i8]
      1) ldarg.1 [i8]
      5) call static TimeGen::Exec(i8, i8, i8, i8, i8):Time
      1) ret
  Total Size: 11

top(Arr<obj>, Arr<obj>):obj
      1) ldarg.1 [Arr<obj>]
      1) ldc.i4.0
      1) ldelem.ref
      5) call static CodeGenUtil::ToRef(obj):Seq<i8>
      1) stloc.0 [Seq<i8>]
      1) ldloc.0 [Seq<i8>]
      1) ldarg.0 [Arr<obj>]
      1) ldc.i4.0
      5) ldelem [Func<i8,Time>]
      5) call static ForEachGen::Exec(Seq<i8>, Func<i8,Time>):Seq<Time>
      5) call static CodeGenUtil::EnumerableToCaching(Seq<Time>):Seq<Time>
      1) ret
  Total Size: 28

Func sig: (I8s:i8*) to t*
Sequence: Seq<Time>
 0) 3.03:03:03.0030000
 1) -7.07:07:07.0070000
 2) 132.09:09:07.1270000
 3) 133.10:10:08.1280000
 4) 266.20:20:16.2560000
 5) 34155.10:13:39.7670000
 6) 34156.11:14:40.7680000
 7) 68312.22:29:21.5360000
 8) 00:00:00
 9) 00:00:00
10) 00:00:00
11) 00:00:00
12) 00:00:00
13) 00:00:00
14) 00:00:00
###
> Map(x: I8s, Time(x, x, x, x, x, x))
Map(x : I8s, Time(x, x, x, x, x, x)) : t*
BndKind:Call, Type:t*, Bnd:(Call(∂.ForEach([map:1] Global(I8s), Call(∂.Time(Scope(1), Scope(1), Scope(1), Scope(1), Scope(1), Scope(1)):t)):t*))
// (∂.I8s:i8*) : t*
ForEach_1(Arr<obj>, i8):Time
      1) ldarg.1 [i8]
      1) ldarg.1 [i8]
      1) ldarg.1 [i8]
      1) ldarg.1 [i8]
      1) ldarg.1 [i8]
      1) ldarg.1 [i8]
      5) call static TimeGen::Exec(i8, i8, i8, i8, i8, i8):Time
      1) ret
  Total Size: 12

top(Arr<obj>, Arr<obj>):obj
      1) ldarg.1 [Arr<obj>]
      1) ldc.i4.0
      1) ldelem.ref
      5) call static CodeGenUtil::ToRef(obj):Seq<i8>
      1) stloc.0 [Seq<i8>]
      1) ldloc.0 [Seq<i8>]
      1) ldarg.0 [Arr<obj>]
      1) ldc.i4.0
      5) ldelem [Func<i8,Time>]
      5) call static ForEachGen::Exec(Seq<i8>, Func<i8,Time>):Seq<Time>
      5) call static CodeGenUtil::EnumerableToCaching(Seq<Time>):Seq<Time>
      1) ret
  Total Size: 28

Func sig: (I8s:i8*) to t*
Sequence: Seq<Time>
 0) 3.03:03:03.0030003
 1) -7.07:07:07.0070007
 2) 132.09:09:07.1270127
 3) 133.10:10:08.1280128
 4) 266.20:20:16.2560256
 5) 34155.10:13:39.7702767
 6) 34156.11:14:40.7712768
 7) 68312.22:29:21.5425536
 8) 00:00:00
 9) 00:00:00
10) 00:00:00
11) 00:00:00
12) 00:00:00
13) 00:00:00
14) 00:00:00
###
> Map(x: I8s, Time(0, x))
Map(x : I8s, Time(0, x)) : t*
BndKind:Call, Type:t*, Bnd:(Call(∂.ForEach([map:1] Global(I8s), Call(∂.Time(0:i8, Scope(1)):t)):t*))
// (∂.I8s:i8*) : t*
ForEach_1(Arr<obj>, i8):Time
      1) ldc.i4.0
      1) conv.i8
      1) ldarg.1 [i8]
      5) call static TimeGen::Exec(i8, i8):Time
      1) ret
  Total Size: 9

top(Arr<obj>, Arr<obj>):obj
      1) ldarg.1 [Arr<obj>]
      1) ldc.i4.0
      1) ldelem.ref
      5) call static CodeGenUtil::ToRef(obj):Seq<i8>
      1) stloc.0 [Seq<i8>]
      1) ldloc.0 [Seq<i8>]
      1) ldarg.0 [Arr<obj>]
      1) ldc.i4.0
      5) ldelem [Func<i8,Time>]
      5) call static ForEachGen::Exec(Seq<i8>, Func<i8,Time>):Seq<Time>
      5) call static CodeGenUtil::EnumerableToCaching(Seq<Time>):Seq<Time>
      1) ret
  Total Size: 28

Func sig: (I8s:i8*) to t*
Sequence: Seq<Time>
 0) 03:00:00
 1) -07:00:00
 2) 5.07:00:00
 3) 5.08:00:00
 4) 10.16:00:00
 5) 1365.07:00:00
 6) 1365.08:00:00
 7) 2730.16:00:00
 8) 00:00:00
 9) 00:00:00
10) 00:00:00
11) 00:00:00
12) 00:00:00
13) 00:00:00
14) 00:00:00
###
> Map(x: I8s, Time(0, 0, x))
Map(x : I8s, Time(0, 0, x)) : t*
BndKind:Call, Type:t*, Bnd:(Call(∂.ForEach([map:1] Global(I8s), Call(∂.Time(0:i8, 0:i8, Scope(1)):t)):t*))
// (∂.I8s:i8*) : t*
ForEach_1(Arr<obj>, i8):Time
      1) ldc.i4.0
      1) conv.i8
      1) ldc.i4.0
      1) conv.i8
      1) ldarg.1 [i8]
      5) call static TimeGen::Exec(i8, i8, i8):Time
      1) ret
  Total Size: 11

top(Arr<obj>, Arr<obj>):obj
      1) ldarg.1 [Arr<obj>]
      1) ldc.i4.0
      1) ldelem.ref
      5) call static CodeGenUtil::ToRef(obj):Seq<i8>
      1) stloc.0 [Seq<i8>]
      1) ldloc.0 [Seq<i8>]
      1) ldarg.0 [Arr<obj>]
      1) ldc.i4.0
      5) ldelem [Func<i8,Time>]
      5) call static ForEachGen::Exec(Seq<i8>, Func<i8,Time>):Seq<Time>
      5) call static CodeGenUtil::EnumerableToCaching(Seq<Time>):Seq<Time>
      1) ret
  Total Size: 28

Func sig: (I8s:i8*) to t*
Sequence: Seq<Time>
 0) 00:03:00
 1) -00:07:00
 2) 02:07:00
 3) 02:08:00
 4) 04:16:00
 5) 22.18:07:00
 6) 22.18:08:00
 7) 45.12:16:00
 8) 1491308.02:07:00
 9) 1491308.02:08:00
10) 2982616.04:16:00
11) 00:00:00
12) 00:00:00
13) 00:00:00
14) 00:00:00
###
> Map(x: I8s, Time(0, 0, 0, x))
Map(x : I8s, Time(0, 0, 0, x)) : t*
BndKind:Call, Type:t*, Bnd:(Call(∂.ForEach([map:1] Global(I8s), Call(∂.Time(0:i8, 0:i8, 0:i8, Scope(1)):t)):t*))
// (∂.I8s:i8*) : t*
ForEach_1(Arr<obj>, i8):Time
      1) ldc.i4.0
      1) conv.i8
      1) ldc.i4.0
      1) conv.i8
      1) ldc.i4.0
      1) conv.i8
      1) ldarg.1 [i8]
      5) call static TimeGen::Exec(i8, i8, i8, i8):Time
      1) ret
  Total Size: 13

top(Arr<obj>, Arr<obj>):obj
      1) ldarg.1 [Arr<obj>]
      1) ldc.i4.0
      1) ldelem.ref
      5) call static CodeGenUtil::ToRef(obj):Seq<i8>
      1) stloc.0 [Seq<i8>]
      1) ldloc.0 [Seq<i8>]
      1) ldarg.0 [Arr<obj>]
      1) ldc.i4.0
      5) ldelem [Func<i8,Time>]
      5) call static ForEachGen::Exec(Seq<i8>, Func<i8,Time>):Seq<Time>
      5) call static CodeGenUtil::EnumerableToCaching(Seq<Time>):Seq<Time>
      1) ret
  Total Size: 28

Func sig: (I8s:i8*) to t*
Sequence: Seq<Time>
 0) 00:00:03
 1) -00:00:07
 2) 00:02:07
 3) 00:02:08
 4) 00:04:16
 5) 09:06:07
 6) 09:06:08
 7) 18:12:16
 8) 24855.03:14:07
 9) 24855.03:14:08
10) 49710.06:28:16
11) 00:00:00
12) 00:00:00
13) 00:00:00
14) 00:00:00
###
> Map(x: I8s, Time(0, 0, 0, 0, x))
Map(x : I8s, Time(0, 0, 0, 0, x)) : t*
BndKind:Call, Type:t*, Bnd:(Call(∂.ForEach([map:1] Global(I8s), Call(∂.Time(0:i8, 0:i8, 0:i8, 0:i8, Scope(1)):t)):t*))
// (∂.I8s:i8*) : t*
ForEach_1(Arr<obj>, i8):Time
      1) ldc.i4.0
      1) conv.i8
      1) ldc.i4.0
      1) conv.i8
      1) ldc.i4.0
      1) conv.i8
      1) ldc.i4.0
      1) conv.i8
      1) ldarg.1 [i8]
      5) call static TimeGen::Exec(i8, i8, i8, i8, i8):Time
      1) ret
  Total Size: 15

top(Arr<obj>, Arr<obj>):obj
      1) ldarg.1 [Arr<obj>]
      1) ldc.i4.0
      1) ldelem.ref
      5) call static CodeGenUtil::ToRef(obj):Seq<i8>
      1) stloc.0 [Seq<i8>]
      1) ldloc.0 [Seq<i8>]
      1) ldarg.0 [Arr<obj>]
      1) ldc.i4.0
      5) ldelem [Func<i8,Time>]
      5) call static ForEachGen::Exec(Seq<i8>, Func<i8,Time>):Seq<Time>
      5) call static CodeGenUtil::EnumerableToCaching(Seq<Time>):Seq<Time>
      1) ret
  Total Size: 28

Func sig: (I8s:i8*) to t*
Sequence: Seq<Time>
 0) 00:00:00.0030000
 1) -00:00:00.0070000
 2) 00:00:00.1270000
 3) 00:00:00.1280000
 4) 00:00:00.2560000
 5) 00:00:32.7670000
 6) 00:00:32.7680000
 7) 00:01:05.5360000
 8) 24.20:31:23.6470000
 9) 24.20:31:23.6480000
10) 49.17:02:47.2960000
11) 00:00:00
12) 00:00:00
13) 00:00:00
14) 00:00:00
###
> Map(x: I8s, Time(0, 0, 0, 0, 0, x))
Map(x : I8s, Time(0, 0, 0, 0, 0, x)) : t*
BndKind:Call, Type:t*, Bnd:(Call(∂.ForEach([map:1] Global(I8s), Call(∂.Time(0:i8, 0:i8, 0:i8, 0:i8, 0:i8, Scope(1)):t)):t*))
// (∂.I8s:i8*) : t*
ForEach_1(Arr<obj>, i8):Time
      1) ldc.i4.0
      1) conv.i8
      1) ldc.i4.0
      1) conv.i8
      1) ldc.i4.0
      1) conv.i8
      1) ldc.i4.0
      1) conv.i8
      1) ldc.i4.0
      1) conv.i8
      1) ldarg.1 [i8]
      5) call static TimeGen::Exec(i8, i8, i8, i8, i8, i8):Time
      1) ret
  Total Size: 17

top(Arr<obj>, Arr<obj>):obj
      1) ldarg.1 [Arr<obj>]
      1) ldc.i4.0
      1) ldelem.ref
      5) call static CodeGenUtil::ToRef(obj):Seq<i8>
      1) stloc.0 [Seq<i8>]
      1) ldloc.0 [Seq<i8>]
      1) ldarg.0 [Arr<obj>]
      1) ldc.i4.0
      5) ldelem [Func<i8,Time>]
      5) call static ForEachGen::Exec(Seq<i8>, Func<i8,Time>):Seq<Time>
      5) call static CodeGenUtil::EnumerableToCaching(Seq<Time>):Seq<Time>
      1) ret
  Total Size: 28

Func sig: (I8s:i8*) to t*
Sequence: Seq<Time>
 0) 00:00:00.0000003
 1) -00:00:00.0000007
 2) 00:00:00.0000127
 3) 00:00:00.0000128
 4) 00:00:00.0000256
 5) 00:00:00.0032767
 6) 00:00:00.0032768
 7) 00:00:00.0065536
 8) 00:03:34.7483647
 9) 00:03:34.7483648
10) 00:07:09.4967296
11) 3652058.23:59:59.9999999
12) 3652059.00:00:00
13) 10675199.02:48:05.4775807
14) -10675199.02:48:05.4775808
###
> [ +5807, +5808, +5809, 0x7FFF_FFFF_FFFF_FFFFi8 ] | Time(+10675199, +2, +48, +5, +477, _)
[+5807, +5808, +5809, 9223372036854775807] | Time(+10675199, +2, +48, +5, +477, _) : t*
BndKind:Call, Type:t*, Bnd:(Call(∂.ForEach([map:1] [5807:i8, 5808:i8, 5809:i8, 9223372036854775807:i8]:i8*, Call(∂.Time(10675199:i8, 2:i8, 48:i8, 5:i8, 477:i8, Scope(1)):t)):t*))
// () : t*
ForEach_1(Arr<obj>, i8):Time
      5) ldc.i4 [10675199]
      1) conv.i8
      1) ldc.i4.2
      1) conv.i8
      2) ldc.i4.s [48]
      1) conv.i8
      1) ldc.i4.5
      1) conv.i8
      5) ldc.i4 [477]
      1) conv.i8
      1) ldarg.1 [i8]
      5) call static TimeGen::Exec(i8, i8, i8, i8, i8, i8):Time
      1) ret
  Total Size: 26

top(Arr<obj>, Arr<obj>):obj
      1) ldc.i4.4
      5) newarr [i8]
      1) dup
      1) ldc.i4.0
      5) ldc.i4 [5807]
      1) conv.i8
      5) stelem [i8]
      1) dup
      1) ldc.i4.1
      5) ldc.i4 [5808]
      1) conv.i8
      5) stelem [i8]
      1) dup
      1) ldc.i4.2
      5) ldc.i4 [5809]
      1) conv.i8
      5) stelem [i8]
      1) dup
      1) ldc.i4.3
      9) ldc.i8 [9223372036854775807]
      5) stelem [i8]
      1) ldarg.0 [Arr<obj>]
      1) ldc.i4.0
      5) ldelem [Func<i8,Time>]
      5) call static ForEachGen::Exec(Seq<i8>, Func<i8,Time>):Seq<Time>
      5) call static CodeGenUtil::EnumerableToCaching(Seq<Time>):Seq<Time>
      1) ret
  Total Size: 79

Func sig: () to t*
Sequence: Seq<Time>
 0) 10675199.02:48:05.4775807
 1) 00:00:00
 2) 00:00:00
 3) 00:00:00
###
> [ -5807, -5808, -5809, 0x8000_0000_0000_0000i8 ] | Time(-10675199, -2, -48, -5, -477, _)
[-5807, -5808, -5809, 9223372036854775808] | Time(-10675199, -2, -48, -5, -477, _) : t*
BndKind:Call, Type:t*, Bnd:(Call(∂.ForEach([map:1] [-5807:i8, -5808:i8, -5809:i8, -9223372036854775808:i8]:i8*, Call(∂.Time(-10675199:i8, -2:i8, -48:i8, -5:i8, -477:i8, Scope(1)):t)):t*))
// () : t*
ForEach_1(Arr<obj>, i8):Time
      5) ldc.i4 [-10675199]
      1) conv.i8
      2) ldc.i4.s [-2]
      1) conv.i8
      2) ldc.i4.s [-48]
      1) conv.i8
      2) ldc.i4.s [-5]
      1) conv.i8
      5) ldc.i4 [-477]
      1) conv.i8
      1) ldarg.1 [i8]
      5) call static TimeGen::Exec(i8, i8, i8, i8, i8, i8):Time
      1) ret
  Total Size: 28

top(Arr<obj>, Arr<obj>):obj
      1) ldc.i4.4
      5) newarr [i8]
      1) dup
      1) ldc.i4.0
      5) ldc.i4 [-5807]
      1) conv.i8
      5) stelem [i8]
      1) dup
      1) ldc.i4.1
      5) ldc.i4 [-5808]
      1) conv.i8
      5) stelem [i8]
      1) dup
      1) ldc.i4.2
      5) ldc.i4 [-5809]
      1) conv.i8
      5) stelem [i8]
      1) dup
      1) ldc.i4.3
      9) ldc.i8 [-9223372036854775808]
      5) stelem [i8]
      1) ldarg.0 [Arr<obj>]
      1) ldc.i4.0
      5) ldelem [Func<i8,Time>]
      5) call static ForEachGen::Exec(Seq<i8>, Func<i8,Time>):Seq<Time>
      5) call static CodeGenUtil::EnumerableToCaching(Seq<Time>):Seq<Time>
      1) ret
  Total Size: 79

Func sig: () to t*
Sequence: Seq<Time>
 0) -10675199.02:48:05.4775807
 1) -10675199.02:48:05.4775808
 2) 00:00:00
 3) 00:00:00
###
