**** New definitions: T8, type: {A:i4, B:r8, C:s}*
**** New definitions: T4, type: {A:i4, B:r4, C:s}*
**** New definitions: Im0, type: U<Image>
**** New definitions: Im1, type: U<Image>
**** New definitions: TU, type: {A:i8, B:i8, C:U<Image>, D:i8}*

> GroupBy(T8, [key] B, X)
GroupBy(T8, [key] B, X) : {B:r8, X:{A:i4, C:s}*}*
BndKind:GroupBy, Type:{B:r8, X:{A:i4, C:s}*}*, Bnd:(GroupBy([scope:1] Global(T8), [key] B:GetField(Scope(1), B), [auto] X:<auto>))
// (<ctx>, ∂.T8:{A:i4, B:r8, C:s}*) : {B:r8, X:{A:i4, C:s}*}*
keySelector(Arr<obj>, {i4,r8,str}):r8
      1) ldarg.1 [{i4,r8,str}]
      5) ldfld {i4,r8,str}::_F1:r8
      1) ret
  Total Size: 7

elementSelector(Arr<obj>, {i4,r8,str}):{i4,str}
      5) newobj {i4,str}()
      1) dup
      1) ldc.i4.3
      5) stfld {i4,str}::_B0:u1
      1) stloc.0 [{i4,str}]
      1) ldloc.0 [{i4,str}]
      1) ldarg.1 [{i4,r8,str}]
      5) ldfld {i4,r8,str}::_F0:i4
      5) stfld {i4,str}::_F0:i4
      1) ldloc.0 [{i4,str}]
      1) ldarg.1 [{i4,r8,str}]
      5) ldfld {i4,r8,str}::_F2:str
      5) stfld {i4,str}::_F1:str
      1) ldloc.0 [{i4,str}]
      1) dup
      1) ldarg.0 [Arr<obj>]
      1) ldc.i4.0
      5) ldelem [RecordRuntimeTypeInfo]
      5) stfld {}::_rrti:RecordRuntimeTypeInfo
      1) ret
  Total Size: 52

resultSelector(Arr<obj>, r8, Seq<{i4,str}>):{r8,Seq<{i4,str}>}
      5) newobj {r8,Seq<{i4,str}>}()
      1) dup
      1) ldc.i4.1
      5) stfld {r8,Seq<{i4,str}>}::_B0:u1
      1) stloc.0 [{r8,Seq<{i4,str}>}]
      1) ldloc.0 [{r8,Seq<{i4,str}>}]
      1) ldarg.1 [r8]
      5) stfld {r8,Seq<{i4,str}>}::_F0:r8
      1) ldloc.0 [{r8,Seq<{i4,str}>}]
      1) ldarg.2 [Seq<{i4,str}>]
      5) call static CodeGenUtil::EnumerableToCaching(Seq<{i4,str}>):Seq<{i4,str}>
      5) stfld {r8,Seq<{i4,str}>}::_F1:Seq<{i4,str}>
      1) ldloc.0 [{r8,Seq<{i4,str}>}]
      1) dup
      1) ldarg.0 [Arr<obj>]
      1) ldc.i4.0
      5) ldelem [RecordRuntimeTypeInfo]
      5) stfld {}::_rrti:RecordRuntimeTypeInfo
      1) ret
  Total Size: 47

top(Arr<obj>, Arr<obj>):obj
      1) ldarg.1 [Arr<obj>]
      1) ldc.i4.0
      1) ldelem.ref
      5) call static CodeGenUtil::ToRef(obj):ExecCtx
      1) stloc.0 [ExecCtx]
      1) ldarg.1 [Arr<obj>]
      1) ldc.i4.1
      1) ldelem.ref
      5) call static CodeGenUtil::ToRef(obj):Seq<{i4,r8,str}>
      1) stloc.1 [Seq<{i4,r8,str}>]
      1) ldloc.1 [Seq<{i4,r8,str}>]
      1) dup
      5) brtrue [0]
      1) pop
      1) ldnull
      5) br [1]
  Label [0]:
      1) ldloc.0 [ExecCtx]
      1) ldc.i4.0
      5) call static CodeGenUtil::EnumerableToPinging(Seq<{i4,r8,str}>, ExecCtx, i4):Seq<{i4,r8,str}>
      1) ldarg.0 [Arr<obj>]
      1) ldc.i4.0
      5) ldelem [Func<{i4,r8,str},r8>]
      1) ldarg.0 [Arr<obj>]
      1) ldc.i4.1
      5) ldelem [Func<{i4,r8,str},{i4,str}>]
      1) ldarg.0 [Arr<obj>]
      1) ldc.i4.2
      5) ldelem [Func<r8,Seq<{i4,str}>,{r8,Seq<{i4,str}>}>]
      5) call static Enumerable::GroupBy(Seq<{i4,r8,str}>, Func<{i4,r8,str},r8>, Func<{i4,r8,str},{i4,str}>, Func<r8,Seq<{i4,str}>,{r8,Seq<{i4,str}>}>):Seq<{r8,Seq<{i4,str}>}>
      5) call static CodeGenUtil::EnumerableToCaching(Seq<{r8,Seq<{i4,str}>}>):Seq<{r8,Seq<{i4,str}>}>
  Label [1]:
      1) ret
  Total Size: 71

Func sig: (<ctx>:x, T8:{A:i4, B:r8, C:s}*) to {B:r8, X:{A:i4, C:s}*}*
Sequence: Seq<{r8,Seq<{i4,str}>}>
 0) { B: 1, 
      X: Sequence: Seq<{i4,str}>
         0) { A: 0, C: X }
    }
 1) { B: NaN, 
      X: Sequence: Seq<{i4,str}>
         0) { A: 1, C: X }
         1) { A: 2, C: X }
    }
 2) { B: -0, 
      X: Sequence: Seq<{i4,str}>
         0) { A: 3, C: Y }
         1) { A: 4, C: Y }
    }
*** Ctx ping count: 6
    [0](6): GroupBy(*1: T8, [key] B:*1.B, [auto] X:<auto>)
###
> GroupBy(T8, [key] C, X)
GroupBy(T8, [key] C, X) : {C:s, X:{A:i4, B:r8}*}*
BndKind:GroupBy, Type:{C:s, X:{A:i4, B:r8}*}*, Bnd:(GroupBy([scope:1] Global(T8), [key] C:GetField(Scope(1), C), [auto] X:<auto>))
// (<ctx>, ∂.T8:{A:i4, B:r8, C:s}*) : {C:s, X:{A:i4, B:r8}*}*
keySelector(Arr<obj>, {i4,r8,str}):str
      1) ldarg.1 [{i4,r8,str}]
      5) ldfld {i4,r8,str}::_F2:str
      1) ret
  Total Size: 7

elementSelector(Arr<obj>, {i4,r8,str}):{i4,r8}
      5) newobj {i4,r8}()
      1) dup
      1) ldc.i4.3
      5) stfld {i4,r8}::_B0:u1
      1) stloc.0 [{i4,r8}]
      1) ldloc.0 [{i4,r8}]
      1) ldarg.1 [{i4,r8,str}]
      5) ldfld {i4,r8,str}::_F0:i4
      5) stfld {i4,r8}::_F0:i4
      1) ldloc.0 [{i4,r8}]
      1) ldarg.1 [{i4,r8,str}]
      5) ldfld {i4,r8,str}::_F1:r8
      5) stfld {i4,r8}::_F1:r8
      1) ldloc.0 [{i4,r8}]
      1) dup
      1) ldarg.0 [Arr<obj>]
      1) ldc.i4.0
      5) ldelem [RecordRuntimeTypeInfo]
      5) stfld {}::_rrti:RecordRuntimeTypeInfo
      1) ret
  Total Size: 52

resultSelector(Arr<obj>, str, Seq<{i4,r8}>):{str,Seq<{i4,r8}>}
      5) newobj {str,Seq<{i4,r8}>}()
      1) dup
      1) ldc.i4.1
      5) stfld {str,Seq<{i4,r8}>}::_B0:u1
      1) stloc.0 [{str,Seq<{i4,r8}>}]
      1) ldloc.0 [{str,Seq<{i4,r8}>}]
      1) ldarg.1 [str]
      5) stfld {str,Seq<{i4,r8}>}::_F0:str
      1) ldloc.0 [{str,Seq<{i4,r8}>}]
      1) ldarg.2 [Seq<{i4,r8}>]
      5) call static CodeGenUtil::EnumerableToCaching(Seq<{i4,r8}>):Seq<{i4,r8}>
      5) stfld {str,Seq<{i4,r8}>}::_F1:Seq<{i4,r8}>
      1) ldloc.0 [{str,Seq<{i4,r8}>}]
      1) dup
      1) ldarg.0 [Arr<obj>]
      1) ldc.i4.0
      5) ldelem [RecordRuntimeTypeInfo]
      5) stfld {}::_rrti:RecordRuntimeTypeInfo
      1) ret
  Total Size: 47

top(Arr<obj>, Arr<obj>):obj
      1) ldarg.1 [Arr<obj>]
      1) ldc.i4.0
      1) ldelem.ref
      5) call static CodeGenUtil::ToRef(obj):ExecCtx
      1) stloc.0 [ExecCtx]
      1) ldarg.1 [Arr<obj>]
      1) ldc.i4.1
      1) ldelem.ref
      5) call static CodeGenUtil::ToRef(obj):Seq<{i4,r8,str}>
      1) stloc.1 [Seq<{i4,r8,str}>]
      1) ldloc.1 [Seq<{i4,r8,str}>]
      1) dup
      5) brtrue [0]
      1) pop
      1) ldnull
      5) br [1]
  Label [0]:
      1) ldloc.0 [ExecCtx]
      1) ldc.i4.0
      5) call static CodeGenUtil::EnumerableToPinging(Seq<{i4,r8,str}>, ExecCtx, i4):Seq<{i4,r8,str}>
      1) ldarg.0 [Arr<obj>]
      1) ldc.i4.0
      5) ldelem [Func<{i4,r8,str},str>]
      1) ldarg.0 [Arr<obj>]
      1) ldc.i4.1
      5) ldelem [Func<{i4,r8,str},{i4,r8}>]
      1) ldarg.0 [Arr<obj>]
      1) ldc.i4.2
      5) ldelem [Func<str,Seq<{i4,r8}>,{str,Seq<{i4,r8}>}>]
      5) call static Enumerable::GroupBy(Seq<{i4,r8,str}>, Func<{i4,r8,str},str>, Func<{i4,r8,str},{i4,r8}>, Func<str,Seq<{i4,r8}>,{str,Seq<{i4,r8}>}>):Seq<{str,Seq<{i4,r8}>}>
      5) call static CodeGenUtil::EnumerableToCaching(Seq<{str,Seq<{i4,r8}>}>):Seq<{str,Seq<{i4,r8}>}>
  Label [1]:
      1) ret
  Total Size: 71

Func sig: (<ctx>:x, T8:{A:i4, B:r8, C:s}*) to {C:s, X:{A:i4, B:r8}*}*
Sequence: Seq<{str,Seq<{i4,r8}>}>
 0) { C: X, 
      X: Sequence: Seq<{i4,r8}>
         0) { A: 0, B: 1 }
         1) { A: 1, B: NaN }
         2) { A: 2, B: NaN }
    }
 1) { C: Y, 
      X: Sequence: Seq<{i4,r8}>
         0) { A: 3, B: -0 }
         1) { A: 4, B: 0 }
    }
*** Ctx ping count: 6
    [0](6): GroupBy(*1: T8, [key] C:*1.C, [auto] X:<auto>)
###
> GroupBy(T8, [key] B, [key] C, X)
GroupBy(T8, [key] B, [key] C, X) : {B:r8, C:s, X:{A:i4}*}*
BndKind:GroupBy, Type:{B:r8, C:s, X:{A:i4}*}*, Bnd:(GroupBy([scope:1] Global(T8), [key] B:GetField(Scope(1), B), [key] C:GetField(Scope(1), C), [auto] X:<auto>))
// (<ctx>, ∂.T8:{A:i4, B:r8, C:s}*) : {B:r8, C:s, X:{A:i4}*}*
elementSelector(Arr<obj>, {i4,r8,str}):{i4}
      5) newobj {i4}()
      1) dup
      1) ldc.i4.1
      5) stfld {i4}::_B0:u1
      1) stloc.0 [{i4}]
      1) ldloc.0 [{i4}]
      1) ldarg.1 [{i4,r8,str}]
      5) ldfld {i4,r8,str}::_F0:i4
      5) stfld {i4}::_F0:i4
      1) ldloc.0 [{i4}]
      1) dup
      1) ldarg.0 [Arr<obj>]
      1) ldc.i4.0
      5) ldelem [RecordRuntimeTypeInfo]
      5) stfld {}::_rrti:RecordRuntimeTypeInfo
      1) ret
  Total Size: 40

resultSelector(Arr<obj>, {i4,r8,str}, Seq<{i4}>):{r8,str,Seq<{i4}>}
      5) newobj {r8,str,Seq<{i4}>}()
      1) dup
      1) ldc.i4.3
      5) stfld {r8,str,Seq<{i4}>}::_B0:u1
      1) stloc.0 [{r8,str,Seq<{i4}>}]
      1) ldloc.0 [{r8,str,Seq<{i4}>}]
      1) ldarg.1 [{i4,r8,str}]
      5) ldfld {i4,r8,str}::_F1:r8
      5) stfld {r8,str,Seq<{i4}>}::_F0:r8
      1) ldloc.0 [{r8,str,Seq<{i4}>}]
      1) ldarg.1 [{i4,r8,str}]
      5) ldfld {i4,r8,str}::_F2:str
      5) stfld {r8,str,Seq<{i4}>}::_F1:str
      1) ldloc.0 [{r8,str,Seq<{i4}>}]
      1) ldarg.2 [Seq<{i4}>]
      5) call static CodeGenUtil::EnumerableToCaching(Seq<{i4}>):Seq<{i4}>
      5) stfld {r8,str,Seq<{i4}>}::_F2:Seq<{i4}>
      1) ldloc.0 [{r8,str,Seq<{i4}>}]
      1) dup
      1) ldarg.0 [Arr<obj>]
      1) ldc.i4.0
      5) ldelem [RecordRuntimeTypeInfo]
      5) stfld {}::_rrti:RecordRuntimeTypeInfo
      1) ret
  Total Size: 64

Equals(Arr<obj>, {i4,r8,str}, {i4,r8,str}):bool
      1) ldarg.1 [{i4,r8,str}]
      5) ldfld {i4,r8,str}::_F1:r8
      1) ldarg.2 [{i4,r8,str}]
      5) ldfld {i4,r8,str}::_F1:r8
      5) call static CodeGenUtil::EqVal(r8, r8):bool
      5) brfalse [0]
      1) ldarg.1 [{i4,r8,str}]
      5) ldfld {i4,r8,str}::_F2:str
      1) ldarg.2 [{i4,r8,str}]
      5) ldfld {i4,r8,str}::_F2:str
      5) call static str::Equals(str, str):bool
      5) br [1]
  Label [0]:
      1) ldc.i4.0
  Label [1]:
      1) ret
  Total Size: 46

GetHashCode(Arr<obj>, {i4,r8,str}):i4
      1) ldarg.1 [{i4,r8,str}]
      5) ldfld {i4,r8,str}::_F1:r8
      1) ldarg.1 [{i4,r8,str}]
      5) ldfld {i4,r8,str}::_F2:str
      5) call static HashCode::Combine(r8, str):i4
      1) ret
  Total Size: 18

top(Arr<obj>, Arr<obj>):obj
      1) ldarg.1 [Arr<obj>]
      1) ldc.i4.0
      1) ldelem.ref
      5) call static CodeGenUtil::ToRef(obj):ExecCtx
      1) stloc.0 [ExecCtx]
      1) ldarg.1 [Arr<obj>]
      1) ldc.i4.1
      1) ldelem.ref
      5) call static CodeGenUtil::ToRef(obj):Seq<{i4,r8,str}>
      1) stloc.1 [Seq<{i4,r8,str}>]
      1) ldloc.1 [Seq<{i4,r8,str}>]
      1) dup
      5) brtrue [0]
      1) pop
      1) ldnull
      5) br [1]
  Label [0]:
      1) ldloc.0 [ExecCtx]
      1) ldc.i4.0
      5) call static CodeGenUtil::EnumerableToPinging(Seq<{i4,r8,str}>, ExecCtx, i4):Seq<{i4,r8,str}>
      1) ldarg.0 [Arr<obj>]
      1) ldc.i4.0
      5) ldelem [Func<{i4,r8,str},{i4,r8,str}>]
      1) ldarg.0 [Arr<obj>]
      1) ldc.i4.1
      5) ldelem [Func<{i4,r8,str},{i4}>]
      1) ldarg.0 [Arr<obj>]
      1) ldc.i4.2
      5) ldelem [Func<{i4,r8,str},Seq<{i4}>,{r8,str,Seq<{i4}>}>]
      1) ldarg.0 [Arr<obj>]
      1) ldc.i4.3
      5) ldelem [GroupByComparer<{i4,r8,str}>]
      5) call static Enumerable::GroupBy(Seq<{i4,r8,str}>, Func<{i4,r8,str},{i4,r8,str}>, Func<{i4,r8,str},{i4}>, Func<{i4,r8,str},Seq<{i4}>,{r8,str,Seq<{i4}>}>, IEqualityComparer<{i4,r8,str}>):Seq<{r8,str,Seq<{i4}>}>
      5) call static CodeGenUtil::EnumerableToCaching(Seq<{r8,str,Seq<{i4}>}>):Seq<{r8,str,Seq<{i4}>}>
  Label [1]:
      1) ret
  Total Size: 78

Func sig: (<ctx>:x, T8:{A:i4, B:r8, C:s}*) to {B:r8, C:s, X:{A:i4}*}*
Sequence: Seq<{r8,str,Seq<{i4}>}>
 0) { B: 1, C: X, 
      X: Sequence: Seq<{i4}>
         0) { A: 0 }
    }
 1) { B: NaN, C: X, 
      X: Sequence: Seq<{i4}>
         0) { A: 1 }
         1) { A: 2 }
    }
 2) { B: -0, C: Y, 
      X: Sequence: Seq<{i4}>
         0) { A: 3 }
         1) { A: 4 }
    }
*** Ctx ping count: 6
    [0](6): GroupBy(*1: T8, [key] B:*1.B, [key] C:*1.C, [auto] X:<auto>)
###
> GroupBy(T8, [key] BC: (B, C), X)
GroupBy(T8, [key] BC : (B, C), X) : {BC:(r8, s), X:{A:i4, B:r8, C:s}*}*
BndKind:GroupBy, Type:{BC:(r8, s), X:{A:i4, B:r8, C:s}*}*, Bnd:(GroupBy([scope:1] Global(T8), [key] BC:(GetField(Scope(1), B), GetField(Scope(1), C)):(r8, s), [auto] X:<auto>))
// (<ctx>, ∂.T8:{A:i4, B:r8, C:s}*) : {BC:(r8, s), X:{A:i4, B:r8, C:s}*}*
keySelector(Arr<obj>, {i4,r8,str}):(r8,str)
      5) newobj (r8,str)()
      1) dup
      1) ldarg.1 [{i4,r8,str}]
      5) ldfld {i4,r8,str}::_F1:r8
      5) stfld (r8,str)::_F0:r8
      1) dup
      1) ldarg.1 [{i4,r8,str}]
      5) ldfld {i4,r8,str}::_F2:str
      5) stfld (r8,str)::_F1:str
      1) ret
  Total Size: 30

resultSelector(Arr<obj>, (r8,str), Seq<{i4,r8,str}>):{(r8,str),Seq<{i4,r8,str}>}
      5) newobj {(r8,str),Seq<{i4,r8,str}>}()
      1) stloc.0 [{(r8,str),Seq<{i4,r8,str}>}]
      1) ldarg.1 [(r8,str)]
      5) brfalse [0]
      1) ldloc.0 [{(r8,str),Seq<{i4,r8,str}>}]
      1) dup
      1) dup
      5) ldfld {(r8,str),Seq<{i4,r8,str}>}::_B0:u1
      1) ldc.i4.1
      1) or
      5) stfld {(r8,str),Seq<{i4,r8,str}>}::_B0:u1
      1) ldarg.1 [(r8,str)]
      5) stfld {(r8,str),Seq<{i4,r8,str}>}::_F0:(r8,str)
  Label [0]:
      1) ldloc.0 [{(r8,str),Seq<{i4,r8,str}>}]
      1) ldarg.2 [Seq<{i4,r8,str}>]
      5) call static CodeGenUtil::EnumerableToCaching(Seq<{i4,r8,str}>):Seq<{i4,r8,str}>
      5) stfld {(r8,str),Seq<{i4,r8,str}>}::_F1:Seq<{i4,r8,str}>
      1) ldloc.0 [{(r8,str),Seq<{i4,r8,str}>}]
      1) dup
      1) ldarg.0 [Arr<obj>]
      1) ldc.i4.0
      5) ldelem [RecordRuntimeTypeInfo]
      5) stfld {}::_rrti:RecordRuntimeTypeInfo
      1) ret
  Total Size: 60

top(Arr<obj>, Arr<obj>):obj
      1) ldarg.1 [Arr<obj>]
      1) ldc.i4.0
      1) ldelem.ref
      5) call static CodeGenUtil::ToRef(obj):ExecCtx
      1) stloc.0 [ExecCtx]
      1) ldarg.1 [Arr<obj>]
      1) ldc.i4.1
      1) ldelem.ref
      5) call static CodeGenUtil::ToRef(obj):Seq<{i4,r8,str}>
      1) stloc.1 [Seq<{i4,r8,str}>]
      1) ldloc.1 [Seq<{i4,r8,str}>]
      1) dup
      5) brtrue [0]
      1) pop
      1) ldnull
      5) br [1]
  Label [0]:
      1) ldloc.0 [ExecCtx]
      1) ldc.i4.0
      5) call static CodeGenUtil::EnumerableToPinging(Seq<{i4,r8,str}>, ExecCtx, i4):Seq<{i4,r8,str}>
      1) ldarg.0 [Arr<obj>]
      1) ldc.i4.0
      5) ldelem [Func<{i4,r8,str},(r8,str)>]
      1) ldarg.0 [Arr<obj>]
      1) ldc.i4.1
      5) ldelem [Func<(r8,str),Seq<{i4,r8,str}>,{(r8,str),Seq<{i4,r8,str}>}>]
      5) call static Enumerable::GroupBy(Seq<{i4,r8,str}>, Func<{i4,r8,str},(r8,str)>, Func<(r8,str),Seq<{i4,r8,str}>,{(r8,str),Seq<{i4,r8,str}>}>):Seq<{(r8,str),Seq<{i4,r8,str}>}>
      5) call static CodeGenUtil::EnumerableToCaching(Seq<{(r8,str),Seq<{i4,r8,str}>}>):Seq<{(r8,str),Seq<{i4,r8,str}>}>
  Label [1]:
      1) ret
  Total Size: 64

Func sig: (<ctx>:x, T8:{A:i4, B:r8, C:s}*) to {BC:(r8, s), X:{A:i4, B:r8, C:s}*}*
Sequence: Seq<{(r8,str),Seq<{i4,r8,str}>}>
 0) { BC: (1, X), 
      X: Sequence: Seq<{i4,r8,str}>
         0) { A: 0, B: 1, C: X }
    }
 1) { BC: (NaN, X), 
      X: Sequence: Seq<{i4,r8,str}>
         0) { A: 1, B: NaN, C: X }
         1) { A: 2, B: NaN, C: X }
    }
 2) { BC: (-0, Y), 
      X: Sequence: Seq<{i4,r8,str}>
         0) { A: 3, B: -0, C: Y }
         1) { A: 4, B: 0, C: Y }
    }
*** Ctx ping count: 6
    [0](6): GroupBy(*1: T8, [key] BC:(*1.B, *1.C), [auto] X:<auto>)
###
> GroupBy(T8 ++ [{A:5i4, B:null, C:"Y"}], [key] B, [key] C, X)
GroupBy(T8 ++ [{ A : 5, B : null, C : "Y" }], [key] B, [key] C, X) : {B:r8?, C:s, X:{A:i4}*}*
BndKind:GroupBy, Type:{B:r8?, C:s, X:{A:i4}*}*, Bnd:(GroupBy([scope:1] SeqConcat(Ref<{A:i4, B:r8?, C:s}*>(Global(T8)), [{A:5:i4, B:null:r8?, C:str(Y)}]:{A:i4, B:r8?, C:s}*), [key] B:GetField(Scope(1), B), [key] C:GetField(Scope(1), C), [auto] X:<auto>))
// (<ctx>, ∂.T8:{A:i4, B:r8, C:s}*) : {B:r8?, C:s, X:{A:i4}*}*
elementSelector(Arr<obj>, {i4,r8,str}):{i4}
      5) newobj {i4}()
      1) dup
      1) ldc.i4.1
      5) stfld {i4}::_B0:u1
      1) stloc.0 [{i4}]
      1) ldloc.0 [{i4}]
      1) ldarg.1 [{i4,r8,str}]
      5) ldfld {i4,r8,str}::_F0:i4
      5) stfld {i4}::_F0:i4
      1) ldloc.0 [{i4}]
      1) dup
      1) ldarg.0 [Arr<obj>]
      1) ldc.i4.0
      5) ldelem [RecordRuntimeTypeInfo]
      5) stfld {}::_rrti:RecordRuntimeTypeInfo
      1) ret
  Total Size: 40

resultSelector(Arr<obj>, {i4,r8,str}, Seq<{i4}>):{r8,str,Seq<{i4}>}
      5) newobj {r8,str,Seq<{i4}>}()
      1) dup
      1) ldc.i4.2
      5) stfld {r8,str,Seq<{i4}>}::_B0:u1
      1) stloc.0 [{r8,str,Seq<{i4}>}]
      1) ldarg.1 [{i4,r8,str}]
      5) ldfld {i4,r8,str}::_B0:u1
      1) ldc.i4.2
      1) and
      5) brfalse [0]
      1) ldloc.0 [{r8,str,Seq<{i4}>}]
      1) dup
      1) dup
      5) ldfld {r8,str,Seq<{i4}>}::_B0:u1
      1) ldc.i4.1
      1) or
      5) stfld {r8,str,Seq<{i4}>}::_B0:u1
      1) ldarg.1 [{i4,r8,str}]
      5) ldfld {i4,r8,str}::_F1:r8
      5) stfld {r8,str,Seq<{i4}>}::_F0:r8
  Label [0]:
      1) ldloc.0 [{r8,str,Seq<{i4}>}]
      1) ldarg.1 [{i4,r8,str}]
      5) ldfld {i4,r8,str}::_F2:str
      5) stfld {r8,str,Seq<{i4}>}::_F1:str
      1) ldloc.0 [{r8,str,Seq<{i4}>}]
      1) ldarg.2 [Seq<{i4}>]
      5) call static CodeGenUtil::EnumerableToCaching(Seq<{i4}>):Seq<{i4}>
      5) stfld {r8,str,Seq<{i4}>}::_F2:Seq<{i4}>
      1) ldloc.0 [{r8,str,Seq<{i4}>}]
      1) dup
      1) ldarg.0 [Arr<obj>]
      1) ldc.i4.0
      5) ldelem [RecordRuntimeTypeInfo]
      5) stfld {}::_rrti:RecordRuntimeTypeInfo
      1) ret
  Total Size: 91

Equals(Arr<obj>, {i4,r8,str}, {i4,r8,str}):bool
      1) ldarg.1 [{i4,r8,str}]
      5) ldfld {i4,r8,str}::_B0:u1
      1) ldc.i4.2
      1) and
      1) ldarg.2 [{i4,r8,str}]
      5) ldfld {i4,r8,str}::_B0:u1
      1) ldc.i4.2
      1) and
      5) brtrue [2]
      5) brtrue [0]
      5) br [3]
  Label [2]:
      5) brfalse [0]
      1) ldarg.1 [{i4,r8,str}]
      5) ldfld {i4,r8,str}::_F1:r8
      1) ldarg.2 [{i4,r8,str}]
      5) ldfld {i4,r8,str}::_F1:r8
      5) call static CodeGenUtil::EqVal(r8, r8):bool
      5) brfalse [0]
  Label [3]:
      1) ldarg.1 [{i4,r8,str}]
      5) ldfld {i4,r8,str}::_F2:str
      1) ldarg.2 [{i4,r8,str}]
      5) ldfld {i4,r8,str}::_F2:str
      5) call static str::Equals(str, str):bool
      5) br [1]
  Label [0]:
      1) ldc.i4.0
  Label [1]:
      1) ret
  Total Size: 82

GetHashCode(Arr<obj>, {i4,r8,str}):i4
      1) ldarg.1 [{i4,r8,str}]
      1) dup
      5) ldfld {i4,r8,str}::_B0:u1
      1) ldc.i4.2
      1) and
      5) brfalse [0]
      5) ldfld {i4,r8,str}::_F1:r8
      5) newobj Opt<r8>(r8)
      5) br [1]
  Label [0]:
      1) pop
      5) call static CodeGenUtil::GetDefault():Opt<r8>
  Label [1]:
      1) ldarg.1 [{i4,r8,str}]
      5) ldfld {i4,r8,str}::_F2:str
      5) call static HashCode::Combine(Opt<r8>, str):i4
      1) ret
  Total Size: 47

top(Arr<obj>, Arr<obj>):obj
      1) ldarg.1 [Arr<obj>]
      1) ldc.i4.0
      1) ldelem.ref
      5) call static CodeGenUtil::ToRef(obj):ExecCtx
      1) stloc.0 [ExecCtx]
      1) ldarg.1 [Arr<obj>]
      1) ldc.i4.1
      1) ldelem.ref
      5) call static CodeGenUtil::ToRef(obj):Seq<{i4,r8,str}>
      1) stloc.1 [Seq<{i4,r8,str}>]
      1) ldloc.1 [Seq<{i4,r8,str}>]
      1) ldc.i4.1
      5) newarr [{i4,r8,str}]
      1) dup
      1) ldc.i4.0
      5) newobj {i4,r8,str}()
      1) dup
      1) ldc.i4.5
      5) stfld {i4,r8,str}::_B0:u1
      1) stloc.2 [{i4,r8,str}]
      1) ldloc.2 [{i4,r8,str}]
      1) ldc.i4.5
      5) stfld {i4,r8,str}::_F0:i4
      1) ldloc.2 [{i4,r8,str}]
      5) ldstr [Y]
      5) stfld {i4,r8,str}::_F2:str
      1) ldloc.2 [{i4,r8,str}]
      1) dup
      1) ldarg.0 [Arr<obj>]
      1) ldc.i4.0
      5) ldelem [RecordRuntimeTypeInfo]
      5) stfld {}::_rrti:RecordRuntimeTypeInfo
      5) stelem [{i4,r8,str}]
      5) call static CodeGenUtil::SeqConcat(Seq<{i4,r8,str}>, Seq<{i4,r8,str}>):Seq<{i4,r8,str}>
      5) call static CodeGenUtil::EnumerableToCaching(Seq<{i4,r8,str}>):Seq<{i4,r8,str}>
      1) ldloc.0 [ExecCtx]
      1) ldc.i4.0
      5) call static CodeGenUtil::EnumerableToPinging(Seq<{i4,r8,str}>, ExecCtx, i4):Seq<{i4,r8,str}>
      1) ldarg.0 [Arr<obj>]
      1) ldc.i4.1
      5) ldelem [Func<{i4,r8,str},{i4,r8,str}>]
      1) ldarg.0 [Arr<obj>]
      1) ldc.i4.2
      5) ldelem [Func<{i4,r8,str},{i4}>]
      1) ldarg.0 [Arr<obj>]
      1) ldc.i4.3
      5) ldelem [Func<{i4,r8,str},Seq<{i4}>,{r8,str,Seq<{i4}>}>]
      1) ldarg.0 [Arr<obj>]
      1) ldc.i4.4
      5) ldelem [GroupByComparer<{i4,r8,str}>]
      5) call static Enumerable::GroupBy(Seq<{i4,r8,str}>, Func<{i4,r8,str},{i4,r8,str}>, Func<{i4,r8,str},{i4}>, Func<{i4,r8,str},Seq<{i4}>,{r8,str,Seq<{i4}>}>, IEqualityComparer<{i4,r8,str}>):Seq<{r8,str,Seq<{i4}>}>
      5) call static CodeGenUtil::EnumerableToCaching(Seq<{r8,str,Seq<{i4}>}>):Seq<{r8,str,Seq<{i4}>}>
      1) ret
  Total Size: 133

Func sig: (<ctx>:x, T8:{A:i4, B:r8, C:s}*) to {B:r8?, C:s, X:{A:i4}*}*
Sequence: Seq<{r8,str,Seq<{i4}>}>
 0) { B: 1, C: X, 
      X: Sequence: Seq<{i4}>
         0) { A: 0 }
    }
 1) { B: NaN, C: X, 
      X: Sequence: Seq<{i4}>
         0) { A: 1 }
         1) { A: 2 }
    }
 2) { B: -0, C: Y, 
      X: Sequence: Seq<{i4}>
         0) { A: 3 }
         1) { A: 4 }
    }
 3) { B: <null>, C: Y, 
      X: Sequence: Seq<{i4}>
         0) { A: 5 }
    }
*** Ctx ping count: 7
    [0](7): GroupBy(*1: SeqConcat(Ref<{A:i4, B:r8?, C:s}*>(T8), [{A:5, B:null, C:"Y"}]), [key] B:*1.B, [key] C:*1.C, [auto] X:<auto>)
###
> GroupBy(T4, [key] B, X)
GroupBy(T4, [key] B, X) : {B:r4, X:{A:i4, C:s}*}*
BndKind:GroupBy, Type:{B:r4, X:{A:i4, C:s}*}*, Bnd:(GroupBy([scope:1] Global(T4), [key] B:GetField(Scope(1), B), [auto] X:<auto>))
// (<ctx>, ∂.T4:{A:i4, B:r4, C:s}*) : {B:r4, X:{A:i4, C:s}*}*
keySelector(Arr<obj>, {i4,r4,str}):r4
      1) ldarg.1 [{i4,r4,str}]
      5) ldfld {i4,r4,str}::_F1:r4
      1) ret
  Total Size: 7

elementSelector(Arr<obj>, {i4,r4,str}):{i4,str}
      5) newobj {i4,str}()
      1) dup
      1) ldc.i4.3
      5) stfld {i4,str}::_B0:u1
      1) stloc.0 [{i4,str}]
      1) ldloc.0 [{i4,str}]
      1) ldarg.1 [{i4,r4,str}]
      5) ldfld {i4,r4,str}::_F0:i4
      5) stfld {i4,str}::_F0:i4
      1) ldloc.0 [{i4,str}]
      1) ldarg.1 [{i4,r4,str}]
      5) ldfld {i4,r4,str}::_F2:str
      5) stfld {i4,str}::_F1:str
      1) ldloc.0 [{i4,str}]
      1) dup
      1) ldarg.0 [Arr<obj>]
      1) ldc.i4.0
      5) ldelem [RecordRuntimeTypeInfo]
      5) stfld {}::_rrti:RecordRuntimeTypeInfo
      1) ret
  Total Size: 52

resultSelector(Arr<obj>, r4, Seq<{i4,str}>):{r4,Seq<{i4,str}>}
      5) newobj {r4,Seq<{i4,str}>}()
      1) dup
      1) ldc.i4.1
      5) stfld {r4,Seq<{i4,str}>}::_B0:u1
      1) stloc.0 [{r4,Seq<{i4,str}>}]
      1) ldloc.0 [{r4,Seq<{i4,str}>}]
      1) ldarg.1 [r4]
      5) stfld {r4,Seq<{i4,str}>}::_F0:r4
      1) ldloc.0 [{r4,Seq<{i4,str}>}]
      1) ldarg.2 [Seq<{i4,str}>]
      5) call static CodeGenUtil::EnumerableToCaching(Seq<{i4,str}>):Seq<{i4,str}>
      5) stfld {r4,Seq<{i4,str}>}::_F1:Seq<{i4,str}>
      1) ldloc.0 [{r4,Seq<{i4,str}>}]
      1) dup
      1) ldarg.0 [Arr<obj>]
      1) ldc.i4.0
      5) ldelem [RecordRuntimeTypeInfo]
      5) stfld {}::_rrti:RecordRuntimeTypeInfo
      1) ret
  Total Size: 47

top(Arr<obj>, Arr<obj>):obj
      1) ldarg.1 [Arr<obj>]
      1) ldc.i4.0
      1) ldelem.ref
      5) call static CodeGenUtil::ToRef(obj):ExecCtx
      1) stloc.0 [ExecCtx]
      1) ldarg.1 [Arr<obj>]
      1) ldc.i4.1
      1) ldelem.ref
      5) call static CodeGenUtil::ToRef(obj):Seq<{i4,r4,str}>
      1) stloc.1 [Seq<{i4,r4,str}>]
      1) ldloc.1 [Seq<{i4,r4,str}>]
      1) dup
      5) brtrue [0]
      1) pop
      1) ldnull
      5) br [1]
  Label [0]:
      1) ldloc.0 [ExecCtx]
      1) ldc.i4.0
      5) call static CodeGenUtil::EnumerableToPinging(Seq<{i4,r4,str}>, ExecCtx, i4):Seq<{i4,r4,str}>
      1) ldarg.0 [Arr<obj>]
      1) ldc.i4.0
      5) ldelem [Func<{i4,r4,str},r4>]
      1) ldarg.0 [Arr<obj>]
      1) ldc.i4.1
      5) ldelem [Func<{i4,r4,str},{i4,str}>]
      1) ldarg.0 [Arr<obj>]
      1) ldc.i4.2
      5) ldelem [Func<r4,Seq<{i4,str}>,{r4,Seq<{i4,str}>}>]
      5) call static Enumerable::GroupBy(Seq<{i4,r4,str}>, Func<{i4,r4,str},r4>, Func<{i4,r4,str},{i4,str}>, Func<r4,Seq<{i4,str}>,{r4,Seq<{i4,str}>}>):Seq<{r4,Seq<{i4,str}>}>
      5) call static CodeGenUtil::EnumerableToCaching(Seq<{r4,Seq<{i4,str}>}>):Seq<{r4,Seq<{i4,str}>}>
  Label [1]:
      1) ret
  Total Size: 71

Func sig: (<ctx>:x, T4:{A:i4, B:r4, C:s}*) to {B:r4, X:{A:i4, C:s}*}*
Sequence: Seq<{r4,Seq<{i4,str}>}>
 0) { B: 1, 
      X: Sequence: Seq<{i4,str}>
         0) { A: 0, C: X }
    }
 1) { B: NaN, 
      X: Sequence: Seq<{i4,str}>
         0) { A: 1, C: X }
         1) { A: 2, C: X }
    }
 2) { B: -0, 
      X: Sequence: Seq<{i4,str}>
         0) { A: 3, C: Y }
         1) { A: 4, C: Y }
    }
*** Ctx ping count: 6
    [0](6): GroupBy(*1: T4, [key] B:*1.B, [auto] X:<auto>)
###
> GroupBy(T4, [key] C, X)
GroupBy(T4, [key] C, X) : {C:s, X:{A:i4, B:r4}*}*
BndKind:GroupBy, Type:{C:s, X:{A:i4, B:r4}*}*, Bnd:(GroupBy([scope:1] Global(T4), [key] C:GetField(Scope(1), C), [auto] X:<auto>))
// (<ctx>, ∂.T4:{A:i4, B:r4, C:s}*) : {C:s, X:{A:i4, B:r4}*}*
keySelector(Arr<obj>, {i4,r4,str}):str
      1) ldarg.1 [{i4,r4,str}]
      5) ldfld {i4,r4,str}::_F2:str
      1) ret
  Total Size: 7

elementSelector(Arr<obj>, {i4,r4,str}):{i4,r4}
      5) newobj {i4,r4}()
      1) dup
      1) ldc.i4.3
      5) stfld {i4,r4}::_B0:u1
      1) stloc.0 [{i4,r4}]
      1) ldloc.0 [{i4,r4}]
      1) ldarg.1 [{i4,r4,str}]
      5) ldfld {i4,r4,str}::_F0:i4
      5) stfld {i4,r4}::_F0:i4
      1) ldloc.0 [{i4,r4}]
      1) ldarg.1 [{i4,r4,str}]
      5) ldfld {i4,r4,str}::_F1:r4
      5) stfld {i4,r4}::_F1:r4
      1) ldloc.0 [{i4,r4}]
      1) dup
      1) ldarg.0 [Arr<obj>]
      1) ldc.i4.0
      5) ldelem [RecordRuntimeTypeInfo]
      5) stfld {}::_rrti:RecordRuntimeTypeInfo
      1) ret
  Total Size: 52

resultSelector(Arr<obj>, str, Seq<{i4,r4}>):{str,Seq<{i4,r4}>}
      5) newobj {str,Seq<{i4,r4}>}()
      1) dup
      1) ldc.i4.1
      5) stfld {str,Seq<{i4,r4}>}::_B0:u1
      1) stloc.0 [{str,Seq<{i4,r4}>}]
      1) ldloc.0 [{str,Seq<{i4,r4}>}]
      1) ldarg.1 [str]
      5) stfld {str,Seq<{i4,r4}>}::_F0:str
      1) ldloc.0 [{str,Seq<{i4,r4}>}]
      1) ldarg.2 [Seq<{i4,r4}>]
      5) call static CodeGenUtil::EnumerableToCaching(Seq<{i4,r4}>):Seq<{i4,r4}>
      5) stfld {str,Seq<{i4,r4}>}::_F1:Seq<{i4,r4}>
      1) ldloc.0 [{str,Seq<{i4,r4}>}]
      1) dup
      1) ldarg.0 [Arr<obj>]
      1) ldc.i4.0
      5) ldelem [RecordRuntimeTypeInfo]
      5) stfld {}::_rrti:RecordRuntimeTypeInfo
      1) ret
  Total Size: 47

top(Arr<obj>, Arr<obj>):obj
      1) ldarg.1 [Arr<obj>]
      1) ldc.i4.0
      1) ldelem.ref
      5) call static CodeGenUtil::ToRef(obj):ExecCtx
      1) stloc.0 [ExecCtx]
      1) ldarg.1 [Arr<obj>]
      1) ldc.i4.1
      1) ldelem.ref
      5) call static CodeGenUtil::ToRef(obj):Seq<{i4,r4,str}>
      1) stloc.1 [Seq<{i4,r4,str}>]
      1) ldloc.1 [Seq<{i4,r4,str}>]
      1) dup
      5) brtrue [0]
      1) pop
      1) ldnull
      5) br [1]
  Label [0]:
      1) ldloc.0 [ExecCtx]
      1) ldc.i4.0
      5) call static CodeGenUtil::EnumerableToPinging(Seq<{i4,r4,str}>, ExecCtx, i4):Seq<{i4,r4,str}>
      1) ldarg.0 [Arr<obj>]
      1) ldc.i4.0
      5) ldelem [Func<{i4,r4,str},str>]
      1) ldarg.0 [Arr<obj>]
      1) ldc.i4.1
      5) ldelem [Func<{i4,r4,str},{i4,r4}>]
      1) ldarg.0 [Arr<obj>]
      1) ldc.i4.2
      5) ldelem [Func<str,Seq<{i4,r4}>,{str,Seq<{i4,r4}>}>]
      5) call static Enumerable::GroupBy(Seq<{i4,r4,str}>, Func<{i4,r4,str},str>, Func<{i4,r4,str},{i4,r4}>, Func<str,Seq<{i4,r4}>,{str,Seq<{i4,r4}>}>):Seq<{str,Seq<{i4,r4}>}>
      5) call static CodeGenUtil::EnumerableToCaching(Seq<{str,Seq<{i4,r4}>}>):Seq<{str,Seq<{i4,r4}>}>
  Label [1]:
      1) ret
  Total Size: 71

Func sig: (<ctx>:x, T4:{A:i4, B:r4, C:s}*) to {C:s, X:{A:i4, B:r4}*}*
Sequence: Seq<{str,Seq<{i4,r4}>}>
 0) { C: X, 
      X: Sequence: Seq<{i4,r4}>
         0) { A: 0, B: 1 }
         1) { A: 1, B: NaN }
         2) { A: 2, B: NaN }
    }
 1) { C: Y, 
      X: Sequence: Seq<{i4,r4}>
         0) { A: 3, B: -0 }
         1) { A: 4, B: 0 }
    }
*** Ctx ping count: 6
    [0](6): GroupBy(*1: T4, [key] C:*1.C, [auto] X:<auto>)
###
> GroupBy(T4, [key] B, [key] C, X)
GroupBy(T4, [key] B, [key] C, X) : {B:r4, C:s, X:{A:i4}*}*
BndKind:GroupBy, Type:{B:r4, C:s, X:{A:i4}*}*, Bnd:(GroupBy([scope:1] Global(T4), [key] B:GetField(Scope(1), B), [key] C:GetField(Scope(1), C), [auto] X:<auto>))
// (<ctx>, ∂.T4:{A:i4, B:r4, C:s}*) : {B:r4, C:s, X:{A:i4}*}*
elementSelector(Arr<obj>, {i4,r4,str}):{i4}
      5) newobj {i4}()
      1) dup
      1) ldc.i4.1
      5) stfld {i4}::_B0:u1
      1) stloc.0 [{i4}]
      1) ldloc.0 [{i4}]
      1) ldarg.1 [{i4,r4,str}]
      5) ldfld {i4,r4,str}::_F0:i4
      5) stfld {i4}::_F0:i4
      1) ldloc.0 [{i4}]
      1) dup
      1) ldarg.0 [Arr<obj>]
      1) ldc.i4.0
      5) ldelem [RecordRuntimeTypeInfo]
      5) stfld {}::_rrti:RecordRuntimeTypeInfo
      1) ret
  Total Size: 40

resultSelector(Arr<obj>, {i4,r4,str}, Seq<{i4}>):{r4,str,Seq<{i4}>}
      5) newobj {r4,str,Seq<{i4}>}()
      1) dup
      1) ldc.i4.3
      5) stfld {r4,str,Seq<{i4}>}::_B0:u1
      1) stloc.0 [{r4,str,Seq<{i4}>}]
      1) ldloc.0 [{r4,str,Seq<{i4}>}]
      1) ldarg.1 [{i4,r4,str}]
      5) ldfld {i4,r4,str}::_F1:r4
      5) stfld {r4,str,Seq<{i4}>}::_F0:r4
      1) ldloc.0 [{r4,str,Seq<{i4}>}]
      1) ldarg.1 [{i4,r4,str}]
      5) ldfld {i4,r4,str}::_F2:str
      5) stfld {r4,str,Seq<{i4}>}::_F1:str
      1) ldloc.0 [{r4,str,Seq<{i4}>}]
      1) ldarg.2 [Seq<{i4}>]
      5) call static CodeGenUtil::EnumerableToCaching(Seq<{i4}>):Seq<{i4}>
      5) stfld {r4,str,Seq<{i4}>}::_F2:Seq<{i4}>
      1) ldloc.0 [{r4,str,Seq<{i4}>}]
      1) dup
      1) ldarg.0 [Arr<obj>]
      1) ldc.i4.0
      5) ldelem [RecordRuntimeTypeInfo]
      5) stfld {}::_rrti:RecordRuntimeTypeInfo
      1) ret
  Total Size: 64

Equals(Arr<obj>, {i4,r4,str}, {i4,r4,str}):bool
      1) ldarg.1 [{i4,r4,str}]
      5) ldfld {i4,r4,str}::_F1:r4
      1) ldarg.2 [{i4,r4,str}]
      5) ldfld {i4,r4,str}::_F1:r4
      5) call static CodeGenUtil::EqVal(r4, r4):bool
      5) brfalse [0]
      1) ldarg.1 [{i4,r4,str}]
      5) ldfld {i4,r4,str}::_F2:str
      1) ldarg.2 [{i4,r4,str}]
      5) ldfld {i4,r4,str}::_F2:str
      5) call static str::Equals(str, str):bool
      5) br [1]
  Label [0]:
      1) ldc.i4.0
  Label [1]:
      1) ret
  Total Size: 46

GetHashCode(Arr<obj>, {i4,r4,str}):i4
      1) ldarg.1 [{i4,r4,str}]
      5) ldfld {i4,r4,str}::_F1:r4
      1) ldarg.1 [{i4,r4,str}]
      5) ldfld {i4,r4,str}::_F2:str
      5) call static HashCode::Combine(r4, str):i4
      1) ret
  Total Size: 18

top(Arr<obj>, Arr<obj>):obj
      1) ldarg.1 [Arr<obj>]
      1) ldc.i4.0
      1) ldelem.ref
      5) call static CodeGenUtil::ToRef(obj):ExecCtx
      1) stloc.0 [ExecCtx]
      1) ldarg.1 [Arr<obj>]
      1) ldc.i4.1
      1) ldelem.ref
      5) call static CodeGenUtil::ToRef(obj):Seq<{i4,r4,str}>
      1) stloc.1 [Seq<{i4,r4,str}>]
      1) ldloc.1 [Seq<{i4,r4,str}>]
      1) dup
      5) brtrue [0]
      1) pop
      1) ldnull
      5) br [1]
  Label [0]:
      1) ldloc.0 [ExecCtx]
      1) ldc.i4.0
      5) call static CodeGenUtil::EnumerableToPinging(Seq<{i4,r4,str}>, ExecCtx, i4):Seq<{i4,r4,str}>
      1) ldarg.0 [Arr<obj>]
      1) ldc.i4.0
      5) ldelem [Func<{i4,r4,str},{i4,r4,str}>]
      1) ldarg.0 [Arr<obj>]
      1) ldc.i4.1
      5) ldelem [Func<{i4,r4,str},{i4}>]
      1) ldarg.0 [Arr<obj>]
      1) ldc.i4.2
      5) ldelem [Func<{i4,r4,str},Seq<{i4}>,{r4,str,Seq<{i4}>}>]
      1) ldarg.0 [Arr<obj>]
      1) ldc.i4.3
      5) ldelem [GroupByComparer<{i4,r4,str}>]
      5) call static Enumerable::GroupBy(Seq<{i4,r4,str}>, Func<{i4,r4,str},{i4,r4,str}>, Func<{i4,r4,str},{i4}>, Func<{i4,r4,str},Seq<{i4}>,{r4,str,Seq<{i4}>}>, IEqualityComparer<{i4,r4,str}>):Seq<{r4,str,Seq<{i4}>}>
      5) call static CodeGenUtil::EnumerableToCaching(Seq<{r4,str,Seq<{i4}>}>):Seq<{r4,str,Seq<{i4}>}>
  Label [1]:
      1) ret
  Total Size: 78

Func sig: (<ctx>:x, T4:{A:i4, B:r4, C:s}*) to {B:r4, C:s, X:{A:i4}*}*
Sequence: Seq<{r4,str,Seq<{i4}>}>
 0) { B: 1, C: X, 
      X: Sequence: Seq<{i4}>
         0) { A: 0 }
    }
 1) { B: NaN, C: X, 
      X: Sequence: Seq<{i4}>
         0) { A: 1 }
         1) { A: 2 }
    }
 2) { B: -0, C: Y, 
      X: Sequence: Seq<{i4}>
         0) { A: 3 }
         1) { A: 4 }
    }
*** Ctx ping count: 6
    [0](6): GroupBy(*1: T4, [key] B:*1.B, [key] C:*1.C, [auto] X:<auto>)
###
> GroupBy(T4, [key] BC: (B, C), X)
GroupBy(T4, [key] BC : (B, C), X) : {BC:(r4, s), X:{A:i4, B:r4, C:s}*}*
BndKind:GroupBy, Type:{BC:(r4, s), X:{A:i4, B:r4, C:s}*}*, Bnd:(GroupBy([scope:1] Global(T4), [key] BC:(GetField(Scope(1), B), GetField(Scope(1), C)):(r4, s), [auto] X:<auto>))
// (<ctx>, ∂.T4:{A:i4, B:r4, C:s}*) : {BC:(r4, s), X:{A:i4, B:r4, C:s}*}*
keySelector(Arr<obj>, {i4,r4,str}):(r4,str)
      5) newobj (r4,str)()
      1) dup
      1) ldarg.1 [{i4,r4,str}]
      5) ldfld {i4,r4,str}::_F1:r4
      5) stfld (r4,str)::_F0:r4
      1) dup
      1) ldarg.1 [{i4,r4,str}]
      5) ldfld {i4,r4,str}::_F2:str
      5) stfld (r4,str)::_F1:str
      1) ret
  Total Size: 30

resultSelector(Arr<obj>, (r4,str), Seq<{i4,r4,str}>):{(r4,str),Seq<{i4,r4,str}>}
      5) newobj {(r4,str),Seq<{i4,r4,str}>}()
      1) stloc.0 [{(r4,str),Seq<{i4,r4,str}>}]
      1) ldarg.1 [(r4,str)]
      5) brfalse [0]
      1) ldloc.0 [{(r4,str),Seq<{i4,r4,str}>}]
      1) dup
      1) dup
      5) ldfld {(r4,str),Seq<{i4,r4,str}>}::_B0:u1
      1) ldc.i4.1
      1) or
      5) stfld {(r4,str),Seq<{i4,r4,str}>}::_B0:u1
      1) ldarg.1 [(r4,str)]
      5) stfld {(r4,str),Seq<{i4,r4,str}>}::_F0:(r4,str)
  Label [0]:
      1) ldloc.0 [{(r4,str),Seq<{i4,r4,str}>}]
      1) ldarg.2 [Seq<{i4,r4,str}>]
      5) call static CodeGenUtil::EnumerableToCaching(Seq<{i4,r4,str}>):Seq<{i4,r4,str}>
      5) stfld {(r4,str),Seq<{i4,r4,str}>}::_F1:Seq<{i4,r4,str}>
      1) ldloc.0 [{(r4,str),Seq<{i4,r4,str}>}]
      1) dup
      1) ldarg.0 [Arr<obj>]
      1) ldc.i4.0
      5) ldelem [RecordRuntimeTypeInfo]
      5) stfld {}::_rrti:RecordRuntimeTypeInfo
      1) ret
  Total Size: 60

top(Arr<obj>, Arr<obj>):obj
      1) ldarg.1 [Arr<obj>]
      1) ldc.i4.0
      1) ldelem.ref
      5) call static CodeGenUtil::ToRef(obj):ExecCtx
      1) stloc.0 [ExecCtx]
      1) ldarg.1 [Arr<obj>]
      1) ldc.i4.1
      1) ldelem.ref
      5) call static CodeGenUtil::ToRef(obj):Seq<{i4,r4,str}>
      1) stloc.1 [Seq<{i4,r4,str}>]
      1) ldloc.1 [Seq<{i4,r4,str}>]
      1) dup
      5) brtrue [0]
      1) pop
      1) ldnull
      5) br [1]
  Label [0]:
      1) ldloc.0 [ExecCtx]
      1) ldc.i4.0
      5) call static CodeGenUtil::EnumerableToPinging(Seq<{i4,r4,str}>, ExecCtx, i4):Seq<{i4,r4,str}>
      1) ldarg.0 [Arr<obj>]
      1) ldc.i4.0
      5) ldelem [Func<{i4,r4,str},(r4,str)>]
      1) ldarg.0 [Arr<obj>]
      1) ldc.i4.1
      5) ldelem [Func<(r4,str),Seq<{i4,r4,str}>,{(r4,str),Seq<{i4,r4,str}>}>]
      5) call static Enumerable::GroupBy(Seq<{i4,r4,str}>, Func<{i4,r4,str},(r4,str)>, Func<(r4,str),Seq<{i4,r4,str}>,{(r4,str),Seq<{i4,r4,str}>}>):Seq<{(r4,str),Seq<{i4,r4,str}>}>
      5) call static CodeGenUtil::EnumerableToCaching(Seq<{(r4,str),Seq<{i4,r4,str}>}>):Seq<{(r4,str),Seq<{i4,r4,str}>}>
  Label [1]:
      1) ret
  Total Size: 64

Func sig: (<ctx>:x, T4:{A:i4, B:r4, C:s}*) to {BC:(r4, s), X:{A:i4, B:r4, C:s}*}*
Sequence: Seq<{(r4,str),Seq<{i4,r4,str}>}>
 0) { BC: (1, X), 
      X: Sequence: Seq<{i4,r4,str}>
         0) { A: 0, B: 1, C: X }
    }
 1) { BC: (NaN, X), 
      X: Sequence: Seq<{i4,r4,str}>
         0) { A: 1, B: NaN, C: X }
         1) { A: 2, B: NaN, C: X }
    }
 2) { BC: (-0, Y), 
      X: Sequence: Seq<{i4,r4,str}>
         0) { A: 3, B: -0, C: Y }
         1) { A: 4, B: 0, C: Y }
    }
*** Ctx ping count: 6
    [0](6): GroupBy(*1: T4, [key] BC:(*1.B, *1.C), [auto] X:<auto>)
###
> GroupBy(T4 ++ [{A:5i4, B:null, C:"Y"}], [key] B, [key] C, X)
GroupBy(T4 ++ [{ A : 5, B : null, C : "Y" }], [key] B, [key] C, X) : {B:r4?, C:s, X:{A:i4}*}*
BndKind:GroupBy, Type:{B:r4?, C:s, X:{A:i4}*}*, Bnd:(GroupBy([scope:1] SeqConcat(Ref<{A:i4, B:r4?, C:s}*>(Global(T4)), [{A:5:i4, B:null:r4?, C:str(Y)}]:{A:i4, B:r4?, C:s}*), [key] B:GetField(Scope(1), B), [key] C:GetField(Scope(1), C), [auto] X:<auto>))
// (<ctx>, ∂.T4:{A:i4, B:r4, C:s}*) : {B:r4?, C:s, X:{A:i4}*}*
elementSelector(Arr<obj>, {i4,r4,str}):{i4}
      5) newobj {i4}()
      1) dup
      1) ldc.i4.1
      5) stfld {i4}::_B0:u1
      1) stloc.0 [{i4}]
      1) ldloc.0 [{i4}]
      1) ldarg.1 [{i4,r4,str}]
      5) ldfld {i4,r4,str}::_F0:i4
      5) stfld {i4}::_F0:i4
      1) ldloc.0 [{i4}]
      1) dup
      1) ldarg.0 [Arr<obj>]
      1) ldc.i4.0
      5) ldelem [RecordRuntimeTypeInfo]
      5) stfld {}::_rrti:RecordRuntimeTypeInfo
      1) ret
  Total Size: 40

resultSelector(Arr<obj>, {i4,r4,str}, Seq<{i4}>):{r4,str,Seq<{i4}>}
      5) newobj {r4,str,Seq<{i4}>}()
      1) dup
      1) ldc.i4.2
      5) stfld {r4,str,Seq<{i4}>}::_B0:u1
      1) stloc.0 [{r4,str,Seq<{i4}>}]
      1) ldarg.1 [{i4,r4,str}]
      5) ldfld {i4,r4,str}::_B0:u1
      1) ldc.i4.2
      1) and
      5) brfalse [0]
      1) ldloc.0 [{r4,str,Seq<{i4}>}]
      1) dup
      1) dup
      5) ldfld {r4,str,Seq<{i4}>}::_B0:u1
      1) ldc.i4.1
      1) or
      5) stfld {r4,str,Seq<{i4}>}::_B0:u1
      1) ldarg.1 [{i4,r4,str}]
      5) ldfld {i4,r4,str}::_F1:r4
      5) stfld {r4,str,Seq<{i4}>}::_F0:r4
  Label [0]:
      1) ldloc.0 [{r4,str,Seq<{i4}>}]
      1) ldarg.1 [{i4,r4,str}]
      5) ldfld {i4,r4,str}::_F2:str
      5) stfld {r4,str,Seq<{i4}>}::_F1:str
      1) ldloc.0 [{r4,str,Seq<{i4}>}]
      1) ldarg.2 [Seq<{i4}>]
      5) call static CodeGenUtil::EnumerableToCaching(Seq<{i4}>):Seq<{i4}>
      5) stfld {r4,str,Seq<{i4}>}::_F2:Seq<{i4}>
      1) ldloc.0 [{r4,str,Seq<{i4}>}]
      1) dup
      1) ldarg.0 [Arr<obj>]
      1) ldc.i4.0
      5) ldelem [RecordRuntimeTypeInfo]
      5) stfld {}::_rrti:RecordRuntimeTypeInfo
      1) ret
  Total Size: 91

Equals(Arr<obj>, {i4,r4,str}, {i4,r4,str}):bool
      1) ldarg.1 [{i4,r4,str}]
      5) ldfld {i4,r4,str}::_B0:u1
      1) ldc.i4.2
      1) and
      1) ldarg.2 [{i4,r4,str}]
      5) ldfld {i4,r4,str}::_B0:u1
      1) ldc.i4.2
      1) and
      5) brtrue [2]
      5) brtrue [0]
      5) br [3]
  Label [2]:
      5) brfalse [0]
      1) ldarg.1 [{i4,r4,str}]
      5) ldfld {i4,r4,str}::_F1:r4
      1) ldarg.2 [{i4,r4,str}]
      5) ldfld {i4,r4,str}::_F1:r4
      5) call static CodeGenUtil::EqVal(r4, r4):bool
      5) brfalse [0]
  Label [3]:
      1) ldarg.1 [{i4,r4,str}]
      5) ldfld {i4,r4,str}::_F2:str
      1) ldarg.2 [{i4,r4,str}]
      5) ldfld {i4,r4,str}::_F2:str
      5) call static str::Equals(str, str):bool
      5) br [1]
  Label [0]:
      1) ldc.i4.0
  Label [1]:
      1) ret
  Total Size: 82

GetHashCode(Arr<obj>, {i4,r4,str}):i4
      1) ldarg.1 [{i4,r4,str}]
      1) dup
      5) ldfld {i4,r4,str}::_B0:u1
      1) ldc.i4.2
      1) and
      5) brfalse [0]
      5) ldfld {i4,r4,str}::_F1:r4
      5) newobj Opt<r4>(r4)
      5) br [1]
  Label [0]:
      1) pop
      5) call static CodeGenUtil::GetDefault():Opt<r4>
  Label [1]:
      1) ldarg.1 [{i4,r4,str}]
      5) ldfld {i4,r4,str}::_F2:str
      5) call static HashCode::Combine(Opt<r4>, str):i4
      1) ret
  Total Size: 47

top(Arr<obj>, Arr<obj>):obj
      1) ldarg.1 [Arr<obj>]
      1) ldc.i4.0
      1) ldelem.ref
      5) call static CodeGenUtil::ToRef(obj):ExecCtx
      1) stloc.0 [ExecCtx]
      1) ldarg.1 [Arr<obj>]
      1) ldc.i4.1
      1) ldelem.ref
      5) call static CodeGenUtil::ToRef(obj):Seq<{i4,r4,str}>
      1) stloc.1 [Seq<{i4,r4,str}>]
      1) ldloc.1 [Seq<{i4,r4,str}>]
      1) ldc.i4.1
      5) newarr [{i4,r4,str}]
      1) dup
      1) ldc.i4.0
      5) newobj {i4,r4,str}()
      1) dup
      1) ldc.i4.5
      5) stfld {i4,r4,str}::_B0:u1
      1) stloc.2 [{i4,r4,str}]
      1) ldloc.2 [{i4,r4,str}]
      1) ldc.i4.5
      5) stfld {i4,r4,str}::_F0:i4
      1) ldloc.2 [{i4,r4,str}]
      5) ldstr [Y]
      5) stfld {i4,r4,str}::_F2:str
      1) ldloc.2 [{i4,r4,str}]
      1) dup
      1) ldarg.0 [Arr<obj>]
      1) ldc.i4.0
      5) ldelem [RecordRuntimeTypeInfo]
      5) stfld {}::_rrti:RecordRuntimeTypeInfo
      5) stelem [{i4,r4,str}]
      5) call static CodeGenUtil::SeqConcat(Seq<{i4,r4,str}>, Seq<{i4,r4,str}>):Seq<{i4,r4,str}>
      5) call static CodeGenUtil::EnumerableToCaching(Seq<{i4,r4,str}>):Seq<{i4,r4,str}>
      1) ldloc.0 [ExecCtx]
      1) ldc.i4.0
      5) call static CodeGenUtil::EnumerableToPinging(Seq<{i4,r4,str}>, ExecCtx, i4):Seq<{i4,r4,str}>
      1) ldarg.0 [Arr<obj>]
      1) ldc.i4.1
      5) ldelem [Func<{i4,r4,str},{i4,r4,str}>]
      1) ldarg.0 [Arr<obj>]
      1) ldc.i4.2
      5) ldelem [Func<{i4,r4,str},{i4}>]
      1) ldarg.0 [Arr<obj>]
      1) ldc.i4.3
      5) ldelem [Func<{i4,r4,str},Seq<{i4}>,{r4,str,Seq<{i4}>}>]
      1) ldarg.0 [Arr<obj>]
      1) ldc.i4.4
      5) ldelem [GroupByComparer<{i4,r4,str}>]
      5) call static Enumerable::GroupBy(Seq<{i4,r4,str}>, Func<{i4,r4,str},{i4,r4,str}>, Func<{i4,r4,str},{i4}>, Func<{i4,r4,str},Seq<{i4}>,{r4,str,Seq<{i4}>}>, IEqualityComparer<{i4,r4,str}>):Seq<{r4,str,Seq<{i4}>}>
      5) call static CodeGenUtil::EnumerableToCaching(Seq<{r4,str,Seq<{i4}>}>):Seq<{r4,str,Seq<{i4}>}>
      1) ret
  Total Size: 133

Func sig: (<ctx>:x, T4:{A:i4, B:r4, C:s}*) to {B:r4?, C:s, X:{A:i4}*}*
Sequence: Seq<{r4,str,Seq<{i4}>}>
 0) { B: 1, C: X, 
      X: Sequence: Seq<{i4}>
         0) { A: 0 }
    }
 1) { B: NaN, C: X, 
      X: Sequence: Seq<{i4}>
         0) { A: 1 }
         1) { A: 2 }
    }
 2) { B: -0, C: Y, 
      X: Sequence: Seq<{i4}>
         0) { A: 3 }
         1) { A: 4 }
    }
 3) { B: <null>, C: Y, 
      X: Sequence: Seq<{i4}>
         0) { A: 5 }
    }
*** Ctx ping count: 7
    [0](7): GroupBy(*1: SeqConcat(Ref<{A:i4, B:r4?, C:s}*>(T4), [{A:5, B:null, C:"Y"}]), [key] B:*1.B, [key] C:*1.C, [auto] X:<auto>)
###
> GroupBy(TU, C, X)
GroupBy(TU, C, X) : {C:U<Image>, X:{A:i8, B:i8, D:i8}*}*
BndKind:GroupBy, Type:{C:U<Image>, X:{A:i8, B:i8, D:i8}*}*, Bnd:(GroupBy([scope:1] Global(TU), [key] C:GetField(Scope(1), C), [auto] X:<auto>))
// (<ctx>, ∂.TU:{A:i8, B:i8, C:U<Image>, D:i8}*) : {C:U<Image>, X:{A:i8, B:i8, D:i8}*}*
keySelector(Arr<obj>, {i8,i8,Link,i8}):Link
      1) ldarg.1 [{i8,i8,Link,i8}]
      5) ldfld {i8,i8,Link,i8}::_F2:Link
      1) ret
  Total Size: 7

elementSelector(Arr<obj>, {i8,i8,Link,i8}):{i8,i8,i8}
      5) newobj {i8,i8,i8}()
      1) dup
      1) ldc.i4.7
      5) stfld {i8,i8,i8}::_B0:u1
      1) stloc.0 [{i8,i8,i8}]
      1) ldloc.0 [{i8,i8,i8}]
      1) ldarg.1 [{i8,i8,Link,i8}]
      5) ldfld {i8,i8,Link,i8}::_F0:i8
      5) stfld {i8,i8,i8}::_F0:i8
      1) ldloc.0 [{i8,i8,i8}]
      1) ldarg.1 [{i8,i8,Link,i8}]
      5) ldfld {i8,i8,Link,i8}::_F1:i8
      5) stfld {i8,i8,i8}::_F1:i8
      1) ldloc.0 [{i8,i8,i8}]
      1) ldarg.1 [{i8,i8,Link,i8}]
      5) ldfld {i8,i8,Link,i8}::_F3:i8
      5) stfld {i8,i8,i8}::_F2:i8
      1) ldloc.0 [{i8,i8,i8}]
      1) dup
      1) ldarg.0 [Arr<obj>]
      1) ldc.i4.0
      5) ldelem [RecordRuntimeTypeInfo]
      5) stfld {}::_rrti:RecordRuntimeTypeInfo
      1) ret
  Total Size: 64

resultSelector(Arr<obj>, Link, Seq<{i8,i8,i8}>):{Link,Seq<{i8,i8,i8}>}
      5) newobj {Link,Seq<{i8,i8,i8}>}()
      1) dup
      1) ldc.i4.1
      5) stfld {Link,Seq<{i8,i8,i8}>}::_B0:u1
      1) stloc.0 [{Link,Seq<{i8,i8,i8}>}]
      1) ldloc.0 [{Link,Seq<{i8,i8,i8}>}]
      1) ldarg.1 [Link]
      5) stfld {Link,Seq<{i8,i8,i8}>}::_F0:Link
      1) ldloc.0 [{Link,Seq<{i8,i8,i8}>}]
      1) ldarg.2 [Seq<{i8,i8,i8}>]
      5) call static CodeGenUtil::EnumerableToCaching(Seq<{i8,i8,i8}>):Seq<{i8,i8,i8}>
      5) stfld {Link,Seq<{i8,i8,i8}>}::_F1:Seq<{i8,i8,i8}>
      1) ldloc.0 [{Link,Seq<{i8,i8,i8}>}]
      1) dup
      1) ldarg.0 [Arr<obj>]
      1) ldc.i4.0
      5) ldelem [RecordRuntimeTypeInfo]
      5) stfld {}::_rrti:RecordRuntimeTypeInfo
      1) ret
  Total Size: 47

top(Arr<obj>, Arr<obj>):obj
      1) ldarg.1 [Arr<obj>]
      1) ldc.i4.0
      1) ldelem.ref
      5) call static CodeGenUtil::ToRef(obj):ExecCtx
      1) stloc.0 [ExecCtx]
      1) ldarg.1 [Arr<obj>]
      1) ldc.i4.1
      1) ldelem.ref
      5) call static CodeGenUtil::ToRef(obj):Seq<{i8,i8,Link,i8}>
      1) stloc.1 [Seq<{i8,i8,Link,i8}>]
      1) ldloc.1 [Seq<{i8,i8,Link,i8}>]
      1) dup
      5) brtrue [0]
      1) pop
      1) ldnull
      5) br [1]
  Label [0]:
      1) ldloc.0 [ExecCtx]
      1) ldc.i4.0
      5) call static CodeGenUtil::EnumerableToPinging(Seq<{i8,i8,Link,i8}>, ExecCtx, i4):Seq<{i8,i8,Link,i8}>
      1) ldarg.0 [Arr<obj>]
      1) ldc.i4.0
      5) ldelem [Func<{i8,i8,Link,i8},Link>]
      1) ldarg.0 [Arr<obj>]
      1) ldc.i4.1
      5) ldelem [Func<{i8,i8,Link,i8},{i8,i8,i8}>]
      1) ldarg.0 [Arr<obj>]
      1) ldc.i4.2
      5) ldelem [Func<Link,Seq<{i8,i8,i8}>,{Link,Seq<{i8,i8,i8}>}>]
      5) call static Enumerable::GroupBy(Seq<{i8,i8,Link,i8}>, Func<{i8,i8,Link,i8},Link>, Func<{i8,i8,Link,i8},{i8,i8,i8}>, Func<Link,Seq<{i8,i8,i8}>,{Link,Seq<{i8,i8,i8}>}>):Seq<{Link,Seq<{i8,i8,i8}>}>
      5) call static CodeGenUtil::EnumerableToCaching(Seq<{Link,Seq<{i8,i8,i8}>}>):Seq<{Link,Seq<{i8,i8,i8}>}>
  Label [1]:
      1) ret
  Total Size: 71

Func sig: (<ctx>:x, TU:{A:i8, B:i8, C:U<Image>, D:i8}*) to {C:U<Image>, X:{A:i8, B:i8, D:i8}*}*
Sequence: Seq<{Link,Seq<{i8,i8,i8}>}>
 0) { C: Link<Generic>(<null>, foo.bmp), 
      X: Sequence: Seq<{i8,i8,i8}>
         0) { A: 0, B: 0, D: 0 }
         1) { A: 2, B: 0, D: 0 }
         2) { A: 4, B: 0, D: 0 }
         3) { A: 6, B: 0, D: 0 }
         4) { A: 8, B: 0, D: 0 }
    }
 1) { C: Link<Generic>(<null>, bar.bmp), 
      X: Sequence: Seq<{i8,i8,i8}>
         0) { A: 1, B: 1, D: 1 }
         1) { A: 3, B: 1, D: 1 }
         2) { A: 5, B: 1, D: 1 }
         3) { A: 7, B: 1, D: 1 }
         4) { A: 9, B: 1, D: 1 }
    }
*** Ctx ping count: 11
    [0](11): GroupBy(*1: TU, [key] C:*1.C, [auto] X:<auto>)
###
> GroupBy(TU, [key] B, [key] C, X)
GroupBy(TU, [key] B, [key] C, X) : {B:i8, C:U<Image>, X:{A:i8, D:i8}*}*
BndKind:GroupBy, Type:{B:i8, C:U<Image>, X:{A:i8, D:i8}*}*, Bnd:(GroupBy([scope:1] Global(TU), [key] B:GetField(Scope(1), B), [key] C:GetField(Scope(1), C), [auto] X:<auto>))
// (<ctx>, ∂.TU:{A:i8, B:i8, C:U<Image>, D:i8}*) : {B:i8, C:U<Image>, X:{A:i8, D:i8}*}*
elementSelector(Arr<obj>, {i8,i8,Link,i8}):{i8,i8}
      5) newobj {i8,i8}()
      1) dup
      1) ldc.i4.3
      5) stfld {i8,i8}::_B0:u1
      1) stloc.0 [{i8,i8}]
      1) ldloc.0 [{i8,i8}]
      1) ldarg.1 [{i8,i8,Link,i8}]
      5) ldfld {i8,i8,Link,i8}::_F0:i8
      5) stfld {i8,i8}::_F0:i8
      1) ldloc.0 [{i8,i8}]
      1) ldarg.1 [{i8,i8,Link,i8}]
      5) ldfld {i8,i8,Link,i8}::_F3:i8
      5) stfld {i8,i8}::_F1:i8
      1) ldloc.0 [{i8,i8}]
      1) dup
      1) ldarg.0 [Arr<obj>]
      1) ldc.i4.0
      5) ldelem [RecordRuntimeTypeInfo]
      5) stfld {}::_rrti:RecordRuntimeTypeInfo
      1) ret
  Total Size: 52

resultSelector(Arr<obj>, {i8,i8,Link,i8}, Seq<{i8,i8}>):{i8,Link,Seq<{i8,i8}>}
      5) newobj {i8,Link,Seq<{i8,i8}>}()
      1) dup
      1) ldc.i4.3
      5) stfld {i8,Link,Seq<{i8,i8}>}::_B0:u1
      1) stloc.0 [{i8,Link,Seq<{i8,i8}>}]
      1) ldloc.0 [{i8,Link,Seq<{i8,i8}>}]
      1) ldarg.1 [{i8,i8,Link,i8}]
      5) ldfld {i8,i8,Link,i8}::_F1:i8
      5) stfld {i8,Link,Seq<{i8,i8}>}::_F0:i8
      1) ldloc.0 [{i8,Link,Seq<{i8,i8}>}]
      1) ldarg.1 [{i8,i8,Link,i8}]
      5) ldfld {i8,i8,Link,i8}::_F2:Link
      5) stfld {i8,Link,Seq<{i8,i8}>}::_F1:Link
      1) ldloc.0 [{i8,Link,Seq<{i8,i8}>}]
      1) ldarg.2 [Seq<{i8,i8}>]
      5) call static CodeGenUtil::EnumerableToCaching(Seq<{i8,i8}>):Seq<{i8,i8}>
      5) stfld {i8,Link,Seq<{i8,i8}>}::_F2:Seq<{i8,i8}>
      1) ldloc.0 [{i8,Link,Seq<{i8,i8}>}]
      1) dup
      1) ldarg.0 [Arr<obj>]
      1) ldc.i4.0
      5) ldelem [RecordRuntimeTypeInfo]
      5) stfld {}::_rrti:RecordRuntimeTypeInfo
      1) ret
  Total Size: 64

Equals(Arr<obj>, {i8,i8,Link,i8}, {i8,i8,Link,i8}):bool
      1) ldarg.1 [{i8,i8,Link,i8}]
      5) ldfld {i8,i8,Link,i8}::_F1:i8
      1) ldarg.2 [{i8,i8,Link,i8}]
      5) ldfld {i8,i8,Link,i8}::_F1:i8
      5) bne.un [0]
      1) ldarg.1 [{i8,i8,Link,i8}]
      5) ldfld {i8,i8,Link,i8}::_F2:Link
      1) ldarg.2 [{i8,i8,Link,i8}]
      5) ldfld {i8,i8,Link,i8}::_F2:Link
      5) call static CodeGenUtil::EqOpt(Link, Link):bool
      5) br [1]
  Label [0]:
      1) ldc.i4.0
  Label [1]:
      1) ret
  Total Size: 41

GetHashCode(Arr<obj>, {i8,i8,Link,i8}):i4
      1) ldarg.1 [{i8,i8,Link,i8}]
      5) ldfld {i8,i8,Link,i8}::_F1:i8
      1) ldarg.1 [{i8,i8,Link,i8}]
      5) ldfld {i8,i8,Link,i8}::_F2:Link
      5) call static HashCode::Combine(i8, Link):i4
      1) ret
  Total Size: 18

top(Arr<obj>, Arr<obj>):obj
      1) ldarg.1 [Arr<obj>]
      1) ldc.i4.0
      1) ldelem.ref
      5) call static CodeGenUtil::ToRef(obj):ExecCtx
      1) stloc.0 [ExecCtx]
      1) ldarg.1 [Arr<obj>]
      1) ldc.i4.1
      1) ldelem.ref
      5) call static CodeGenUtil::ToRef(obj):Seq<{i8,i8,Link,i8}>
      1) stloc.1 [Seq<{i8,i8,Link,i8}>]
      1) ldloc.1 [Seq<{i8,i8,Link,i8}>]
      1) dup
      5) brtrue [0]
      1) pop
      1) ldnull
      5) br [1]
  Label [0]:
      1) ldloc.0 [ExecCtx]
      1) ldc.i4.0
      5) call static CodeGenUtil::EnumerableToPinging(Seq<{i8,i8,Link,i8}>, ExecCtx, i4):Seq<{i8,i8,Link,i8}>
      1) ldarg.0 [Arr<obj>]
      1) ldc.i4.0
      5) ldelem [Func<{i8,i8,Link,i8},{i8,i8,Link,i8}>]
      1) ldarg.0 [Arr<obj>]
      1) ldc.i4.1
      5) ldelem [Func<{i8,i8,Link,i8},{i8,i8}>]
      1) ldarg.0 [Arr<obj>]
      1) ldc.i4.2
      5) ldelem [Func<{i8,i8,Link,i8},Seq<{i8,i8}>,{i8,Link,Seq<{i8,i8}>}>]
      1) ldarg.0 [Arr<obj>]
      1) ldc.i4.3
      5) ldelem [GroupByComparer<{i8,i8,Link,i8}>]
      5) call static Enumerable::GroupBy(Seq<{i8,i8,Link,i8}>, Func<{i8,i8,Link,i8},{i8,i8,Link,i8}>, Func<{i8,i8,Link,i8},{i8,i8}>, Func<{i8,i8,Link,i8},Seq<{i8,i8}>,{i8,Link,Seq<{i8,i8}>}>, IEqualityComparer<{i8,i8,Link,i8}>):Seq<{i8,Link,Seq<{i8,i8}>}>
      5) call static CodeGenUtil::EnumerableToCaching(Seq<{i8,Link,Seq<{i8,i8}>}>):Seq<{i8,Link,Seq<{i8,i8}>}>
  Label [1]:
      1) ret
  Total Size: 78

Func sig: (<ctx>:x, TU:{A:i8, B:i8, C:U<Image>, D:i8}*) to {B:i8, C:U<Image>, X:{A:i8, D:i8}*}*
Sequence: Seq<{i8,Link,Seq<{i8,i8}>}>
 0) { B: 0, C: Link<Generic>(<null>, foo.bmp), 
      X: Sequence: Seq<{i8,i8}>
         0) { A: 0, D: 0 }
         1) { A: 2, D: 0 }
         2) { A: 4, D: 0 }
         3) { A: 6, D: 0 }
         4) { A: 8, D: 0 }
    }
 1) { B: 1, C: Link<Generic>(<null>, bar.bmp), 
      X: Sequence: Seq<{i8,i8}>
         0) { A: 1, D: 1 }
         1) { A: 3, D: 1 }
         2) { A: 5, D: 1 }
         3) { A: 7, D: 1 }
         4) { A: 9, D: 1 }
    }
*** Ctx ping count: 11
    [0](11): GroupBy(*1: TU, [key] B:*1.B, [key] C:*1.C, [auto] X:<auto>)
###
> GroupBy(TU, [key] C, [key] D, X)
GroupBy(TU, [key] C, [key] D, X) : {C:U<Image>, D:i8, X:{A:i8, B:i8}*}*
BndKind:GroupBy, Type:{C:U<Image>, D:i8, X:{A:i8, B:i8}*}*, Bnd:(GroupBy([scope:1] Global(TU), [key] C:GetField(Scope(1), C), [key] D:GetField(Scope(1), D), [auto] X:<auto>))
// (<ctx>, ∂.TU:{A:i8, B:i8, C:U<Image>, D:i8}*) : {C:U<Image>, D:i8, X:{A:i8, B:i8}*}*
elementSelector(Arr<obj>, {i8,i8,Link,i8}):{i8,i8}
      5) newobj {i8,i8}()
      1) dup
      1) ldc.i4.3
      5) stfld {i8,i8}::_B0:u1
      1) stloc.0 [{i8,i8}]
      1) ldloc.0 [{i8,i8}]
      1) ldarg.1 [{i8,i8,Link,i8}]
      5) ldfld {i8,i8,Link,i8}::_F0:i8
      5) stfld {i8,i8}::_F0:i8
      1) ldloc.0 [{i8,i8}]
      1) ldarg.1 [{i8,i8,Link,i8}]
      5) ldfld {i8,i8,Link,i8}::_F1:i8
      5) stfld {i8,i8}::_F1:i8
      1) ldloc.0 [{i8,i8}]
      1) dup
      1) ldarg.0 [Arr<obj>]
      1) ldc.i4.0
      5) ldelem [RecordRuntimeTypeInfo]
      5) stfld {}::_rrti:RecordRuntimeTypeInfo
      1) ret
  Total Size: 52

resultSelector(Arr<obj>, {i8,i8,Link,i8}, Seq<{i8,i8}>):{Link,i8,Seq<{i8,i8}>}
      5) newobj {Link,i8,Seq<{i8,i8}>}()
      1) dup
      1) ldc.i4.3
      5) stfld {Link,i8,Seq<{i8,i8}>}::_B0:u1
      1) stloc.0 [{Link,i8,Seq<{i8,i8}>}]
      1) ldloc.0 [{Link,i8,Seq<{i8,i8}>}]
      1) ldarg.1 [{i8,i8,Link,i8}]
      5) ldfld {i8,i8,Link,i8}::_F2:Link
      5) stfld {Link,i8,Seq<{i8,i8}>}::_F0:Link
      1) ldloc.0 [{Link,i8,Seq<{i8,i8}>}]
      1) ldarg.1 [{i8,i8,Link,i8}]
      5) ldfld {i8,i8,Link,i8}::_F3:i8
      5) stfld {Link,i8,Seq<{i8,i8}>}::_F1:i8
      1) ldloc.0 [{Link,i8,Seq<{i8,i8}>}]
      1) ldarg.2 [Seq<{i8,i8}>]
      5) call static CodeGenUtil::EnumerableToCaching(Seq<{i8,i8}>):Seq<{i8,i8}>
      5) stfld {Link,i8,Seq<{i8,i8}>}::_F2:Seq<{i8,i8}>
      1) ldloc.0 [{Link,i8,Seq<{i8,i8}>}]
      1) dup
      1) ldarg.0 [Arr<obj>]
      1) ldc.i4.0
      5) ldelem [RecordRuntimeTypeInfo]
      5) stfld {}::_rrti:RecordRuntimeTypeInfo
      1) ret
  Total Size: 64

Equals(Arr<obj>, {i8,i8,Link,i8}, {i8,i8,Link,i8}):bool
      1) ldarg.1 [{i8,i8,Link,i8}]
      5) ldfld {i8,i8,Link,i8}::_F2:Link
      1) ldarg.2 [{i8,i8,Link,i8}]
      5) ldfld {i8,i8,Link,i8}::_F2:Link
      5) call static CodeGenUtil::EqOpt(Link, Link):bool
      5) brfalse [0]
      1) ldarg.1 [{i8,i8,Link,i8}]
      5) ldfld {i8,i8,Link,i8}::_F3:i8
      1) ldarg.2 [{i8,i8,Link,i8}]
      5) ldfld {i8,i8,Link,i8}::_F3:i8
      2) ceq
      5) br [1]
  Label [0]:
      1) ldc.i4.0
  Label [1]:
      1) ret
  Total Size: 43

GetHashCode(Arr<obj>, {i8,i8,Link,i8}):i4
      1) ldarg.1 [{i8,i8,Link,i8}]
      5) ldfld {i8,i8,Link,i8}::_F2:Link
      1) ldarg.1 [{i8,i8,Link,i8}]
      5) ldfld {i8,i8,Link,i8}::_F3:i8
      5) call static HashCode::Combine(Link, i8):i4
      1) ret
  Total Size: 18

top(Arr<obj>, Arr<obj>):obj
      1) ldarg.1 [Arr<obj>]
      1) ldc.i4.0
      1) ldelem.ref
      5) call static CodeGenUtil::ToRef(obj):ExecCtx
      1) stloc.0 [ExecCtx]
      1) ldarg.1 [Arr<obj>]
      1) ldc.i4.1
      1) ldelem.ref
      5) call static CodeGenUtil::ToRef(obj):Seq<{i8,i8,Link,i8}>
      1) stloc.1 [Seq<{i8,i8,Link,i8}>]
      1) ldloc.1 [Seq<{i8,i8,Link,i8}>]
      1) dup
      5) brtrue [0]
      1) pop
      1) ldnull
      5) br [1]
  Label [0]:
      1) ldloc.0 [ExecCtx]
      1) ldc.i4.0
      5) call static CodeGenUtil::EnumerableToPinging(Seq<{i8,i8,Link,i8}>, ExecCtx, i4):Seq<{i8,i8,Link,i8}>
      1) ldarg.0 [Arr<obj>]
      1) ldc.i4.0
      5) ldelem [Func<{i8,i8,Link,i8},{i8,i8,Link,i8}>]
      1) ldarg.0 [Arr<obj>]
      1) ldc.i4.1
      5) ldelem [Func<{i8,i8,Link,i8},{i8,i8}>]
      1) ldarg.0 [Arr<obj>]
      1) ldc.i4.2
      5) ldelem [Func<{i8,i8,Link,i8},Seq<{i8,i8}>,{Link,i8,Seq<{i8,i8}>}>]
      1) ldarg.0 [Arr<obj>]
      1) ldc.i4.3
      5) ldelem [GroupByComparer<{i8,i8,Link,i8}>]
      5) call static Enumerable::GroupBy(Seq<{i8,i8,Link,i8}>, Func<{i8,i8,Link,i8},{i8,i8,Link,i8}>, Func<{i8,i8,Link,i8},{i8,i8}>, Func<{i8,i8,Link,i8},Seq<{i8,i8}>,{Link,i8,Seq<{i8,i8}>}>, IEqualityComparer<{i8,i8,Link,i8}>):Seq<{Link,i8,Seq<{i8,i8}>}>
      5) call static CodeGenUtil::EnumerableToCaching(Seq<{Link,i8,Seq<{i8,i8}>}>):Seq<{Link,i8,Seq<{i8,i8}>}>
  Label [1]:
      1) ret
  Total Size: 78

Func sig: (<ctx>:x, TU:{A:i8, B:i8, C:U<Image>, D:i8}*) to {C:U<Image>, D:i8, X:{A:i8, B:i8}*}*
Sequence: Seq<{Link,i8,Seq<{i8,i8}>}>
 0) { C: Link<Generic>(<null>, foo.bmp), D: 0, 
      X: Sequence: Seq<{i8,i8}>
         0) { A: 0, B: 0 }
         1) { A: 2, B: 0 }
         2) { A: 4, B: 0 }
         3) { A: 6, B: 0 }
         4) { A: 8, B: 0 }
    }
 1) { C: Link<Generic>(<null>, bar.bmp), D: 1, 
      X: Sequence: Seq<{i8,i8}>
         0) { A: 1, B: 1 }
         1) { A: 3, B: 1 }
         2) { A: 5, B: 1 }
         3) { A: 7, B: 1 }
         4) { A: 9, B: 1 }
    }
*** Ctx ping count: 11
    [0](11): GroupBy(*1: TU, [key] C:*1.C, [key] D:*1.D, [auto] X:<auto>)
###
> GroupBy(TU, [key] C, [key] EId: A mod 2, X)
GroupBy(TU, [key] C, [key] EId : A mod 2, X) : {C:U<Image>, EId:i8, X:{A:i8, B:i8, D:i8}*}*
BndKind:GroupBy, Type:{C:U<Image>, EId:i8, X:{A:i8, B:i8, D:i8}*}*, Bnd:(GroupBy([scope:1] Global(TU), [key] C:GetField(Scope(1), C), [key] EId:IntMod(GetField(Scope(1), A), 2:i8), [auto] X:<auto>))
// (<ctx>, ∂.TU:{A:i8, B:i8, C:U<Image>, D:i8}*) : {C:U<Image>, EId:i8, X:{A:i8, B:i8, D:i8}*}*
keySelector(Arr<obj>, {i8,i8,Link,i8}):{Link,i8}
      5) newobj {Link,i8}()
      1) dup
      1) ldc.i4.3
      5) stfld {Link,i8}::_B0:u1
      1) stloc.0 [{Link,i8}]
      1) ldloc.0 [{Link,i8}]
      1) ldarg.1 [{i8,i8,Link,i8}]
      5) ldfld {i8,i8,Link,i8}::_F2:Link
      5) stfld {Link,i8}::_F0:Link
      1) ldloc.0 [{Link,i8}]
      1) ldarg.1 [{i8,i8,Link,i8}]
      5) ldfld {i8,i8,Link,i8}::_F0:i8
      1) ldc.i4.2
      1) conv.i8
      1) rem
      5) stfld {Link,i8}::_F1:i8
      1) ldloc.0 [{Link,i8}]
      1) dup
      1) ldarg.0 [Arr<obj>]
      1) ldc.i4.0
      5) ldelem [RecordRuntimeTypeInfo]
      5) stfld {}::_rrti:RecordRuntimeTypeInfo
      1) ret
  Total Size: 55

elementSelector(Arr<obj>, {i8,i8,Link,i8}):{i8,i8,i8}
      5) newobj {i8,i8,i8}()
      1) dup
      1) ldc.i4.7
      5) stfld {i8,i8,i8}::_B0:u1
      1) stloc.0 [{i8,i8,i8}]
      1) ldloc.0 [{i8,i8,i8}]
      1) ldarg.1 [{i8,i8,Link,i8}]
      5) ldfld {i8,i8,Link,i8}::_F0:i8
      5) stfld {i8,i8,i8}::_F0:i8
      1) ldloc.0 [{i8,i8,i8}]
      1) ldarg.1 [{i8,i8,Link,i8}]
      5) ldfld {i8,i8,Link,i8}::_F1:i8
      5) stfld {i8,i8,i8}::_F1:i8
      1) ldloc.0 [{i8,i8,i8}]
      1) ldarg.1 [{i8,i8,Link,i8}]
      5) ldfld {i8,i8,Link,i8}::_F3:i8
      5) stfld {i8,i8,i8}::_F2:i8
      1) ldloc.0 [{i8,i8,i8}]
      1) dup
      1) ldarg.0 [Arr<obj>]
      1) ldc.i4.0
      5) ldelem [RecordRuntimeTypeInfo]
      5) stfld {}::_rrti:RecordRuntimeTypeInfo
      1) ret
  Total Size: 64

resultSelector(Arr<obj>, {Link,i8}, Seq<{i8,i8,i8}>):{Link,i8,Seq<{i8,i8,i8}>}
      5) newobj {Link,i8,Seq<{i8,i8,i8}>}()
      1) dup
      1) ldc.i4.3
      5) stfld {Link,i8,Seq<{i8,i8,i8}>}::_B0:u1
      1) stloc.0 [{Link,i8,Seq<{i8,i8,i8}>}]
      1) ldloc.0 [{Link,i8,Seq<{i8,i8,i8}>}]
      1) ldarg.1 [{Link,i8}]
      5) ldfld {Link,i8}::_F0:Link
      5) stfld {Link,i8,Seq<{i8,i8,i8}>}::_F0:Link
      1) ldloc.0 [{Link,i8,Seq<{i8,i8,i8}>}]
      1) ldarg.1 [{Link,i8}]
      5) ldfld {Link,i8}::_F1:i8
      5) stfld {Link,i8,Seq<{i8,i8,i8}>}::_F1:i8
      1) ldloc.0 [{Link,i8,Seq<{i8,i8,i8}>}]
      1) ldarg.2 [Seq<{i8,i8,i8}>]
      5) call static CodeGenUtil::EnumerableToCaching(Seq<{i8,i8,i8}>):Seq<{i8,i8,i8}>
      5) stfld {Link,i8,Seq<{i8,i8,i8}>}::_F2:Seq<{i8,i8,i8}>
      1) ldloc.0 [{Link,i8,Seq<{i8,i8,i8}>}]
      1) dup
      1) ldarg.0 [Arr<obj>]
      1) ldc.i4.0
      5) ldelem [RecordRuntimeTypeInfo]
      5) stfld {}::_rrti:RecordRuntimeTypeInfo
      1) ret
  Total Size: 64

top(Arr<obj>, Arr<obj>):obj
      1) ldarg.1 [Arr<obj>]
      1) ldc.i4.0
      1) ldelem.ref
      5) call static CodeGenUtil::ToRef(obj):ExecCtx
      1) stloc.0 [ExecCtx]
      1) ldarg.1 [Arr<obj>]
      1) ldc.i4.1
      1) ldelem.ref
      5) call static CodeGenUtil::ToRef(obj):Seq<{i8,i8,Link,i8}>
      1) stloc.1 [Seq<{i8,i8,Link,i8}>]
      1) ldloc.1 [Seq<{i8,i8,Link,i8}>]
      1) dup
      5) brtrue [0]
      1) pop
      1) ldnull
      5) br [1]
  Label [0]:
      1) ldloc.0 [ExecCtx]
      1) ldc.i4.0
      5) call static CodeGenUtil::EnumerableToPinging(Seq<{i8,i8,Link,i8}>, ExecCtx, i4):Seq<{i8,i8,Link,i8}>
      1) ldarg.0 [Arr<obj>]
      1) ldc.i4.0
      5) ldelem [Func<{i8,i8,Link,i8},{Link,i8}>]
      1) ldarg.0 [Arr<obj>]
      1) ldc.i4.1
      5) ldelem [Func<{i8,i8,Link,i8},{i8,i8,i8}>]
      1) ldarg.0 [Arr<obj>]
      1) ldc.i4.2
      5) ldelem [Func<{Link,i8},Seq<{i8,i8,i8}>,{Link,i8,Seq<{i8,i8,i8}>}>]
      5) call static Enumerable::GroupBy(Seq<{i8,i8,Link,i8}>, Func<{i8,i8,Link,i8},{Link,i8}>, Func<{i8,i8,Link,i8},{i8,i8,i8}>, Func<{Link,i8},Seq<{i8,i8,i8}>,{Link,i8,Seq<{i8,i8,i8}>}>):Seq<{Link,i8,Seq<{i8,i8,i8}>}>
      5) call static CodeGenUtil::EnumerableToCaching(Seq<{Link,i8,Seq<{i8,i8,i8}>}>):Seq<{Link,i8,Seq<{i8,i8,i8}>}>
  Label [1]:
      1) ret
  Total Size: 71

Func sig: (<ctx>:x, TU:{A:i8, B:i8, C:U<Image>, D:i8}*) to {C:U<Image>, EId:i8, X:{A:i8, B:i8, D:i8}*}*
Sequence: Seq<{Link,i8,Seq<{i8,i8,i8}>}>
 0) { C: Link<Generic>(<null>, foo.bmp), EId: 0, 
      X: Sequence: Seq<{i8,i8,i8}>
         0) { A: 0, B: 0, D: 0 }
         1) { A: 2, B: 0, D: 0 }
         2) { A: 4, B: 0, D: 0 }
         3) { A: 6, B: 0, D: 0 }
         4) { A: 8, B: 0, D: 0 }
    }
 1) { C: Link<Generic>(<null>, bar.bmp), EId: 1, 
      X: Sequence: Seq<{i8,i8,i8}>
         0) { A: 1, B: 1, D: 1 }
         1) { A: 3, B: 1, D: 1 }
         2) { A: 5, B: 1, D: 1 }
         3) { A: 7, B: 1, D: 1 }
         4) { A: 9, B: 1, D: 1 }
    }
*** Ctx ping count: 11
    [0](11): GroupBy(*1: TU, [key] C:*1.C, [key] EId:IntMod(*1.A, 2), [auto] X:<auto>)
###
> GroupBy(TU, [key] AId: A mod 2, [key] C, X)
GroupBy(TU, [key] AId : A mod 2, [key] C, X) : {AId:i8, C:U<Image>, X:{A:i8, B:i8, D:i8}*}*
BndKind:GroupBy, Type:{AId:i8, C:U<Image>, X:{A:i8, B:i8, D:i8}*}*, Bnd:(GroupBy([scope:1] Global(TU), [key] AId:IntMod(GetField(Scope(1), A), 2:i8), [key] C:GetField(Scope(1), C), [auto] X:<auto>))
// (<ctx>, ∂.TU:{A:i8, B:i8, C:U<Image>, D:i8}*) : {AId:i8, C:U<Image>, X:{A:i8, B:i8, D:i8}*}*
keySelector(Arr<obj>, {i8,i8,Link,i8}):{i8,Link}
      5) newobj {i8,Link}()
      1) dup
      1) ldc.i4.3
      5) stfld {i8,Link}::_B0:u1
      1) stloc.0 [{i8,Link}]
      1) ldloc.0 [{i8,Link}]
      1) ldarg.1 [{i8,i8,Link,i8}]
      5) ldfld {i8,i8,Link,i8}::_F0:i8
      1) ldc.i4.2
      1) conv.i8
      1) rem
      5) stfld {i8,Link}::_F0:i8
      1) ldloc.0 [{i8,Link}]
      1) ldarg.1 [{i8,i8,Link,i8}]
      5) ldfld {i8,i8,Link,i8}::_F2:Link
      5) stfld {i8,Link}::_F1:Link
      1) ldloc.0 [{i8,Link}]
      1) dup
      1) ldarg.0 [Arr<obj>]
      1) ldc.i4.0
      5) ldelem [RecordRuntimeTypeInfo]
      5) stfld {}::_rrti:RecordRuntimeTypeInfo
      1) ret
  Total Size: 55

elementSelector(Arr<obj>, {i8,i8,Link,i8}):{i8,i8,i8}
      5) newobj {i8,i8,i8}()
      1) dup
      1) ldc.i4.7
      5) stfld {i8,i8,i8}::_B0:u1
      1) stloc.0 [{i8,i8,i8}]
      1) ldloc.0 [{i8,i8,i8}]
      1) ldarg.1 [{i8,i8,Link,i8}]
      5) ldfld {i8,i8,Link,i8}::_F0:i8
      5) stfld {i8,i8,i8}::_F0:i8
      1) ldloc.0 [{i8,i8,i8}]
      1) ldarg.1 [{i8,i8,Link,i8}]
      5) ldfld {i8,i8,Link,i8}::_F1:i8
      5) stfld {i8,i8,i8}::_F1:i8
      1) ldloc.0 [{i8,i8,i8}]
      1) ldarg.1 [{i8,i8,Link,i8}]
      5) ldfld {i8,i8,Link,i8}::_F3:i8
      5) stfld {i8,i8,i8}::_F2:i8
      1) ldloc.0 [{i8,i8,i8}]
      1) dup
      1) ldarg.0 [Arr<obj>]
      1) ldc.i4.0
      5) ldelem [RecordRuntimeTypeInfo]
      5) stfld {}::_rrti:RecordRuntimeTypeInfo
      1) ret
  Total Size: 64

resultSelector(Arr<obj>, {i8,Link}, Seq<{i8,i8,i8}>):{i8,Link,Seq<{i8,i8,i8}>}
      5) newobj {i8,Link,Seq<{i8,i8,i8}>}()
      1) dup
      1) ldc.i4.3
      5) stfld {i8,Link,Seq<{i8,i8,i8}>}::_B0:u1
      1) stloc.0 [{i8,Link,Seq<{i8,i8,i8}>}]
      1) ldloc.0 [{i8,Link,Seq<{i8,i8,i8}>}]
      1) ldarg.1 [{i8,Link}]
      5) ldfld {i8,Link}::_F0:i8
      5) stfld {i8,Link,Seq<{i8,i8,i8}>}::_F0:i8
      1) ldloc.0 [{i8,Link,Seq<{i8,i8,i8}>}]
      1) ldarg.1 [{i8,Link}]
      5) ldfld {i8,Link}::_F1:Link
      5) stfld {i8,Link,Seq<{i8,i8,i8}>}::_F1:Link
      1) ldloc.0 [{i8,Link,Seq<{i8,i8,i8}>}]
      1) ldarg.2 [Seq<{i8,i8,i8}>]
      5) call static CodeGenUtil::EnumerableToCaching(Seq<{i8,i8,i8}>):Seq<{i8,i8,i8}>
      5) stfld {i8,Link,Seq<{i8,i8,i8}>}::_F2:Seq<{i8,i8,i8}>
      1) ldloc.0 [{i8,Link,Seq<{i8,i8,i8}>}]
      1) dup
      1) ldarg.0 [Arr<obj>]
      1) ldc.i4.0
      5) ldelem [RecordRuntimeTypeInfo]
      5) stfld {}::_rrti:RecordRuntimeTypeInfo
      1) ret
  Total Size: 64

top(Arr<obj>, Arr<obj>):obj
      1) ldarg.1 [Arr<obj>]
      1) ldc.i4.0
      1) ldelem.ref
      5) call static CodeGenUtil::ToRef(obj):ExecCtx
      1) stloc.0 [ExecCtx]
      1) ldarg.1 [Arr<obj>]
      1) ldc.i4.1
      1) ldelem.ref
      5) call static CodeGenUtil::ToRef(obj):Seq<{i8,i8,Link,i8}>
      1) stloc.1 [Seq<{i8,i8,Link,i8}>]
      1) ldloc.1 [Seq<{i8,i8,Link,i8}>]
      1) dup
      5) brtrue [0]
      1) pop
      1) ldnull
      5) br [1]
  Label [0]:
      1) ldloc.0 [ExecCtx]
      1) ldc.i4.0
      5) call static CodeGenUtil::EnumerableToPinging(Seq<{i8,i8,Link,i8}>, ExecCtx, i4):Seq<{i8,i8,Link,i8}>
      1) ldarg.0 [Arr<obj>]
      1) ldc.i4.0
      5) ldelem [Func<{i8,i8,Link,i8},{i8,Link}>]
      1) ldarg.0 [Arr<obj>]
      1) ldc.i4.1
      5) ldelem [Func<{i8,i8,Link,i8},{i8,i8,i8}>]
      1) ldarg.0 [Arr<obj>]
      1) ldc.i4.2
      5) ldelem [Func<{i8,Link},Seq<{i8,i8,i8}>,{i8,Link,Seq<{i8,i8,i8}>}>]
      5) call static Enumerable::GroupBy(Seq<{i8,i8,Link,i8}>, Func<{i8,i8,Link,i8},{i8,Link}>, Func<{i8,i8,Link,i8},{i8,i8,i8}>, Func<{i8,Link},Seq<{i8,i8,i8}>,{i8,Link,Seq<{i8,i8,i8}>}>):Seq<{i8,Link,Seq<{i8,i8,i8}>}>
      5) call static CodeGenUtil::EnumerableToCaching(Seq<{i8,Link,Seq<{i8,i8,i8}>}>):Seq<{i8,Link,Seq<{i8,i8,i8}>}>
  Label [1]:
      1) ret
  Total Size: 71

Func sig: (<ctx>:x, TU:{A:i8, B:i8, C:U<Image>, D:i8}*) to {AId:i8, C:U<Image>, X:{A:i8, B:i8, D:i8}*}*
Sequence: Seq<{i8,Link,Seq<{i8,i8,i8}>}>
 0) { AId: 0, C: Link<Generic>(<null>, foo.bmp), 
      X: Sequence: Seq<{i8,i8,i8}>
         0) { A: 0, B: 0, D: 0 }
         1) { A: 2, B: 0, D: 0 }
         2) { A: 4, B: 0, D: 0 }
         3) { A: 6, B: 0, D: 0 }
         4) { A: 8, B: 0, D: 0 }
    }
 1) { AId: 1, C: Link<Generic>(<null>, bar.bmp), 
      X: Sequence: Seq<{i8,i8,i8}>
         0) { A: 1, B: 1, D: 1 }
         1) { A: 3, B: 1, D: 1 }
         2) { A: 5, B: 1, D: 1 }
         3) { A: 7, B: 1, D: 1 }
         4) { A: 9, B: 1, D: 1 }
    }
*** Ctx ping count: 11
    [0](11): GroupBy(*1: TU, [key] AId:IntMod(*1.A, 2), [key] C:*1.C, [auto] X:<auto>)
###

**** New definitions: SS, type: s*
**** New definitions: D, type: {Id:i8, M:i8, N:s}*

> GroupBy(D, N, X)
GroupBy(D, N, X) : {N:s, X:{Id:i8, M:i8}*}*
BndKind:GroupBy, Type:{N:s, X:{Id:i8, M:i8}*}*, Bnd:(GroupBy([scope:1] Global(D), [key] N:GetField(Scope(1), N), [auto] X:<auto>))
// (<ctx>, ∂.D:{Id:i8, M:i8, N:s}*) : {N:s, X:{Id:i8, M:i8}*}*
keySelector(Arr<obj>, {i8,i8,str}):str
      1) ldarg.1 [{i8,i8,str}]
      5) ldfld {i8,i8,str}::_F2:str
      1) ret
  Total Size: 7

elementSelector(Arr<obj>, {i8,i8,str}):{i8,i8}
      5) newobj {i8,i8}()
      1) dup
      1) ldc.i4.3
      5) stfld {i8,i8}::_B0:u1
      1) stloc.0 [{i8,i8}]
      1) ldloc.0 [{i8,i8}]
      1) ldarg.1 [{i8,i8,str}]
      5) ldfld {i8,i8,str}::_F0:i8
      5) stfld {i8,i8}::_F0:i8
      1) ldloc.0 [{i8,i8}]
      1) ldarg.1 [{i8,i8,str}]
      5) ldfld {i8,i8,str}::_F1:i8
      5) stfld {i8,i8}::_F1:i8
      1) ldloc.0 [{i8,i8}]
      1) dup
      1) ldarg.0 [Arr<obj>]
      1) ldc.i4.0
      5) ldelem [RecordRuntimeTypeInfo]
      5) stfld {}::_rrti:RecordRuntimeTypeInfo
      1) ret
  Total Size: 52

resultSelector(Arr<obj>, str, Seq<{i8,i8}>):{str,Seq<{i8,i8}>}
      5) newobj {str,Seq<{i8,i8}>}()
      1) dup
      1) ldc.i4.1
      5) stfld {str,Seq<{i8,i8}>}::_B0:u1
      1) stloc.0 [{str,Seq<{i8,i8}>}]
      1) ldloc.0 [{str,Seq<{i8,i8}>}]
      1) ldarg.1 [str]
      5) stfld {str,Seq<{i8,i8}>}::_F0:str
      1) ldloc.0 [{str,Seq<{i8,i8}>}]
      1) ldarg.2 [Seq<{i8,i8}>]
      5) call static CodeGenUtil::EnumerableToCaching(Seq<{i8,i8}>):Seq<{i8,i8}>
      5) stfld {str,Seq<{i8,i8}>}::_F1:Seq<{i8,i8}>
      1) ldloc.0 [{str,Seq<{i8,i8}>}]
      1) dup
      1) ldarg.0 [Arr<obj>]
      1) ldc.i4.0
      5) ldelem [RecordRuntimeTypeInfo]
      5) stfld {}::_rrti:RecordRuntimeTypeInfo
      1) ret
  Total Size: 47

top(Arr<obj>, Arr<obj>):obj
      1) ldarg.1 [Arr<obj>]
      1) ldc.i4.0
      1) ldelem.ref
      5) call static CodeGenUtil::ToRef(obj):ExecCtx
      1) stloc.0 [ExecCtx]
      1) ldarg.1 [Arr<obj>]
      1) ldc.i4.1
      1) ldelem.ref
      5) call static CodeGenUtil::ToRef(obj):Seq<{i8,i8,str}>
      1) stloc.1 [Seq<{i8,i8,str}>]
      1) ldloc.1 [Seq<{i8,i8,str}>]
      1) dup
      5) brtrue [0]
      1) pop
      1) ldnull
      5) br [1]
  Label [0]:
      1) ldloc.0 [ExecCtx]
      1) ldc.i4.0
      5) call static CodeGenUtil::EnumerableToPinging(Seq<{i8,i8,str}>, ExecCtx, i4):Seq<{i8,i8,str}>
      1) ldarg.0 [Arr<obj>]
      1) ldc.i4.0
      5) ldelem [Func<{i8,i8,str},str>]
      1) ldarg.0 [Arr<obj>]
      1) ldc.i4.1
      5) ldelem [Func<{i8,i8,str},{i8,i8}>]
      1) ldarg.0 [Arr<obj>]
      1) ldc.i4.2
      5) ldelem [Func<str,Seq<{i8,i8}>,{str,Seq<{i8,i8}>}>]
      5) call static Enumerable::GroupBy(Seq<{i8,i8,str}>, Func<{i8,i8,str},str>, Func<{i8,i8,str},{i8,i8}>, Func<str,Seq<{i8,i8}>,{str,Seq<{i8,i8}>}>):Seq<{str,Seq<{i8,i8}>}>
      5) call static CodeGenUtil::EnumerableToCaching(Seq<{str,Seq<{i8,i8}>}>):Seq<{str,Seq<{i8,i8}>}>
  Label [1]:
      1) ret
  Total Size: 71

Func sig: (<ctx>:x, D:{Id:i8, M:i8, N:s}*) to {N:s, X:{Id:i8, M:i8}*}*
Sequence: Seq<{str,Seq<{i8,i8}>}>
 0) { N: A, 
      X: Sequence: Seq<{i8,i8}>
         0) { Id: 0, M: 0 }
         1) { Id: 4, M: 1 }
         2) { Id: 7, M: 1 }
    }
 1) { N: b, 
      X: Sequence: Seq<{i8,i8}>
         0) { Id: 1, M: 1 }
         1) { Id: 5, M: 2 }
         2) { Id: 8, M: 2 }
    }
 2) { N: B, 
      X: Sequence: Seq<{i8,i8}>
         0) { Id: 2, M: 2 }
         1) { Id: 11, M: 2 }
    }
 3) { N: a, 
      X: Sequence: Seq<{i8,i8}>
         0) { Id: 3, M: 0 }
         1) { Id: 10, M: 1 }
    }
 4) { N: <null>, 
      X: Sequence: Seq<{i8,i8}>
         0) { Id: 6, M: 0 }
         1) { Id: 9, M: 0 }
         2) { Id: 12, M: 0 }
    }
*** Ctx ping count: 14
    [0](14): GroupBy(*1: D, [key] N:*1.N, [auto] X:<auto>)
###
> GroupBy(D, [~] N, X)
GroupBy(D, [~] N, X) : {N:s, X:{Id:i8, M:i8, N:s}*}*
BndKind:GroupBy, Type:{N:s, X:{Id:i8, M:i8, N:s}*}*, Bnd:(GroupBy([scope:1] Global(D), [~] N:GetField(Scope(1), N), [auto] X:<auto>))
// (<ctx>, ∂.D:{Id:i8, M:i8, N:s}*) : {N:s, X:{Id:i8, M:i8, N:s}*}*
keySelector(Arr<obj>, {i8,i8,str}):str
      1) ldarg.1 [{i8,i8,str}]
      5) ldfld {i8,i8,str}::_F2:str
      1) ret
  Total Size: 7

resultSelector(Arr<obj>, str, Seq<{i8,i8,str}>):{str,Seq<{i8,i8,str}>}
      5) newobj {str,Seq<{i8,i8,str}>}()
      1) dup
      1) ldc.i4.1
      5) stfld {str,Seq<{i8,i8,str}>}::_B0:u1
      1) stloc.0 [{str,Seq<{i8,i8,str}>}]
      1) ldloc.0 [{str,Seq<{i8,i8,str}>}]
      1) ldarg.1 [str]
      5) stfld {str,Seq<{i8,i8,str}>}::_F0:str
      1) ldloc.0 [{str,Seq<{i8,i8,str}>}]
      1) ldarg.2 [Seq<{i8,i8,str}>]
      5) call static CodeGenUtil::EnumerableToCaching(Seq<{i8,i8,str}>):Seq<{i8,i8,str}>
      5) stfld {str,Seq<{i8,i8,str}>}::_F1:Seq<{i8,i8,str}>
      1) ldloc.0 [{str,Seq<{i8,i8,str}>}]
      1) dup
      1) ldarg.0 [Arr<obj>]
      1) ldc.i4.0
      5) ldelem [RecordRuntimeTypeInfo]
      5) stfld {}::_rrti:RecordRuntimeTypeInfo
      1) ret
  Total Size: 47

top(Arr<obj>, Arr<obj>):obj
      1) ldarg.1 [Arr<obj>]
      1) ldc.i4.0
      1) ldelem.ref
      5) call static CodeGenUtil::ToRef(obj):ExecCtx
      1) stloc.0 [ExecCtx]
      1) ldarg.1 [Arr<obj>]
      1) ldc.i4.1
      1) ldelem.ref
      5) call static CodeGenUtil::ToRef(obj):Seq<{i8,i8,str}>
      1) stloc.1 [Seq<{i8,i8,str}>]
      1) ldloc.1 [Seq<{i8,i8,str}>]
      1) dup
      5) brtrue [0]
      1) pop
      1) ldnull
      5) br [1]
  Label [0]:
      1) ldloc.0 [ExecCtx]
      1) ldc.i4.0
      5) call static CodeGenUtil::EnumerableToPinging(Seq<{i8,i8,str}>, ExecCtx, i4):Seq<{i8,i8,str}>
      1) ldarg.0 [Arr<obj>]
      1) ldc.i4.0
      5) ldelem [Func<{i8,i8,str},str>]
      1) ldarg.0 [Arr<obj>]
      1) ldc.i4.1
      5) ldelem [Func<str,Seq<{i8,i8,str}>,{str,Seq<{i8,i8,str}>}>]
      5) ldsfld static EqCmpStrCi::Instance:EqCmpStrCi
      5) call static Enumerable::GroupBy(Seq<{i8,i8,str}>, Func<{i8,i8,str},str>, Func<str,Seq<{i8,i8,str}>,{str,Seq<{i8,i8,str}>}>, IEqualityComparer<str>):Seq<{str,Seq<{i8,i8,str}>}>
      5) call static CodeGenUtil::EnumerableToCaching(Seq<{str,Seq<{i8,i8,str}>}>):Seq<{str,Seq<{i8,i8,str}>}>
  Label [1]:
      1) ret
  Total Size: 69

Func sig: (<ctx>:x, D:{Id:i8, M:i8, N:s}*) to {N:s, X:{Id:i8, M:i8, N:s}*}*
Sequence: Seq<{str,Seq<{i8,i8,str}>}>
 0) { N: A, 
      X: Sequence: Seq<{i8,i8,str}>
         0) { Id: 0, M: 0, N: A }
         1) { Id: 3, M: 0, N: a }
         2) { Id: 4, M: 1, N: A }
         3) { Id: 7, M: 1, N: A }
         4) { Id: 10, M: 1, N: a }
    }
 1) { N: b, 
      X: Sequence: Seq<{i8,i8,str}>
         0) { Id: 1, M: 1, N: b }
         1) { Id: 2, M: 2, N: B }
         2) { Id: 5, M: 2, N: b }
         3) { Id: 8, M: 2, N: b }
         4) { Id: 11, M: 2, N: B }
    }
 2) { N: <null>, 
      X: Sequence: Seq<{i8,i8,str}>
         0) { Id: 6, M: 0, N: <null> }
         1) { Id: 9, M: 0, N: <null> }
         2) { Id: 12, M: 0, N: <null> }
    }
*** Ctx ping count: 14
    [0](14): GroupBy(*1: D, [~] N:*1.N, [auto] X:<auto>)
###
> GroupBy(D, [~] N, M, X)
GroupBy(D, [~] N, M, X) : {M:i8, N:s, X:{Id:i8, N:s}*}*
BndKind:GroupBy, Type:{M:i8, N:s, X:{Id:i8, N:s}*}*, Bnd:(GroupBy([scope:1] Global(D), [key] M:GetField(Scope(1), M), [~] N:GetField(Scope(1), N), [auto] X:<auto>))
// (<ctx>, ∂.D:{Id:i8, M:i8, N:s}*) : {M:i8, N:s, X:{Id:i8, N:s}*}*
elementSelector(Arr<obj>, {i8,i8,str}):{i8,str}
      5) newobj {i8,str}()
      1) dup
      1) ldc.i4.3
      5) stfld {i8,str}::_B0:u1
      1) stloc.0 [{i8,str}]
      1) ldloc.0 [{i8,str}]
      1) ldarg.1 [{i8,i8,str}]
      5) ldfld {i8,i8,str}::_F0:i8
      5) stfld {i8,str}::_F0:i8
      1) ldloc.0 [{i8,str}]
      1) ldarg.1 [{i8,i8,str}]
      5) ldfld {i8,i8,str}::_F2:str
      5) stfld {i8,str}::_F1:str
      1) ldloc.0 [{i8,str}]
      1) dup
      1) ldarg.0 [Arr<obj>]
      1) ldc.i4.0
      5) ldelem [RecordRuntimeTypeInfo]
      5) stfld {}::_rrti:RecordRuntimeTypeInfo
      1) ret
  Total Size: 52

resultSelector(Arr<obj>, {i8,i8,str}, Seq<{i8,str}>):{i8,str,Seq<{i8,str}>}
      5) newobj {i8,str,Seq<{i8,str}>}()
      1) dup
      1) ldc.i4.3
      5) stfld {i8,str,Seq<{i8,str}>}::_B0:u1
      1) stloc.0 [{i8,str,Seq<{i8,str}>}]
      1) ldloc.0 [{i8,str,Seq<{i8,str}>}]
      1) ldarg.1 [{i8,i8,str}]
      5) ldfld {i8,i8,str}::_F1:i8
      5) stfld {i8,str,Seq<{i8,str}>}::_F0:i8
      1) ldloc.0 [{i8,str,Seq<{i8,str}>}]
      1) ldarg.1 [{i8,i8,str}]
      5) ldfld {i8,i8,str}::_F2:str
      5) stfld {i8,str,Seq<{i8,str}>}::_F1:str
      1) ldloc.0 [{i8,str,Seq<{i8,str}>}]
      1) ldarg.2 [Seq<{i8,str}>]
      5) call static CodeGenUtil::EnumerableToCaching(Seq<{i8,str}>):Seq<{i8,str}>
      5) stfld {i8,str,Seq<{i8,str}>}::_F2:Seq<{i8,str}>
      1) ldloc.0 [{i8,str,Seq<{i8,str}>}]
      1) dup
      1) ldarg.0 [Arr<obj>]
      1) ldc.i4.0
      5) ldelem [RecordRuntimeTypeInfo]
      5) stfld {}::_rrti:RecordRuntimeTypeInfo
      1) ret
  Total Size: 64

Equals(Arr<obj>, {i8,i8,str}, {i8,i8,str}):bool
      1) ldarg.1 [{i8,i8,str}]
      5) ldfld {i8,i8,str}::_F1:i8
      1) ldarg.2 [{i8,i8,str}]
      5) ldfld {i8,i8,str}::_F1:i8
      5) bne.un [0]
      1) ldarg.1 [{i8,i8,str}]
      5) ldfld {i8,i8,str}::_F2:str
      1) ldarg.2 [{i8,i8,str}]
      5) ldfld {i8,i8,str}::_F2:str
      5) call static StrComparer::EqCi(str, str):bool
      5) br [1]
  Label [0]:
      1) ldc.i4.0
  Label [1]:
      1) ret
  Total Size: 41

GetHashCode(Arr<obj>, {i8,i8,str}):i4
      1) ldarg.1 [{i8,i8,str}]
      5) ldfld {i8,i8,str}::_F1:i8
      1) ldarg.1 [{i8,i8,str}]
      5) ldfld {i8,i8,str}::_F2:str
      5) call static StrComparer::GetHashCodeCi(str):i4
      5) call static HashCode::Combine(i8, i4):i4
      1) ret
  Total Size: 23

top(Arr<obj>, Arr<obj>):obj
      1) ldarg.1 [Arr<obj>]
      1) ldc.i4.0
      1) ldelem.ref
      5) call static CodeGenUtil::ToRef(obj):ExecCtx
      1) stloc.0 [ExecCtx]
      1) ldarg.1 [Arr<obj>]
      1) ldc.i4.1
      1) ldelem.ref
      5) call static CodeGenUtil::ToRef(obj):Seq<{i8,i8,str}>
      1) stloc.1 [Seq<{i8,i8,str}>]
      1) ldloc.1 [Seq<{i8,i8,str}>]
      1) dup
      5) brtrue [0]
      1) pop
      1) ldnull
      5) br [1]
  Label [0]:
      1) ldloc.0 [ExecCtx]
      1) ldc.i4.0
      5) call static CodeGenUtil::EnumerableToPinging(Seq<{i8,i8,str}>, ExecCtx, i4):Seq<{i8,i8,str}>
      1) ldarg.0 [Arr<obj>]
      1) ldc.i4.0
      5) ldelem [Func<{i8,i8,str},{i8,i8,str}>]
      1) ldarg.0 [Arr<obj>]
      1) ldc.i4.1
      5) ldelem [Func<{i8,i8,str},{i8,str}>]
      1) ldarg.0 [Arr<obj>]
      1) ldc.i4.2
      5) ldelem [Func<{i8,i8,str},Seq<{i8,str}>,{i8,str,Seq<{i8,str}>}>]
      1) ldarg.0 [Arr<obj>]
      1) ldc.i4.3
      5) ldelem [GroupByComparer<{i8,i8,str}>]
      5) call static Enumerable::GroupBy(Seq<{i8,i8,str}>, Func<{i8,i8,str},{i8,i8,str}>, Func<{i8,i8,str},{i8,str}>, Func<{i8,i8,str},Seq<{i8,str}>,{i8,str,Seq<{i8,str}>}>, IEqualityComparer<{i8,i8,str}>):Seq<{i8,str,Seq<{i8,str}>}>
      5) call static CodeGenUtil::EnumerableToCaching(Seq<{i8,str,Seq<{i8,str}>}>):Seq<{i8,str,Seq<{i8,str}>}>
  Label [1]:
      1) ret
  Total Size: 78

Func sig: (<ctx>:x, D:{Id:i8, M:i8, N:s}*) to {M:i8, N:s, X:{Id:i8, N:s}*}*
Sequence: Seq<{i8,str,Seq<{i8,str}>}>
 0) { M: 0, N: A, 
      X: Sequence: Seq<{i8,str}>
         0) { Id: 0, N: A }
         1) { Id: 3, N: a }
    }
 1) { M: 1, N: b, 
      X: Sequence: Seq<{i8,str}>
         0) { Id: 1, N: b }
    }
 2) { M: 2, N: B, 
      X: Sequence: Seq<{i8,str}>
         0) { Id: 2, N: B }
         1) { Id: 5, N: b }
         2) { Id: 8, N: b }
         3) { Id: 11, N: B }
    }
 3) { M: 1, N: A, 
      X: Sequence: Seq<{i8,str}>
         0) { Id: 4, N: A }
         1) { Id: 7, N: A }
         2) { Id: 10, N: a }
    }
 4) { M: 0, N: <null>, 
      X: Sequence: Seq<{i8,str}>
         0) { Id: 6, N: <null> }
         1) { Id: 9, N: <null> }
         2) { Id: 12, N: <null> }
    }
*** Ctx ping count: 14
    [0](14): GroupBy(*1: D, [key] M:*1.M, [~] N:*1.N, [auto] X:<auto>)
###
> GroupBy(D, [~] _: N, M, X)
GroupBy(D, [~] _ : N, M, X) : {M:i8, X:{Id:i8, N:s}*}*
BndKind:GroupBy, Type:{M:i8, X:{Id:i8, N:s}*}*, Bnd:(GroupBy([scope:1] Global(D), [~] GetField(Scope(1), N), [key] M:GetField(Scope(1), M), [auto] X:<auto>))
// (<ctx>, ∂.D:{Id:i8, M:i8, N:s}*) : {M:i8, X:{Id:i8, N:s}*}*
elementSelector(Arr<obj>, {i8,i8,str}):{i8,str}
      5) newobj {i8,str}()
      1) dup
      1) ldc.i4.3
      5) stfld {i8,str}::_B0:u1
      1) stloc.0 [{i8,str}]
      1) ldloc.0 [{i8,str}]
      1) ldarg.1 [{i8,i8,str}]
      5) ldfld {i8,i8,str}::_F0:i8
      5) stfld {i8,str}::_F0:i8
      1) ldloc.0 [{i8,str}]
      1) ldarg.1 [{i8,i8,str}]
      5) ldfld {i8,i8,str}::_F2:str
      5) stfld {i8,str}::_F1:str
      1) ldloc.0 [{i8,str}]
      1) dup
      1) ldarg.0 [Arr<obj>]
      1) ldc.i4.0
      5) ldelem [RecordRuntimeTypeInfo]
      5) stfld {}::_rrti:RecordRuntimeTypeInfo
      1) ret
  Total Size: 52

resultSelector(Arr<obj>, {i8,i8,str}, Seq<{i8,str}>):{i8,Seq<{i8,str}>}
      5) newobj {i8,Seq<{i8,str}>}()
      1) dup
      1) ldc.i4.1
      5) stfld {i8,Seq<{i8,str}>}::_B0:u1
      1) stloc.0 [{i8,Seq<{i8,str}>}]
      1) ldloc.0 [{i8,Seq<{i8,str}>}]
      1) ldarg.1 [{i8,i8,str}]
      5) ldfld {i8,i8,str}::_F1:i8
      5) stfld {i8,Seq<{i8,str}>}::_F0:i8
      1) ldloc.0 [{i8,Seq<{i8,str}>}]
      1) ldarg.2 [Seq<{i8,str}>]
      5) call static CodeGenUtil::EnumerableToCaching(Seq<{i8,str}>):Seq<{i8,str}>
      5) stfld {i8,Seq<{i8,str}>}::_F1:Seq<{i8,str}>
      1) ldloc.0 [{i8,Seq<{i8,str}>}]
      1) dup
      1) ldarg.0 [Arr<obj>]
      1) ldc.i4.0
      5) ldelem [RecordRuntimeTypeInfo]
      5) stfld {}::_rrti:RecordRuntimeTypeInfo
      1) ret
  Total Size: 52

Equals(Arr<obj>, {i8,i8,str}, {i8,i8,str}):bool
      1) ldarg.1 [{i8,i8,str}]
      5) ldfld {i8,i8,str}::_F2:str
      1) ldarg.2 [{i8,i8,str}]
      5) ldfld {i8,i8,str}::_F2:str
      5) call static StrComparer::EqCi(str, str):bool
      5) brfalse [0]
      1) ldarg.1 [{i8,i8,str}]
      5) ldfld {i8,i8,str}::_F1:i8
      1) ldarg.2 [{i8,i8,str}]
      5) ldfld {i8,i8,str}::_F1:i8
      2) ceq
      5) br [1]
  Label [0]:
      1) ldc.i4.0
  Label [1]:
      1) ret
  Total Size: 43

GetHashCode(Arr<obj>, {i8,i8,str}):i4
      1) ldarg.1 [{i8,i8,str}]
      5) ldfld {i8,i8,str}::_F2:str
      5) call static StrComparer::GetHashCodeCi(str):i4
      1) ldarg.1 [{i8,i8,str}]
      5) ldfld {i8,i8,str}::_F1:i8
      5) call static HashCode::Combine(i4, i8):i4
      1) ret
  Total Size: 23

top(Arr<obj>, Arr<obj>):obj
      1) ldarg.1 [Arr<obj>]
      1) ldc.i4.0
      1) ldelem.ref
      5) call static CodeGenUtil::ToRef(obj):ExecCtx
      1) stloc.0 [ExecCtx]
      1) ldarg.1 [Arr<obj>]
      1) ldc.i4.1
      1) ldelem.ref
      5) call static CodeGenUtil::ToRef(obj):Seq<{i8,i8,str}>
      1) stloc.1 [Seq<{i8,i8,str}>]
      1) ldloc.1 [Seq<{i8,i8,str}>]
      1) dup
      5) brtrue [0]
      1) pop
      1) ldnull
      5) br [1]
  Label [0]:
      1) ldloc.0 [ExecCtx]
      1) ldc.i4.0
      5) call static CodeGenUtil::EnumerableToPinging(Seq<{i8,i8,str}>, ExecCtx, i4):Seq<{i8,i8,str}>
      1) ldarg.0 [Arr<obj>]
      1) ldc.i4.0
      5) ldelem [Func<{i8,i8,str},{i8,i8,str}>]
      1) ldarg.0 [Arr<obj>]
      1) ldc.i4.1
      5) ldelem [Func<{i8,i8,str},{i8,str}>]
      1) ldarg.0 [Arr<obj>]
      1) ldc.i4.2
      5) ldelem [Func<{i8,i8,str},Seq<{i8,str}>,{i8,Seq<{i8,str}>}>]
      1) ldarg.0 [Arr<obj>]
      1) ldc.i4.3
      5) ldelem [GroupByComparer<{i8,i8,str}>]
      5) call static Enumerable::GroupBy(Seq<{i8,i8,str}>, Func<{i8,i8,str},{i8,i8,str}>, Func<{i8,i8,str},{i8,str}>, Func<{i8,i8,str},Seq<{i8,str}>,{i8,Seq<{i8,str}>}>, IEqualityComparer<{i8,i8,str}>):Seq<{i8,Seq<{i8,str}>}>
      5) call static CodeGenUtil::EnumerableToCaching(Seq<{i8,Seq<{i8,str}>}>):Seq<{i8,Seq<{i8,str}>}>
  Label [1]:
      1) ret
  Total Size: 78

Func sig: (<ctx>:x, D:{Id:i8, M:i8, N:s}*) to {M:i8, X:{Id:i8, N:s}*}*
Sequence: Seq<{i8,Seq<{i8,str}>}>
 0) { M: 0, 
      X: Sequence: Seq<{i8,str}>
         0) { Id: 0, N: A }
         1) { Id: 3, N: a }
    }
 1) { M: 1, 
      X: Sequence: Seq<{i8,str}>
         0) { Id: 1, N: b }
    }
 2) { M: 2, 
      X: Sequence: Seq<{i8,str}>
         0) { Id: 2, N: B }
         1) { Id: 5, N: b }
         2) { Id: 8, N: b }
         3) { Id: 11, N: B }
    }
 3) { M: 1, 
      X: Sequence: Seq<{i8,str}>
         0) { Id: 4, N: A }
         1) { Id: 7, N: A }
         2) { Id: 10, N: a }
    }
 4) { M: 0, 
      X: Sequence: Seq<{i8,str}>
         0) { Id: 6, N: <null> }
         1) { Id: 9, N: <null> }
         2) { Id: 12, N: <null> }
    }
*** Ctx ping count: 14
    [0](14): GroupBy(*1: D, [~] *1.N, [key] M:*1.M, [auto] X:<auto>)
###
> GroupBy(D, [~] _: N, [key] _: M)
GroupBy(D, [~] _ : N, [key] _ : M) : {Id:i8, M:i8, N:s}**
BndKind:GroupBy, Type:{Id:i8, M:i8, N:s}**, Bnd:(GroupBy([scope:1] Global(D), [~] GetField(Scope(1), N), [key] GetField(Scope(1), M)))
// (<ctx>, ∂.D:{Id:i8, M:i8, N:s}*) : {Id:i8, M:i8, N:s}**
resultSelector(Arr<obj>, {i8,i8,str}, Seq<{i8,i8,str}>):Seq<{i8,i8,str}>
      1) ldarg.2 [Seq<{i8,i8,str}>]
      5) call static CodeGenUtil::EnumerableToCaching(Seq<{i8,i8,str}>):Seq<{i8,i8,str}>
      1) ret
  Total Size: 7

Equals(Arr<obj>, {i8,i8,str}, {i8,i8,str}):bool
      1) ldarg.1 [{i8,i8,str}]
      5) ldfld {i8,i8,str}::_F2:str
      1) ldarg.2 [{i8,i8,str}]
      5) ldfld {i8,i8,str}::_F2:str
      5) call static StrComparer::EqCi(str, str):bool
      5) brfalse [0]
      1) ldarg.1 [{i8,i8,str}]
      5) ldfld {i8,i8,str}::_F1:i8
      1) ldarg.2 [{i8,i8,str}]
      5) ldfld {i8,i8,str}::_F1:i8
      2) ceq
      5) br [1]
  Label [0]:
      1) ldc.i4.0
  Label [1]:
      1) ret
  Total Size: 43

GetHashCode(Arr<obj>, {i8,i8,str}):i4
      1) ldarg.1 [{i8,i8,str}]
      5) ldfld {i8,i8,str}::_F2:str
      5) call static StrComparer::GetHashCodeCi(str):i4
      1) ldarg.1 [{i8,i8,str}]
      5) ldfld {i8,i8,str}::_F1:i8
      5) call static HashCode::Combine(i4, i8):i4
      1) ret
  Total Size: 23

top(Arr<obj>, Arr<obj>):obj
      1) ldarg.1 [Arr<obj>]
      1) ldc.i4.0
      1) ldelem.ref
      5) call static CodeGenUtil::ToRef(obj):ExecCtx
      1) stloc.0 [ExecCtx]
      1) ldarg.1 [Arr<obj>]
      1) ldc.i4.1
      1) ldelem.ref
      5) call static CodeGenUtil::ToRef(obj):Seq<{i8,i8,str}>
      1) stloc.1 [Seq<{i8,i8,str}>]
      1) ldloc.1 [Seq<{i8,i8,str}>]
      1) dup
      5) brtrue [0]
      1) pop
      1) ldnull
      5) br [1]
  Label [0]:
      1) ldloc.0 [ExecCtx]
      1) ldc.i4.0
      5) call static CodeGenUtil::EnumerableToPinging(Seq<{i8,i8,str}>, ExecCtx, i4):Seq<{i8,i8,str}>
      1) ldarg.0 [Arr<obj>]
      1) ldc.i4.0
      5) ldelem [Func<{i8,i8,str},{i8,i8,str}>]
      1) ldarg.0 [Arr<obj>]
      1) ldc.i4.1
      5) ldelem [Func<{i8,i8,str},Seq<{i8,i8,str}>,Seq<{i8,i8,str}>>]
      1) ldarg.0 [Arr<obj>]
      1) ldc.i4.2
      5) ldelem [GroupByComparer<{i8,i8,str}>]
      5) call static Enumerable::GroupBy(Seq<{i8,i8,str}>, Func<{i8,i8,str},{i8,i8,str}>, Func<{i8,i8,str},Seq<{i8,i8,str}>,Seq<{i8,i8,str}>>, IEqualityComparer<{i8,i8,str}>):Seq<Seq<{i8,i8,str}>>
      5) call static CodeGenUtil::EnumerableToCaching(Seq<Seq<{i8,i8,str}>>):Seq<Seq<{i8,i8,str}>>
  Label [1]:
      1) ret
  Total Size: 71

Func sig: (<ctx>:x, D:{Id:i8, M:i8, N:s}*) to {Id:i8, M:i8, N:s}**
Sequence: Seq<Seq<{i8,i8,str}>>
 0) Sequence: Seq<{i8,i8,str}>
     0) { Id: 0, M: 0, N: A }
     1) { Id: 3, M: 0, N: a }
 1) Sequence: Seq<{i8,i8,str}>
     0) { Id: 1, M: 1, N: b }
 2) Sequence: Seq<{i8,i8,str}>
     0) { Id: 2, M: 2, N: B }
     1) { Id: 5, M: 2, N: b }
     2) { Id: 8, M: 2, N: b }
     3) { Id: 11, M: 2, N: B }
 3) Sequence: Seq<{i8,i8,str}>
     0) { Id: 4, M: 1, N: A }
     1) { Id: 7, M: 1, N: A }
     2) { Id: 10, M: 1, N: a }
 4) Sequence: Seq<{i8,i8,str}>
     0) { Id: 6, M: 0, N: <null> }
     1) { Id: 9, M: 0, N: <null> }
     2) { Id: 12, M: 0, N: <null> }
*** Ctx ping count: 14
    [0](14): GroupBy(*1: D, [~] *1.N, [key] *1.M)
###
> GroupBy(D, [key] _: M, [~] _: N)
GroupBy(D, [key] _ : M, [~] _ : N) : {Id:i8, M:i8, N:s}**
BndKind:GroupBy, Type:{Id:i8, M:i8, N:s}**, Bnd:(GroupBy([scope:1] Global(D), [key] GetField(Scope(1), M), [~] GetField(Scope(1), N)))
// (<ctx>, ∂.D:{Id:i8, M:i8, N:s}*) : {Id:i8, M:i8, N:s}**
resultSelector(Arr<obj>, {i8,i8,str}, Seq<{i8,i8,str}>):Seq<{i8,i8,str}>
      1) ldarg.2 [Seq<{i8,i8,str}>]
      5) call static CodeGenUtil::EnumerableToCaching(Seq<{i8,i8,str}>):Seq<{i8,i8,str}>
      1) ret
  Total Size: 7

Equals(Arr<obj>, {i8,i8,str}, {i8,i8,str}):bool
      1) ldarg.1 [{i8,i8,str}]
      5) ldfld {i8,i8,str}::_F1:i8
      1) ldarg.2 [{i8,i8,str}]
      5) ldfld {i8,i8,str}::_F1:i8
      5) bne.un [0]
      1) ldarg.1 [{i8,i8,str}]
      5) ldfld {i8,i8,str}::_F2:str
      1) ldarg.2 [{i8,i8,str}]
      5) ldfld {i8,i8,str}::_F2:str
      5) call static StrComparer::EqCi(str, str):bool
      5) br [1]
  Label [0]:
      1) ldc.i4.0
  Label [1]:
      1) ret
  Total Size: 41

GetHashCode(Arr<obj>, {i8,i8,str}):i4
      1) ldarg.1 [{i8,i8,str}]
      5) ldfld {i8,i8,str}::_F1:i8
      1) ldarg.1 [{i8,i8,str}]
      5) ldfld {i8,i8,str}::_F2:str
      5) call static StrComparer::GetHashCodeCi(str):i4
      5) call static HashCode::Combine(i8, i4):i4
      1) ret
  Total Size: 23

top(Arr<obj>, Arr<obj>):obj
      1) ldarg.1 [Arr<obj>]
      1) ldc.i4.0
      1) ldelem.ref
      5) call static CodeGenUtil::ToRef(obj):ExecCtx
      1) stloc.0 [ExecCtx]
      1) ldarg.1 [Arr<obj>]
      1) ldc.i4.1
      1) ldelem.ref
      5) call static CodeGenUtil::ToRef(obj):Seq<{i8,i8,str}>
      1) stloc.1 [Seq<{i8,i8,str}>]
      1) ldloc.1 [Seq<{i8,i8,str}>]
      1) dup
      5) brtrue [0]
      1) pop
      1) ldnull
      5) br [1]
  Label [0]:
      1) ldloc.0 [ExecCtx]
      1) ldc.i4.0
      5) call static CodeGenUtil::EnumerableToPinging(Seq<{i8,i8,str}>, ExecCtx, i4):Seq<{i8,i8,str}>
      1) ldarg.0 [Arr<obj>]
      1) ldc.i4.0
      5) ldelem [Func<{i8,i8,str},{i8,i8,str}>]
      1) ldarg.0 [Arr<obj>]
      1) ldc.i4.1
      5) ldelem [Func<{i8,i8,str},Seq<{i8,i8,str}>,Seq<{i8,i8,str}>>]
      1) ldarg.0 [Arr<obj>]
      1) ldc.i4.2
      5) ldelem [GroupByComparer<{i8,i8,str}>]
      5) call static Enumerable::GroupBy(Seq<{i8,i8,str}>, Func<{i8,i8,str},{i8,i8,str}>, Func<{i8,i8,str},Seq<{i8,i8,str}>,Seq<{i8,i8,str}>>, IEqualityComparer<{i8,i8,str}>):Seq<Seq<{i8,i8,str}>>
      5) call static CodeGenUtil::EnumerableToCaching(Seq<Seq<{i8,i8,str}>>):Seq<Seq<{i8,i8,str}>>
  Label [1]:
      1) ret
  Total Size: 71

Func sig: (<ctx>:x, D:{Id:i8, M:i8, N:s}*) to {Id:i8, M:i8, N:s}**
Sequence: Seq<Seq<{i8,i8,str}>>
 0) Sequence: Seq<{i8,i8,str}>
     0) { Id: 0, M: 0, N: A }
     1) { Id: 3, M: 0, N: a }
 1) Sequence: Seq<{i8,i8,str}>
     0) { Id: 1, M: 1, N: b }
 2) Sequence: Seq<{i8,i8,str}>
     0) { Id: 2, M: 2, N: B }
     1) { Id: 5, M: 2, N: b }
     2) { Id: 8, M: 2, N: b }
     3) { Id: 11, M: 2, N: B }
 3) Sequence: Seq<{i8,i8,str}>
     0) { Id: 4, M: 1, N: A }
     1) { Id: 7, M: 1, N: A }
     2) { Id: 10, M: 1, N: a }
 4) Sequence: Seq<{i8,i8,str}>
     0) { Id: 6, M: 0, N: <null> }
     1) { Id: 9, M: 0, N: <null> }
     2) { Id: 12, M: 0, N: <null> }
*** Ctx ping count: 14
    [0](14): GroupBy(*1: D, [key] *1.M, [~] *1.N)
###
> GroupBy(D, [~] _: N, [~]   _: N & N)
GroupBy(D, [~] _ : N, [~] _ : N & N) : {Id:i8, M:i8, N:s}**
BndKind:GroupBy, Type:{Id:i8, M:i8, N:s}**, Bnd:(GroupBy([scope:1] Global(D), [~] GetField(Scope(1), N), [~] StrConcat(GetField(Scope(1), N), GetField(Scope(1), N))))
// (<ctx>, ∂.D:{Id:i8, M:i8, N:s}*) : {Id:i8, M:i8, N:s}**
keySelector(Arr<obj>, {i8,i8,str}):{str,str}
      5) newobj {str,str}()
      1) dup
      1) ldc.i4.3
      5) stfld {str,str}::_B0:u1
      1) stloc.0 [{str,str}]
      1) ldloc.0 [{str,str}]
      1) ldarg.1 [{i8,i8,str}]
      5) ldfld {i8,i8,str}::_F2:str
      5) stfld {str,str}::_F0:str
      1) ldloc.0 [{str,str}]
      1) ldarg.1 [{i8,i8,str}]
      5) ldfld {i8,i8,str}::_F2:str
      1) ldarg.1 [{i8,i8,str}]
      5) ldfld {i8,i8,str}::_F2:str
      5) call static str::Concat(str, str):str
      5) stfld {str,str}::_F1:str
      1) ldloc.0 [{str,str}]
      1) dup
      1) ldarg.0 [Arr<obj>]
      1) ldc.i4.0
      5) ldelem [RecordRuntimeTypeInfo]
      5) stfld {}::_rrti:RecordRuntimeTypeInfo
      1) ret
  Total Size: 63

resultSelector(Arr<obj>, {str,str}, Seq<{i8,i8,str}>):Seq<{i8,i8,str}>
      1) ldarg.2 [Seq<{i8,i8,str}>]
      5) call static CodeGenUtil::EnumerableToCaching(Seq<{i8,i8,str}>):Seq<{i8,i8,str}>
      1) ret
  Total Size: 7

top(Arr<obj>, Arr<obj>):obj
      1) ldarg.1 [Arr<obj>]
      1) ldc.i4.0
      1) ldelem.ref
      5) call static CodeGenUtil::ToRef(obj):ExecCtx
      1) stloc.0 [ExecCtx]
      1) ldarg.1 [Arr<obj>]
      1) ldc.i4.1
      1) ldelem.ref
      5) call static CodeGenUtil::ToRef(obj):Seq<{i8,i8,str}>
      1) stloc.1 [Seq<{i8,i8,str}>]
      1) ldloc.1 [Seq<{i8,i8,str}>]
      1) dup
      5) brtrue [0]
      1) pop
      1) ldnull
      5) br [1]
  Label [0]:
      1) ldloc.0 [ExecCtx]
      1) ldc.i4.0
      5) call static CodeGenUtil::EnumerableToPinging(Seq<{i8,i8,str}>, ExecCtx, i4):Seq<{i8,i8,str}>
      1) ldarg.0 [Arr<obj>]
      1) ldc.i4.0
      5) ldelem [Func<{i8,i8,str},{str,str}>]
      1) ldarg.0 [Arr<obj>]
      1) ldc.i4.1
      5) ldelem [Func<{str,str},Seq<{i8,i8,str}>,Seq<{i8,i8,str}>>]
      1) ldarg.0 [Arr<obj>]
      1) ldc.i4.2
      5) ldelem [EqualityComparer<{str,str}>]
      5) call static Enumerable::GroupBy(Seq<{i8,i8,str}>, Func<{i8,i8,str},{str,str}>, Func<{str,str},Seq<{i8,i8,str}>,Seq<{i8,i8,str}>>, IEqualityComparer<{str,str}>):Seq<Seq<{i8,i8,str}>>
      5) call static CodeGenUtil::EnumerableToCaching(Seq<Seq<{i8,i8,str}>>):Seq<Seq<{i8,i8,str}>>
  Label [1]:
      1) ret
  Total Size: 71

Func sig: (<ctx>:x, D:{Id:i8, M:i8, N:s}*) to {Id:i8, M:i8, N:s}**
Sequence: Seq<Seq<{i8,i8,str}>>
 0) Sequence: Seq<{i8,i8,str}>
     0) { Id: 0, M: 0, N: A }
     1) { Id: 3, M: 0, N: a }
     2) { Id: 4, M: 1, N: A }
     3) { Id: 7, M: 1, N: A }
     4) { Id: 10, M: 1, N: a }
 1) Sequence: Seq<{i8,i8,str}>
     0) { Id: 1, M: 1, N: b }
     1) { Id: 2, M: 2, N: B }
     2) { Id: 5, M: 2, N: b }
     3) { Id: 8, M: 2, N: b }
     4) { Id: 11, M: 2, N: B }
 2) Sequence: Seq<{i8,i8,str}>
     0) { Id: 6, M: 0, N: <null> }
     1) { Id: 9, M: 0, N: <null> }
     2) { Id: 12, M: 0, N: <null> }
*** Ctx ping count: 14
    [0](14): GroupBy(*1: D, [~] *1.N, [~] StrConcat(*1.N, *1.N))
###
> GroupBy(D, [~] _: N, [key] _: N.Lower)
GroupBy(D, [~] _ : N, [key] _ : N.Lower) : {Id:i8, M:i8, N:s}**
BndKind:GroupBy, Type:{Id:i8, M:i8, N:s}**, Bnd:(GroupBy([scope:1] Global(D), [~] GetField(Scope(1), N), [key] Call(∂.Text.Lower(GetField(Scope(1), N)):s)))
// (<ctx>, ∂.D:{Id:i8, M:i8, N:s}*) : {Id:i8, M:i8, N:s}**
keySelector(Arr<obj>, {i8,i8,str}):{str,str}
      5) newobj {str,str}()
      1) dup
      1) ldc.i4.3
      5) stfld {str,str}::_B0:u1
      1) stloc.0 [{str,str}]
      1) ldloc.0 [{str,str}]
      1) ldarg.1 [{i8,i8,str}]
      5) ldfld {i8,i8,str}::_F2:str
      5) stfld {str,str}::_F0:str
      1) ldloc.0 [{str,str}]
      1) ldarg.1 [{i8,i8,str}]
      5) ldfld {i8,i8,str}::_F2:str
      5) call static TextCaseFunc::ExecLower(str):str
      5) stfld {str,str}::_F1:str
      1) ldloc.0 [{str,str}]
      1) dup
      1) ldarg.0 [Arr<obj>]
      1) ldc.i4.0
      5) ldelem [RecordRuntimeTypeInfo]
      5) stfld {}::_rrti:RecordRuntimeTypeInfo
      1) ret
  Total Size: 57

resultSelector(Arr<obj>, {str,str}, Seq<{i8,i8,str}>):Seq<{i8,i8,str}>
      1) ldarg.2 [Seq<{i8,i8,str}>]
      5) call static CodeGenUtil::EnumerableToCaching(Seq<{i8,i8,str}>):Seq<{i8,i8,str}>
      1) ret
  Total Size: 7

Equals(Arr<obj>, {str,str}, {str,str}):bool
      1) ldarg.1 [{str,str}]
      5) ldfld {str,str}::_F0:str
      1) ldarg.2 [{str,str}]
      5) ldfld {str,str}::_F0:str
      5) call static StrComparer::EqCi(str, str):bool
      5) brfalse [0]
      1) ldarg.1 [{str,str}]
      5) ldfld {str,str}::_F1:str
      1) ldarg.2 [{str,str}]
      5) ldfld {str,str}::_F1:str
      5) call static str::Equals(str, str):bool
      5) br [1]
  Label [0]:
      1) ldc.i4.0
  Label [1]:
      1) ret
  Total Size: 46

GetHashCode(Arr<obj>, {str,str}):i4
      1) ldarg.1 [{str,str}]
      5) ldfld {str,str}::_F0:str
      5) call static StrComparer::GetHashCodeCi(str):i4
      1) ldarg.1 [{str,str}]
      5) ldfld {str,str}::_F1:str
      5) call static HashCode::Combine(i4, str):i4
      1) ret
  Total Size: 23

top(Arr<obj>, Arr<obj>):obj
      1) ldarg.1 [Arr<obj>]
      1) ldc.i4.0
      1) ldelem.ref
      5) call static CodeGenUtil::ToRef(obj):ExecCtx
      1) stloc.0 [ExecCtx]
      1) ldarg.1 [Arr<obj>]
      1) ldc.i4.1
      1) ldelem.ref
      5) call static CodeGenUtil::ToRef(obj):Seq<{i8,i8,str}>
      1) stloc.1 [Seq<{i8,i8,str}>]
      1) ldloc.1 [Seq<{i8,i8,str}>]
      1) dup
      5) brtrue [0]
      1) pop
      1) ldnull
      5) br [1]
  Label [0]:
      1) ldloc.0 [ExecCtx]
      1) ldc.i4.0
      5) call static CodeGenUtil::EnumerableToPinging(Seq<{i8,i8,str}>, ExecCtx, i4):Seq<{i8,i8,str}>
      1) ldarg.0 [Arr<obj>]
      1) ldc.i4.0
      5) ldelem [Func<{i8,i8,str},{str,str}>]
      1) ldarg.0 [Arr<obj>]
      1) ldc.i4.1
      5) ldelem [Func<{str,str},Seq<{i8,i8,str}>,Seq<{i8,i8,str}>>]
      1) ldarg.0 [Arr<obj>]
      1) ldc.i4.2
      5) ldelem [GroupByComparer<{str,str}>]
      5) call static Enumerable::GroupBy(Seq<{i8,i8,str}>, Func<{i8,i8,str},{str,str}>, Func<{str,str},Seq<{i8,i8,str}>,Seq<{i8,i8,str}>>, IEqualityComparer<{str,str}>):Seq<Seq<{i8,i8,str}>>
      5) call static CodeGenUtil::EnumerableToCaching(Seq<Seq<{i8,i8,str}>>):Seq<Seq<{i8,i8,str}>>
  Label [1]:
      1) ret
  Total Size: 71

Func sig: (<ctx>:x, D:{Id:i8, M:i8, N:s}*) to {Id:i8, M:i8, N:s}**
Sequence: Seq<Seq<{i8,i8,str}>>
 0) Sequence: Seq<{i8,i8,str}>
     0) { Id: 0, M: 0, N: A }
     1) { Id: 3, M: 0, N: a }
     2) { Id: 4, M: 1, N: A }
     3) { Id: 7, M: 1, N: A }
     4) { Id: 10, M: 1, N: a }
 1) Sequence: Seq<{i8,i8,str}>
     0) { Id: 1, M: 1, N: b }
     1) { Id: 2, M: 2, N: B }
     2) { Id: 5, M: 2, N: b }
     3) { Id: 8, M: 2, N: b }
     4) { Id: 11, M: 2, N: B }
 2) Sequence: Seq<{i8,i8,str}>
     0) { Id: 6, M: 0, N: <null> }
     1) { Id: 9, M: 0, N: <null> }
     2) { Id: 12, M: 0, N: <null> }
*** Ctx ping count: 14
    [0](14): GroupBy(*1: D, [~] *1.N, [key] Text.Lower(*1.N))
###
> GroupBy(D, [key] _: N.Upper, [~] _: N)
GroupBy(D, [key] _ : N.Upper, [~] _ : N) : {Id:i8, M:i8, N:s}**
BndKind:GroupBy, Type:{Id:i8, M:i8, N:s}**, Bnd:(GroupBy([scope:1] Global(D), [key] Call(∂.Text.Upper(GetField(Scope(1), N)):s), [~] GetField(Scope(1), N)))
// (<ctx>, ∂.D:{Id:i8, M:i8, N:s}*) : {Id:i8, M:i8, N:s}**
keySelector(Arr<obj>, {i8,i8,str}):{str,str}
      5) newobj {str,str}()
      1) dup
      1) ldc.i4.3
      5) stfld {str,str}::_B0:u1
      1) stloc.0 [{str,str}]
      1) ldloc.0 [{str,str}]
      1) ldarg.1 [{i8,i8,str}]
      5) ldfld {i8,i8,str}::_F2:str
      5) call static TextCaseFunc::ExecUpper(str):str
      5) stfld {str,str}::_F0:str
      1) ldloc.0 [{str,str}]
      1) ldarg.1 [{i8,i8,str}]
      5) ldfld {i8,i8,str}::_F2:str
      5) stfld {str,str}::_F1:str
      1) ldloc.0 [{str,str}]
      1) dup
      1) ldarg.0 [Arr<obj>]
      1) ldc.i4.0
      5) ldelem [RecordRuntimeTypeInfo]
      5) stfld {}::_rrti:RecordRuntimeTypeInfo
      1) ret
  Total Size: 57

resultSelector(Arr<obj>, {str,str}, Seq<{i8,i8,str}>):Seq<{i8,i8,str}>
      1) ldarg.2 [Seq<{i8,i8,str}>]
      5) call static CodeGenUtil::EnumerableToCaching(Seq<{i8,i8,str}>):Seq<{i8,i8,str}>
      1) ret
  Total Size: 7

Equals(Arr<obj>, {str,str}, {str,str}):bool
      1) ldarg.1 [{str,str}]
      5) ldfld {str,str}::_F0:str
      1) ldarg.2 [{str,str}]
      5) ldfld {str,str}::_F0:str
      5) call static str::Equals(str, str):bool
      5) brfalse [0]
      1) ldarg.1 [{str,str}]
      5) ldfld {str,str}::_F1:str
      1) ldarg.2 [{str,str}]
      5) ldfld {str,str}::_F1:str
      5) call static StrComparer::EqCi(str, str):bool
      5) br [1]
  Label [0]:
      1) ldc.i4.0
  Label [1]:
      1) ret
  Total Size: 46

GetHashCode(Arr<obj>, {str,str}):i4
      1) ldarg.1 [{str,str}]
      5) ldfld {str,str}::_F0:str
      1) ldarg.1 [{str,str}]
      5) ldfld {str,str}::_F1:str
      5) call static StrComparer::GetHashCodeCi(str):i4
      5) call static HashCode::Combine(str, i4):i4
      1) ret
  Total Size: 23

top(Arr<obj>, Arr<obj>):obj
      1) ldarg.1 [Arr<obj>]
      1) ldc.i4.0
      1) ldelem.ref
      5) call static CodeGenUtil::ToRef(obj):ExecCtx
      1) stloc.0 [ExecCtx]
      1) ldarg.1 [Arr<obj>]
      1) ldc.i4.1
      1) ldelem.ref
      5) call static CodeGenUtil::ToRef(obj):Seq<{i8,i8,str}>
      1) stloc.1 [Seq<{i8,i8,str}>]
      1) ldloc.1 [Seq<{i8,i8,str}>]
      1) dup
      5) brtrue [0]
      1) pop
      1) ldnull
      5) br [1]
  Label [0]:
      1) ldloc.0 [ExecCtx]
      1) ldc.i4.0
      5) call static CodeGenUtil::EnumerableToPinging(Seq<{i8,i8,str}>, ExecCtx, i4):Seq<{i8,i8,str}>
      1) ldarg.0 [Arr<obj>]
      1) ldc.i4.0
      5) ldelem [Func<{i8,i8,str},{str,str}>]
      1) ldarg.0 [Arr<obj>]
      1) ldc.i4.1
      5) ldelem [Func<{str,str},Seq<{i8,i8,str}>,Seq<{i8,i8,str}>>]
      1) ldarg.0 [Arr<obj>]
      1) ldc.i4.2
      5) ldelem [GroupByComparer<{str,str}>]
      5) call static Enumerable::GroupBy(Seq<{i8,i8,str}>, Func<{i8,i8,str},{str,str}>, Func<{str,str},Seq<{i8,i8,str}>,Seq<{i8,i8,str}>>, IEqualityComparer<{str,str}>):Seq<Seq<{i8,i8,str}>>
      5) call static CodeGenUtil::EnumerableToCaching(Seq<Seq<{i8,i8,str}>>):Seq<Seq<{i8,i8,str}>>
  Label [1]:
      1) ret
  Total Size: 71

Func sig: (<ctx>:x, D:{Id:i8, M:i8, N:s}*) to {Id:i8, M:i8, N:s}**
Sequence: Seq<Seq<{i8,i8,str}>>
 0) Sequence: Seq<{i8,i8,str}>
     0) { Id: 0, M: 0, N: A }
     1) { Id: 3, M: 0, N: a }
     2) { Id: 4, M: 1, N: A }
     3) { Id: 7, M: 1, N: A }
     4) { Id: 10, M: 1, N: a }
 1) Sequence: Seq<{i8,i8,str}>
     0) { Id: 1, M: 1, N: b }
     1) { Id: 2, M: 2, N: B }
     2) { Id: 5, M: 2, N: b }
     3) { Id: 8, M: 2, N: b }
     4) { Id: 11, M: 2, N: B }
 2) Sequence: Seq<{i8,i8,str}>
     0) { Id: 6, M: 0, N: <null> }
     1) { Id: 9, M: 0, N: <null> }
     2) { Id: 12, M: 0, N: <null> }
*** Ctx ping count: 14
    [0](14): GroupBy(*1: D, [key] Text.Upper(*1.N), [~] *1.N)
###
> GroupBy(D, [~]   _: N, [key] _: N & N)
GroupBy(D, [~] _ : N, [key] _ : N & N) : {Id:i8, M:i8, N:s}**
BndKind:GroupBy, Type:{Id:i8, M:i8, N:s}**, Bnd:(GroupBy([scope:1] Global(D), [~] GetField(Scope(1), N), [key] StrConcat(GetField(Scope(1), N), GetField(Scope(1), N))))
// (<ctx>, ∂.D:{Id:i8, M:i8, N:s}*) : {Id:i8, M:i8, N:s}**
keySelector(Arr<obj>, {i8,i8,str}):{str,str}
      5) newobj {str,str}()
      1) dup
      1) ldc.i4.3
      5) stfld {str,str}::_B0:u1
      1) stloc.0 [{str,str}]
      1) ldloc.0 [{str,str}]
      1) ldarg.1 [{i8,i8,str}]
      5) ldfld {i8,i8,str}::_F2:str
      5) stfld {str,str}::_F0:str
      1) ldloc.0 [{str,str}]
      1) ldarg.1 [{i8,i8,str}]
      5) ldfld {i8,i8,str}::_F2:str
      1) ldarg.1 [{i8,i8,str}]
      5) ldfld {i8,i8,str}::_F2:str
      5) call static str::Concat(str, str):str
      5) stfld {str,str}::_F1:str
      1) ldloc.0 [{str,str}]
      1) dup
      1) ldarg.0 [Arr<obj>]
      1) ldc.i4.0
      5) ldelem [RecordRuntimeTypeInfo]
      5) stfld {}::_rrti:RecordRuntimeTypeInfo
      1) ret
  Total Size: 63

resultSelector(Arr<obj>, {str,str}, Seq<{i8,i8,str}>):Seq<{i8,i8,str}>
      1) ldarg.2 [Seq<{i8,i8,str}>]
      5) call static CodeGenUtil::EnumerableToCaching(Seq<{i8,i8,str}>):Seq<{i8,i8,str}>
      1) ret
  Total Size: 7

Equals(Arr<obj>, {str,str}, {str,str}):bool
      1) ldarg.1 [{str,str}]
      5) ldfld {str,str}::_F0:str
      1) ldarg.2 [{str,str}]
      5) ldfld {str,str}::_F0:str
      5) call static StrComparer::EqCi(str, str):bool
      5) brfalse [0]
      1) ldarg.1 [{str,str}]
      5) ldfld {str,str}::_F1:str
      1) ldarg.2 [{str,str}]
      5) ldfld {str,str}::_F1:str
      5) call static str::Equals(str, str):bool
      5) br [1]
  Label [0]:
      1) ldc.i4.0
  Label [1]:
      1) ret
  Total Size: 46

GetHashCode(Arr<obj>, {str,str}):i4
      1) ldarg.1 [{str,str}]
      5) ldfld {str,str}::_F0:str
      5) call static StrComparer::GetHashCodeCi(str):i4
      1) ldarg.1 [{str,str}]
      5) ldfld {str,str}::_F1:str
      5) call static HashCode::Combine(i4, str):i4
      1) ret
  Total Size: 23

top(Arr<obj>, Arr<obj>):obj
      1) ldarg.1 [Arr<obj>]
      1) ldc.i4.0
      1) ldelem.ref
      5) call static CodeGenUtil::ToRef(obj):ExecCtx
      1) stloc.0 [ExecCtx]
      1) ldarg.1 [Arr<obj>]
      1) ldc.i4.1
      1) ldelem.ref
      5) call static CodeGenUtil::ToRef(obj):Seq<{i8,i8,str}>
      1) stloc.1 [Seq<{i8,i8,str}>]
      1) ldloc.1 [Seq<{i8,i8,str}>]
      1) dup
      5) brtrue [0]
      1) pop
      1) ldnull
      5) br [1]
  Label [0]:
      1) ldloc.0 [ExecCtx]
      1) ldc.i4.0
      5) call static CodeGenUtil::EnumerableToPinging(Seq<{i8,i8,str}>, ExecCtx, i4):Seq<{i8,i8,str}>
      1) ldarg.0 [Arr<obj>]
      1) ldc.i4.0
      5) ldelem [Func<{i8,i8,str},{str,str}>]
      1) ldarg.0 [Arr<obj>]
      1) ldc.i4.1
      5) ldelem [Func<{str,str},Seq<{i8,i8,str}>,Seq<{i8,i8,str}>>]
      1) ldarg.0 [Arr<obj>]
      1) ldc.i4.2
      5) ldelem [GroupByComparer<{str,str}>]
      5) call static Enumerable::GroupBy(Seq<{i8,i8,str}>, Func<{i8,i8,str},{str,str}>, Func<{str,str},Seq<{i8,i8,str}>,Seq<{i8,i8,str}>>, IEqualityComparer<{str,str}>):Seq<Seq<{i8,i8,str}>>
      5) call static CodeGenUtil::EnumerableToCaching(Seq<Seq<{i8,i8,str}>>):Seq<Seq<{i8,i8,str}>>
  Label [1]:
      1) ret
  Total Size: 71

Func sig: (<ctx>:x, D:{Id:i8, M:i8, N:s}*) to {Id:i8, M:i8, N:s}**
Sequence: Seq<Seq<{i8,i8,str}>>
 0) Sequence: Seq<{i8,i8,str}>
     0) { Id: 0, M: 0, N: A }
     1) { Id: 4, M: 1, N: A }
     2) { Id: 7, M: 1, N: A }
 1) Sequence: Seq<{i8,i8,str}>
     0) { Id: 1, M: 1, N: b }
     1) { Id: 5, M: 2, N: b }
     2) { Id: 8, M: 2, N: b }
 2) Sequence: Seq<{i8,i8,str}>
     0) { Id: 2, M: 2, N: B }
     1) { Id: 11, M: 2, N: B }
 3) Sequence: Seq<{i8,i8,str}>
     0) { Id: 3, M: 0, N: a }
     1) { Id: 10, M: 1, N: a }
 4) Sequence: Seq<{i8,i8,str}>
     0) { Id: 6, M: 0, N: <null> }
     1) { Id: 9, M: 0, N: <null> }
     2) { Id: 12, M: 0, N: <null> }
*** Ctx ping count: 14
    [0](14): GroupBy(*1: D, [~] *1.N, [key] StrConcat(*1.N, *1.N))
###
> GroupBy(D, [key] _: N, [~]   _: N & N)
GroupBy(D, [key] _ : N, [~] _ : N & N) : {Id:i8, M:i8, N:s}**
BndKind:GroupBy, Type:{Id:i8, M:i8, N:s}**, Bnd:(GroupBy([scope:1] Global(D), [key] GetField(Scope(1), N), [~] StrConcat(GetField(Scope(1), N), GetField(Scope(1), N))))
// (<ctx>, ∂.D:{Id:i8, M:i8, N:s}*) : {Id:i8, M:i8, N:s}**
keySelector(Arr<obj>, {i8,i8,str}):{str,str}
      5) newobj {str,str}()
      1) dup
      1) ldc.i4.3
      5) stfld {str,str}::_B0:u1
      1) stloc.0 [{str,str}]
      1) ldloc.0 [{str,str}]
      1) ldarg.1 [{i8,i8,str}]
      5) ldfld {i8,i8,str}::_F2:str
      5) stfld {str,str}::_F0:str
      1) ldloc.0 [{str,str}]
      1) ldarg.1 [{i8,i8,str}]
      5) ldfld {i8,i8,str}::_F2:str
      1) ldarg.1 [{i8,i8,str}]
      5) ldfld {i8,i8,str}::_F2:str
      5) call static str::Concat(str, str):str
      5) stfld {str,str}::_F1:str
      1) ldloc.0 [{str,str}]
      1) dup
      1) ldarg.0 [Arr<obj>]
      1) ldc.i4.0
      5) ldelem [RecordRuntimeTypeInfo]
      5) stfld {}::_rrti:RecordRuntimeTypeInfo
      1) ret
  Total Size: 63

resultSelector(Arr<obj>, {str,str}, Seq<{i8,i8,str}>):Seq<{i8,i8,str}>
      1) ldarg.2 [Seq<{i8,i8,str}>]
      5) call static CodeGenUtil::EnumerableToCaching(Seq<{i8,i8,str}>):Seq<{i8,i8,str}>
      1) ret
  Total Size: 7

Equals(Arr<obj>, {str,str}, {str,str}):bool
      1) ldarg.1 [{str,str}]
      5) ldfld {str,str}::_F0:str
      1) ldarg.2 [{str,str}]
      5) ldfld {str,str}::_F0:str
      5) call static str::Equals(str, str):bool
      5) brfalse [0]
      1) ldarg.1 [{str,str}]
      5) ldfld {str,str}::_F1:str
      1) ldarg.2 [{str,str}]
      5) ldfld {str,str}::_F1:str
      5) call static StrComparer::EqCi(str, str):bool
      5) br [1]
  Label [0]:
      1) ldc.i4.0
  Label [1]:
      1) ret
  Total Size: 46

GetHashCode(Arr<obj>, {str,str}):i4
      1) ldarg.1 [{str,str}]
      5) ldfld {str,str}::_F0:str
      1) ldarg.1 [{str,str}]
      5) ldfld {str,str}::_F1:str
      5) call static StrComparer::GetHashCodeCi(str):i4
      5) call static HashCode::Combine(str, i4):i4
      1) ret
  Total Size: 23

top(Arr<obj>, Arr<obj>):obj
      1) ldarg.1 [Arr<obj>]
      1) ldc.i4.0
      1) ldelem.ref
      5) call static CodeGenUtil::ToRef(obj):ExecCtx
      1) stloc.0 [ExecCtx]
      1) ldarg.1 [Arr<obj>]
      1) ldc.i4.1
      1) ldelem.ref
      5) call static CodeGenUtil::ToRef(obj):Seq<{i8,i8,str}>
      1) stloc.1 [Seq<{i8,i8,str}>]
      1) ldloc.1 [Seq<{i8,i8,str}>]
      1) dup
      5) brtrue [0]
      1) pop
      1) ldnull
      5) br [1]
  Label [0]:
      1) ldloc.0 [ExecCtx]
      1) ldc.i4.0
      5) call static CodeGenUtil::EnumerableToPinging(Seq<{i8,i8,str}>, ExecCtx, i4):Seq<{i8,i8,str}>
      1) ldarg.0 [Arr<obj>]
      1) ldc.i4.0
      5) ldelem [Func<{i8,i8,str},{str,str}>]
      1) ldarg.0 [Arr<obj>]
      1) ldc.i4.1
      5) ldelem [Func<{str,str},Seq<{i8,i8,str}>,Seq<{i8,i8,str}>>]
      1) ldarg.0 [Arr<obj>]
      1) ldc.i4.2
      5) ldelem [GroupByComparer<{str,str}>]
      5) call static Enumerable::GroupBy(Seq<{i8,i8,str}>, Func<{i8,i8,str},{str,str}>, Func<{str,str},Seq<{i8,i8,str}>,Seq<{i8,i8,str}>>, IEqualityComparer<{str,str}>):Seq<Seq<{i8,i8,str}>>
      5) call static CodeGenUtil::EnumerableToCaching(Seq<Seq<{i8,i8,str}>>):Seq<Seq<{i8,i8,str}>>
  Label [1]:
      1) ret
  Total Size: 71

Func sig: (<ctx>:x, D:{Id:i8, M:i8, N:s}*) to {Id:i8, M:i8, N:s}**
Sequence: Seq<Seq<{i8,i8,str}>>
 0) Sequence: Seq<{i8,i8,str}>
     0) { Id: 0, M: 0, N: A }
     1) { Id: 4, M: 1, N: A }
     2) { Id: 7, M: 1, N: A }
 1) Sequence: Seq<{i8,i8,str}>
     0) { Id: 1, M: 1, N: b }
     1) { Id: 5, M: 2, N: b }
     2) { Id: 8, M: 2, N: b }
 2) Sequence: Seq<{i8,i8,str}>
     0) { Id: 2, M: 2, N: B }
     1) { Id: 11, M: 2, N: B }
 3) Sequence: Seq<{i8,i8,str}>
     0) { Id: 3, M: 0, N: a }
     1) { Id: 10, M: 1, N: a }
 4) Sequence: Seq<{i8,i8,str}>
     0) { Id: 6, M: 0, N: <null> }
     1) { Id: 9, M: 0, N: <null> }
     2) { Id: 12, M: 0, N: <null> }
*** Ctx ping count: 14
    [0](14): GroupBy(*1: D, [key] *1.N, [~] StrConcat(*1.N, *1.N))
###
> GroupBy(D, [key] _: N, [key] _: N & N)
GroupBy(D, [key] _ : N, [key] _ : N & N) : {Id:i8, M:i8, N:s}**
BndKind:GroupBy, Type:{Id:i8, M:i8, N:s}**, Bnd:(GroupBy([scope:1] Global(D), [key] GetField(Scope(1), N), [key] StrConcat(GetField(Scope(1), N), GetField(Scope(1), N))))
// (<ctx>, ∂.D:{Id:i8, M:i8, N:s}*) : {Id:i8, M:i8, N:s}**
keySelector(Arr<obj>, {i8,i8,str}):{str,str}
      5) newobj {str,str}()
      1) dup
      1) ldc.i4.3
      5) stfld {str,str}::_B0:u1
      1) stloc.0 [{str,str}]
      1) ldloc.0 [{str,str}]
      1) ldarg.1 [{i8,i8,str}]
      5) ldfld {i8,i8,str}::_F2:str
      5) stfld {str,str}::_F0:str
      1) ldloc.0 [{str,str}]
      1) ldarg.1 [{i8,i8,str}]
      5) ldfld {i8,i8,str}::_F2:str
      1) ldarg.1 [{i8,i8,str}]
      5) ldfld {i8,i8,str}::_F2:str
      5) call static str::Concat(str, str):str
      5) stfld {str,str}::_F1:str
      1) ldloc.0 [{str,str}]
      1) dup
      1) ldarg.0 [Arr<obj>]
      1) ldc.i4.0
      5) ldelem [RecordRuntimeTypeInfo]
      5) stfld {}::_rrti:RecordRuntimeTypeInfo
      1) ret
  Total Size: 63

resultSelector(Arr<obj>, {str,str}, Seq<{i8,i8,str}>):Seq<{i8,i8,str}>
      1) ldarg.2 [Seq<{i8,i8,str}>]
      5) call static CodeGenUtil::EnumerableToCaching(Seq<{i8,i8,str}>):Seq<{i8,i8,str}>
      1) ret
  Total Size: 7

top(Arr<obj>, Arr<obj>):obj
      1) ldarg.1 [Arr<obj>]
      1) ldc.i4.0
      1) ldelem.ref
      5) call static CodeGenUtil::ToRef(obj):ExecCtx
      1) stloc.0 [ExecCtx]
      1) ldarg.1 [Arr<obj>]
      1) ldc.i4.1
      1) ldelem.ref
      5) call static CodeGenUtil::ToRef(obj):Seq<{i8,i8,str}>
      1) stloc.1 [Seq<{i8,i8,str}>]
      1) ldloc.1 [Seq<{i8,i8,str}>]
      1) dup
      5) brtrue [0]
      1) pop
      1) ldnull
      5) br [1]
  Label [0]:
      1) ldloc.0 [ExecCtx]
      1) ldc.i4.0
      5) call static CodeGenUtil::EnumerableToPinging(Seq<{i8,i8,str}>, ExecCtx, i4):Seq<{i8,i8,str}>
      1) ldarg.0 [Arr<obj>]
      1) ldc.i4.0
      5) ldelem [Func<{i8,i8,str},{str,str}>]
      1) ldarg.0 [Arr<obj>]
      1) ldc.i4.1
      5) ldelem [Func<{str,str},Seq<{i8,i8,str}>,Seq<{i8,i8,str}>>]
      5) call static Enumerable::GroupBy(Seq<{i8,i8,str}>, Func<{i8,i8,str},{str,str}>, Func<{str,str},Seq<{i8,i8,str}>,Seq<{i8,i8,str}>>):Seq<Seq<{i8,i8,str}>>
      5) call static CodeGenUtil::EnumerableToCaching(Seq<Seq<{i8,i8,str}>>):Seq<Seq<{i8,i8,str}>>
  Label [1]:
      1) ret
  Total Size: 64

Func sig: (<ctx>:x, D:{Id:i8, M:i8, N:s}*) to {Id:i8, M:i8, N:s}**
Sequence: Seq<Seq<{i8,i8,str}>>
 0) Sequence: Seq<{i8,i8,str}>
     0) { Id: 0, M: 0, N: A }
     1) { Id: 4, M: 1, N: A }
     2) { Id: 7, M: 1, N: A }
 1) Sequence: Seq<{i8,i8,str}>
     0) { Id: 1, M: 1, N: b }
     1) { Id: 5, M: 2, N: b }
     2) { Id: 8, M: 2, N: b }
 2) Sequence: Seq<{i8,i8,str}>
     0) { Id: 2, M: 2, N: B }
     1) { Id: 11, M: 2, N: B }
 3) Sequence: Seq<{i8,i8,str}>
     0) { Id: 3, M: 0, N: a }
     1) { Id: 10, M: 1, N: a }
 4) Sequence: Seq<{i8,i8,str}>
     0) { Id: 6, M: 0, N: <null> }
     1) { Id: 9, M: 0, N: <null> }
     2) { Id: 12, M: 0, N: <null> }
*** Ctx ping count: 14
    [0](14): GroupBy(*1: D, [key] *1.N, [key] StrConcat(*1.N, *1.N))
###
> GroupBy(D, [~] A: N, [~]   B: N & N)
GroupBy(D, [~] A : N, [~] B : N & N) : {A:s, B:s}*
BndKind:GroupBy, Type:{A:s, B:s}*, Bnd:(GroupBy([scope:1] Global(D), [~] A:GetField(Scope(1), N), [~] B:StrConcat(GetField(Scope(1), N), GetField(Scope(1), N))))
// (<ctx>, ∂.D:{Id:i8, M:i8, N:s}*) : {A:s, B:s}*
keySelector(Arr<obj>, {i8,i8,str}):{str,str}
      5) newobj {str,str}()
      1) dup
      1) ldc.i4.3
      5) stfld {str,str}::_B0:u1
      1) stloc.0 [{str,str}]
      1) ldloc.0 [{str,str}]
      1) ldarg.1 [{i8,i8,str}]
      5) ldfld {i8,i8,str}::_F2:str
      5) stfld {str,str}::_F0:str
      1) ldloc.0 [{str,str}]
      1) ldarg.1 [{i8,i8,str}]
      5) ldfld {i8,i8,str}::_F2:str
      1) ldarg.1 [{i8,i8,str}]
      5) ldfld {i8,i8,str}::_F2:str
      5) call static str::Concat(str, str):str
      5) stfld {str,str}::_F1:str
      1) ldloc.0 [{str,str}]
      1) dup
      1) ldarg.0 [Arr<obj>]
      1) ldc.i4.0
      5) ldelem [RecordRuntimeTypeInfo]
      5) stfld {}::_rrti:RecordRuntimeTypeInfo
      1) ret
  Total Size: 63

resultSelector(Arr<obj>, {str,str}, Seq<{i8,i8,str}>):{str,str}
      5) newobj {str,str}()
      1) dup
      1) ldc.i4.3
      5) stfld {str,str}::_B0:u1
      1) stloc.0 [{str,str}]
      1) ldloc.0 [{str,str}]
      1) ldarg.1 [{str,str}]
      5) ldfld {str,str}::_F0:str
      5) stfld {str,str}::_F0:str
      1) ldloc.0 [{str,str}]
      1) ldarg.1 [{str,str}]
      5) ldfld {str,str}::_F1:str
      5) stfld {str,str}::_F1:str
      1) ldarg.2 [Seq<{i8,i8,str}>]
      5) call static CodeGenUtil::EnumerableToCaching(Seq<{i8,i8,str}>):Seq<{i8,i8,str}>
      1) pop
      1) ldloc.0 [{str,str}]
      1) dup
      1) ldarg.0 [Arr<obj>]
      1) ldc.i4.0
      5) ldelem [RecordRuntimeTypeInfo]
      5) stfld {}::_rrti:RecordRuntimeTypeInfo
      1) ret
  Total Size: 59

top(Arr<obj>, Arr<obj>):obj
      1) ldarg.1 [Arr<obj>]
      1) ldc.i4.0
      1) ldelem.ref
      5) call static CodeGenUtil::ToRef(obj):ExecCtx
      1) stloc.0 [ExecCtx]
      1) ldarg.1 [Arr<obj>]
      1) ldc.i4.1
      1) ldelem.ref
      5) call static CodeGenUtil::ToRef(obj):Seq<{i8,i8,str}>
      1) stloc.1 [Seq<{i8,i8,str}>]
      1) ldloc.1 [Seq<{i8,i8,str}>]
      1) dup
      5) brtrue [0]
      1) pop
      1) ldnull
      5) br [1]
  Label [0]:
      1) ldloc.0 [ExecCtx]
      1) ldc.i4.0
      5) call static CodeGenUtil::EnumerableToPinging(Seq<{i8,i8,str}>, ExecCtx, i4):Seq<{i8,i8,str}>
      1) ldarg.0 [Arr<obj>]
      1) ldc.i4.0
      5) ldelem [Func<{i8,i8,str},{str,str}>]
      1) ldarg.0 [Arr<obj>]
      1) ldc.i4.1
      5) ldelem [Func<{str,str},Seq<{i8,i8,str}>,{str,str}>]
      1) ldarg.0 [Arr<obj>]
      1) ldc.i4.2
      5) ldelem [EqualityComparer<{str,str}>]
      5) call static Enumerable::GroupBy(Seq<{i8,i8,str}>, Func<{i8,i8,str},{str,str}>, Func<{str,str},Seq<{i8,i8,str}>,{str,str}>, IEqualityComparer<{str,str}>):Seq<{str,str}>
      5) call static CodeGenUtil::EnumerableToCaching(Seq<{str,str}>):Seq<{str,str}>
  Label [1]:
      1) ret
  Total Size: 71

Func sig: (<ctx>:x, D:{Id:i8, M:i8, N:s}*) to {A:s, B:s}*
Sequence: Seq<{str,str}>
 0) { A: A, B: AA }
 1) { A: b, B: bb }
 2) { A: <null>, B:  }
*** Ctx ping count: 14
    [0](14): GroupBy(*1: D, [~] A:*1.N, [~] B:StrConcat(*1.N, *1.N))
###
> GroupBy(D, [~] A: N, [key] B: N.Lower)
GroupBy(D, [~] A : N, [key] B : N.Lower) : {A:s, B:s}*
BndKind:GroupBy, Type:{A:s, B:s}*, Bnd:(GroupBy([scope:1] Global(D), [~] A:GetField(Scope(1), N), [key] B:Call(∂.Text.Lower(GetField(Scope(1), N)):s)))
// (<ctx>, ∂.D:{Id:i8, M:i8, N:s}*) : {A:s, B:s}*
keySelector(Arr<obj>, {i8,i8,str}):{str,str}
      5) newobj {str,str}()
      1) dup
      1) ldc.i4.3
      5) stfld {str,str}::_B0:u1
      1) stloc.0 [{str,str}]
      1) ldloc.0 [{str,str}]
      1) ldarg.1 [{i8,i8,str}]
      5) ldfld {i8,i8,str}::_F2:str
      5) stfld {str,str}::_F0:str
      1) ldloc.0 [{str,str}]
      1) ldarg.1 [{i8,i8,str}]
      5) ldfld {i8,i8,str}::_F2:str
      5) call static TextCaseFunc::ExecLower(str):str
      5) stfld {str,str}::_F1:str
      1) ldloc.0 [{str,str}]
      1) dup
      1) ldarg.0 [Arr<obj>]
      1) ldc.i4.0
      5) ldelem [RecordRuntimeTypeInfo]
      5) stfld {}::_rrti:RecordRuntimeTypeInfo
      1) ret
  Total Size: 57

resultSelector(Arr<obj>, {str,str}, Seq<{i8,i8,str}>):{str,str}
      5) newobj {str,str}()
      1) dup
      1) ldc.i4.3
      5) stfld {str,str}::_B0:u1
      1) stloc.0 [{str,str}]
      1) ldloc.0 [{str,str}]
      1) ldarg.1 [{str,str}]
      5) ldfld {str,str}::_F0:str
      5) stfld {str,str}::_F0:str
      1) ldloc.0 [{str,str}]
      1) ldarg.1 [{str,str}]
      5) ldfld {str,str}::_F1:str
      5) stfld {str,str}::_F1:str
      1) ldarg.2 [Seq<{i8,i8,str}>]
      5) call static CodeGenUtil::EnumerableToCaching(Seq<{i8,i8,str}>):Seq<{i8,i8,str}>
      1) pop
      1) ldloc.0 [{str,str}]
      1) dup
      1) ldarg.0 [Arr<obj>]
      1) ldc.i4.0
      5) ldelem [RecordRuntimeTypeInfo]
      5) stfld {}::_rrti:RecordRuntimeTypeInfo
      1) ret
  Total Size: 59

Equals(Arr<obj>, {str,str}, {str,str}):bool
      1) ldarg.1 [{str,str}]
      5) ldfld {str,str}::_F0:str
      1) ldarg.2 [{str,str}]
      5) ldfld {str,str}::_F0:str
      5) call static StrComparer::EqCi(str, str):bool
      5) brfalse [0]
      1) ldarg.1 [{str,str}]
      5) ldfld {str,str}::_F1:str
      1) ldarg.2 [{str,str}]
      5) ldfld {str,str}::_F1:str
      5) call static str::Equals(str, str):bool
      5) br [1]
  Label [0]:
      1) ldc.i4.0
  Label [1]:
      1) ret
  Total Size: 46

GetHashCode(Arr<obj>, {str,str}):i4
      1) ldarg.1 [{str,str}]
      5) ldfld {str,str}::_F0:str
      5) call static StrComparer::GetHashCodeCi(str):i4
      1) ldarg.1 [{str,str}]
      5) ldfld {str,str}::_F1:str
      5) call static HashCode::Combine(i4, str):i4
      1) ret
  Total Size: 23

top(Arr<obj>, Arr<obj>):obj
      1) ldarg.1 [Arr<obj>]
      1) ldc.i4.0
      1) ldelem.ref
      5) call static CodeGenUtil::ToRef(obj):ExecCtx
      1) stloc.0 [ExecCtx]
      1) ldarg.1 [Arr<obj>]
      1) ldc.i4.1
      1) ldelem.ref
      5) call static CodeGenUtil::ToRef(obj):Seq<{i8,i8,str}>
      1) stloc.1 [Seq<{i8,i8,str}>]
      1) ldloc.1 [Seq<{i8,i8,str}>]
      1) dup
      5) brtrue [0]
      1) pop
      1) ldnull
      5) br [1]
  Label [0]:
      1) ldloc.0 [ExecCtx]
      1) ldc.i4.0
      5) call static CodeGenUtil::EnumerableToPinging(Seq<{i8,i8,str}>, ExecCtx, i4):Seq<{i8,i8,str}>
      1) ldarg.0 [Arr<obj>]
      1) ldc.i4.0
      5) ldelem [Func<{i8,i8,str},{str,str}>]
      1) ldarg.0 [Arr<obj>]
      1) ldc.i4.1
      5) ldelem [Func<{str,str},Seq<{i8,i8,str}>,{str,str}>]
      1) ldarg.0 [Arr<obj>]
      1) ldc.i4.2
      5) ldelem [GroupByComparer<{str,str}>]
      5) call static Enumerable::GroupBy(Seq<{i8,i8,str}>, Func<{i8,i8,str},{str,str}>, Func<{str,str},Seq<{i8,i8,str}>,{str,str}>, IEqualityComparer<{str,str}>):Seq<{str,str}>
      5) call static CodeGenUtil::EnumerableToCaching(Seq<{str,str}>):Seq<{str,str}>
  Label [1]:
      1) ret
  Total Size: 71

Func sig: (<ctx>:x, D:{Id:i8, M:i8, N:s}*) to {A:s, B:s}*
Sequence: Seq<{str,str}>
 0) { A: A, B: a }
 1) { A: b, B: b }
 2) { A: <null>, B: <null> }
*** Ctx ping count: 14
    [0](14): GroupBy(*1: D, [~] A:*1.N, [key] B:Text.Lower(*1.N))
###
> GroupBy(D, [key] A: N.Upper, [~] B: N)
GroupBy(D, [key] A : N.Upper, [~] B : N) : {A:s, B:s}*
BndKind:GroupBy, Type:{A:s, B:s}*, Bnd:(GroupBy([scope:1] Global(D), [key] A:Call(∂.Text.Upper(GetField(Scope(1), N)):s), [~] B:GetField(Scope(1), N)))
// (<ctx>, ∂.D:{Id:i8, M:i8, N:s}*) : {A:s, B:s}*
keySelector(Arr<obj>, {i8,i8,str}):{str,str}
      5) newobj {str,str}()
      1) dup
      1) ldc.i4.3
      5) stfld {str,str}::_B0:u1
      1) stloc.0 [{str,str}]
      1) ldloc.0 [{str,str}]
      1) ldarg.1 [{i8,i8,str}]
      5) ldfld {i8,i8,str}::_F2:str
      5) call static TextCaseFunc::ExecUpper(str):str
      5) stfld {str,str}::_F0:str
      1) ldloc.0 [{str,str}]
      1) ldarg.1 [{i8,i8,str}]
      5) ldfld {i8,i8,str}::_F2:str
      5) stfld {str,str}::_F1:str
      1) ldloc.0 [{str,str}]
      1) dup
      1) ldarg.0 [Arr<obj>]
      1) ldc.i4.0
      5) ldelem [RecordRuntimeTypeInfo]
      5) stfld {}::_rrti:RecordRuntimeTypeInfo
      1) ret
  Total Size: 57

resultSelector(Arr<obj>, {str,str}, Seq<{i8,i8,str}>):{str,str}
      5) newobj {str,str}()
      1) dup
      1) ldc.i4.3
      5) stfld {str,str}::_B0:u1
      1) stloc.0 [{str,str}]
      1) ldloc.0 [{str,str}]
      1) ldarg.1 [{str,str}]
      5) ldfld {str,str}::_F0:str
      5) stfld {str,str}::_F0:str
      1) ldloc.0 [{str,str}]
      1) ldarg.1 [{str,str}]
      5) ldfld {str,str}::_F1:str
      5) stfld {str,str}::_F1:str
      1) ldarg.2 [Seq<{i8,i8,str}>]
      5) call static CodeGenUtil::EnumerableToCaching(Seq<{i8,i8,str}>):Seq<{i8,i8,str}>
      1) pop
      1) ldloc.0 [{str,str}]
      1) dup
      1) ldarg.0 [Arr<obj>]
      1) ldc.i4.0
      5) ldelem [RecordRuntimeTypeInfo]
      5) stfld {}::_rrti:RecordRuntimeTypeInfo
      1) ret
  Total Size: 59

Equals(Arr<obj>, {str,str}, {str,str}):bool
      1) ldarg.1 [{str,str}]
      5) ldfld {str,str}::_F0:str
      1) ldarg.2 [{str,str}]
      5) ldfld {str,str}::_F0:str
      5) call static str::Equals(str, str):bool
      5) brfalse [0]
      1) ldarg.1 [{str,str}]
      5) ldfld {str,str}::_F1:str
      1) ldarg.2 [{str,str}]
      5) ldfld {str,str}::_F1:str
      5) call static StrComparer::EqCi(str, str):bool
      5) br [1]
  Label [0]:
      1) ldc.i4.0
  Label [1]:
      1) ret
  Total Size: 46

GetHashCode(Arr<obj>, {str,str}):i4
      1) ldarg.1 [{str,str}]
      5) ldfld {str,str}::_F0:str
      1) ldarg.1 [{str,str}]
      5) ldfld {str,str}::_F1:str
      5) call static StrComparer::GetHashCodeCi(str):i4
      5) call static HashCode::Combine(str, i4):i4
      1) ret
  Total Size: 23

top(Arr<obj>, Arr<obj>):obj
      1) ldarg.1 [Arr<obj>]
      1) ldc.i4.0
      1) ldelem.ref
      5) call static CodeGenUtil::ToRef(obj):ExecCtx
      1) stloc.0 [ExecCtx]
      1) ldarg.1 [Arr<obj>]
      1) ldc.i4.1
      1) ldelem.ref
      5) call static CodeGenUtil::ToRef(obj):Seq<{i8,i8,str}>
      1) stloc.1 [Seq<{i8,i8,str}>]
      1) ldloc.1 [Seq<{i8,i8,str}>]
      1) dup
      5) brtrue [0]
      1) pop
      1) ldnull
      5) br [1]
  Label [0]:
      1) ldloc.0 [ExecCtx]
      1) ldc.i4.0
      5) call static CodeGenUtil::EnumerableToPinging(Seq<{i8,i8,str}>, ExecCtx, i4):Seq<{i8,i8,str}>
      1) ldarg.0 [Arr<obj>]
      1) ldc.i4.0
      5) ldelem [Func<{i8,i8,str},{str,str}>]
      1) ldarg.0 [Arr<obj>]
      1) ldc.i4.1
      5) ldelem [Func<{str,str},Seq<{i8,i8,str}>,{str,str}>]
      1) ldarg.0 [Arr<obj>]
      1) ldc.i4.2
      5) ldelem [GroupByComparer<{str,str}>]
      5) call static Enumerable::GroupBy(Seq<{i8,i8,str}>, Func<{i8,i8,str},{str,str}>, Func<{str,str},Seq<{i8,i8,str}>,{str,str}>, IEqualityComparer<{str,str}>):Seq<{str,str}>
      5) call static CodeGenUtil::EnumerableToCaching(Seq<{str,str}>):Seq<{str,str}>
  Label [1]:
      1) ret
  Total Size: 71

Func sig: (<ctx>:x, D:{Id:i8, M:i8, N:s}*) to {A:s, B:s}*
Sequence: Seq<{str,str}>
 0) { A: A, B: A }
 1) { A: B, B: b }
 2) { A: <null>, B: <null> }
*** Ctx ping count: 14
    [0](14): GroupBy(*1: D, [key] A:Text.Upper(*1.N), [~] B:*1.N)
###

**** New definitions: D, type: {Id:i8, R:{M:i8, N:s}}*

> GroupBy(D, R, X)
GroupBy(D, R, X) : {R:{M:i8, N:s}, X:{Id:i8}*}*
BndKind:GroupBy, Type:{R:{M:i8, N:s}, X:{Id:i8}*}*, Bnd:(GroupBy([scope:1] Global(D), [key] R:GetField(Scope(1), R), [auto] X:<auto>))
// (<ctx>, ∂.D:{Id:i8, R:{M:i8, N:s}}*) : {R:{M:i8, N:s}, X:{Id:i8}*}*
keySelector(Arr<obj>, {i8,{i8,str}}):{i8,str}
      1) ldarg.1 [{i8,{i8,str}}]
      5) ldfld {i8,{i8,str}}::_F1:{i8,str}
      1) ret
  Total Size: 7

elementSelector(Arr<obj>, {i8,{i8,str}}):{i8}
      5) newobj {i8}()
      1) dup
      1) ldc.i4.1
      5) stfld {i8}::_B0:u1
      1) stloc.0 [{i8}]
      1) ldloc.0 [{i8}]
      1) ldarg.1 [{i8,{i8,str}}]
      5) ldfld {i8,{i8,str}}::_F0:i8
      5) stfld {i8}::_F0:i8
      1) ldloc.0 [{i8}]
      1) dup
      1) ldarg.0 [Arr<obj>]
      1) ldc.i4.0
      5) ldelem [RecordRuntimeTypeInfo]
      5) stfld {}::_rrti:RecordRuntimeTypeInfo
      1) ret
  Total Size: 40

resultSelector(Arr<obj>, {i8,str}, Seq<{i8}>):{{i8,str},Seq<{i8}>}
      5) newobj {{i8,str},Seq<{i8}>}()
      1) stloc.0 [{{i8,str},Seq<{i8}>}]
      1) ldarg.1 [{i8,str}]
      5) brfalse [0]
      1) ldloc.0 [{{i8,str},Seq<{i8}>}]
      1) dup
      1) dup
      5) ldfld {{i8,str},Seq<{i8}>}::_B0:u1
      1) ldc.i4.1
      1) or
      5) stfld {{i8,str},Seq<{i8}>}::_B0:u1
      1) ldarg.1 [{i8,str}]
      5) stfld {{i8,str},Seq<{i8}>}::_F0:{i8,str}
  Label [0]:
      1) ldloc.0 [{{i8,str},Seq<{i8}>}]
      1) ldarg.2 [Seq<{i8}>]
      5) call static CodeGenUtil::EnumerableToCaching(Seq<{i8}>):Seq<{i8}>
      5) stfld {{i8,str},Seq<{i8}>}::_F1:Seq<{i8}>
      1) ldloc.0 [{{i8,str},Seq<{i8}>}]
      1) dup
      1) ldarg.0 [Arr<obj>]
      1) ldc.i4.0
      5) ldelem [RecordRuntimeTypeInfo]
      5) stfld {}::_rrti:RecordRuntimeTypeInfo
      1) ret
  Total Size: 60

top(Arr<obj>, Arr<obj>):obj
      1) ldarg.1 [Arr<obj>]
      1) ldc.i4.0
      1) ldelem.ref
      5) call static CodeGenUtil::ToRef(obj):ExecCtx
      1) stloc.0 [ExecCtx]
      1) ldarg.1 [Arr<obj>]
      1) ldc.i4.1
      1) ldelem.ref
      5) call static CodeGenUtil::ToRef(obj):Seq<{i8,{i8,str}}>
      1) stloc.1 [Seq<{i8,{i8,str}}>]
      1) ldloc.1 [Seq<{i8,{i8,str}}>]
      1) dup
      5) brtrue [0]
      1) pop
      1) ldnull
      5) br [1]
  Label [0]:
      1) ldloc.0 [ExecCtx]
      1) ldc.i4.0
      5) call static CodeGenUtil::EnumerableToPinging(Seq<{i8,{i8,str}}>, ExecCtx, i4):Seq<{i8,{i8,str}}>
      1) ldarg.0 [Arr<obj>]
      1) ldc.i4.0
      5) ldelem [Func<{i8,{i8,str}},{i8,str}>]
      1) ldarg.0 [Arr<obj>]
      1) ldc.i4.1
      5) ldelem [Func<{i8,{i8,str}},{i8}>]
      1) ldarg.0 [Arr<obj>]
      1) ldc.i4.2
      5) ldelem [Func<{i8,str},Seq<{i8}>,{{i8,str},Seq<{i8}>}>]
      5) call static Enumerable::GroupBy(Seq<{i8,{i8,str}}>, Func<{i8,{i8,str}},{i8,str}>, Func<{i8,{i8,str}},{i8}>, Func<{i8,str},Seq<{i8}>,{{i8,str},Seq<{i8}>}>):Seq<{{i8,str},Seq<{i8}>}>
      5) call static CodeGenUtil::EnumerableToCaching(Seq<{{i8,str},Seq<{i8}>}>):Seq<{{i8,str},Seq<{i8}>}>
  Label [1]:
      1) ret
  Total Size: 71

Func sig: (<ctx>:x, D:{Id:i8, R:{M:i8, N:s}}*) to {R:{M:i8, N:s}, X:{Id:i8}*}*
Sequence: Seq<{{i8,str},Seq<{i8}>}>
 0) { R: { M: 0, N: A }, 
      X: Sequence: Seq<{i8}>
         0) { Id: 0 }
    }
 1) { R: { M: 1, N: b }, 
      X: Sequence: Seq<{i8}>
         0) { Id: 1 }
    }
 2) { R: { M: 2, N: B }, 
      X: Sequence: Seq<{i8}>
         0) { Id: 2 }
         1) { Id: 11 }
    }
 3) { R: { M: 0, N: a }, 
      X: Sequence: Seq<{i8}>
         0) { Id: 3 }
    }
 4) { R: { M: 1, N: A }, 
      X: Sequence: Seq<{i8}>
         0) { Id: 4 }
         1) { Id: 7 }
    }
 5) { R: { M: 2, N: b }, 
      X: Sequence: Seq<{i8}>
         0) { Id: 5 }
         1) { Id: 8 }
    }
 6) { R: { M: 0, N: <null> }, 
      X: Sequence: Seq<{i8}>
         0) { Id: 6 }
         1) { Id: 9 }
         2) { Id: 12 }
    }
 7) { R: { M: 1, N: a }, 
      X: Sequence: Seq<{i8}>
         0) { Id: 10 }
    }
*** Ctx ping count: 14
    [0](14): GroupBy(*1: D, [key] R:*1.R, [auto] X:<auto>)
###
> GroupBy(D, [~] R, X)
GroupBy(D, [~] R, X) : {R:{M:i8, N:s}, X:{Id:i8, R:{M:i8, N:s}}*}*
BndKind:GroupBy, Type:{R:{M:i8, N:s}, X:{Id:i8, R:{M:i8, N:s}}*}*, Bnd:(GroupBy([scope:1] Global(D), [~] R:GetField(Scope(1), R), [auto] X:<auto>))
// (<ctx>, ∂.D:{Id:i8, R:{M:i8, N:s}}*) : {R:{M:i8, N:s}, X:{Id:i8, R:{M:i8, N:s}}*}*
keySelector(Arr<obj>, {i8,{i8,str}}):{i8,str}
      1) ldarg.1 [{i8,{i8,str}}]
      5) ldfld {i8,{i8,str}}::_F1:{i8,str}
      1) ret
  Total Size: 7

resultSelector(Arr<obj>, {i8,str}, Seq<{i8,{i8,str}}>):{{i8,str},Seq<{i8,{i8,str}}>}
      5) newobj {{i8,str},Seq<{i8,{i8,str}}>}()
      1) stloc.0 [{{i8,str},Seq<{i8,{i8,str}}>}]
      1) ldarg.1 [{i8,str}]
      5) brfalse [0]
      1) ldloc.0 [{{i8,str},Seq<{i8,{i8,str}}>}]
      1) dup
      1) dup
      5) ldfld {{i8,str},Seq<{i8,{i8,str}}>}::_B0:u1
      1) ldc.i4.1
      1) or
      5) stfld {{i8,str},Seq<{i8,{i8,str}}>}::_B0:u1
      1) ldarg.1 [{i8,str}]
      5) stfld {{i8,str},Seq<{i8,{i8,str}}>}::_F0:{i8,str}
  Label [0]:
      1) ldloc.0 [{{i8,str},Seq<{i8,{i8,str}}>}]
      1) ldarg.2 [Seq<{i8,{i8,str}}>]
      5) call static CodeGenUtil::EnumerableToCaching(Seq<{i8,{i8,str}}>):Seq<{i8,{i8,str}}>
      5) stfld {{i8,str},Seq<{i8,{i8,str}}>}::_F1:Seq<{i8,{i8,str}}>
      1) ldloc.0 [{{i8,str},Seq<{i8,{i8,str}}>}]
      1) dup
      1) ldarg.0 [Arr<obj>]
      1) ldc.i4.0
      5) ldelem [RecordRuntimeTypeInfo]
      5) stfld {}::_rrti:RecordRuntimeTypeInfo
      1) ret
  Total Size: 60

top(Arr<obj>, Arr<obj>):obj
      1) ldarg.1 [Arr<obj>]
      1) ldc.i4.0
      1) ldelem.ref
      5) call static CodeGenUtil::ToRef(obj):ExecCtx
      1) stloc.0 [ExecCtx]
      1) ldarg.1 [Arr<obj>]
      1) ldc.i4.1
      1) ldelem.ref
      5) call static CodeGenUtil::ToRef(obj):Seq<{i8,{i8,str}}>
      1) stloc.1 [Seq<{i8,{i8,str}}>]
      1) ldloc.1 [Seq<{i8,{i8,str}}>]
      1) dup
      5) brtrue [0]
      1) pop
      1) ldnull
      5) br [1]
  Label [0]:
      1) ldloc.0 [ExecCtx]
      1) ldc.i4.0
      5) call static CodeGenUtil::EnumerableToPinging(Seq<{i8,{i8,str}}>, ExecCtx, i4):Seq<{i8,{i8,str}}>
      1) ldarg.0 [Arr<obj>]
      1) ldc.i4.0
      5) ldelem [Func<{i8,{i8,str}},{i8,str}>]
      1) ldarg.0 [Arr<obj>]
      1) ldc.i4.1
      5) ldelem [Func<{i8,str},Seq<{i8,{i8,str}}>,{{i8,str},Seq<{i8,{i8,str}}>}>]
      1) ldarg.0 [Arr<obj>]
      1) ldc.i4.2
      5) ldelem [EqualityComparer<{i8,str}>]
      5) call static Enumerable::GroupBy(Seq<{i8,{i8,str}}>, Func<{i8,{i8,str}},{i8,str}>, Func<{i8,str},Seq<{i8,{i8,str}}>,{{i8,str},Seq<{i8,{i8,str}}>}>, IEqualityComparer<{i8,str}>):Seq<{{i8,str},Seq<{i8,{i8,str}}>}>
      5) call static CodeGenUtil::EnumerableToCaching(Seq<{{i8,str},Seq<{i8,{i8,str}}>}>):Seq<{{i8,str},Seq<{i8,{i8,str}}>}>
  Label [1]:
      1) ret
  Total Size: 71

Func sig: (<ctx>:x, D:{Id:i8, R:{M:i8, N:s}}*) to {R:{M:i8, N:s}, X:{Id:i8, R:{M:i8, N:s}}*}*
Sequence: Seq<{{i8,str},Seq<{i8,{i8,str}}>}>
 0) { R: { M: 0, N: A }, 
      X: Sequence: Seq<{i8,{i8,str}}>
         0) { Id: 0, R: { M: 0, N: A } }
         1) { Id: 3, R: { M: 0, N: a } }
    }
 1) { R: { M: 1, N: b }, 
      X: Sequence: Seq<{i8,{i8,str}}>
         0) { Id: 1, R: { M: 1, N: b } }
    }
 2) { R: { M: 2, N: B }, 
      X: Sequence: Seq<{i8,{i8,str}}>
         0) { Id: 2, R: { M: 2, N: B } }
         1) { Id: 5, R: { M: 2, N: b } }
         2) { Id: 8, R: { M: 2, N: b } }
         3) { Id: 11, R: { M: 2, N: B } }
    }
 3) { R: { M: 1, N: A }, 
      X: Sequence: Seq<{i8,{i8,str}}>
         0) { Id: 4, R: { M: 1, N: A } }
         1) { Id: 7, R: { M: 1, N: A } }
         2) { Id: 10, R: { M: 1, N: a } }
    }
 4) { R: { M: 0, N: <null> }, 
      X: Sequence: Seq<{i8,{i8,str}}>
         0) { Id: 6, R: { M: 0, N: <null> } }
         1) { Id: 9, R: { M: 0, N: <null> } }
         2) { Id: 12, R: { M: 0, N: <null> } }
    }
*** Ctx ping count: 14
    [0](14): GroupBy(*1: D, [~] R:*1.R, [auto] X:<auto>)
###
> GroupBy(D, R, S: # div 100, X)
GroupBy(D, R, S : # div 100, X) : {R:{M:i8, N:s}, S:i8, X:{Id:i8}*}*
BndKind:GroupBy, Type:{R:{M:i8, N:s}, S:i8, X:{Id:i8}*}*, Bnd:(GroupBy([scope:2] Global(D), [key] R:GetField(Scope(2), R), [key] S:IntDiv(Scope(1), 100:i8), [auto] X:<auto>))
// (<ctx>, ∂.D:{Id:i8, R:{M:i8, N:s}}*) : {R:{M:i8, N:s}, S:i8, X:{Id:i8}*}*
keySelector(Arr<obj>, ValueTuple<{i8,{i8,str}},i8>):{{i8,str},i8}
      1) ldarg.1 [ValueTuple<{i8,{i8,str}},i8>]
      5) ldfld ValueTuple<{i8,{i8,str}},i8>::Item1:{i8,{i8,str}}
      1) stloc.0 [{i8,{i8,str}}]
      1) ldarg.1 [ValueTuple<{i8,{i8,str}},i8>]
      5) ldfld ValueTuple<{i8,{i8,str}},i8>::Item2:i8
      1) stloc.1 [i8]
      5) newobj {{i8,str},i8}()
      1) dup
      1) ldc.i4.2
      5) stfld {{i8,str},i8}::_B0:u1
      1) stloc.2 [{{i8,str},i8}]
      1) ldloc.2 [{{i8,str},i8}]
      1) ldloc.0 [{i8,{i8,str}}]
      5) ldfld {i8,{i8,str}}::_F1:{i8,str}
      1) dup
      5) brfalse [0]
      5) stfld {{i8,str},i8}::_F0:{i8,str}
      1) ldloc.2 [{{i8,str},i8}]
      1) dup
      5) ldfld {{i8,str},i8}::_B0:u1
      1) ldc.i4.1
      1) or
      5) stfld {{i8,str},i8}::_B0:u1
      5) br [1]
  Label [0]:
      1) pop
      1) pop
  Label [1]:
      1) ldloc.2 [{{i8,str},i8}]
      1) ldloc.1 [i8]
      2) ldc.i4.s [100]
      1) conv.i8
      1) div
      5) stfld {{i8,str},i8}::_F1:i8
      1) ldloc.2 [{{i8,str},i8}]
      1) dup
      1) ldarg.0 [Arr<obj>]
      1) ldc.i4.0
      5) ldelem [RecordRuntimeTypeInfo]
      5) stfld {}::_rrti:RecordRuntimeTypeInfo
      1) ret
  Total Size: 92

elementSelector(Arr<obj>, ValueTuple<{i8,{i8,str}},i8>):{i8}
      1) ldarg.1 [ValueTuple<{i8,{i8,str}},i8>]
      5) ldfld ValueTuple<{i8,{i8,str}},i8>::Item1:{i8,{i8,str}}
      1) stloc.0 [{i8,{i8,str}}]
      5) newobj {i8}()
      1) dup
      1) ldc.i4.1
      5) stfld {i8}::_B0:u1
      1) stloc.1 [{i8}]
      1) ldloc.1 [{i8}]
      1) ldloc.0 [{i8,{i8,str}}]
      5) ldfld {i8,{i8,str}}::_F0:i8
      5) stfld {i8}::_F0:i8
      1) ldloc.1 [{i8}]
      1) dup
      1) ldarg.0 [Arr<obj>]
      1) ldc.i4.0
      5) ldelem [RecordRuntimeTypeInfo]
      5) stfld {}::_rrti:RecordRuntimeTypeInfo
      1) ret
  Total Size: 47

resultSelector(Arr<obj>, {{i8,str},i8}, Seq<{i8}>):{{i8,str},i8,Seq<{i8}>}
      5) newobj {{i8,str},i8,Seq<{i8}>}()
      1) dup
      1) ldc.i4.2
      5) stfld {{i8,str},i8,Seq<{i8}>}::_B0:u1
      1) stloc.0 [{{i8,str},i8,Seq<{i8}>}]
      1) ldarg.1 [{{i8,str},i8}]
      5) ldfld {{i8,str},i8}::_F0:{i8,str}
      5) brfalse [0]
      1) ldloc.0 [{{i8,str},i8,Seq<{i8}>}]
      1) dup
      1) dup
      5) ldfld {{i8,str},i8,Seq<{i8}>}::_B0:u1
      1) ldc.i4.1
      1) or
      5) stfld {{i8,str},i8,Seq<{i8}>}::_B0:u1
      1) ldarg.1 [{{i8,str},i8}]
      5) ldfld {{i8,str},i8}::_F0:{i8,str}
      5) stfld {{i8,str},i8,Seq<{i8}>}::_F0:{i8,str}
  Label [0]:
      1) ldloc.0 [{{i8,str},i8,Seq<{i8}>}]
      1) ldarg.1 [{{i8,str},i8}]
      5) ldfld {{i8,str},i8}::_F1:i8
      5) stfld {{i8,str},i8,Seq<{i8}>}::_F1:i8
      1) ldloc.0 [{{i8,str},i8,Seq<{i8}>}]
      1) ldarg.2 [Seq<{i8}>]
      5) call static CodeGenUtil::EnumerableToCaching(Seq<{i8}>):Seq<{i8}>
      5) stfld {{i8,str},i8,Seq<{i8}>}::_F2:Seq<{i8}>
      1) ldloc.0 [{{i8,str},i8,Seq<{i8}>}]
      1) dup
      1) ldarg.0 [Arr<obj>]
      1) ldc.i4.0
      5) ldelem [RecordRuntimeTypeInfo]
      5) stfld {}::_rrti:RecordRuntimeTypeInfo
      1) ret
  Total Size: 89

top(Arr<obj>, Arr<obj>):obj
      1) ldarg.1 [Arr<obj>]
      1) ldc.i4.0
      1) ldelem.ref
      5) call static CodeGenUtil::ToRef(obj):ExecCtx
      1) stloc.0 [ExecCtx]
      1) ldarg.1 [Arr<obj>]
      1) ldc.i4.1
      1) ldelem.ref
      5) call static CodeGenUtil::ToRef(obj):Seq<{i8,{i8,str}}>
      1) stloc.1 [Seq<{i8,{i8,str}}>]
      1) ldloc.1 [Seq<{i8,{i8,str}}>]
      1) dup
      5) brtrue [0]
      1) pop
      1) ldnull
      5) br [1]
  Label [0]:
      1) ldloc.0 [ExecCtx]
      1) ldc.i4.0
      5) call static CodeGenUtil::EnumerableToPinging(Seq<{i8,{i8,str}}>, ExecCtx, i4):Seq<{i8,{i8,str}}>
      5) call static CodeGenUtil::WrapIndPairs(Seq<{i8,{i8,str}}>):Seq<ValueTuple<{i8,{i8,str}},i8>>
      1) ldarg.0 [Arr<obj>]
      1) ldc.i4.0
      5) ldelem [Func<ValueTuple<{i8,{i8,str}},i8>,{{i8,str},i8}>]
      1) ldarg.0 [Arr<obj>]
      1) ldc.i4.1
      5) ldelem [Func<ValueTuple<{i8,{i8,str}},i8>,{i8}>]
      1) ldarg.0 [Arr<obj>]
      1) ldc.i4.2
      5) ldelem [Func<{{i8,str},i8},Seq<{i8}>,{{i8,str},i8,Seq<{i8}>}>]
      5) call static Enumerable::GroupBy(Seq<ValueTuple<{i8,{i8,str}},i8>>, Func<ValueTuple<{i8,{i8,str}},i8>,{{i8,str},i8}>, Func<ValueTuple<{i8,{i8,str}},i8>,{i8}>, Func<{{i8,str},i8},Seq<{i8}>,{{i8,str},i8,Seq<{i8}>}>):Seq<{{i8,str},i8,Seq<{i8}>}>
      5) call static CodeGenUtil::EnumerableToCaching(Seq<{{i8,str},i8,Seq<{i8}>}>):Seq<{{i8,str},i8,Seq<{i8}>}>
  Label [1]:
      1) ret
  Total Size: 76

Func sig: (<ctx>:x, D:{Id:i8, R:{M:i8, N:s}}*) to {R:{M:i8, N:s}, S:i8, X:{Id:i8}*}*
Sequence: Seq<{{i8,str},i8,Seq<{i8}>}>
 0) { R: { M: 0, N: A }, S: 0, 
      X: Sequence: Seq<{i8}>
         0) { Id: 0 }
    }
 1) { R: { M: 1, N: b }, S: 0, 
      X: Sequence: Seq<{i8}>
         0) { Id: 1 }
    }
 2) { R: { M: 2, N: B }, S: 0, 
      X: Sequence: Seq<{i8}>
         0) { Id: 2 }
         1) { Id: 11 }
    }
 3) { R: { M: 0, N: a }, S: 0, 
      X: Sequence: Seq<{i8}>
         0) { Id: 3 }
    }
 4) { R: { M: 1, N: A }, S: 0, 
      X: Sequence: Seq<{i8}>
         0) { Id: 4 }
         1) { Id: 7 }
    }
 5) { R: { M: 2, N: b }, S: 0, 
      X: Sequence: Seq<{i8}>
         0) { Id: 5 }
         1) { Id: 8 }
    }
 6) { R: { M: 0, N: <null> }, S: 0, 
      X: Sequence: Seq<{i8}>
         0) { Id: 6 }
         1) { Id: 9 }
         2) { Id: 12 }
    }
 7) { R: { M: 1, N: a }, S: 0, 
      X: Sequence: Seq<{i8}>
         0) { Id: 10 }
    }
*** Ctx ping count: 14
    [0](14): GroupBy(*2: D, [key] R:*2.R, [key] S:IntDiv(#1, 100), [auto] X:<auto>)
###
> GroupBy(D, [~] R, S: # div 100, X)
GroupBy(D, [~] R, S : # div 100, X) : {R:{M:i8, N:s}, S:i8, X:{Id:i8, R:{M:i8, N:s}}*}*
BndKind:GroupBy, Type:{R:{M:i8, N:s}, S:i8, X:{Id:i8, R:{M:i8, N:s}}*}*, Bnd:(GroupBy([scope:2] Global(D), [~] R:GetField(Scope(2), R), [key] S:IntDiv(Scope(1), 100:i8), [auto] X:<auto>))
// (<ctx>, ∂.D:{Id:i8, R:{M:i8, N:s}}*) : {R:{M:i8, N:s}, S:i8, X:{Id:i8, R:{M:i8, N:s}}*}*
keySelector(Arr<obj>, ValueTuple<{i8,{i8,str}},i8>):{{i8,str},i8}
      1) ldarg.1 [ValueTuple<{i8,{i8,str}},i8>]
      5) ldfld ValueTuple<{i8,{i8,str}},i8>::Item1:{i8,{i8,str}}
      1) stloc.0 [{i8,{i8,str}}]
      1) ldarg.1 [ValueTuple<{i8,{i8,str}},i8>]
      5) ldfld ValueTuple<{i8,{i8,str}},i8>::Item2:i8
      1) stloc.1 [i8]
      5) newobj {{i8,str},i8}()
      1) dup
      1) ldc.i4.2
      5) stfld {{i8,str},i8}::_B0:u1
      1) stloc.2 [{{i8,str},i8}]
      1) ldloc.2 [{{i8,str},i8}]
      1) ldloc.0 [{i8,{i8,str}}]
      5) ldfld {i8,{i8,str}}::_F1:{i8,str}
      1) dup
      5) brfalse [0]
      5) stfld {{i8,str},i8}::_F0:{i8,str}
      1) ldloc.2 [{{i8,str},i8}]
      1) dup
      5) ldfld {{i8,str},i8}::_B0:u1
      1) ldc.i4.1
      1) or
      5) stfld {{i8,str},i8}::_B0:u1
      5) br [1]
  Label [0]:
      1) pop
      1) pop
  Label [1]:
      1) ldloc.2 [{{i8,str},i8}]
      1) ldloc.1 [i8]
      2) ldc.i4.s [100]
      1) conv.i8
      1) div
      5) stfld {{i8,str},i8}::_F1:i8
      1) ldloc.2 [{{i8,str},i8}]
      1) dup
      1) ldarg.0 [Arr<obj>]
      1) ldc.i4.0
      5) ldelem [RecordRuntimeTypeInfo]
      5) stfld {}::_rrti:RecordRuntimeTypeInfo
      1) ret
  Total Size: 92

elementSelector(Arr<obj>, ValueTuple<{i8,{i8,str}},i8>):{i8,{i8,str}}
      1) ldarg.1 [ValueTuple<{i8,{i8,str}},i8>]
      5) ldfld ValueTuple<{i8,{i8,str}},i8>::Item1:{i8,{i8,str}}
      1) ret
  Total Size: 7

resultSelector(Arr<obj>, {{i8,str},i8}, Seq<{i8,{i8,str}}>):{{i8,str},i8,Seq<{i8,{i8,str}}>}
      5) newobj {{i8,str},i8,Seq<{i8,{i8,str}}>}()
      1) dup
      1) ldc.i4.2
      5) stfld {{i8,str},i8,Seq<{i8,{i8,str}}>}::_B0:u1
      1) stloc.0 [{{i8,str},i8,Seq<{i8,{i8,str}}>}]
      1) ldarg.1 [{{i8,str},i8}]
      5) ldfld {{i8,str},i8}::_F0:{i8,str}
      5) brfalse [0]
      1) ldloc.0 [{{i8,str},i8,Seq<{i8,{i8,str}}>}]
      1) dup
      1) dup
      5) ldfld {{i8,str},i8,Seq<{i8,{i8,str}}>}::_B0:u1
      1) ldc.i4.1
      1) or
      5) stfld {{i8,str},i8,Seq<{i8,{i8,str}}>}::_B0:u1
      1) ldarg.1 [{{i8,str},i8}]
      5) ldfld {{i8,str},i8}::_F0:{i8,str}
      5) stfld {{i8,str},i8,Seq<{i8,{i8,str}}>}::_F0:{i8,str}
  Label [0]:
      1) ldloc.0 [{{i8,str},i8,Seq<{i8,{i8,str}}>}]
      1) ldarg.1 [{{i8,str},i8}]
      5) ldfld {{i8,str},i8}::_F1:i8
      5) stfld {{i8,str},i8,Seq<{i8,{i8,str}}>}::_F1:i8
      1) ldloc.0 [{{i8,str},i8,Seq<{i8,{i8,str}}>}]
      1) ldarg.2 [Seq<{i8,{i8,str}}>]
      5) call static CodeGenUtil::EnumerableToCaching(Seq<{i8,{i8,str}}>):Seq<{i8,{i8,str}}>
      5) stfld {{i8,str},i8,Seq<{i8,{i8,str}}>}::_F2:Seq<{i8,{i8,str}}>
      1) ldloc.0 [{{i8,str},i8,Seq<{i8,{i8,str}}>}]
      1) dup
      1) ldarg.0 [Arr<obj>]
      1) ldc.i4.0
      5) ldelem [RecordRuntimeTypeInfo]
      5) stfld {}::_rrti:RecordRuntimeTypeInfo
      1) ret
  Total Size: 89

top(Arr<obj>, Arr<obj>):obj
      1) ldarg.1 [Arr<obj>]
      1) ldc.i4.0
      1) ldelem.ref
      5) call static CodeGenUtil::ToRef(obj):ExecCtx
      1) stloc.0 [ExecCtx]
      1) ldarg.1 [Arr<obj>]
      1) ldc.i4.1
      1) ldelem.ref
      5) call static CodeGenUtil::ToRef(obj):Seq<{i8,{i8,str}}>
      1) stloc.1 [Seq<{i8,{i8,str}}>]
      1) ldloc.1 [Seq<{i8,{i8,str}}>]
      1) dup
      5) brtrue [0]
      1) pop
      1) ldnull
      5) br [1]
  Label [0]:
      1) ldloc.0 [ExecCtx]
      1) ldc.i4.0
      5) call static CodeGenUtil::EnumerableToPinging(Seq<{i8,{i8,str}}>, ExecCtx, i4):Seq<{i8,{i8,str}}>
      5) call static CodeGenUtil::WrapIndPairs(Seq<{i8,{i8,str}}>):Seq<ValueTuple<{i8,{i8,str}},i8>>
      1) ldarg.0 [Arr<obj>]
      1) ldc.i4.0
      5) ldelem [Func<ValueTuple<{i8,{i8,str}},i8>,{{i8,str},i8}>]
      1) ldarg.0 [Arr<obj>]
      1) ldc.i4.1
      5) ldelem [Func<ValueTuple<{i8,{i8,str}},i8>,{i8,{i8,str}}>]
      1) ldarg.0 [Arr<obj>]
      1) ldc.i4.2
      5) ldelem [Func<{{i8,str},i8},Seq<{i8,{i8,str}}>,{{i8,str},i8,Seq<{i8,{i8,str}}>}>]
      1) ldarg.0 [Arr<obj>]
      1) ldc.i4.3
      5) ldelem [EqualityComparer<{{i8,str},i8}>]
      5) call static Enumerable::GroupBy(Seq<ValueTuple<{i8,{i8,str}},i8>>, Func<ValueTuple<{i8,{i8,str}},i8>,{{i8,str},i8}>, Func<ValueTuple<{i8,{i8,str}},i8>,{i8,{i8,str}}>, Func<{{i8,str},i8},Seq<{i8,{i8,str}}>,{{i8,str},i8,Seq<{i8,{i8,str}}>}>, IEqualityComparer<{{i8,str},i8}>):Seq<{{i8,str},i8,Seq<{i8,{i8,str}}>}>
      5) call static CodeGenUtil::EnumerableToCaching(Seq<{{i8,str},i8,Seq<{i8,{i8,str}}>}>):Seq<{{i8,str},i8,Seq<{i8,{i8,str}}>}>
  Label [1]:
      1) ret
  Total Size: 83

Func sig: (<ctx>:x, D:{Id:i8, R:{M:i8, N:s}}*) to {R:{M:i8, N:s}, S:i8, X:{Id:i8, R:{M:i8, N:s}}*}*
Sequence: Seq<{{i8,str},i8,Seq<{i8,{i8,str}}>}>
 0) { R: { M: 0, N: A }, S: 0, 
      X: Sequence: Seq<{i8,{i8,str}}>
         0) { Id: 0, R: { M: 0, N: A } }
         1) { Id: 3, R: { M: 0, N: a } }
    }
 1) { R: { M: 1, N: b }, S: 0, 
      X: Sequence: Seq<{i8,{i8,str}}>
         0) { Id: 1, R: { M: 1, N: b } }
    }
 2) { R: { M: 2, N: B }, S: 0, 
      X: Sequence: Seq<{i8,{i8,str}}>
         0) { Id: 2, R: { M: 2, N: B } }
         1) { Id: 5, R: { M: 2, N: b } }
         2) { Id: 8, R: { M: 2, N: b } }
         3) { Id: 11, R: { M: 2, N: B } }
    }
 3) { R: { M: 1, N: A }, S: 0, 
      X: Sequence: Seq<{i8,{i8,str}}>
         0) { Id: 4, R: { M: 1, N: A } }
         1) { Id: 7, R: { M: 1, N: A } }
         2) { Id: 10, R: { M: 1, N: a } }
    }
 4) { R: { M: 0, N: <null> }, S: 0, 
      X: Sequence: Seq<{i8,{i8,str}}>
         0) { Id: 6, R: { M: 0, N: <null> } }
         1) { Id: 9, R: { M: 0, N: <null> } }
         2) { Id: 12, R: { M: 0, N: <null> } }
    }
*** Ctx ping count: 14
    [0](14): GroupBy(*2: D, [~] R:*2.R, [key] S:IntDiv(#1, 100), [auto] X:<auto>)
###
> GroupBy(D, R, S: # div 7, X)
GroupBy(D, R, S : # div 7, X) : {R:{M:i8, N:s}, S:i8, X:{Id:i8}*}*
BndKind:GroupBy, Type:{R:{M:i8, N:s}, S:i8, X:{Id:i8}*}*, Bnd:(GroupBy([scope:2] Global(D), [key] R:GetField(Scope(2), R), [key] S:IntDiv(Scope(1), 7:i8), [auto] X:<auto>))
// (<ctx>, ∂.D:{Id:i8, R:{M:i8, N:s}}*) : {R:{M:i8, N:s}, S:i8, X:{Id:i8}*}*
keySelector(Arr<obj>, ValueTuple<{i8,{i8,str}},i8>):{{i8,str},i8}
      1) ldarg.1 [ValueTuple<{i8,{i8,str}},i8>]
      5) ldfld ValueTuple<{i8,{i8,str}},i8>::Item1:{i8,{i8,str}}
      1) stloc.0 [{i8,{i8,str}}]
      1) ldarg.1 [ValueTuple<{i8,{i8,str}},i8>]
      5) ldfld ValueTuple<{i8,{i8,str}},i8>::Item2:i8
      1) stloc.1 [i8]
      5) newobj {{i8,str},i8}()
      1) dup
      1) ldc.i4.2
      5) stfld {{i8,str},i8}::_B0:u1
      1) stloc.2 [{{i8,str},i8}]
      1) ldloc.2 [{{i8,str},i8}]
      1) ldloc.0 [{i8,{i8,str}}]
      5) ldfld {i8,{i8,str}}::_F1:{i8,str}
      1) dup
      5) brfalse [0]
      5) stfld {{i8,str},i8}::_F0:{i8,str}
      1) ldloc.2 [{{i8,str},i8}]
      1) dup
      5) ldfld {{i8,str},i8}::_B0:u1
      1) ldc.i4.1
      1) or
      5) stfld {{i8,str},i8}::_B0:u1
      5) br [1]
  Label [0]:
      1) pop
      1) pop
  Label [1]:
      1) ldloc.2 [{{i8,str},i8}]
      1) ldloc.1 [i8]
      1) ldc.i4.7
      1) conv.i8
      1) div
      5) stfld {{i8,str},i8}::_F1:i8
      1) ldloc.2 [{{i8,str},i8}]
      1) dup
      1) ldarg.0 [Arr<obj>]
      1) ldc.i4.0
      5) ldelem [RecordRuntimeTypeInfo]
      5) stfld {}::_rrti:RecordRuntimeTypeInfo
      1) ret
  Total Size: 91

elementSelector(Arr<obj>, ValueTuple<{i8,{i8,str}},i8>):{i8}
      1) ldarg.1 [ValueTuple<{i8,{i8,str}},i8>]
      5) ldfld ValueTuple<{i8,{i8,str}},i8>::Item1:{i8,{i8,str}}
      1) stloc.0 [{i8,{i8,str}}]
      5) newobj {i8}()
      1) dup
      1) ldc.i4.1
      5) stfld {i8}::_B0:u1
      1) stloc.1 [{i8}]
      1) ldloc.1 [{i8}]
      1) ldloc.0 [{i8,{i8,str}}]
      5) ldfld {i8,{i8,str}}::_F0:i8
      5) stfld {i8}::_F0:i8
      1) ldloc.1 [{i8}]
      1) dup
      1) ldarg.0 [Arr<obj>]
      1) ldc.i4.0
      5) ldelem [RecordRuntimeTypeInfo]
      5) stfld {}::_rrti:RecordRuntimeTypeInfo
      1) ret
  Total Size: 47

resultSelector(Arr<obj>, {{i8,str},i8}, Seq<{i8}>):{{i8,str},i8,Seq<{i8}>}
      5) newobj {{i8,str},i8,Seq<{i8}>}()
      1) dup
      1) ldc.i4.2
      5) stfld {{i8,str},i8,Seq<{i8}>}::_B0:u1
      1) stloc.0 [{{i8,str},i8,Seq<{i8}>}]
      1) ldarg.1 [{{i8,str},i8}]
      5) ldfld {{i8,str},i8}::_F0:{i8,str}
      5) brfalse [0]
      1) ldloc.0 [{{i8,str},i8,Seq<{i8}>}]
      1) dup
      1) dup
      5) ldfld {{i8,str},i8,Seq<{i8}>}::_B0:u1
      1) ldc.i4.1
      1) or
      5) stfld {{i8,str},i8,Seq<{i8}>}::_B0:u1
      1) ldarg.1 [{{i8,str},i8}]
      5) ldfld {{i8,str},i8}::_F0:{i8,str}
      5) stfld {{i8,str},i8,Seq<{i8}>}::_F0:{i8,str}
  Label [0]:
      1) ldloc.0 [{{i8,str},i8,Seq<{i8}>}]
      1) ldarg.1 [{{i8,str},i8}]
      5) ldfld {{i8,str},i8}::_F1:i8
      5) stfld {{i8,str},i8,Seq<{i8}>}::_F1:i8
      1) ldloc.0 [{{i8,str},i8,Seq<{i8}>}]
      1) ldarg.2 [Seq<{i8}>]
      5) call static CodeGenUtil::EnumerableToCaching(Seq<{i8}>):Seq<{i8}>
      5) stfld {{i8,str},i8,Seq<{i8}>}::_F2:Seq<{i8}>
      1) ldloc.0 [{{i8,str},i8,Seq<{i8}>}]
      1) dup
      1) ldarg.0 [Arr<obj>]
      1) ldc.i4.0
      5) ldelem [RecordRuntimeTypeInfo]
      5) stfld {}::_rrti:RecordRuntimeTypeInfo
      1) ret
  Total Size: 89

top(Arr<obj>, Arr<obj>):obj
      1) ldarg.1 [Arr<obj>]
      1) ldc.i4.0
      1) ldelem.ref
      5) call static CodeGenUtil::ToRef(obj):ExecCtx
      1) stloc.0 [ExecCtx]
      1) ldarg.1 [Arr<obj>]
      1) ldc.i4.1
      1) ldelem.ref
      5) call static CodeGenUtil::ToRef(obj):Seq<{i8,{i8,str}}>
      1) stloc.1 [Seq<{i8,{i8,str}}>]
      1) ldloc.1 [Seq<{i8,{i8,str}}>]
      1) dup
      5) brtrue [0]
      1) pop
      1) ldnull
      5) br [1]
  Label [0]:
      1) ldloc.0 [ExecCtx]
      1) ldc.i4.0
      5) call static CodeGenUtil::EnumerableToPinging(Seq<{i8,{i8,str}}>, ExecCtx, i4):Seq<{i8,{i8,str}}>
      5) call static CodeGenUtil::WrapIndPairs(Seq<{i8,{i8,str}}>):Seq<ValueTuple<{i8,{i8,str}},i8>>
      1) ldarg.0 [Arr<obj>]
      1) ldc.i4.0
      5) ldelem [Func<ValueTuple<{i8,{i8,str}},i8>,{{i8,str},i8}>]
      1) ldarg.0 [Arr<obj>]
      1) ldc.i4.1
      5) ldelem [Func<ValueTuple<{i8,{i8,str}},i8>,{i8}>]
      1) ldarg.0 [Arr<obj>]
      1) ldc.i4.2
      5) ldelem [Func<{{i8,str},i8},Seq<{i8}>,{{i8,str},i8,Seq<{i8}>}>]
      5) call static Enumerable::GroupBy(Seq<ValueTuple<{i8,{i8,str}},i8>>, Func<ValueTuple<{i8,{i8,str}},i8>,{{i8,str},i8}>, Func<ValueTuple<{i8,{i8,str}},i8>,{i8}>, Func<{{i8,str},i8},Seq<{i8}>,{{i8,str},i8,Seq<{i8}>}>):Seq<{{i8,str},i8,Seq<{i8}>}>
      5) call static CodeGenUtil::EnumerableToCaching(Seq<{{i8,str},i8,Seq<{i8}>}>):Seq<{{i8,str},i8,Seq<{i8}>}>
  Label [1]:
      1) ret
  Total Size: 76

Func sig: (<ctx>:x, D:{Id:i8, R:{M:i8, N:s}}*) to {R:{M:i8, N:s}, S:i8, X:{Id:i8}*}*
Sequence: Seq<{{i8,str},i8,Seq<{i8}>}>
 0) { R: { M: 0, N: A }, S: 0, 
      X: Sequence: Seq<{i8}>
         0) { Id: 0 }
    }
 1) { R: { M: 1, N: b }, S: 0, 
      X: Sequence: Seq<{i8}>
         0) { Id: 1 }
    }
 2) { R: { M: 2, N: B }, S: 0, 
      X: Sequence: Seq<{i8}>
         0) { Id: 2 }
    }
 3) { R: { M: 0, N: a }, S: 0, 
      X: Sequence: Seq<{i8}>
         0) { Id: 3 }
    }
 4) { R: { M: 1, N: A }, S: 0, 
      X: Sequence: Seq<{i8}>
         0) { Id: 4 }
    }
 5) { R: { M: 2, N: b }, S: 0, 
      X: Sequence: Seq<{i8}>
         0) { Id: 5 }
    }
 6) { R: { M: 0, N: <null> }, S: 0, 
      X: Sequence: Seq<{i8}>
         0) { Id: 6 }
    }
 7) { R: { M: 1, N: A }, S: 1, 
      X: Sequence: Seq<{i8}>
         0) { Id: 7 }
    }
 8) { R: { M: 2, N: b }, S: 1, 
      X: Sequence: Seq<{i8}>
         0) { Id: 8 }
    }
 9) { R: { M: 0, N: <null> }, S: 1, 
      X: Sequence: Seq<{i8}>
         0) { Id: 9 }
         1) { Id: 12 }
    }
10) { R: { M: 1, N: a }, S: 1, 
      X: Sequence: Seq<{i8}>
         0) { Id: 10 }
    }
11) { R: { M: 2, N: B }, S: 1, 
      X: Sequence: Seq<{i8}>
         0) { Id: 11 }
    }
*** Ctx ping count: 14
    [0](14): GroupBy(*2: D, [key] R:*2.R, [key] S:IntDiv(#1, 7), [auto] X:<auto>)
###
> GroupBy(D, [~] R, S: # div y, X)
GroupBy(D, [~] R, S : # div y, X) : {R:{M:i8, N:s}, S:i8, X:{Id:i8, R:{M:i8, N:s}}*}*
BndKind:GroupBy, Type:{R:{M:i8, N:s}, S:i8, X:{Id:i8, R:{M:i8, N:s}}*}*, Bnd:(GroupBy([scope:1] Global(D), [~] R:GetField(Scope(1), R), [key] S:0:i8, [auto] X:<auto>))
*** Error: (27,28) Node: y, Message: Name does not exist in the current context
*** Warning: (23,26) Node: # div y, Message: Integer division by zero
###

**** New definitions: D, type: {Id:i8, R:{M:i8, N:s}, S:i8, S2:i8}*

> GroupBy(D, R, X)
GroupBy(D, R, X) : {R:{M:i8, N:s}, X:{Id:i8, S:i8, S2:i8}*}*
BndKind:GroupBy, Type:{R:{M:i8, N:s}, X:{Id:i8, S:i8, S2:i8}*}*, Bnd:(GroupBy([scope:1] Global(D), [key] R:GetField(Scope(1), R), [auto] X:<auto>))
// (<ctx>, ∂.D:{Id:i8, R:{M:i8, N:s}, S:i8, S2:i8}*) : {R:{M:i8, N:s}, X:{Id:i8, S:i8, S2:i8}*}*
keySelector(Arr<obj>, {i8,{i8,str},i8,i8}):{i8,str}
      1) ldarg.1 [{i8,{i8,str},i8,i8}]
      5) ldfld {i8,{i8,str},i8,i8}::_F1:{i8,str}
      1) ret
  Total Size: 7

elementSelector(Arr<obj>, {i8,{i8,str},i8,i8}):{i8,i8,i8}
      5) newobj {i8,i8,i8}()
      1) dup
      1) ldc.i4.7
      5) stfld {i8,i8,i8}::_B0:u1
      1) stloc.0 [{i8,i8,i8}]
      1) ldloc.0 [{i8,i8,i8}]
      1) ldarg.1 [{i8,{i8,str},i8,i8}]
      5) ldfld {i8,{i8,str},i8,i8}::_F0:i8
      5) stfld {i8,i8,i8}::_F0:i8
      1) ldloc.0 [{i8,i8,i8}]
      1) ldarg.1 [{i8,{i8,str},i8,i8}]
      5) ldfld {i8,{i8,str},i8,i8}::_F2:i8
      5) stfld {i8,i8,i8}::_F1:i8
      1) ldloc.0 [{i8,i8,i8}]
      1) ldarg.1 [{i8,{i8,str},i8,i8}]
      5) ldfld {i8,{i8,str},i8,i8}::_F3:i8
      5) stfld {i8,i8,i8}::_F2:i8
      1) ldloc.0 [{i8,i8,i8}]
      1) dup
      1) ldarg.0 [Arr<obj>]
      1) ldc.i4.0
      5) ldelem [RecordRuntimeTypeInfo]
      5) stfld {}::_rrti:RecordRuntimeTypeInfo
      1) ret
  Total Size: 64

resultSelector(Arr<obj>, {i8,str}, Seq<{i8,i8,i8}>):{{i8,str},Seq<{i8,i8,i8}>}
      5) newobj {{i8,str},Seq<{i8,i8,i8}>}()
      1) stloc.0 [{{i8,str},Seq<{i8,i8,i8}>}]
      1) ldarg.1 [{i8,str}]
      5) brfalse [0]
      1) ldloc.0 [{{i8,str},Seq<{i8,i8,i8}>}]
      1) dup
      1) dup
      5) ldfld {{i8,str},Seq<{i8,i8,i8}>}::_B0:u1
      1) ldc.i4.1
      1) or
      5) stfld {{i8,str},Seq<{i8,i8,i8}>}::_B0:u1
      1) ldarg.1 [{i8,str}]
      5) stfld {{i8,str},Seq<{i8,i8,i8}>}::_F0:{i8,str}
  Label [0]:
      1) ldloc.0 [{{i8,str},Seq<{i8,i8,i8}>}]
      1) ldarg.2 [Seq<{i8,i8,i8}>]
      5) call static CodeGenUtil::EnumerableToCaching(Seq<{i8,i8,i8}>):Seq<{i8,i8,i8}>
      5) stfld {{i8,str},Seq<{i8,i8,i8}>}::_F1:Seq<{i8,i8,i8}>
      1) ldloc.0 [{{i8,str},Seq<{i8,i8,i8}>}]
      1) dup
      1) ldarg.0 [Arr<obj>]
      1) ldc.i4.0
      5) ldelem [RecordRuntimeTypeInfo]
      5) stfld {}::_rrti:RecordRuntimeTypeInfo
      1) ret
  Total Size: 60

top(Arr<obj>, Arr<obj>):obj
      1) ldarg.1 [Arr<obj>]
      1) ldc.i4.0
      1) ldelem.ref
      5) call static CodeGenUtil::ToRef(obj):ExecCtx
      1) stloc.0 [ExecCtx]
      1) ldarg.1 [Arr<obj>]
      1) ldc.i4.1
      1) ldelem.ref
      5) call static CodeGenUtil::ToRef(obj):Seq<{i8,{i8,str},i8,i8}>
      1) stloc.1 [Seq<{i8,{i8,str},i8,i8}>]
      1) ldloc.1 [Seq<{i8,{i8,str},i8,i8}>]
      1) dup
      5) brtrue [0]
      1) pop
      1) ldnull
      5) br [1]
  Label [0]:
      1) ldloc.0 [ExecCtx]
      1) ldc.i4.0
      5) call static CodeGenUtil::EnumerableToPinging(Seq<{i8,{i8,str},i8,i8}>, ExecCtx, i4):Seq<{i8,{i8,str},i8,i8}>
      1) ldarg.0 [Arr<obj>]
      1) ldc.i4.0
      5) ldelem [Func<{i8,{i8,str},i8,i8},{i8,str}>]
      1) ldarg.0 [Arr<obj>]
      1) ldc.i4.1
      5) ldelem [Func<{i8,{i8,str},i8,i8},{i8,i8,i8}>]
      1) ldarg.0 [Arr<obj>]
      1) ldc.i4.2
      5) ldelem [Func<{i8,str},Seq<{i8,i8,i8}>,{{i8,str},Seq<{i8,i8,i8}>}>]
      5) call static Enumerable::GroupBy(Seq<{i8,{i8,str},i8,i8}>, Func<{i8,{i8,str},i8,i8},{i8,str}>, Func<{i8,{i8,str},i8,i8},{i8,i8,i8}>, Func<{i8,str},Seq<{i8,i8,i8}>,{{i8,str},Seq<{i8,i8,i8}>}>):Seq<{{i8,str},Seq<{i8,i8,i8}>}>
      5) call static CodeGenUtil::EnumerableToCaching(Seq<{{i8,str},Seq<{i8,i8,i8}>}>):Seq<{{i8,str},Seq<{i8,i8,i8}>}>
  Label [1]:
      1) ret
  Total Size: 71

Func sig: (<ctx>:x, D:{Id:i8, R:{M:i8, N:s}, S:i8, S2:i8}*) to {R:{M:i8, N:s}, X:{Id:i8, S:i8, S2:i8}*}*
Sequence: Seq<{{i8,str},Seq<{i8,i8,i8}>}>
 0) { R: { M: 0, N: A }, 
      X: Sequence: Seq<{i8,i8,i8}>
         0) { Id: 0, S: 0, S2: 0 }
    }
 1) { R: { M: 1, N: b }, 
      X: Sequence: Seq<{i8,i8,i8}>
         0) { Id: 1, S: 0, S2: 0 }
    }
 2) { R: { M: 2, N: B }, 
      X: Sequence: Seq<{i8,i8,i8}>
         0) { Id: 2, S: 0, S2: 0 }
         1) { Id: 11, S: 0, S2: 1 }
    }
 3) { R: { M: 0, N: a }, 
      X: Sequence: Seq<{i8,i8,i8}>
         0) { Id: 3, S: 0, S2: 0 }
    }
 4) { R: { M: 1, N: A }, 
      X: Sequence: Seq<{i8,i8,i8}>
         0) { Id: 4, S: 0, S2: 0 }
         1) { Id: 7, S: 0, S2: 1 }
    }
 5) { R: { M: 2, N: b }, 
      X: Sequence: Seq<{i8,i8,i8}>
         0) { Id: 5, S: 0, S2: 0 }
         1) { Id: 8, S: 0, S2: 1 }
    }
 6) { R: { M: 0, N: <null> }, 
      X: Sequence: Seq<{i8,i8,i8}>
         0) { Id: 6, S: 0, S2: 0 }
         1) { Id: 9, S: 0, S2: 1 }
         2) { Id: 12, S: 0, S2: 1 }
    }
 7) { R: { M: 1, N: a }, 
      X: Sequence: Seq<{i8,i8,i8}>
         0) { Id: 10, S: 0, S2: 1 }
    }
*** Ctx ping count: 14
    [0](14): GroupBy(*1: D, [key] R:*1.R, [auto] X:<auto>)
###
> GroupBy(D, [~] R, X)
GroupBy(D, [~] R, X) : {R:{M:i8, N:s}, X:{Id:i8, R:{M:i8, N:s}, S:i8, S2:i8}*}*
BndKind:GroupBy, Type:{R:{M:i8, N:s}, X:{Id:i8, R:{M:i8, N:s}, S:i8, S2:i8}*}*, Bnd:(GroupBy([scope:1] Global(D), [~] R:GetField(Scope(1), R), [auto] X:<auto>))
// (<ctx>, ∂.D:{Id:i8, R:{M:i8, N:s}, S:i8, S2:i8}*) : {R:{M:i8, N:s}, X:{Id:i8, R:{M:i8, N:s}, S:i8, S2:i8}*}*
keySelector(Arr<obj>, {i8,{i8,str},i8,i8}):{i8,str}
      1) ldarg.1 [{i8,{i8,str},i8,i8}]
      5) ldfld {i8,{i8,str},i8,i8}::_F1:{i8,str}
      1) ret
  Total Size: 7

resultSelector(Arr<obj>, {i8,str}, Seq<{i8,{i8,str},i8,i8}>):{{i8,str},Seq<{i8,{i8,str},i8,i8}>}
      5) newobj {{i8,str},Seq<{i8,{i8,str},i8,i8}>}()
      1) stloc.0 [{{i8,str},Seq<{i8,{i8,str},i8,i8}>}]
      1) ldarg.1 [{i8,str}]
      5) brfalse [0]
      1) ldloc.0 [{{i8,str},Seq<{i8,{i8,str},i8,i8}>}]
      1) dup
      1) dup
      5) ldfld {{i8,str},Seq<{i8,{i8,str},i8,i8}>}::_B0:u1
      1) ldc.i4.1
      1) or
      5) stfld {{i8,str},Seq<{i8,{i8,str},i8,i8}>}::_B0:u1
      1) ldarg.1 [{i8,str}]
      5) stfld {{i8,str},Seq<{i8,{i8,str},i8,i8}>}::_F0:{i8,str}
  Label [0]:
      1) ldloc.0 [{{i8,str},Seq<{i8,{i8,str},i8,i8}>}]
      1) ldarg.2 [Seq<{i8,{i8,str},i8,i8}>]
      5) call static CodeGenUtil::EnumerableToCaching(Seq<{i8,{i8,str},i8,i8}>):Seq<{i8,{i8,str},i8,i8}>
      5) stfld {{i8,str},Seq<{i8,{i8,str},i8,i8}>}::_F1:Seq<{i8,{i8,str},i8,i8}>
      1) ldloc.0 [{{i8,str},Seq<{i8,{i8,str},i8,i8}>}]
      1) dup
      1) ldarg.0 [Arr<obj>]
      1) ldc.i4.0
      5) ldelem [RecordRuntimeTypeInfo]
      5) stfld {}::_rrti:RecordRuntimeTypeInfo
      1) ret
  Total Size: 60

top(Arr<obj>, Arr<obj>):obj
      1) ldarg.1 [Arr<obj>]
      1) ldc.i4.0
      1) ldelem.ref
      5) call static CodeGenUtil::ToRef(obj):ExecCtx
      1) stloc.0 [ExecCtx]
      1) ldarg.1 [Arr<obj>]
      1) ldc.i4.1
      1) ldelem.ref
      5) call static CodeGenUtil::ToRef(obj):Seq<{i8,{i8,str},i8,i8}>
      1) stloc.1 [Seq<{i8,{i8,str},i8,i8}>]
      1) ldloc.1 [Seq<{i8,{i8,str},i8,i8}>]
      1) dup
      5) brtrue [0]
      1) pop
      1) ldnull
      5) br [1]
  Label [0]:
      1) ldloc.0 [ExecCtx]
      1) ldc.i4.0
      5) call static CodeGenUtil::EnumerableToPinging(Seq<{i8,{i8,str},i8,i8}>, ExecCtx, i4):Seq<{i8,{i8,str},i8,i8}>
      1) ldarg.0 [Arr<obj>]
      1) ldc.i4.0
      5) ldelem [Func<{i8,{i8,str},i8,i8},{i8,str}>]
      1) ldarg.0 [Arr<obj>]
      1) ldc.i4.1
      5) ldelem [Func<{i8,str},Seq<{i8,{i8,str},i8,i8}>,{{i8,str},Seq<{i8,{i8,str},i8,i8}>}>]
      1) ldarg.0 [Arr<obj>]
      1) ldc.i4.2
      5) ldelem [EqualityComparer<{i8,str}>]
      5) call static Enumerable::GroupBy(Seq<{i8,{i8,str},i8,i8}>, Func<{i8,{i8,str},i8,i8},{i8,str}>, Func<{i8,str},Seq<{i8,{i8,str},i8,i8}>,{{i8,str},Seq<{i8,{i8,str},i8,i8}>}>, IEqualityComparer<{i8,str}>):Seq<{{i8,str},Seq<{i8,{i8,str},i8,i8}>}>
      5) call static CodeGenUtil::EnumerableToCaching(Seq<{{i8,str},Seq<{i8,{i8,str},i8,i8}>}>):Seq<{{i8,str},Seq<{i8,{i8,str},i8,i8}>}>
  Label [1]:
      1) ret
  Total Size: 71

Func sig: (<ctx>:x, D:{Id:i8, R:{M:i8, N:s}, S:i8, S2:i8}*) to {R:{M:i8, N:s}, X:{Id:i8, R:{M:i8, N:s}, S:i8, S2:i8}*}*
Sequence: Seq<{{i8,str},Seq<{i8,{i8,str},i8,i8}>}>
 0) { R: { M: 0, N: A }, 
      X: Sequence: Seq<{i8,{i8,str},i8,i8}>
         0) { Id: 0, R: { M: 0, N: A }, S: 0, S2: 0 }
         1) { Id: 3, R: { M: 0, N: a }, S: 0, S2: 0 }
    }
 1) { R: { M: 1, N: b }, 
      X: Sequence: Seq<{i8,{i8,str},i8,i8}>
         0) { Id: 1, R: { M: 1, N: b }, S: 0, S2: 0 }
    }
 2) { R: { M: 2, N: B }, 
      X: Sequence: Seq<{i8,{i8,str},i8,i8}>
         0) { Id: 2, R: { M: 2, N: B }, S: 0, S2: 0 }
         1) { Id: 5, R: { M: 2, N: b }, S: 0, S2: 0 }
         2) { Id: 8, R: { M: 2, N: b }, S: 0, S2: 1 }
         3) { Id: 11, R: { M: 2, N: B }, S: 0, S2: 1 }
    }
 3) { R: { M: 1, N: A }, 
      X: Sequence: Seq<{i8,{i8,str},i8,i8}>
         0) { Id: 4, R: { M: 1, N: A }, S: 0, S2: 0 }
         1) { Id: 7, R: { M: 1, N: A }, S: 0, S2: 1 }
         2) { Id: 10, R: { M: 1, N: a }, S: 0, S2: 1 }
    }
 4) { R: { M: 0, N: <null> }, 
      X: Sequence: Seq<{i8,{i8,str},i8,i8}>
         0) { Id: 6, R: { M: 0, N: <null> }, S: 0, S2: 0 }
         1) { Id: 9, R: { M: 0, N: <null> }, S: 0, S2: 1 }
         2) { Id: 12, R: { M: 0, N: <null> }, S: 0, S2: 1 }
    }
*** Ctx ping count: 14
    [0](14): GroupBy(*1: D, [~] R:*1.R, [auto] X:<auto>)
###
> GroupBy(D, R, S, X)
GroupBy(D, R, S, X) : {R:{M:i8, N:s}, S:i8, X:{Id:i8, S2:i8}*}*
BndKind:GroupBy, Type:{R:{M:i8, N:s}, S:i8, X:{Id:i8, S2:i8}*}*, Bnd:(GroupBy([scope:1] Global(D), [key] R:GetField(Scope(1), R), [key] S:GetField(Scope(1), S), [auto] X:<auto>))
// (<ctx>, ∂.D:{Id:i8, R:{M:i8, N:s}, S:i8, S2:i8}*) : {R:{M:i8, N:s}, S:i8, X:{Id:i8, S2:i8}*}*
elementSelector(Arr<obj>, {i8,{i8,str},i8,i8}):{i8,i8}
      5) newobj {i8,i8}()
      1) dup
      1) ldc.i4.3
      5) stfld {i8,i8}::_B0:u1
      1) stloc.0 [{i8,i8}]
      1) ldloc.0 [{i8,i8}]
      1) ldarg.1 [{i8,{i8,str},i8,i8}]
      5) ldfld {i8,{i8,str},i8,i8}::_F0:i8
      5) stfld {i8,i8}::_F0:i8
      1) ldloc.0 [{i8,i8}]
      1) ldarg.1 [{i8,{i8,str},i8,i8}]
      5) ldfld {i8,{i8,str},i8,i8}::_F3:i8
      5) stfld {i8,i8}::_F1:i8
      1) ldloc.0 [{i8,i8}]
      1) dup
      1) ldarg.0 [Arr<obj>]
      1) ldc.i4.0
      5) ldelem [RecordRuntimeTypeInfo]
      5) stfld {}::_rrti:RecordRuntimeTypeInfo
      1) ret
  Total Size: 52

resultSelector(Arr<obj>, {i8,{i8,str},i8,i8}, Seq<{i8,i8}>):{{i8,str},i8,Seq<{i8,i8}>}
      5) newobj {{i8,str},i8,Seq<{i8,i8}>}()
      1) dup
      1) ldc.i4.2
      5) stfld {{i8,str},i8,Seq<{i8,i8}>}::_B0:u1
      1) stloc.0 [{{i8,str},i8,Seq<{i8,i8}>}]
      1) ldarg.1 [{i8,{i8,str},i8,i8}]
      5) ldfld {i8,{i8,str},i8,i8}::_F1:{i8,str}
      5) brfalse [0]
      1) ldloc.0 [{{i8,str},i8,Seq<{i8,i8}>}]
      1) dup
      1) dup
      5) ldfld {{i8,str},i8,Seq<{i8,i8}>}::_B0:u1
      1) ldc.i4.1
      1) or
      5) stfld {{i8,str},i8,Seq<{i8,i8}>}::_B0:u1
      1) ldarg.1 [{i8,{i8,str},i8,i8}]
      5) ldfld {i8,{i8,str},i8,i8}::_F1:{i8,str}
      5) stfld {{i8,str},i8,Seq<{i8,i8}>}::_F0:{i8,str}
  Label [0]:
      1) ldloc.0 [{{i8,str},i8,Seq<{i8,i8}>}]
      1) ldarg.1 [{i8,{i8,str},i8,i8}]
      5) ldfld {i8,{i8,str},i8,i8}::_F2:i8
      5) stfld {{i8,str},i8,Seq<{i8,i8}>}::_F1:i8
      1) ldloc.0 [{{i8,str},i8,Seq<{i8,i8}>}]
      1) ldarg.2 [Seq<{i8,i8}>]
      5) call static CodeGenUtil::EnumerableToCaching(Seq<{i8,i8}>):Seq<{i8,i8}>
      5) stfld {{i8,str},i8,Seq<{i8,i8}>}::_F2:Seq<{i8,i8}>
      1) ldloc.0 [{{i8,str},i8,Seq<{i8,i8}>}]
      1) dup
      1) ldarg.0 [Arr<obj>]
      1) ldc.i4.0
      5) ldelem [RecordRuntimeTypeInfo]
      5) stfld {}::_rrti:RecordRuntimeTypeInfo
      1) ret
  Total Size: 89

Equals(Arr<obj>, {i8,{i8,str},i8,i8}, {i8,{i8,str},i8,i8}):bool
      1) ldarg.1 [{i8,{i8,str},i8,i8}]
      5) ldfld {i8,{i8,str},i8,i8}::_F1:{i8,str}
      1) ldarg.2 [{i8,{i8,str},i8,i8}]
      5) ldfld {i8,{i8,str},i8,i8}::_F1:{i8,str}
      5) call static {i8,str}::Equals2({i8,str}, {i8,str}):bool
      5) brfalse [0]
      1) ldarg.1 [{i8,{i8,str},i8,i8}]
      5) ldfld {i8,{i8,str},i8,i8}::_F2:i8
      1) ldarg.2 [{i8,{i8,str},i8,i8}]
      5) ldfld {i8,{i8,str},i8,i8}::_F2:i8
      2) ceq
      5) br [1]
  Label [0]:
      1) ldc.i4.0
  Label [1]:
      1) ret
  Total Size: 43

GetHashCode(Arr<obj>, {i8,{i8,str},i8,i8}):i4
      5) call static EqualityComparer<{i8,str}>::get_Default():EqualityComparer<{i8,str}>
      1) ldarg.1 [{i8,{i8,str},i8,i8}]
      5) ldfld {i8,{i8,str},i8,i8}::_F1:{i8,str}
      5) callvirt EqualityComparer<{i8,str}>::GetHashCode({i8,str}):i4
      1) ldarg.1 [{i8,{i8,str},i8,i8}]
      5) ldfld {i8,{i8,str},i8,i8}::_F2:i8
      5) call static HashCode::Combine(i4, i8):i4
      1) ret
  Total Size: 28

top(Arr<obj>, Arr<obj>):obj
      1) ldarg.1 [Arr<obj>]
      1) ldc.i4.0
      1) ldelem.ref
      5) call static CodeGenUtil::ToRef(obj):ExecCtx
      1) stloc.0 [ExecCtx]
      1) ldarg.1 [Arr<obj>]
      1) ldc.i4.1
      1) ldelem.ref
      5) call static CodeGenUtil::ToRef(obj):Seq<{i8,{i8,str},i8,i8}>
      1) stloc.1 [Seq<{i8,{i8,str},i8,i8}>]
      1) ldloc.1 [Seq<{i8,{i8,str},i8,i8}>]
      1) dup
      5) brtrue [0]
      1) pop
      1) ldnull
      5) br [1]
  Label [0]:
      1) ldloc.0 [ExecCtx]
      1) ldc.i4.0
      5) call static CodeGenUtil::EnumerableToPinging(Seq<{i8,{i8,str},i8,i8}>, ExecCtx, i4):Seq<{i8,{i8,str},i8,i8}>
      1) ldarg.0 [Arr<obj>]
      1) ldc.i4.0
      5) ldelem [Func<{i8,{i8,str},i8,i8},{i8,{i8,str},i8,i8}>]
      1) ldarg.0 [Arr<obj>]
      1) ldc.i4.1
      5) ldelem [Func<{i8,{i8,str},i8,i8},{i8,i8}>]
      1) ldarg.0 [Arr<obj>]
      1) ldc.i4.2
      5) ldelem [Func<{i8,{i8,str},i8,i8},Seq<{i8,i8}>,{{i8,str},i8,Seq<{i8,i8}>}>]
      1) ldarg.0 [Arr<obj>]
      1) ldc.i4.3
      5) ldelem [GroupByComparer<{i8,{i8,str},i8,i8}>]
      5) call static Enumerable::GroupBy(Seq<{i8,{i8,str},i8,i8}>, Func<{i8,{i8,str},i8,i8},{i8,{i8,str},i8,i8}>, Func<{i8,{i8,str},i8,i8},{i8,i8}>, Func<{i8,{i8,str},i8,i8},Seq<{i8,i8}>,{{i8,str},i8,Seq<{i8,i8}>}>, IEqualityComparer<{i8,{i8,str},i8,i8}>):Seq<{{i8,str},i8,Seq<{i8,i8}>}>
      5) call static CodeGenUtil::EnumerableToCaching(Seq<{{i8,str},i8,Seq<{i8,i8}>}>):Seq<{{i8,str},i8,Seq<{i8,i8}>}>
  Label [1]:
      1) ret
  Total Size: 78

Func sig: (<ctx>:x, D:{Id:i8, R:{M:i8, N:s}, S:i8, S2:i8}*) to {R:{M:i8, N:s}, S:i8, X:{Id:i8, S2:i8}*}*
Sequence: Seq<{{i8,str},i8,Seq<{i8,i8}>}>
 0) { R: { M: 0, N: A }, S: 0, 
      X: Sequence: Seq<{i8,i8}>
         0) { Id: 0, S2: 0 }
    }
 1) { R: { M: 1, N: b }, S: 0, 
      X: Sequence: Seq<{i8,i8}>
         0) { Id: 1, S2: 0 }
    }
 2) { R: { M: 2, N: B }, S: 0, 
      X: Sequence: Seq<{i8,i8}>
         0) { Id: 2, S2: 0 }
         1) { Id: 11, S2: 1 }
    }
 3) { R: { M: 0, N: a }, S: 0, 
      X: Sequence: Seq<{i8,i8}>
         0) { Id: 3, S2: 0 }
    }
 4) { R: { M: 1, N: A }, S: 0, 
      X: Sequence: Seq<{i8,i8}>
         0) { Id: 4, S2: 0 }
         1) { Id: 7, S2: 1 }
    }
 5) { R: { M: 2, N: b }, S: 0, 
      X: Sequence: Seq<{i8,i8}>
         0) { Id: 5, S2: 0 }
         1) { Id: 8, S2: 1 }
    }
 6) { R: { M: 0, N: <null> }, S: 0, 
      X: Sequence: Seq<{i8,i8}>
         0) { Id: 6, S2: 0 }
         1) { Id: 9, S2: 1 }
         2) { Id: 12, S2: 1 }
    }
 7) { R: { M: 1, N: a }, S: 0, 
      X: Sequence: Seq<{i8,i8}>
         0) { Id: 10, S2: 1 }
    }
*** Ctx ping count: 14
    [0](14): GroupBy(*1: D, [key] R:*1.R, [key] S:*1.S, [auto] X:<auto>)
###
> GroupBy(D, [~] R, S, X)
GroupBy(D, [~] R, S, X) : {R:{M:i8, N:s}, S:i8, X:{Id:i8, R:{M:i8, N:s}, S2:i8}*}*
BndKind:GroupBy, Type:{R:{M:i8, N:s}, S:i8, X:{Id:i8, R:{M:i8, N:s}, S2:i8}*}*, Bnd:(GroupBy([scope:1] Global(D), [~] R:GetField(Scope(1), R), [key] S:GetField(Scope(1), S), [auto] X:<auto>))
// (<ctx>, ∂.D:{Id:i8, R:{M:i8, N:s}, S:i8, S2:i8}*) : {R:{M:i8, N:s}, S:i8, X:{Id:i8, R:{M:i8, N:s}, S2:i8}*}*
elementSelector(Arr<obj>, {i8,{i8,str},i8,i8}):{i8,{i8,str},i8}
      5) newobj {i8,{i8,str},i8}()
      1) dup
      1) ldc.i4.5
      5) stfld {i8,{i8,str},i8}::_B0:u1
      1) stloc.0 [{i8,{i8,str},i8}]
      1) ldloc.0 [{i8,{i8,str},i8}]
      1) ldarg.1 [{i8,{i8,str},i8,i8}]
      5) ldfld {i8,{i8,str},i8,i8}::_F0:i8
      5) stfld {i8,{i8,str},i8}::_F0:i8
      1) ldarg.1 [{i8,{i8,str},i8,i8}]
      5) ldfld {i8,{i8,str},i8,i8}::_F1:{i8,str}
      5) brfalse [0]
      1) ldloc.0 [{i8,{i8,str},i8}]
      1) dup
      1) dup
      5) ldfld {i8,{i8,str},i8}::_B0:u1
      1) ldc.i4.2
      1) or
      5) stfld {i8,{i8,str},i8}::_B0:u1
      1) ldarg.1 [{i8,{i8,str},i8,i8}]
      5) ldfld {i8,{i8,str},i8,i8}::_F1:{i8,str}
      5) stfld {i8,{i8,str},i8}::_F1:{i8,str}
  Label [0]:
      1) ldloc.0 [{i8,{i8,str},i8}]
      1) ldarg.1 [{i8,{i8,str},i8,i8}]
      5) ldfld {i8,{i8,str},i8,i8}::_F3:i8
      5) stfld {i8,{i8,str},i8}::_F2:i8
      1) ldloc.0 [{i8,{i8,str},i8}]
      1) dup
      1) ldarg.0 [Arr<obj>]
      1) ldc.i4.0
      5) ldelem [RecordRuntimeTypeInfo]
      5) stfld {}::_rrti:RecordRuntimeTypeInfo
      1) ret
  Total Size: 89

resultSelector(Arr<obj>, {i8,{i8,str},i8,i8}, Seq<{i8,{i8,str},i8}>):{{i8,str},i8,Seq<{i8,{i8,str},i8}>}
      5) newobj {{i8,str},i8,Seq<{i8,{i8,str},i8}>}()
      1) dup
      1) ldc.i4.2
      5) stfld {{i8,str},i8,Seq<{i8,{i8,str},i8}>}::_B0:u1
      1) stloc.0 [{{i8,str},i8,Seq<{i8,{i8,str},i8}>}]
      1) ldarg.1 [{i8,{i8,str},i8,i8}]
      5) ldfld {i8,{i8,str},i8,i8}::_F1:{i8,str}
      5) brfalse [0]
      1) ldloc.0 [{{i8,str},i8,Seq<{i8,{i8,str},i8}>}]
      1) dup
      1) dup
      5) ldfld {{i8,str},i8,Seq<{i8,{i8,str},i8}>}::_B0:u1
      1) ldc.i4.1
      1) or
      5) stfld {{i8,str},i8,Seq<{i8,{i8,str},i8}>}::_B0:u1
      1) ldarg.1 [{i8,{i8,str},i8,i8}]
      5) ldfld {i8,{i8,str},i8,i8}::_F1:{i8,str}
      5) stfld {{i8,str},i8,Seq<{i8,{i8,str},i8}>}::_F0:{i8,str}
  Label [0]:
      1) ldloc.0 [{{i8,str},i8,Seq<{i8,{i8,str},i8}>}]
      1) ldarg.1 [{i8,{i8,str},i8,i8}]
      5) ldfld {i8,{i8,str},i8,i8}::_F2:i8
      5) stfld {{i8,str},i8,Seq<{i8,{i8,str},i8}>}::_F1:i8
      1) ldloc.0 [{{i8,str},i8,Seq<{i8,{i8,str},i8}>}]
      1) ldarg.2 [Seq<{i8,{i8,str},i8}>]
      5) call static CodeGenUtil::EnumerableToCaching(Seq<{i8,{i8,str},i8}>):Seq<{i8,{i8,str},i8}>
      5) stfld {{i8,str},i8,Seq<{i8,{i8,str},i8}>}::_F2:Seq<{i8,{i8,str},i8}>
      1) ldloc.0 [{{i8,str},i8,Seq<{i8,{i8,str},i8}>}]
      1) dup
      1) ldarg.0 [Arr<obj>]
      1) ldc.i4.0
      5) ldelem [RecordRuntimeTypeInfo]
      5) stfld {}::_rrti:RecordRuntimeTypeInfo
      1) ret
  Total Size: 89

Equals(Arr<obj>, {i8,{i8,str},i8,i8}, {i8,{i8,str},i8,i8}):bool
      1) ldarg.0 [Arr<obj>]
      1) ldc.i4.0
      5) ldelem [EqualityComparer<{i8,str}>]
      1) ldarg.1 [{i8,{i8,str},i8,i8}]
      5) ldfld {i8,{i8,str},i8,i8}::_F1:{i8,str}
      1) ldarg.2 [{i8,{i8,str},i8,i8}]
      5) ldfld {i8,{i8,str},i8,i8}::_F1:{i8,str}
      5) callvirt EqualityComparer<{i8,str}>::Equals({i8,str}, {i8,str}):bool
      5) brfalse [0]
      1) ldarg.1 [{i8,{i8,str},i8,i8}]
      5) ldfld {i8,{i8,str},i8,i8}::_F2:i8
      1) ldarg.2 [{i8,{i8,str},i8,i8}]
      5) ldfld {i8,{i8,str},i8,i8}::_F2:i8
      2) ceq
      5) br [1]
  Label [0]:
      1) ldc.i4.0
  Label [1]:
      1) ret
  Total Size: 50

GetHashCode(Arr<obj>, {i8,{i8,str},i8,i8}):i4
      1) ldarg.0 [Arr<obj>]
      1) ldc.i4.0
      5) ldelem [EqualityComparer<{i8,str}>]
      1) ldarg.1 [{i8,{i8,str},i8,i8}]
      5) ldfld {i8,{i8,str},i8,i8}::_F1:{i8,str}
      5) callvirt EqualityComparer<{i8,str}>::GetHashCode({i8,str}):i4
      1) ldarg.1 [{i8,{i8,str},i8,i8}]
      5) ldfld {i8,{i8,str},i8,i8}::_F2:i8
      5) call static HashCode::Combine(i4, i8):i4
      1) ret
  Total Size: 30

top(Arr<obj>, Arr<obj>):obj
      1) ldarg.1 [Arr<obj>]
      1) ldc.i4.0
      1) ldelem.ref
      5) call static CodeGenUtil::ToRef(obj):ExecCtx
      1) stloc.0 [ExecCtx]
      1) ldarg.1 [Arr<obj>]
      1) ldc.i4.1
      1) ldelem.ref
      5) call static CodeGenUtil::ToRef(obj):Seq<{i8,{i8,str},i8,i8}>
      1) stloc.1 [Seq<{i8,{i8,str},i8,i8}>]
      1) ldloc.1 [Seq<{i8,{i8,str},i8,i8}>]
      1) dup
      5) brtrue [0]
      1) pop
      1) ldnull
      5) br [1]
  Label [0]:
      1) ldloc.0 [ExecCtx]
      1) ldc.i4.0
      5) call static CodeGenUtil::EnumerableToPinging(Seq<{i8,{i8,str},i8,i8}>, ExecCtx, i4):Seq<{i8,{i8,str},i8,i8}>
      1) ldarg.0 [Arr<obj>]
      1) ldc.i4.0
      5) ldelem [Func<{i8,{i8,str},i8,i8},{i8,{i8,str},i8,i8}>]
      1) ldarg.0 [Arr<obj>]
      1) ldc.i4.1
      5) ldelem [Func<{i8,{i8,str},i8,i8},{i8,{i8,str},i8}>]
      1) ldarg.0 [Arr<obj>]
      1) ldc.i4.2
      5) ldelem [Func<{i8,{i8,str},i8,i8},Seq<{i8,{i8,str},i8}>,{{i8,str},i8,Seq<{i8,{i8,str},i8}>}>]
      1) ldarg.0 [Arr<obj>]
      1) ldc.i4.3
      5) ldelem [GroupByComparer<{i8,{i8,str},i8,i8}>]
      5) call static Enumerable::GroupBy(Seq<{i8,{i8,str},i8,i8}>, Func<{i8,{i8,str},i8,i8},{i8,{i8,str},i8,i8}>, Func<{i8,{i8,str},i8,i8},{i8,{i8,str},i8}>, Func<{i8,{i8,str},i8,i8},Seq<{i8,{i8,str},i8}>,{{i8,str},i8,Seq<{i8,{i8,str},i8}>}>, IEqualityComparer<{i8,{i8,str},i8,i8}>):Seq<{{i8,str},i8,Seq<{i8,{i8,str},i8}>}>
      5) call static CodeGenUtil::EnumerableToCaching(Seq<{{i8,str},i8,Seq<{i8,{i8,str},i8}>}>):Seq<{{i8,str},i8,Seq<{i8,{i8,str},i8}>}>
  Label [1]:
      1) ret
  Total Size: 78

Func sig: (<ctx>:x, D:{Id:i8, R:{M:i8, N:s}, S:i8, S2:i8}*) to {R:{M:i8, N:s}, S:i8, X:{Id:i8, R:{M:i8, N:s}, S2:i8}*}*
Sequence: Seq<{{i8,str},i8,Seq<{i8,{i8,str},i8}>}>
 0) { R: { M: 0, N: A }, S: 0, 
      X: Sequence: Seq<{i8,{i8,str},i8}>
         0) { Id: 0, R: { M: 0, N: A }, S2: 0 }
         1) { Id: 3, R: { M: 0, N: a }, S2: 0 }
    }
 1) { R: { M: 1, N: b }, S: 0, 
      X: Sequence: Seq<{i8,{i8,str},i8}>
         0) { Id: 1, R: { M: 1, N: b }, S2: 0 }
    }
 2) { R: { M: 2, N: B }, S: 0, 
      X: Sequence: Seq<{i8,{i8,str},i8}>
         0) { Id: 2, R: { M: 2, N: B }, S2: 0 }
         1) { Id: 5, R: { M: 2, N: b }, S2: 0 }
         2) { Id: 8, R: { M: 2, N: b }, S2: 1 }
         3) { Id: 11, R: { M: 2, N: B }, S2: 1 }
    }
 3) { R: { M: 1, N: A }, S: 0, 
      X: Sequence: Seq<{i8,{i8,str},i8}>
         0) { Id: 4, R: { M: 1, N: A }, S2: 0 }
         1) { Id: 7, R: { M: 1, N: A }, S2: 1 }
         2) { Id: 10, R: { M: 1, N: a }, S2: 1 }
    }
 4) { R: { M: 0, N: <null> }, S: 0, 
      X: Sequence: Seq<{i8,{i8,str},i8}>
         0) { Id: 6, R: { M: 0, N: <null> }, S2: 0 }
         1) { Id: 9, R: { M: 0, N: <null> }, S2: 1 }
         2) { Id: 12, R: { M: 0, N: <null> }, S2: 1 }
    }
*** Ctx ping count: 14
    [0](14): GroupBy(*1: D, [~] R:*1.R, [key] S:*1.S, [auto] X:<auto>)
###
> GroupBy(D, [~] R, S, [item] T: #, X)
GroupBy(D, [~] R, S, [map] T : #, X) : {R:{M:i8, N:s}, S:i8, T:i8*, X:{Id:i8, R:{M:i8, N:s}, S2:i8}*}*
BndKind:GroupBy, Type:{R:{M:i8, N:s}, S:i8, T:i8*, X:{Id:i8, R:{M:i8, N:s}, S2:i8}*}*, Bnd:(GroupBy([scope:1] Global(D), [~] R:GetField(Scope(1), R), [key] S:GetField(Scope(1), S), [map] T:Scope(2), [auto] X:<auto>))
// (<ctx>, ∂.D:{Id:i8, R:{M:i8, N:s}, S:i8, S2:i8}*) : {R:{M:i8, N:s}, S:i8, T:i8*, X:{Id:i8, R:{M:i8, N:s}, S2:i8}*}*
keySelector(Arr<obj>, ValueTuple<{i8,{i8,str},i8,i8},i8>):{{i8,str},i8}
      1) ldarg.1 [ValueTuple<{i8,{i8,str},i8,i8},i8>]
      5) ldfld ValueTuple<{i8,{i8,str},i8,i8},i8>::Item1:{i8,{i8,str},i8,i8}
      1) stloc.0 [{i8,{i8,str},i8,i8}]
      5) newobj {{i8,str},i8}()
      1) dup
      1) ldc.i4.2
      5) stfld {{i8,str},i8}::_B0:u1
      1) stloc.1 [{{i8,str},i8}]
      1) ldloc.1 [{{i8,str},i8}]
      1) ldloc.0 [{i8,{i8,str},i8,i8}]
      5) ldfld {i8,{i8,str},i8,i8}::_F1:{i8,str}
      1) dup
      5) brfalse [0]
      5) stfld {{i8,str},i8}::_F0:{i8,str}
      1) ldloc.1 [{{i8,str},i8}]
      1) dup
      5) ldfld {{i8,str},i8}::_B0:u1
      1) ldc.i4.1
      1) or
      5) stfld {{i8,str},i8}::_B0:u1
      5) br [1]
  Label [0]:
      1) pop
      1) pop
  Label [1]:
      1) ldloc.1 [{{i8,str},i8}]
      1) ldloc.0 [{i8,{i8,str},i8,i8}]
      5) ldfld {i8,{i8,str},i8,i8}::_F2:i8
      5) stfld {{i8,str},i8}::_F1:i8
      1) ldloc.1 [{{i8,str},i8}]
      1) dup
      1) ldarg.0 [Arr<obj>]
      1) ldc.i4.0
      5) ldelem [RecordRuntimeTypeInfo]
      5) stfld {}::_rrti:RecordRuntimeTypeInfo
      1) ret
  Total Size: 86

mapItem0(Arr<obj>, ValueTuple<{i8,{i8,str},i8,i8},i8>):i8
      1) ldarg.1 [ValueTuple<{i8,{i8,str},i8,i8},i8>]
      5) ldfld ValueTuple<{i8,{i8,str},i8,i8},i8>::Item1:{i8,{i8,str},i8,i8}
      1) stloc.0 [{i8,{i8,str},i8,i8}]
      1) ldarg.1 [ValueTuple<{i8,{i8,str},i8,i8},i8>]
      5) ldfld ValueTuple<{i8,{i8,str},i8,i8},i8>::Item2:i8
      1) stloc.1 [i8]
      1) ldloc.1 [i8]
      1) ret
  Total Size: 16

mapItem1(Arr<obj>, ValueTuple<{i8,{i8,str},i8,i8},i8>):{i8,{i8,str},i8}
      1) ldarg.1 [ValueTuple<{i8,{i8,str},i8,i8},i8>]
      5) ldfld ValueTuple<{i8,{i8,str},i8,i8},i8>::Item1:{i8,{i8,str},i8,i8}
      1) stloc.0 [{i8,{i8,str},i8,i8}]
      5) newobj {i8,{i8,str},i8}()
      1) dup
      1) ldc.i4.5
      5) stfld {i8,{i8,str},i8}::_B0:u1
      1) stloc.1 [{i8,{i8,str},i8}]
      1) ldloc.1 [{i8,{i8,str},i8}]
      1) ldloc.0 [{i8,{i8,str},i8,i8}]
      5) ldfld {i8,{i8,str},i8,i8}::_F0:i8
      5) stfld {i8,{i8,str},i8}::_F0:i8
      1) ldloc.0 [{i8,{i8,str},i8,i8}]
      5) ldfld {i8,{i8,str},i8,i8}::_F1:{i8,str}
      5) brfalse [0]
      1) ldloc.1 [{i8,{i8,str},i8}]
      1) dup
      1) dup
      5) ldfld {i8,{i8,str},i8}::_B0:u1
      1) ldc.i4.2
      1) or
      5) stfld {i8,{i8,str},i8}::_B0:u1
      1) ldloc.0 [{i8,{i8,str},i8,i8}]
      5) ldfld {i8,{i8,str},i8,i8}::_F1:{i8,str}
      5) stfld {i8,{i8,str},i8}::_F1:{i8,str}
  Label [0]:
      1) ldloc.1 [{i8,{i8,str},i8}]
      1) ldloc.0 [{i8,{i8,str},i8,i8}]
      5) ldfld {i8,{i8,str},i8,i8}::_F3:i8
      5) stfld {i8,{i8,str},i8}::_F2:i8
      1) ldloc.1 [{i8,{i8,str},i8}]
      1) dup
      1) ldarg.0 [Arr<obj>]
      1) ldc.i4.0
      5) ldelem [RecordRuntimeTypeInfo]
      5) stfld {}::_rrti:RecordRuntimeTypeInfo
      1) ret
  Total Size: 96

resultSelector(Arr<obj>, {{i8,str},i8}, Seq<ValueTuple<{i8,{i8,str},i8,i8},i8>>):{{i8,str},i8,Seq<i8>,Seq<{i8,{i8,str},i8}>}
      5) newobj {{i8,str},i8,Seq<i8>,Seq<{i8,{i8,str},i8}>}()
      1) dup
      1) ldc.i4.2
      5) stfld {{i8,str},i8,Seq<i8>,Seq<{i8,{i8,str},i8}>}::_B0:u1
      1) stloc.0 [{{i8,str},i8,Seq<i8>,Seq<{i8,{i8,str},i8}>}]
      1) ldarg.1 [{{i8,str},i8}]
      5) ldfld {{i8,str},i8}::_F0:{i8,str}
      5) brfalse [0]
      1) ldloc.0 [{{i8,str},i8,Seq<i8>,Seq<{i8,{i8,str},i8}>}]
      1) dup
      1) dup
      5) ldfld {{i8,str},i8,Seq<i8>,Seq<{i8,{i8,str},i8}>}::_B0:u1
      1) ldc.i4.1
      1) or
      5) stfld {{i8,str},i8,Seq<i8>,Seq<{i8,{i8,str},i8}>}::_B0:u1
      1) ldarg.1 [{{i8,str},i8}]
      5) ldfld {{i8,str},i8}::_F0:{i8,str}
      5) stfld {{i8,str},i8,Seq<i8>,Seq<{i8,{i8,str},i8}>}::_F0:{i8,str}
  Label [0]:
      1) ldloc.0 [{{i8,str},i8,Seq<i8>,Seq<{i8,{i8,str},i8}>}]
      1) ldarg.1 [{{i8,str},i8}]
      5) ldfld {{i8,str},i8}::_F1:i8
      5) stfld {{i8,str},i8,Seq<i8>,Seq<{i8,{i8,str},i8}>}::_F1:i8
      1) ldarg.2 [Seq<ValueTuple<{i8,{i8,str},i8,i8},i8>>]
      5) call static CodeGenUtil::EnumerableToCaching(Seq<ValueTuple<{i8,{i8,str},i8,i8},i8>>):Seq<ValueTuple<{i8,{i8,str},i8,i8},i8>>
      1) stloc.1 [Seq<ValueTuple<{i8,{i8,str},i8,i8},i8>>]
      1) ldloc.0 [{{i8,str},i8,Seq<i8>,Seq<{i8,{i8,str},i8}>}]
      1) ldloc.1 [Seq<ValueTuple<{i8,{i8,str},i8,i8},i8>>]
      1) ldarg.0 [Arr<obj>]
      1) ldc.i4.0
      5) ldelem [Func<ValueTuple<{i8,{i8,str},i8,i8},i8>,i8>]
      5) call static Enumerable::Select(Seq<ValueTuple<{i8,{i8,str},i8,i8},i8>>, Func<ValueTuple<{i8,{i8,str},i8,i8},i8>,i8>):Seq<i8>
      5) call static CodeGenUtil::EnumerableToCaching(Seq<i8>):Seq<i8>
      5) stfld {{i8,str},i8,Seq<i8>,Seq<{i8,{i8,str},i8}>}::_F2:Seq<i8>
      1) ldloc.0 [{{i8,str},i8,Seq<i8>,Seq<{i8,{i8,str},i8}>}]
      1) ldloc.1 [Seq<ValueTuple<{i8,{i8,str},i8,i8},i8>>]
      1) ldarg.0 [Arr<obj>]
      1) ldc.i4.1
      5) ldelem [Func<ValueTuple<{i8,{i8,str},i8,i8},i8>,{i8,{i8,str},i8}>]
      5) call static Enumerable::Select(Seq<ValueTuple<{i8,{i8,str},i8,i8},i8>>, Func<ValueTuple<{i8,{i8,str},i8,i8},i8>,{i8,{i8,str},i8}>):Seq<{i8,{i8,str},i8}>
      5) call static CodeGenUtil::EnumerableToCaching(Seq<{i8,{i8,str},i8}>):Seq<{i8,{i8,str},i8}>
      5) stfld {{i8,str},i8,Seq<i8>,Seq<{i8,{i8,str},i8}>}::_F3:Seq<{i8,{i8,str},i8}>
      1) ldloc.1 [Seq<ValueTuple<{i8,{i8,str},i8,i8},i8>>]
      1) pop
      1) ldloc.0 [{{i8,str},i8,Seq<i8>,Seq<{i8,{i8,str},i8}>}]
      1) dup
      1) ldarg.0 [Arr<obj>]
      1) ldc.i4.2
      5) ldelem [RecordRuntimeTypeInfo]
      5) stfld {}::_rrti:RecordRuntimeTypeInfo
      1) ret
  Total Size: 134

top(Arr<obj>, Arr<obj>):obj
      1) ldarg.1 [Arr<obj>]
      1) ldc.i4.0
      1) ldelem.ref
      5) call static CodeGenUtil::ToRef(obj):ExecCtx
      1) stloc.0 [ExecCtx]
      1) ldarg.1 [Arr<obj>]
      1) ldc.i4.1
      1) ldelem.ref
      5) call static CodeGenUtil::ToRef(obj):Seq<{i8,{i8,str},i8,i8}>
      1) stloc.1 [Seq<{i8,{i8,str},i8,i8}>]
      1) ldloc.1 [Seq<{i8,{i8,str},i8,i8}>]
      1) dup
      5) brtrue [0]
      1) pop
      1) ldnull
      5) br [1]
  Label [0]:
      1) ldloc.0 [ExecCtx]
      1) ldc.i4.0
      5) call static CodeGenUtil::EnumerableToPinging(Seq<{i8,{i8,str},i8,i8}>, ExecCtx, i4):Seq<{i8,{i8,str},i8,i8}>
      5) call static CodeGenUtil::WrapIndPairs(Seq<{i8,{i8,str},i8,i8}>):Seq<ValueTuple<{i8,{i8,str},i8,i8},i8>>
      1) ldarg.0 [Arr<obj>]
      1) ldc.i4.0
      5) ldelem [Func<ValueTuple<{i8,{i8,str},i8,i8},i8>,{{i8,str},i8}>]
      1) ldarg.0 [Arr<obj>]
      1) ldc.i4.1
      5) ldelem [Func<{{i8,str},i8},Seq<ValueTuple<{i8,{i8,str},i8,i8},i8>>,{{i8,str},i8,Seq<i8>,Seq<{i8,{i8,str},i8}>}>]
      1) ldarg.0 [Arr<obj>]
      1) ldc.i4.2
      5) ldelem [EqualityComparer<{{i8,str},i8}>]
      5) call static Enumerable::GroupBy(Seq<ValueTuple<{i8,{i8,str},i8,i8},i8>>, Func<ValueTuple<{i8,{i8,str},i8,i8},i8>,{{i8,str},i8}>, Func<{{i8,str},i8},Seq<ValueTuple<{i8,{i8,str},i8,i8},i8>>,{{i8,str},i8,Seq<i8>,Seq<{i8,{i8,str},i8}>}>, IEqualityComparer<{{i8,str},i8}>):Seq<{{i8,str},i8,Seq<i8>,Seq<{i8,{i8,str},i8}>}>
      5) call static CodeGenUtil::EnumerableToCaching(Seq<{{i8,str},i8,Seq<i8>,Seq<{i8,{i8,str},i8}>}>):Seq<{{i8,str},i8,Seq<i8>,Seq<{i8,{i8,str},i8}>}>
  Label [1]:
      1) ret
  Total Size: 76

Func sig: (<ctx>:x, D:{Id:i8, R:{M:i8, N:s}, S:i8, S2:i8}*) to {R:{M:i8, N:s}, S:i8, T:i8*, X:{Id:i8, R:{M:i8, N:s}, S2:i8}*}*
Sequence: Seq<{{i8,str},i8,Seq<i8>,Seq<{i8,{i8,str},i8}>}>
 0) { R: { M: 0, N: A }, S: 0, 
      T: Sequence: Seq<i8>
         0) 0
         1) 3
      X: Sequence: Seq<{i8,{i8,str},i8}>
         0) { Id: 0, R: { M: 0, N: A }, S2: 0 }
         1) { Id: 3, R: { M: 0, N: a }, S2: 0 }
    }
 1) { R: { M: 1, N: b }, S: 0, 
      T: Sequence: Seq<i8>
         0) 1
      X: Sequence: Seq<{i8,{i8,str},i8}>
         0) { Id: 1, R: { M: 1, N: b }, S2: 0 }
    }
 2) { R: { M: 2, N: B }, S: 0, 
      T: Sequence: Seq<i8>
         0) 2
         1) 5
         2) 8
         3) 11
      X: Sequence: Seq<{i8,{i8,str},i8}>
         0) { Id: 2, R: { M: 2, N: B }, S2: 0 }
         1) { Id: 5, R: { M: 2, N: b }, S2: 0 }
         2) { Id: 8, R: { M: 2, N: b }, S2: 1 }
         3) { Id: 11, R: { M: 2, N: B }, S2: 1 }
    }
 3) { R: { M: 1, N: A }, S: 0, 
      T: Sequence: Seq<i8>
         0) 4
         1) 7
         2) 10
      X: Sequence: Seq<{i8,{i8,str},i8}>
         0) { Id: 4, R: { M: 1, N: A }, S2: 0 }
         1) { Id: 7, R: { M: 1, N: A }, S2: 1 }
         2) { Id: 10, R: { M: 1, N: a }, S2: 1 }
    }
 4) { R: { M: 0, N: <null> }, S: 0, 
      T: Sequence: Seq<i8>
         0) 6
         1) 9
         2) 12
      X: Sequence: Seq<{i8,{i8,str},i8}>
         0) { Id: 6, R: { M: 0, N: <null> }, S2: 0 }
         1) { Id: 9, R: { M: 0, N: <null> }, S2: 1 }
         2) { Id: 12, R: { M: 0, N: <null> }, S2: 1 }
    }
*** Ctx ping count: 14
    [0](14): GroupBy(*1: D, [~] R:*1.R, [key] S:*1.S, [map] T:#2, [auto] X:<auto>)
###
> GroupBy(D, R, S2, X)
GroupBy(D, R, S2, X) : {R:{M:i8, N:s}, S2:i8, X:{Id:i8, S:i8}*}*
BndKind:GroupBy, Type:{R:{M:i8, N:s}, S2:i8, X:{Id:i8, S:i8}*}*, Bnd:(GroupBy([scope:1] Global(D), [key] R:GetField(Scope(1), R), [key] S2:GetField(Scope(1), S2), [auto] X:<auto>))
// (<ctx>, ∂.D:{Id:i8, R:{M:i8, N:s}, S:i8, S2:i8}*) : {R:{M:i8, N:s}, S2:i8, X:{Id:i8, S:i8}*}*
elementSelector(Arr<obj>, {i8,{i8,str},i8,i8}):{i8,i8}
      5) newobj {i8,i8}()
      1) dup
      1) ldc.i4.3
      5) stfld {i8,i8}::_B0:u1
      1) stloc.0 [{i8,i8}]
      1) ldloc.0 [{i8,i8}]
      1) ldarg.1 [{i8,{i8,str},i8,i8}]
      5) ldfld {i8,{i8,str},i8,i8}::_F0:i8
      5) stfld {i8,i8}::_F0:i8
      1) ldloc.0 [{i8,i8}]
      1) ldarg.1 [{i8,{i8,str},i8,i8}]
      5) ldfld {i8,{i8,str},i8,i8}::_F2:i8
      5) stfld {i8,i8}::_F1:i8
      1) ldloc.0 [{i8,i8}]
      1) dup
      1) ldarg.0 [Arr<obj>]
      1) ldc.i4.0
      5) ldelem [RecordRuntimeTypeInfo]
      5) stfld {}::_rrti:RecordRuntimeTypeInfo
      1) ret
  Total Size: 52

resultSelector(Arr<obj>, {i8,{i8,str},i8,i8}, Seq<{i8,i8}>):{{i8,str},i8,Seq<{i8,i8}>}
      5) newobj {{i8,str},i8,Seq<{i8,i8}>}()
      1) dup
      1) ldc.i4.2
      5) stfld {{i8,str},i8,Seq<{i8,i8}>}::_B0:u1
      1) stloc.0 [{{i8,str},i8,Seq<{i8,i8}>}]
      1) ldarg.1 [{i8,{i8,str},i8,i8}]
      5) ldfld {i8,{i8,str},i8,i8}::_F1:{i8,str}
      5) brfalse [0]
      1) ldloc.0 [{{i8,str},i8,Seq<{i8,i8}>}]
      1) dup
      1) dup
      5) ldfld {{i8,str},i8,Seq<{i8,i8}>}::_B0:u1
      1) ldc.i4.1
      1) or
      5) stfld {{i8,str},i8,Seq<{i8,i8}>}::_B0:u1
      1) ldarg.1 [{i8,{i8,str},i8,i8}]
      5) ldfld {i8,{i8,str},i8,i8}::_F1:{i8,str}
      5) stfld {{i8,str},i8,Seq<{i8,i8}>}::_F0:{i8,str}
  Label [0]:
      1) ldloc.0 [{{i8,str},i8,Seq<{i8,i8}>}]
      1) ldarg.1 [{i8,{i8,str},i8,i8}]
      5) ldfld {i8,{i8,str},i8,i8}::_F3:i8
      5) stfld {{i8,str},i8,Seq<{i8,i8}>}::_F1:i8
      1) ldloc.0 [{{i8,str},i8,Seq<{i8,i8}>}]
      1) ldarg.2 [Seq<{i8,i8}>]
      5) call static CodeGenUtil::EnumerableToCaching(Seq<{i8,i8}>):Seq<{i8,i8}>
      5) stfld {{i8,str},i8,Seq<{i8,i8}>}::_F2:Seq<{i8,i8}>
      1) ldloc.0 [{{i8,str},i8,Seq<{i8,i8}>}]
      1) dup
      1) ldarg.0 [Arr<obj>]
      1) ldc.i4.0
      5) ldelem [RecordRuntimeTypeInfo]
      5) stfld {}::_rrti:RecordRuntimeTypeInfo
      1) ret
  Total Size: 89

Equals(Arr<obj>, {i8,{i8,str},i8,i8}, {i8,{i8,str},i8,i8}):bool
      1) ldarg.1 [{i8,{i8,str},i8,i8}]
      5) ldfld {i8,{i8,str},i8,i8}::_F1:{i8,str}
      1) ldarg.2 [{i8,{i8,str},i8,i8}]
      5) ldfld {i8,{i8,str},i8,i8}::_F1:{i8,str}
      5) call static {i8,str}::Equals2({i8,str}, {i8,str}):bool
      5) brfalse [0]
      1) ldarg.1 [{i8,{i8,str},i8,i8}]
      5) ldfld {i8,{i8,str},i8,i8}::_F3:i8
      1) ldarg.2 [{i8,{i8,str},i8,i8}]
      5) ldfld {i8,{i8,str},i8,i8}::_F3:i8
      2) ceq
      5) br [1]
  Label [0]:
      1) ldc.i4.0
  Label [1]:
      1) ret
  Total Size: 43

GetHashCode(Arr<obj>, {i8,{i8,str},i8,i8}):i4
      5) call static EqualityComparer<{i8,str}>::get_Default():EqualityComparer<{i8,str}>
      1) ldarg.1 [{i8,{i8,str},i8,i8}]
      5) ldfld {i8,{i8,str},i8,i8}::_F1:{i8,str}
      5) callvirt EqualityComparer<{i8,str}>::GetHashCode({i8,str}):i4
      1) ldarg.1 [{i8,{i8,str},i8,i8}]
      5) ldfld {i8,{i8,str},i8,i8}::_F3:i8
      5) call static HashCode::Combine(i4, i8):i4
      1) ret
  Total Size: 28

top(Arr<obj>, Arr<obj>):obj
      1) ldarg.1 [Arr<obj>]
      1) ldc.i4.0
      1) ldelem.ref
      5) call static CodeGenUtil::ToRef(obj):ExecCtx
      1) stloc.0 [ExecCtx]
      1) ldarg.1 [Arr<obj>]
      1) ldc.i4.1
      1) ldelem.ref
      5) call static CodeGenUtil::ToRef(obj):Seq<{i8,{i8,str},i8,i8}>
      1) stloc.1 [Seq<{i8,{i8,str},i8,i8}>]
      1) ldloc.1 [Seq<{i8,{i8,str},i8,i8}>]
      1) dup
      5) brtrue [0]
      1) pop
      1) ldnull
      5) br [1]
  Label [0]:
      1) ldloc.0 [ExecCtx]
      1) ldc.i4.0
      5) call static CodeGenUtil::EnumerableToPinging(Seq<{i8,{i8,str},i8,i8}>, ExecCtx, i4):Seq<{i8,{i8,str},i8,i8}>
      1) ldarg.0 [Arr<obj>]
      1) ldc.i4.0
      5) ldelem [Func<{i8,{i8,str},i8,i8},{i8,{i8,str},i8,i8}>]
      1) ldarg.0 [Arr<obj>]
      1) ldc.i4.1
      5) ldelem [Func<{i8,{i8,str},i8,i8},{i8,i8}>]
      1) ldarg.0 [Arr<obj>]
      1) ldc.i4.2
      5) ldelem [Func<{i8,{i8,str},i8,i8},Seq<{i8,i8}>,{{i8,str},i8,Seq<{i8,i8}>}>]
      1) ldarg.0 [Arr<obj>]
      1) ldc.i4.3
      5) ldelem [GroupByComparer<{i8,{i8,str},i8,i8}>]
      5) call static Enumerable::GroupBy(Seq<{i8,{i8,str},i8,i8}>, Func<{i8,{i8,str},i8,i8},{i8,{i8,str},i8,i8}>, Func<{i8,{i8,str},i8,i8},{i8,i8}>, Func<{i8,{i8,str},i8,i8},Seq<{i8,i8}>,{{i8,str},i8,Seq<{i8,i8}>}>, IEqualityComparer<{i8,{i8,str},i8,i8}>):Seq<{{i8,str},i8,Seq<{i8,i8}>}>
      5) call static CodeGenUtil::EnumerableToCaching(Seq<{{i8,str},i8,Seq<{i8,i8}>}>):Seq<{{i8,str},i8,Seq<{i8,i8}>}>
  Label [1]:
      1) ret
  Total Size: 78

Func sig: (<ctx>:x, D:{Id:i8, R:{M:i8, N:s}, S:i8, S2:i8}*) to {R:{M:i8, N:s}, S2:i8, X:{Id:i8, S:i8}*}*
Sequence: Seq<{{i8,str},i8,Seq<{i8,i8}>}>
 0) { R: { M: 0, N: A }, S2: 0, 
      X: Sequence: Seq<{i8,i8}>
         0) { Id: 0, S: 0 }
    }
 1) { R: { M: 1, N: b }, S2: 0, 
      X: Sequence: Seq<{i8,i8}>
         0) { Id: 1, S: 0 }
    }
 2) { R: { M: 2, N: B }, S2: 0, 
      X: Sequence: Seq<{i8,i8}>
         0) { Id: 2, S: 0 }
    }
 3) { R: { M: 0, N: a }, S2: 0, 
      X: Sequence: Seq<{i8,i8}>
         0) { Id: 3, S: 0 }
    }
 4) { R: { M: 1, N: A }, S2: 0, 
      X: Sequence: Seq<{i8,i8}>
         0) { Id: 4, S: 0 }
    }
 5) { R: { M: 2, N: b }, S2: 0, 
      X: Sequence: Seq<{i8,i8}>
         0) { Id: 5, S: 0 }
    }
 6) { R: { M: 0, N: <null> }, S2: 0, 
      X: Sequence: Seq<{i8,i8}>
         0) { Id: 6, S: 0 }
    }
 7) { R: { M: 1, N: A }, S2: 1, 
      X: Sequence: Seq<{i8,i8}>
         0) { Id: 7, S: 0 }
    }
 8) { R: { M: 2, N: b }, S2: 1, 
      X: Sequence: Seq<{i8,i8}>
         0) { Id: 8, S: 0 }
    }
 9) { R: { M: 0, N: <null> }, S2: 1, 
      X: Sequence: Seq<{i8,i8}>
         0) { Id: 9, S: 0 }
         1) { Id: 12, S: 0 }
    }
10) { R: { M: 1, N: a }, S2: 1, 
      X: Sequence: Seq<{i8,i8}>
         0) { Id: 10, S: 0 }
    }
11) { R: { M: 2, N: B }, S2: 1, 
      X: Sequence: Seq<{i8,i8}>
         0) { Id: 11, S: 0 }
    }
*** Ctx ping count: 14
    [0](14): GroupBy(*1: D, [key] R:*1.R, [key] S2:*1.S2, [auto] X:<auto>)
###
> GroupBy(D, [~] R, S2, X)
GroupBy(D, [~] R, S2, X) : {R:{M:i8, N:s}, S2:i8, X:{Id:i8, R:{M:i8, N:s}, S:i8}*}*
BndKind:GroupBy, Type:{R:{M:i8, N:s}, S2:i8, X:{Id:i8, R:{M:i8, N:s}, S:i8}*}*, Bnd:(GroupBy([scope:1] Global(D), [~] R:GetField(Scope(1), R), [key] S2:GetField(Scope(1), S2), [auto] X:<auto>))
// (<ctx>, ∂.D:{Id:i8, R:{M:i8, N:s}, S:i8, S2:i8}*) : {R:{M:i8, N:s}, S2:i8, X:{Id:i8, R:{M:i8, N:s}, S:i8}*}*
elementSelector(Arr<obj>, {i8,{i8,str},i8,i8}):{i8,{i8,str},i8}
      5) newobj {i8,{i8,str},i8}()
      1) dup
      1) ldc.i4.5
      5) stfld {i8,{i8,str},i8}::_B0:u1
      1) stloc.0 [{i8,{i8,str},i8}]
      1) ldloc.0 [{i8,{i8,str},i8}]
      1) ldarg.1 [{i8,{i8,str},i8,i8}]
      5) ldfld {i8,{i8,str},i8,i8}::_F0:i8
      5) stfld {i8,{i8,str},i8}::_F0:i8
      1) ldarg.1 [{i8,{i8,str},i8,i8}]
      5) ldfld {i8,{i8,str},i8,i8}::_F1:{i8,str}
      5) brfalse [0]
      1) ldloc.0 [{i8,{i8,str},i8}]
      1) dup
      1) dup
      5) ldfld {i8,{i8,str},i8}::_B0:u1
      1) ldc.i4.2
      1) or
      5) stfld {i8,{i8,str},i8}::_B0:u1
      1) ldarg.1 [{i8,{i8,str},i8,i8}]
      5) ldfld {i8,{i8,str},i8,i8}::_F1:{i8,str}
      5) stfld {i8,{i8,str},i8}::_F1:{i8,str}
  Label [0]:
      1) ldloc.0 [{i8,{i8,str},i8}]
      1) ldarg.1 [{i8,{i8,str},i8,i8}]
      5) ldfld {i8,{i8,str},i8,i8}::_F2:i8
      5) stfld {i8,{i8,str},i8}::_F2:i8
      1) ldloc.0 [{i8,{i8,str},i8}]
      1) dup
      1) ldarg.0 [Arr<obj>]
      1) ldc.i4.0
      5) ldelem [RecordRuntimeTypeInfo]
      5) stfld {}::_rrti:RecordRuntimeTypeInfo
      1) ret
  Total Size: 89

resultSelector(Arr<obj>, {i8,{i8,str},i8,i8}, Seq<{i8,{i8,str},i8}>):{{i8,str},i8,Seq<{i8,{i8,str},i8}>}
      5) newobj {{i8,str},i8,Seq<{i8,{i8,str},i8}>}()
      1) dup
      1) ldc.i4.2
      5) stfld {{i8,str},i8,Seq<{i8,{i8,str},i8}>}::_B0:u1
      1) stloc.0 [{{i8,str},i8,Seq<{i8,{i8,str},i8}>}]
      1) ldarg.1 [{i8,{i8,str},i8,i8}]
      5) ldfld {i8,{i8,str},i8,i8}::_F1:{i8,str}
      5) brfalse [0]
      1) ldloc.0 [{{i8,str},i8,Seq<{i8,{i8,str},i8}>}]
      1) dup
      1) dup
      5) ldfld {{i8,str},i8,Seq<{i8,{i8,str},i8}>}::_B0:u1
      1) ldc.i4.1
      1) or
      5) stfld {{i8,str},i8,Seq<{i8,{i8,str},i8}>}::_B0:u1
      1) ldarg.1 [{i8,{i8,str},i8,i8}]
      5) ldfld {i8,{i8,str},i8,i8}::_F1:{i8,str}
      5) stfld {{i8,str},i8,Seq<{i8,{i8,str},i8}>}::_F0:{i8,str}
  Label [0]:
      1) ldloc.0 [{{i8,str},i8,Seq<{i8,{i8,str},i8}>}]
      1) ldarg.1 [{i8,{i8,str},i8,i8}]
      5) ldfld {i8,{i8,str},i8,i8}::_F3:i8
      5) stfld {{i8,str},i8,Seq<{i8,{i8,str},i8}>}::_F1:i8
      1) ldloc.0 [{{i8,str},i8,Seq<{i8,{i8,str},i8}>}]
      1) ldarg.2 [Seq<{i8,{i8,str},i8}>]
      5) call static CodeGenUtil::EnumerableToCaching(Seq<{i8,{i8,str},i8}>):Seq<{i8,{i8,str},i8}>
      5) stfld {{i8,str},i8,Seq<{i8,{i8,str},i8}>}::_F2:Seq<{i8,{i8,str},i8}>
      1) ldloc.0 [{{i8,str},i8,Seq<{i8,{i8,str},i8}>}]
      1) dup
      1) ldarg.0 [Arr<obj>]
      1) ldc.i4.0
      5) ldelem [RecordRuntimeTypeInfo]
      5) stfld {}::_rrti:RecordRuntimeTypeInfo
      1) ret
  Total Size: 89

Equals(Arr<obj>, {i8,{i8,str},i8,i8}, {i8,{i8,str},i8,i8}):bool
      1) ldarg.0 [Arr<obj>]
      1) ldc.i4.0
      5) ldelem [EqualityComparer<{i8,str}>]
      1) ldarg.1 [{i8,{i8,str},i8,i8}]
      5) ldfld {i8,{i8,str},i8,i8}::_F1:{i8,str}
      1) ldarg.2 [{i8,{i8,str},i8,i8}]
      5) ldfld {i8,{i8,str},i8,i8}::_F1:{i8,str}
      5) callvirt EqualityComparer<{i8,str}>::Equals({i8,str}, {i8,str}):bool
      5) brfalse [0]
      1) ldarg.1 [{i8,{i8,str},i8,i8}]
      5) ldfld {i8,{i8,str},i8,i8}::_F3:i8
      1) ldarg.2 [{i8,{i8,str},i8,i8}]
      5) ldfld {i8,{i8,str},i8,i8}::_F3:i8
      2) ceq
      5) br [1]
  Label [0]:
      1) ldc.i4.0
  Label [1]:
      1) ret
  Total Size: 50

GetHashCode(Arr<obj>, {i8,{i8,str},i8,i8}):i4
      1) ldarg.0 [Arr<obj>]
      1) ldc.i4.0
      5) ldelem [EqualityComparer<{i8,str}>]
      1) ldarg.1 [{i8,{i8,str},i8,i8}]
      5) ldfld {i8,{i8,str},i8,i8}::_F1:{i8,str}
      5) callvirt EqualityComparer<{i8,str}>::GetHashCode({i8,str}):i4
      1) ldarg.1 [{i8,{i8,str},i8,i8}]
      5) ldfld {i8,{i8,str},i8,i8}::_F3:i8
      5) call static HashCode::Combine(i4, i8):i4
      1) ret
  Total Size: 30

top(Arr<obj>, Arr<obj>):obj
      1) ldarg.1 [Arr<obj>]
      1) ldc.i4.0
      1) ldelem.ref
      5) call static CodeGenUtil::ToRef(obj):ExecCtx
      1) stloc.0 [ExecCtx]
      1) ldarg.1 [Arr<obj>]
      1) ldc.i4.1
      1) ldelem.ref
      5) call static CodeGenUtil::ToRef(obj):Seq<{i8,{i8,str},i8,i8}>
      1) stloc.1 [Seq<{i8,{i8,str},i8,i8}>]
      1) ldloc.1 [Seq<{i8,{i8,str},i8,i8}>]
      1) dup
      5) brtrue [0]
      1) pop
      1) ldnull
      5) br [1]
  Label [0]:
      1) ldloc.0 [ExecCtx]
      1) ldc.i4.0
      5) call static CodeGenUtil::EnumerableToPinging(Seq<{i8,{i8,str},i8,i8}>, ExecCtx, i4):Seq<{i8,{i8,str},i8,i8}>
      1) ldarg.0 [Arr<obj>]
      1) ldc.i4.0
      5) ldelem [Func<{i8,{i8,str},i8,i8},{i8,{i8,str},i8,i8}>]
      1) ldarg.0 [Arr<obj>]
      1) ldc.i4.1
      5) ldelem [Func<{i8,{i8,str},i8,i8},{i8,{i8,str},i8}>]
      1) ldarg.0 [Arr<obj>]
      1) ldc.i4.2
      5) ldelem [Func<{i8,{i8,str},i8,i8},Seq<{i8,{i8,str},i8}>,{{i8,str},i8,Seq<{i8,{i8,str},i8}>}>]
      1) ldarg.0 [Arr<obj>]
      1) ldc.i4.3
      5) ldelem [GroupByComparer<{i8,{i8,str},i8,i8}>]
      5) call static Enumerable::GroupBy(Seq<{i8,{i8,str},i8,i8}>, Func<{i8,{i8,str},i8,i8},{i8,{i8,str},i8,i8}>, Func<{i8,{i8,str},i8,i8},{i8,{i8,str},i8}>, Func<{i8,{i8,str},i8,i8},Seq<{i8,{i8,str},i8}>,{{i8,str},i8,Seq<{i8,{i8,str},i8}>}>, IEqualityComparer<{i8,{i8,str},i8,i8}>):Seq<{{i8,str},i8,Seq<{i8,{i8,str},i8}>}>
      5) call static CodeGenUtil::EnumerableToCaching(Seq<{{i8,str},i8,Seq<{i8,{i8,str},i8}>}>):Seq<{{i8,str},i8,Seq<{i8,{i8,str},i8}>}>
  Label [1]:
      1) ret
  Total Size: 78

Func sig: (<ctx>:x, D:{Id:i8, R:{M:i8, N:s}, S:i8, S2:i8}*) to {R:{M:i8, N:s}, S2:i8, X:{Id:i8, R:{M:i8, N:s}, S:i8}*}*
Sequence: Seq<{{i8,str},i8,Seq<{i8,{i8,str},i8}>}>
 0) { R: { M: 0, N: A }, S2: 0, 
      X: Sequence: Seq<{i8,{i8,str},i8}>
         0) { Id: 0, R: { M: 0, N: A }, S: 0 }
         1) { Id: 3, R: { M: 0, N: a }, S: 0 }
    }
 1) { R: { M: 1, N: b }, S2: 0, 
      X: Sequence: Seq<{i8,{i8,str},i8}>
         0) { Id: 1, R: { M: 1, N: b }, S: 0 }
    }
 2) { R: { M: 2, N: B }, S2: 0, 
      X: Sequence: Seq<{i8,{i8,str},i8}>
         0) { Id: 2, R: { M: 2, N: B }, S: 0 }
         1) { Id: 5, R: { M: 2, N: b }, S: 0 }
    }
 3) { R: { M: 1, N: A }, S2: 0, 
      X: Sequence: Seq<{i8,{i8,str},i8}>
         0) { Id: 4, R: { M: 1, N: A }, S: 0 }
    }
 4) { R: { M: 0, N: <null> }, S2: 0, 
      X: Sequence: Seq<{i8,{i8,str},i8}>
         0) { Id: 6, R: { M: 0, N: <null> }, S: 0 }
    }
 5) { R: { M: 1, N: A }, S2: 1, 
      X: Sequence: Seq<{i8,{i8,str},i8}>
         0) { Id: 7, R: { M: 1, N: A }, S: 0 }
         1) { Id: 10, R: { M: 1, N: a }, S: 0 }
    }
 6) { R: { M: 2, N: b }, S2: 1, 
      X: Sequence: Seq<{i8,{i8,str},i8}>
         0) { Id: 8, R: { M: 2, N: b }, S: 0 }
         1) { Id: 11, R: { M: 2, N: B }, S: 0 }
    }
 7) { R: { M: 0, N: <null> }, S2: 1, 
      X: Sequence: Seq<{i8,{i8,str},i8}>
         0) { Id: 9, R: { M: 0, N: <null> }, S: 0 }
         1) { Id: 12, R: { M: 0, N: <null> }, S: 0 }
    }
*** Ctx ping count: 14
    [0](14): GroupBy(*1: D, [~] R:*1.R, [key] S2:*1.S2, [auto] X:<auto>)
###
> GroupBy(D, [~] R, S2, [item] T: #, X)
GroupBy(D, [~] R, S2, [map] T : #, X) : {R:{M:i8, N:s}, S2:i8, T:i8*, X:{Id:i8, R:{M:i8, N:s}, S:i8}*}*
BndKind:GroupBy, Type:{R:{M:i8, N:s}, S2:i8, T:i8*, X:{Id:i8, R:{M:i8, N:s}, S:i8}*}*, Bnd:(GroupBy([scope:1] Global(D), [~] R:GetField(Scope(1), R), [key] S2:GetField(Scope(1), S2), [map] T:Scope(2), [auto] X:<auto>))
// (<ctx>, ∂.D:{Id:i8, R:{M:i8, N:s}, S:i8, S2:i8}*) : {R:{M:i8, N:s}, S2:i8, T:i8*, X:{Id:i8, R:{M:i8, N:s}, S:i8}*}*
keySelector(Arr<obj>, ValueTuple<{i8,{i8,str},i8,i8},i8>):{{i8,str},i8}
      1) ldarg.1 [ValueTuple<{i8,{i8,str},i8,i8},i8>]
      5) ldfld ValueTuple<{i8,{i8,str},i8,i8},i8>::Item1:{i8,{i8,str},i8,i8}
      1) stloc.0 [{i8,{i8,str},i8,i8}]
      5) newobj {{i8,str},i8}()
      1) dup
      1) ldc.i4.2
      5) stfld {{i8,str},i8}::_B0:u1
      1) stloc.1 [{{i8,str},i8}]
      1) ldloc.1 [{{i8,str},i8}]
      1) ldloc.0 [{i8,{i8,str},i8,i8}]
      5) ldfld {i8,{i8,str},i8,i8}::_F1:{i8,str}
      1) dup
      5) brfalse [0]
      5) stfld {{i8,str},i8}::_F0:{i8,str}
      1) ldloc.1 [{{i8,str},i8}]
      1) dup
      5) ldfld {{i8,str},i8}::_B0:u1
      1) ldc.i4.1
      1) or
      5) stfld {{i8,str},i8}::_B0:u1
      5) br [1]
  Label [0]:
      1) pop
      1) pop
  Label [1]:
      1) ldloc.1 [{{i8,str},i8}]
      1) ldloc.0 [{i8,{i8,str},i8,i8}]
      5) ldfld {i8,{i8,str},i8,i8}::_F3:i8
      5) stfld {{i8,str},i8}::_F1:i8
      1) ldloc.1 [{{i8,str},i8}]
      1) dup
      1) ldarg.0 [Arr<obj>]
      1) ldc.i4.0
      5) ldelem [RecordRuntimeTypeInfo]
      5) stfld {}::_rrti:RecordRuntimeTypeInfo
      1) ret
  Total Size: 86

mapItem0(Arr<obj>, ValueTuple<{i8,{i8,str},i8,i8},i8>):i8
      1) ldarg.1 [ValueTuple<{i8,{i8,str},i8,i8},i8>]
      5) ldfld ValueTuple<{i8,{i8,str},i8,i8},i8>::Item1:{i8,{i8,str},i8,i8}
      1) stloc.0 [{i8,{i8,str},i8,i8}]
      1) ldarg.1 [ValueTuple<{i8,{i8,str},i8,i8},i8>]
      5) ldfld ValueTuple<{i8,{i8,str},i8,i8},i8>::Item2:i8
      1) stloc.1 [i8]
      1) ldloc.1 [i8]
      1) ret
  Total Size: 16

mapItem1(Arr<obj>, ValueTuple<{i8,{i8,str},i8,i8},i8>):{i8,{i8,str},i8}
      1) ldarg.1 [ValueTuple<{i8,{i8,str},i8,i8},i8>]
      5) ldfld ValueTuple<{i8,{i8,str},i8,i8},i8>::Item1:{i8,{i8,str},i8,i8}
      1) stloc.0 [{i8,{i8,str},i8,i8}]
      5) newobj {i8,{i8,str},i8}()
      1) dup
      1) ldc.i4.5
      5) stfld {i8,{i8,str},i8}::_B0:u1
      1) stloc.1 [{i8,{i8,str},i8}]
      1) ldloc.1 [{i8,{i8,str},i8}]
      1) ldloc.0 [{i8,{i8,str},i8,i8}]
      5) ldfld {i8,{i8,str},i8,i8}::_F0:i8
      5) stfld {i8,{i8,str},i8}::_F0:i8
      1) ldloc.0 [{i8,{i8,str},i8,i8}]
      5) ldfld {i8,{i8,str},i8,i8}::_F1:{i8,str}
      5) brfalse [0]
      1) ldloc.1 [{i8,{i8,str},i8}]
      1) dup
      1) dup
      5) ldfld {i8,{i8,str},i8}::_B0:u1
      1) ldc.i4.2
      1) or
      5) stfld {i8,{i8,str},i8}::_B0:u1
      1) ldloc.0 [{i8,{i8,str},i8,i8}]
      5) ldfld {i8,{i8,str},i8,i8}::_F1:{i8,str}
      5) stfld {i8,{i8,str},i8}::_F1:{i8,str}
  Label [0]:
      1) ldloc.1 [{i8,{i8,str},i8}]
      1) ldloc.0 [{i8,{i8,str},i8,i8}]
      5) ldfld {i8,{i8,str},i8,i8}::_F2:i8
      5) stfld {i8,{i8,str},i8}::_F2:i8
      1) ldloc.1 [{i8,{i8,str},i8}]
      1) dup
      1) ldarg.0 [Arr<obj>]
      1) ldc.i4.0
      5) ldelem [RecordRuntimeTypeInfo]
      5) stfld {}::_rrti:RecordRuntimeTypeInfo
      1) ret
  Total Size: 96

resultSelector(Arr<obj>, {{i8,str},i8}, Seq<ValueTuple<{i8,{i8,str},i8,i8},i8>>):{{i8,str},i8,Seq<i8>,Seq<{i8,{i8,str},i8}>}
      5) newobj {{i8,str},i8,Seq<i8>,Seq<{i8,{i8,str},i8}>}()
      1) dup
      1) ldc.i4.2
      5) stfld {{i8,str},i8,Seq<i8>,Seq<{i8,{i8,str},i8}>}::_B0:u1
      1) stloc.0 [{{i8,str},i8,Seq<i8>,Seq<{i8,{i8,str},i8}>}]
      1) ldarg.1 [{{i8,str},i8}]
      5) ldfld {{i8,str},i8}::_F0:{i8,str}
      5) brfalse [0]
      1) ldloc.0 [{{i8,str},i8,Seq<i8>,Seq<{i8,{i8,str},i8}>}]
      1) dup
      1) dup
      5) ldfld {{i8,str},i8,Seq<i8>,Seq<{i8,{i8,str},i8}>}::_B0:u1
      1) ldc.i4.1
      1) or
      5) stfld {{i8,str},i8,Seq<i8>,Seq<{i8,{i8,str},i8}>}::_B0:u1
      1) ldarg.1 [{{i8,str},i8}]
      5) ldfld {{i8,str},i8}::_F0:{i8,str}
      5) stfld {{i8,str},i8,Seq<i8>,Seq<{i8,{i8,str},i8}>}::_F0:{i8,str}
  Label [0]:
      1) ldloc.0 [{{i8,str},i8,Seq<i8>,Seq<{i8,{i8,str},i8}>}]
      1) ldarg.1 [{{i8,str},i8}]
      5) ldfld {{i8,str},i8}::_F1:i8
      5) stfld {{i8,str},i8,Seq<i8>,Seq<{i8,{i8,str},i8}>}::_F1:i8
      1) ldarg.2 [Seq<ValueTuple<{i8,{i8,str},i8,i8},i8>>]
      5) call static CodeGenUtil::EnumerableToCaching(Seq<ValueTuple<{i8,{i8,str},i8,i8},i8>>):Seq<ValueTuple<{i8,{i8,str},i8,i8},i8>>
      1) stloc.1 [Seq<ValueTuple<{i8,{i8,str},i8,i8},i8>>]
      1) ldloc.0 [{{i8,str},i8,Seq<i8>,Seq<{i8,{i8,str},i8}>}]
      1) ldloc.1 [Seq<ValueTuple<{i8,{i8,str},i8,i8},i8>>]
      1) ldarg.0 [Arr<obj>]
      1) ldc.i4.0
      5) ldelem [Func<ValueTuple<{i8,{i8,str},i8,i8},i8>,i8>]
      5) call static Enumerable::Select(Seq<ValueTuple<{i8,{i8,str},i8,i8},i8>>, Func<ValueTuple<{i8,{i8,str},i8,i8},i8>,i8>):Seq<i8>
      5) call static CodeGenUtil::EnumerableToCaching(Seq<i8>):Seq<i8>
      5) stfld {{i8,str},i8,Seq<i8>,Seq<{i8,{i8,str},i8}>}::_F2:Seq<i8>
      1) ldloc.0 [{{i8,str},i8,Seq<i8>,Seq<{i8,{i8,str},i8}>}]
      1) ldloc.1 [Seq<ValueTuple<{i8,{i8,str},i8,i8},i8>>]
      1) ldarg.0 [Arr<obj>]
      1) ldc.i4.1
      5) ldelem [Func<ValueTuple<{i8,{i8,str},i8,i8},i8>,{i8,{i8,str},i8}>]
      5) call static Enumerable::Select(Seq<ValueTuple<{i8,{i8,str},i8,i8},i8>>, Func<ValueTuple<{i8,{i8,str},i8,i8},i8>,{i8,{i8,str},i8}>):Seq<{i8,{i8,str},i8}>
      5) call static CodeGenUtil::EnumerableToCaching(Seq<{i8,{i8,str},i8}>):Seq<{i8,{i8,str},i8}>
      5) stfld {{i8,str},i8,Seq<i8>,Seq<{i8,{i8,str},i8}>}::_F3:Seq<{i8,{i8,str},i8}>
      1) ldloc.1 [Seq<ValueTuple<{i8,{i8,str},i8,i8},i8>>]
      1) pop
      1) ldloc.0 [{{i8,str},i8,Seq<i8>,Seq<{i8,{i8,str},i8}>}]
      1) dup
      1) ldarg.0 [Arr<obj>]
      1) ldc.i4.2
      5) ldelem [RecordRuntimeTypeInfo]
      5) stfld {}::_rrti:RecordRuntimeTypeInfo
      1) ret
  Total Size: 134

top(Arr<obj>, Arr<obj>):obj
      1) ldarg.1 [Arr<obj>]
      1) ldc.i4.0
      1) ldelem.ref
      5) call static CodeGenUtil::ToRef(obj):ExecCtx
      1) stloc.0 [ExecCtx]
      1) ldarg.1 [Arr<obj>]
      1) ldc.i4.1
      1) ldelem.ref
      5) call static CodeGenUtil::ToRef(obj):Seq<{i8,{i8,str},i8,i8}>
      1) stloc.1 [Seq<{i8,{i8,str},i8,i8}>]
      1) ldloc.1 [Seq<{i8,{i8,str},i8,i8}>]
      1) dup
      5) brtrue [0]
      1) pop
      1) ldnull
      5) br [1]
  Label [0]:
      1) ldloc.0 [ExecCtx]
      1) ldc.i4.0
      5) call static CodeGenUtil::EnumerableToPinging(Seq<{i8,{i8,str},i8,i8}>, ExecCtx, i4):Seq<{i8,{i8,str},i8,i8}>
      5) call static CodeGenUtil::WrapIndPairs(Seq<{i8,{i8,str},i8,i8}>):Seq<ValueTuple<{i8,{i8,str},i8,i8},i8>>
      1) ldarg.0 [Arr<obj>]
      1) ldc.i4.0
      5) ldelem [Func<ValueTuple<{i8,{i8,str},i8,i8},i8>,{{i8,str},i8}>]
      1) ldarg.0 [Arr<obj>]
      1) ldc.i4.1
      5) ldelem [Func<{{i8,str},i8},Seq<ValueTuple<{i8,{i8,str},i8,i8},i8>>,{{i8,str},i8,Seq<i8>,Seq<{i8,{i8,str},i8}>}>]
      1) ldarg.0 [Arr<obj>]
      1) ldc.i4.2
      5) ldelem [EqualityComparer<{{i8,str},i8}>]
      5) call static Enumerable::GroupBy(Seq<ValueTuple<{i8,{i8,str},i8,i8},i8>>, Func<ValueTuple<{i8,{i8,str},i8,i8},i8>,{{i8,str},i8}>, Func<{{i8,str},i8},Seq<ValueTuple<{i8,{i8,str},i8,i8},i8>>,{{i8,str},i8,Seq<i8>,Seq<{i8,{i8,str},i8}>}>, IEqualityComparer<{{i8,str},i8}>):Seq<{{i8,str},i8,Seq<i8>,Seq<{i8,{i8,str},i8}>}>
      5) call static CodeGenUtil::EnumerableToCaching(Seq<{{i8,str},i8,Seq<i8>,Seq<{i8,{i8,str},i8}>}>):Seq<{{i8,str},i8,Seq<i8>,Seq<{i8,{i8,str},i8}>}>
  Label [1]:
      1) ret
  Total Size: 76

Func sig: (<ctx>:x, D:{Id:i8, R:{M:i8, N:s}, S:i8, S2:i8}*) to {R:{M:i8, N:s}, S2:i8, T:i8*, X:{Id:i8, R:{M:i8, N:s}, S:i8}*}*
Sequence: Seq<{{i8,str},i8,Seq<i8>,Seq<{i8,{i8,str},i8}>}>
 0) { R: { M: 0, N: A }, S2: 0, 
      T: Sequence: Seq<i8>
         0) 0
         1) 3
      X: Sequence: Seq<{i8,{i8,str},i8}>
         0) { Id: 0, R: { M: 0, N: A }, S: 0 }
         1) { Id: 3, R: { M: 0, N: a }, S: 0 }
    }
 1) { R: { M: 1, N: b }, S2: 0, 
      T: Sequence: Seq<i8>
         0) 1
      X: Sequence: Seq<{i8,{i8,str},i8}>
         0) { Id: 1, R: { M: 1, N: b }, S: 0 }
    }
 2) { R: { M: 2, N: B }, S2: 0, 
      T: Sequence: Seq<i8>
         0) 2
         1) 5
      X: Sequence: Seq<{i8,{i8,str},i8}>
         0) { Id: 2, R: { M: 2, N: B }, S: 0 }
         1) { Id: 5, R: { M: 2, N: b }, S: 0 }
    }
 3) { R: { M: 1, N: A }, S2: 0, 
      T: Sequence: Seq<i8>
         0) 4
      X: Sequence: Seq<{i8,{i8,str},i8}>
         0) { Id: 4, R: { M: 1, N: A }, S: 0 }
    }
 4) { R: { M: 0, N: <null> }, S2: 0, 
      T: Sequence: Seq<i8>
         0) 6
      X: Sequence: Seq<{i8,{i8,str},i8}>
         0) { Id: 6, R: { M: 0, N: <null> }, S: 0 }
    }
 5) { R: { M: 1, N: A }, S2: 1, 
      T: Sequence: Seq<i8>
         0) 7
         1) 10
      X: Sequence: Seq<{i8,{i8,str},i8}>
         0) { Id: 7, R: { M: 1, N: A }, S: 0 }
         1) { Id: 10, R: { M: 1, N: a }, S: 0 }
    }
 6) { R: { M: 2, N: b }, S2: 1, 
      T: Sequence: Seq<i8>
         0) 8
         1) 11
      X: Sequence: Seq<{i8,{i8,str},i8}>
         0) { Id: 8, R: { M: 2, N: b }, S: 0 }
         1) { Id: 11, R: { M: 2, N: B }, S: 0 }
    }
 7) { R: { M: 0, N: <null> }, S2: 1, 
      T: Sequence: Seq<i8>
         0) 9
         1) 12
      X: Sequence: Seq<{i8,{i8,str},i8}>
         0) { Id: 9, R: { M: 0, N: <null> }, S: 0 }
         1) { Id: 12, R: { M: 0, N: <null> }, S: 0 }
    }
*** Ctx ping count: 14
    [0](14): GroupBy(*1: D, [~] R:*1.R, [key] S2:*1.S2, [map] T:#2, [auto] X:<auto>)
###
