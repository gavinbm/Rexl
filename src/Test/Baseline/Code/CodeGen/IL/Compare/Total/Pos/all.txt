**** New udf: Glue, arity: 2
**** New udf: Glue, arity: 3
**** New udf: Polish, arity: 1
**** New udf: M, arity: 1
**** New udf: Op, arity: 1
**** New udf: H, arity: 2
**** New definitions: xs__, type: s*
**** New definitions: xb__, type: b*
**** New definitions: xr8_, type: r8*
**** New definitions: xr4_, type: r4*
**** New definitions: xi__, type: i*
**** New definitions: xi2_, type: i2*
**** New definitions: xu4_, type: u4*
**** New definitions: xd__, type: d*
**** New definitions: xt__, type: t*
**** New definitions: ys__, type: s*
**** New definitions: yb__, type: b*
**** New definitions: yr8_, type: r8*
**** New definitions: yr4_, type: r4*
**** New definitions: yi__, type: i*
**** New definitions: yi2_, type: i2*
**** New definitions: yu4_, type: u4*
**** New definitions: yd__, type: d*
**** New definitions: yt__, type: t*
**** New definitions: xs_q, type: s*
**** New definitions: xb_q, type: b?*
**** New definitions: xr8q, type: r8?*
**** New definitions: xr4q, type: r4?*
**** New definitions: xi_q, type: i?*
**** New definitions: xi2q, type: i2?*
**** New definitions: xu4q, type: u4?*
**** New definitions: xd_q, type: d?*
**** New definitions: xt_q, type: t?*
**** New definitions: ys_q, type: s*
**** New definitions: yb_q, type: b?*
**** New definitions: yr8q, type: r8?*
**** New definitions: yr4q, type: r4?*
**** New definitions: yi_q, type: i?*
**** New definitions: yi2q, type: i2?*
**** New definitions: yu4q, type: u4?*
**** New definitions: yd_q, type: d?*
**** New definitions: yt_q, type: t?*
**** New udf: G, arity: 2
**** New definitions: __IL_Func_Ind, type: i8

> G(xs__, ys__) // Req with Req (RR).
G(xs__, ys__) : (s, s, s, s)*
BndKind:Call, Type:(s, s, s, s)*, Bnd:(Call(∂.ForEach([map:6] Call(∂.Test.Wrap(Call(∂.ForEach([map:3] Call(∂.Test.Wrap(Call(∂.ChainMap([map:1] Global(xs__), Call(∂.ForEach([map:2] Global(ys__), (Scope(1), Scope(2)):(s, s)):(s, s)*)):(s, s)*)):(s, s)*), Call(∂.With([with:4] Call(∂.Test.Wrap(GetSlot(Scope(3), 0)):s), [with:5] Call(∂.Test.Wrap(GetSlot(Scope(3), 1)):s), (Cmp(Scope(4) @= Scope(5)), Cmp(Scope(4) @< Scope(5)), Cmp(Scope(4) @<= Scope(5)), Cmp(Scope(4) @> Scope(5)), Cmp(Scope(4) @>= Scope(5)), Scope(4), Scope(5)):(b, b, b, b, b, s, s)):(b, b, b, b, b, s, s))):(b, b, b, b, b, s, s)*)):(b, b, b, b, b, s, s)*), Call(∂.With([with:7] StrConcat(If(GetSlot(Scope(6), 0), str(M), str(_)), If(GetSlot(Scope(6), 1), str(M), str(_)), If(GetSlot(Scope(6), 2), str(M), str(_)), If(GetSlot(Scope(6), 3), str(M), str(_)), If(GetSlot(Scope(6), 4), str(M), str(_))), TupleConcat((Scope(7), If(Cmp(Scope(7) @= str(_____)), str(__), If(Cmp(Scope(7) @= str(M_M_M)), str(EQ), If(Cmp(Scope(7) @= str(__M__)), str(LE), If(Cmp(Scope(7) @= str(_MM__)), str(LT), If(Cmp(Scope(7) @= str(____M)), str(GE), If(Cmp(Scope(7) @= str(___MM)), str(GT), If(Cmp(Scope(7) @= str(MMMMM)), str(N___), If(Cmp(Scope(7) @= str(_M_M_)), str(N_E_), If(Cmp(Scope(7) @= str(M__MM)), str(N_L_), If(Cmp(Scope(7) @= str(MMM__)), str(N_G_), If(Cmp(Scope(7) @= str(___M_)), str(N_EL), If(Cmp(Scope(7) @= str(_M___)), str(N_EG), If(Cmp(Scope(7) @= str(M____)), str(N_LG), str(***BAD!***))))))))))))))):(s, s), GetSlice(Scope(6), 5:7:1):(s, s))):(s, s, s, s))):(s, s, s, s)*))
ForEach_1(Arr<obj>, (str,str)):(bool,bool,bool,bool,bool,str,str)
      1) ldarg.1 [(str,str)]
      5) ldfld (str,str)::_F0:str
      5) call static WrapFuncGen::Exec(str):str
      1) stloc.0 [str]
      1) ldarg.1 [(str,str)]
      5) ldfld (str,str)::_F1:str
      5) call static WrapFuncGen::Exec(str):str
      1) stloc.1 [str]
      5) newobj (bool,bool,bool,bool,bool,str,str)()
      1) dup
      1) ldloc.0 [str]
      1) ldloc.1 [str]
      5) call static str::Equals(str, str):bool
      5) stfld (bool,bool,bool,bool,bool,str,str)::_F0:bool
      1) dup
      1) ldloc.0 [str]
      1) ldloc.1 [str]
      5) call static StrComparer::Lt(str, str):bool
      5) stfld (bool,bool,bool,bool,bool,str,str)::_F1:bool
      1) dup
      1) ldloc.0 [str]
      1) ldloc.1 [str]
      5) call static StrComparer::Le(str, str):bool
      5) stfld (bool,bool,bool,bool,bool,str,str)::_F2:bool
      1) dup
      1) ldloc.0 [str]
      1) ldloc.1 [str]
      5) call static StrComparer::Gt(str, str):bool
      5) stfld (bool,bool,bool,bool,bool,str,str)::_F3:bool
      1) dup
      1) ldloc.0 [str]
      1) ldloc.1 [str]
      5) call static StrComparer::Ge(str, str):bool
      5) stfld (bool,bool,bool,bool,bool,str,str)::_F4:bool
      1) dup
      1) ldloc.0 [str]
      5) stfld (bool,bool,bool,bool,bool,str,str)::_F5:str
      1) dup
      1) ldloc.1 [str]
      5) stfld (bool,bool,bool,bool,bool,str,str)::_F6:str
      1) ret
  Total Size: 109

Func sig: (<ctx>:x, xs__:s*, ys__:s*) to (s, s, s, s)*
Sequence: Seq<(str,str,str,str)>
 0) (M_M_M, EQ, <null>, <null>)
 1) (_MM__, LT, <null>, A)
 2) (_MM__, LT, <null>, B)
 3) (___MM, GT, A, <null>)
 4) (M_M_M, EQ, A, A)
 5) (_MM__, LT, A, B)
 6) (___MM, GT, B, <null>)
 7) (___MM, GT, B, A)
 8) (M_M_M, EQ, B, B)
*** Ctx ping count: 4
    [0](4): ChainMap(*1: xs__, ForEach(*2: ys__, (*1, *2)))
###
> G(xb__, yb__)
G(xb__, yb__) : (s, s, b, b)*
BndKind:Call, Type:(s, s, b, b)*, Bnd:(Call(∂.ForEach([map:6] Call(∂.Test.Wrap(Call(∂.ForEach([map:3] Call(∂.Test.Wrap(Call(∂.ChainMap([map:1] Global(xb__), Call(∂.ForEach([map:2] Global(yb__), (Scope(1), Scope(2)):(b, b)):(b, b)*)):(b, b)*)):(b, b)*), Call(∂.With([with:4] Call(∂.Test.Wrap(GetSlot(Scope(3), 0)):b), [with:5] Call(∂.Test.Wrap(GetSlot(Scope(3), 1)):b), (Cmp(Scope(4) @= Scope(5)), Cmp(Scope(4) @< Scope(5)), Cmp(Scope(4) @<= Scope(5)), Cmp(Scope(4) @> Scope(5)), Cmp(Scope(4) @>= Scope(5)), Scope(4), Scope(5)):(b, b, b, b, b, b, b)):(b, b, b, b, b, b, b))):(b, b, b, b, b, b, b)*)):(b, b, b, b, b, b, b)*), Call(∂.With([with:7] StrConcat(If(GetSlot(Scope(6), 0), str(M), str(_)), If(GetSlot(Scope(6), 1), str(M), str(_)), If(GetSlot(Scope(6), 2), str(M), str(_)), If(GetSlot(Scope(6), 3), str(M), str(_)), If(GetSlot(Scope(6), 4), str(M), str(_))), TupleConcat((Scope(7), If(Cmp(Scope(7) @= str(_____)), str(__), If(Cmp(Scope(7) @= str(M_M_M)), str(EQ), If(Cmp(Scope(7) @= str(__M__)), str(LE), If(Cmp(Scope(7) @= str(_MM__)), str(LT), If(Cmp(Scope(7) @= str(____M)), str(GE), If(Cmp(Scope(7) @= str(___MM)), str(GT), If(Cmp(Scope(7) @= str(MMMMM)), str(N___), If(Cmp(Scope(7) @= str(_M_M_)), str(N_E_), If(Cmp(Scope(7) @= str(M__MM)), str(N_L_), If(Cmp(Scope(7) @= str(MMM__)), str(N_G_), If(Cmp(Scope(7) @= str(___M_)), str(N_EL), If(Cmp(Scope(7) @= str(_M___)), str(N_EG), If(Cmp(Scope(7) @= str(M____)), str(N_LG), str(***BAD!***))))))))))))))):(s, s), GetSlice(Scope(6), 5:7:1):(b, b))):(s, s, b, b))):(s, s, b, b)*))
ForEach_1(Arr<obj>, (bool,bool)):(bool,bool,bool,bool,bool,bool,bool)
      1) ldarg.1 [(bool,bool)]
      5) ldfld (bool,bool)::_F0:bool
      5) call static WrapFuncGen::Exec(bool):bool
      1) stloc.0 [bool]
      1) ldarg.1 [(bool,bool)]
      5) ldfld (bool,bool)::_F1:bool
      5) call static WrapFuncGen::Exec(bool):bool
      1) stloc.1 [bool]
      5) newobj (bool,bool,bool,bool,bool,bool,bool)()
      1) dup
      1) ldloc.0 [bool]
      1) ldloc.1 [bool]
      2) ceq
      5) stfld (bool,bool,bool,bool,bool,bool,bool)::_F0:bool
      1) dup
      1) ldloc.0 [bool]
      1) ldloc.1 [bool]
      2) clt.un
      5) stfld (bool,bool,bool,bool,bool,bool,bool)::_F1:bool
      1) dup
      1) ldloc.0 [bool]
      1) ldloc.1 [bool]
      2) cgt.un
      1) ldc.i4.0
      2) ceq
      5) stfld (bool,bool,bool,bool,bool,bool,bool)::_F2:bool
      1) dup
      1) ldloc.0 [bool]
      1) ldloc.1 [bool]
      2) cgt.un
      5) stfld (bool,bool,bool,bool,bool,bool,bool)::_F3:bool
      1) dup
      1) ldloc.0 [bool]
      1) ldloc.1 [bool]
      2) clt.un
      1) ldc.i4.0
      2) ceq
      5) stfld (bool,bool,bool,bool,bool,bool,bool)::_F4:bool
      1) dup
      1) ldloc.0 [bool]
      5) stfld (bool,bool,bool,bool,bool,bool,bool)::_F5:bool
      1) dup
      1) ldloc.1 [bool]
      5) stfld (bool,bool,bool,bool,bool,bool,bool)::_F6:bool
      1) ret
  Total Size: 100

Func sig: (<ctx>:x, xb__:b*, yb__:b*) to (s, s, b, b)*
Sequence: Seq<(str,str,bool,bool)>
 0) (M_M_M, EQ, false, false)
 1) (_MM__, LT, false, true )
 2) (___MM, GT, true , false)
 3) (M_M_M, EQ, true , true )
*** Ctx ping count: 3
    [0](3): ChainMap(*1: xb__, ForEach(*2: yb__, (*1, *2)))
###
> G(xr8_, yr8_)
G(xr8_, yr8_) : (s, s, r8, r8)*
BndKind:Call, Type:(s, s, r8, r8)*, Bnd:(Call(∂.ForEach([map:6] Call(∂.Test.Wrap(Call(∂.ForEach([map:3] Call(∂.Test.Wrap(Call(∂.ChainMap([map:1] Global(xr8_), Call(∂.ForEach([map:2] Global(yr8_), (Scope(1), Scope(2)):(r8, r8)):(r8, r8)*)):(r8, r8)*)):(r8, r8)*), Call(∂.With([with:4] Call(∂.Test.Wrap(GetSlot(Scope(3), 0)):r8), [with:5] Call(∂.Test.Wrap(GetSlot(Scope(3), 1)):r8), (Cmp(Scope(4) @= Scope(5)), Cmp(Scope(4) @< Scope(5)), Cmp(Scope(4) @<= Scope(5)), Cmp(Scope(4) @> Scope(5)), Cmp(Scope(4) @>= Scope(5)), Scope(4), Scope(5)):(b, b, b, b, b, r8, r8)):(b, b, b, b, b, r8, r8))):(b, b, b, b, b, r8, r8)*)):(b, b, b, b, b, r8, r8)*), Call(∂.With([with:7] StrConcat(If(GetSlot(Scope(6), 0), str(M), str(_)), If(GetSlot(Scope(6), 1), str(M), str(_)), If(GetSlot(Scope(6), 2), str(M), str(_)), If(GetSlot(Scope(6), 3), str(M), str(_)), If(GetSlot(Scope(6), 4), str(M), str(_))), TupleConcat((Scope(7), If(Cmp(Scope(7) @= str(_____)), str(__), If(Cmp(Scope(7) @= str(M_M_M)), str(EQ), If(Cmp(Scope(7) @= str(__M__)), str(LE), If(Cmp(Scope(7) @= str(_MM__)), str(LT), If(Cmp(Scope(7) @= str(____M)), str(GE), If(Cmp(Scope(7) @= str(___MM)), str(GT), If(Cmp(Scope(7) @= str(MMMMM)), str(N___), If(Cmp(Scope(7) @= str(_M_M_)), str(N_E_), If(Cmp(Scope(7) @= str(M__MM)), str(N_L_), If(Cmp(Scope(7) @= str(MMM__)), str(N_G_), If(Cmp(Scope(7) @= str(___M_)), str(N_EL), If(Cmp(Scope(7) @= str(_M___)), str(N_EG), If(Cmp(Scope(7) @= str(M____)), str(N_LG), str(***BAD!***))))))))))))))):(s, s), GetSlice(Scope(6), 5:7:1):(r8, r8))):(s, s, r8, r8))):(s, s, r8, r8)*))
ForEach_1(Arr<obj>, (r8,r8)):(bool,bool,bool,bool,bool,r8,r8)
      1) ldarg.1 [(r8,r8)]
      5) ldfld (r8,r8)::_F0:r8
      5) call static WrapFuncGen::Exec(r8):r8
      1) stloc.0 [r8]
      1) ldarg.1 [(r8,r8)]
      5) ldfld (r8,r8)::_F1:r8
      5) call static WrapFuncGen::Exec(r8):r8
      1) stloc.1 [r8]
      5) newobj (bool,bool,bool,bool,bool,r8,r8)()
      1) dup
      1) ldloc.0 [r8]
      1) ldloc.1 [r8]
      5) call static NumUtil::Eq(r8, r8):bool
      5) stfld (bool,bool,bool,bool,bool,r8,r8)::_F0:bool
      1) dup
      1) ldloc.0 [r8]
      1) ldloc.1 [r8]
      5) call static NumUtil::Lt(r8, r8):bool
      5) stfld (bool,bool,bool,bool,bool,r8,r8)::_F1:bool
      1) dup
      1) ldloc.0 [r8]
      1) ldloc.1 [r8]
      5) call static NumUtil::Le(r8, r8):bool
      5) stfld (bool,bool,bool,bool,bool,r8,r8)::_F2:bool
      1) dup
      1) ldloc.0 [r8]
      1) ldloc.1 [r8]
      5) call static NumUtil::Gt(r8, r8):bool
      5) stfld (bool,bool,bool,bool,bool,r8,r8)::_F3:bool
      1) dup
      1) ldloc.0 [r8]
      1) ldloc.1 [r8]
      5) call static NumUtil::Ge(r8, r8):bool
      5) stfld (bool,bool,bool,bool,bool,r8,r8)::_F4:bool
      1) dup
      1) ldloc.0 [r8]
      5) stfld (bool,bool,bool,bool,bool,r8,r8)::_F5:r8
      1) dup
      1) ldloc.1 [r8]
      5) stfld (bool,bool,bool,bool,bool,r8,r8)::_F6:r8
      1) ret
  Total Size: 109

Func sig: (<ctx>:x, xr8_:r8*, yr8_:r8*) to (s, s, r8, r8)*
Sequence: Seq<(str,str,r8,r8)>
 0) (M_M_M, EQ, NaN, NaN)
 1) (_MM__, LT, NaN, -3)
 2) (_MM__, LT, NaN, 0)
 3) (_MM__, LT, NaN, 5)
 4) (___MM, GT, -3, NaN)
 5) (M_M_M, EQ, -3, -3)
 6) (_MM__, LT, -3, 0)
 7) (_MM__, LT, -3, 5)
 8) (___MM, GT, 0, NaN)
 9) (___MM, GT, 0, -3)
10) (M_M_M, EQ, 0, 0)
11) (_MM__, LT, 0, 5)
12) (___MM, GT, 5, NaN)
13) (___MM, GT, 5, -3)
14) (___MM, GT, 5, 0)
15) (M_M_M, EQ, 5, 5)
*** Ctx ping count: 5
    [0](5): ChainMap(*1: xr8_, ForEach(*2: yr8_, (*1, *2)))
###
> G(xr4_, yr4_)
G(xr4_, yr4_) : (s, s, r4, r4)*
BndKind:Call, Type:(s, s, r4, r4)*, Bnd:(Call(∂.ForEach([map:6] Call(∂.Test.Wrap(Call(∂.ForEach([map:3] Call(∂.Test.Wrap(Call(∂.ChainMap([map:1] Global(xr4_), Call(∂.ForEach([map:2] Global(yr4_), (Scope(1), Scope(2)):(r4, r4)):(r4, r4)*)):(r4, r4)*)):(r4, r4)*), Call(∂.With([with:4] Call(∂.Test.Wrap(GetSlot(Scope(3), 0)):r4), [with:5] Call(∂.Test.Wrap(GetSlot(Scope(3), 1)):r4), (Cmp(Scope(4) @= Scope(5)), Cmp(Scope(4) @< Scope(5)), Cmp(Scope(4) @<= Scope(5)), Cmp(Scope(4) @> Scope(5)), Cmp(Scope(4) @>= Scope(5)), Scope(4), Scope(5)):(b, b, b, b, b, r4, r4)):(b, b, b, b, b, r4, r4))):(b, b, b, b, b, r4, r4)*)):(b, b, b, b, b, r4, r4)*), Call(∂.With([with:7] StrConcat(If(GetSlot(Scope(6), 0), str(M), str(_)), If(GetSlot(Scope(6), 1), str(M), str(_)), If(GetSlot(Scope(6), 2), str(M), str(_)), If(GetSlot(Scope(6), 3), str(M), str(_)), If(GetSlot(Scope(6), 4), str(M), str(_))), TupleConcat((Scope(7), If(Cmp(Scope(7) @= str(_____)), str(__), If(Cmp(Scope(7) @= str(M_M_M)), str(EQ), If(Cmp(Scope(7) @= str(__M__)), str(LE), If(Cmp(Scope(7) @= str(_MM__)), str(LT), If(Cmp(Scope(7) @= str(____M)), str(GE), If(Cmp(Scope(7) @= str(___MM)), str(GT), If(Cmp(Scope(7) @= str(MMMMM)), str(N___), If(Cmp(Scope(7) @= str(_M_M_)), str(N_E_), If(Cmp(Scope(7) @= str(M__MM)), str(N_L_), If(Cmp(Scope(7) @= str(MMM__)), str(N_G_), If(Cmp(Scope(7) @= str(___M_)), str(N_EL), If(Cmp(Scope(7) @= str(_M___)), str(N_EG), If(Cmp(Scope(7) @= str(M____)), str(N_LG), str(***BAD!***))))))))))))))):(s, s), GetSlice(Scope(6), 5:7:1):(r4, r4))):(s, s, r4, r4))):(s, s, r4, r4)*))
ForEach_1(Arr<obj>, (r4,r4)):(bool,bool,bool,bool,bool,r4,r4)
      1) ldarg.1 [(r4,r4)]
      5) ldfld (r4,r4)::_F0:r4
      5) call static WrapFuncGen::Exec(r4):r4
      1) stloc.0 [r4]
      1) ldarg.1 [(r4,r4)]
      5) ldfld (r4,r4)::_F1:r4
      5) call static WrapFuncGen::Exec(r4):r4
      1) stloc.1 [r4]
      5) newobj (bool,bool,bool,bool,bool,r4,r4)()
      1) dup
      1) ldloc.0 [r4]
      1) ldloc.1 [r4]
      5) call static NumUtil::Eq(r4, r4):bool
      5) stfld (bool,bool,bool,bool,bool,r4,r4)::_F0:bool
      1) dup
      1) ldloc.0 [r4]
      1) ldloc.1 [r4]
      5) call static NumUtil::Lt(r4, r4):bool
      5) stfld (bool,bool,bool,bool,bool,r4,r4)::_F1:bool
      1) dup
      1) ldloc.0 [r4]
      1) ldloc.1 [r4]
      5) call static NumUtil::Le(r4, r4):bool
      5) stfld (bool,bool,bool,bool,bool,r4,r4)::_F2:bool
      1) dup
      1) ldloc.0 [r4]
      1) ldloc.1 [r4]
      5) call static NumUtil::Gt(r4, r4):bool
      5) stfld (bool,bool,bool,bool,bool,r4,r4)::_F3:bool
      1) dup
      1) ldloc.0 [r4]
      1) ldloc.1 [r4]
      5) call static NumUtil::Ge(r4, r4):bool
      5) stfld (bool,bool,bool,bool,bool,r4,r4)::_F4:bool
      1) dup
      1) ldloc.0 [r4]
      5) stfld (bool,bool,bool,bool,bool,r4,r4)::_F5:r4
      1) dup
      1) ldloc.1 [r4]
      5) stfld (bool,bool,bool,bool,bool,r4,r4)::_F6:r4
      1) ret
  Total Size: 109

Func sig: (<ctx>:x, xr4_:r4*, yr4_:r4*) to (s, s, r4, r4)*
Sequence: Seq<(str,str,r4,r4)>
 0) (M_M_M, EQ, NaN, NaN)
 1) (_MM__, LT, NaN, -3)
 2) (_MM__, LT, NaN, 0)
 3) (_MM__, LT, NaN, 5)
 4) (___MM, GT, -3, NaN)
 5) (M_M_M, EQ, -3, -3)
 6) (_MM__, LT, -3, 0)
 7) (_MM__, LT, -3, 5)
 8) (___MM, GT, 0, NaN)
 9) (___MM, GT, 0, -3)
10) (M_M_M, EQ, 0, 0)
11) (_MM__, LT, 0, 5)
12) (___MM, GT, 5, NaN)
13) (___MM, GT, 5, -3)
14) (___MM, GT, 5, 0)
15) (M_M_M, EQ, 5, 5)
*** Ctx ping count: 5
    [0](5): ChainMap(*1: xr4_, ForEach(*2: yr4_, (*1, *2)))
###
> G(xi__, yi__)
G(xi__, yi__) : (s, s, i, i)*
BndKind:Call, Type:(s, s, i, i)*, Bnd:(Call(∂.ForEach([map:6] Call(∂.Test.Wrap(Call(∂.ForEach([map:3] Call(∂.Test.Wrap(Call(∂.ChainMap([map:1] Global(xi__), Call(∂.ForEach([map:2] Global(yi__), (Scope(1), Scope(2)):(i, i)):(i, i)*)):(i, i)*)):(i, i)*), Call(∂.With([with:4] Call(∂.Test.Wrap(GetSlot(Scope(3), 0)):i), [with:5] Call(∂.Test.Wrap(GetSlot(Scope(3), 1)):i), (Cmp(Scope(4) @= Scope(5)), Cmp(Scope(4) @< Scope(5)), Cmp(Scope(4) @<= Scope(5)), Cmp(Scope(4) @> Scope(5)), Cmp(Scope(4) @>= Scope(5)), Scope(4), Scope(5)):(b, b, b, b, b, i, i)):(b, b, b, b, b, i, i))):(b, b, b, b, b, i, i)*)):(b, b, b, b, b, i, i)*), Call(∂.With([with:7] StrConcat(If(GetSlot(Scope(6), 0), str(M), str(_)), If(GetSlot(Scope(6), 1), str(M), str(_)), If(GetSlot(Scope(6), 2), str(M), str(_)), If(GetSlot(Scope(6), 3), str(M), str(_)), If(GetSlot(Scope(6), 4), str(M), str(_))), TupleConcat((Scope(7), If(Cmp(Scope(7) @= str(_____)), str(__), If(Cmp(Scope(7) @= str(M_M_M)), str(EQ), If(Cmp(Scope(7) @= str(__M__)), str(LE), If(Cmp(Scope(7) @= str(_MM__)), str(LT), If(Cmp(Scope(7) @= str(____M)), str(GE), If(Cmp(Scope(7) @= str(___MM)), str(GT), If(Cmp(Scope(7) @= str(MMMMM)), str(N___), If(Cmp(Scope(7) @= str(_M_M_)), str(N_E_), If(Cmp(Scope(7) @= str(M__MM)), str(N_L_), If(Cmp(Scope(7) @= str(MMM__)), str(N_G_), If(Cmp(Scope(7) @= str(___M_)), str(N_EL), If(Cmp(Scope(7) @= str(_M___)), str(N_EG), If(Cmp(Scope(7) @= str(M____)), str(N_LG), str(***BAD!***))))))))))))))):(s, s), GetSlice(Scope(6), 5:7:1):(i, i))):(s, s, i, i))):(s, s, i, i)*))
ForEach_1(Arr<obj>, (ia,ia)):(bool,bool,bool,bool,bool,ia,ia)
      1) ldarg.1 [(ia,ia)]
      5) ldfld (ia,ia)::_F0:ia
      5) call static WrapFuncGen::Exec(ia):ia
      1) stloc.0 [ia]
      1) ldarg.1 [(ia,ia)]
      5) ldfld (ia,ia)::_F1:ia
      5) call static WrapFuncGen::Exec(ia):ia
      1) stloc.1 [ia]
      5) newobj (bool,bool,bool,bool,bool,ia,ia)()
      1) dup
      1) ldloc.0 [ia]
      1) ldloc.1 [ia]
      5) call static ia::op_Equality(ia, ia):bool
      5) stfld (bool,bool,bool,bool,bool,ia,ia)::_F0:bool
      1) dup
      1) ldloc.0 [ia]
      1) ldloc.1 [ia]
      5) call static ia::op_LessThan(ia, ia):bool
      5) stfld (bool,bool,bool,bool,bool,ia,ia)::_F1:bool
      1) dup
      1) ldloc.0 [ia]
      1) ldloc.1 [ia]
      5) call static ia::op_LessThanOrEqual(ia, ia):bool
      5) stfld (bool,bool,bool,bool,bool,ia,ia)::_F2:bool
      1) dup
      1) ldloc.0 [ia]
      1) ldloc.1 [ia]
      5) call static ia::op_GreaterThan(ia, ia):bool
      5) stfld (bool,bool,bool,bool,bool,ia,ia)::_F3:bool
      1) dup
      1) ldloc.0 [ia]
      1) ldloc.1 [ia]
      5) call static ia::op_GreaterThanOrEqual(ia, ia):bool
      5) stfld (bool,bool,bool,bool,bool,ia,ia)::_F4:bool
      1) dup
      1) ldloc.0 [ia]
      5) stfld (bool,bool,bool,bool,bool,ia,ia)::_F5:ia
      1) dup
      1) ldloc.1 [ia]
      5) stfld (bool,bool,bool,bool,bool,ia,ia)::_F6:ia
      1) ret
  Total Size: 109

Func sig: (<ctx>:x, xi__:i*, yi__:i*) to (s, s, i, i)*
Sequence: Seq<(str,str,ia,ia)>
 0) (M_M_M, EQ, -3, -3)
 1) (_MM__, LT, -3, 0)
 2) (_MM__, LT, -3, 5)
 3) (___MM, GT, 0, -3)
 4) (M_M_M, EQ, 0, 0)
 5) (_MM__, LT, 0, 5)
 6) (___MM, GT, 5, -3)
 7) (___MM, GT, 5, 0)
 8) (M_M_M, EQ, 5, 5)
*** Ctx ping count: 4
    [0](4): ChainMap(*1: xi__, ForEach(*2: yi__, (*1, *2)))
###
> G(xi2_, yi2_)
G(xi2_, yi2_) : (s, s, i2, i2)*
BndKind:Call, Type:(s, s, i2, i2)*, Bnd:(Call(∂.ForEach([map:6] Call(∂.Test.Wrap(Call(∂.ForEach([map:3] Call(∂.Test.Wrap(Call(∂.ChainMap([map:1] Global(xi2_), Call(∂.ForEach([map:2] Global(yi2_), (Scope(1), Scope(2)):(i2, i2)):(i2, i2)*)):(i2, i2)*)):(i2, i2)*), Call(∂.With([with:4] Call(∂.Test.Wrap(GetSlot(Scope(3), 0)):i2), [with:5] Call(∂.Test.Wrap(GetSlot(Scope(3), 1)):i2), (Cmp(Scope(4) @= Scope(5)), Cmp(Scope(4) @< Scope(5)), Cmp(Scope(4) @<= Scope(5)), Cmp(Scope(4) @> Scope(5)), Cmp(Scope(4) @>= Scope(5)), Scope(4), Scope(5)):(b, b, b, b, b, i2, i2)):(b, b, b, b, b, i2, i2))):(b, b, b, b, b, i2, i2)*)):(b, b, b, b, b, i2, i2)*), Call(∂.With([with:7] StrConcat(If(GetSlot(Scope(6), 0), str(M), str(_)), If(GetSlot(Scope(6), 1), str(M), str(_)), If(GetSlot(Scope(6), 2), str(M), str(_)), If(GetSlot(Scope(6), 3), str(M), str(_)), If(GetSlot(Scope(6), 4), str(M), str(_))), TupleConcat((Scope(7), If(Cmp(Scope(7) @= str(_____)), str(__), If(Cmp(Scope(7) @= str(M_M_M)), str(EQ), If(Cmp(Scope(7) @= str(__M__)), str(LE), If(Cmp(Scope(7) @= str(_MM__)), str(LT), If(Cmp(Scope(7) @= str(____M)), str(GE), If(Cmp(Scope(7) @= str(___MM)), str(GT), If(Cmp(Scope(7) @= str(MMMMM)), str(N___), If(Cmp(Scope(7) @= str(_M_M_)), str(N_E_), If(Cmp(Scope(7) @= str(M__MM)), str(N_L_), If(Cmp(Scope(7) @= str(MMM__)), str(N_G_), If(Cmp(Scope(7) @= str(___M_)), str(N_EL), If(Cmp(Scope(7) @= str(_M___)), str(N_EG), If(Cmp(Scope(7) @= str(M____)), str(N_LG), str(***BAD!***))))))))))))))):(s, s), GetSlice(Scope(6), 5:7:1):(i2, i2))):(s, s, i2, i2))):(s, s, i2, i2)*))
ForEach_1(Arr<obj>, (i2,i2)):(bool,bool,bool,bool,bool,i2,i2)
      1) ldarg.1 [(i2,i2)]
      5) ldfld (i2,i2)::_F0:i2
      5) call static WrapFuncGen::Exec(i2):i2
      1) stloc.0 [i2]
      1) ldarg.1 [(i2,i2)]
      5) ldfld (i2,i2)::_F1:i2
      5) call static WrapFuncGen::Exec(i2):i2
      1) stloc.1 [i2]
      5) newobj (bool,bool,bool,bool,bool,i2,i2)()
      1) dup
      1) ldloc.0 [i2]
      1) ldloc.1 [i2]
      2) ceq
      5) stfld (bool,bool,bool,bool,bool,i2,i2)::_F0:bool
      1) dup
      1) ldloc.0 [i2]
      1) ldloc.1 [i2]
      2) clt
      5) stfld (bool,bool,bool,bool,bool,i2,i2)::_F1:bool
      1) dup
      1) ldloc.0 [i2]
      1) ldloc.1 [i2]
      2) cgt
      1) ldc.i4.0
      2) ceq
      5) stfld (bool,bool,bool,bool,bool,i2,i2)::_F2:bool
      1) dup
      1) ldloc.0 [i2]
      1) ldloc.1 [i2]
      2) cgt
      5) stfld (bool,bool,bool,bool,bool,i2,i2)::_F3:bool
      1) dup
      1) ldloc.0 [i2]
      1) ldloc.1 [i2]
      2) clt
      1) ldc.i4.0
      2) ceq
      5) stfld (bool,bool,bool,bool,bool,i2,i2)::_F4:bool
      1) dup
      1) ldloc.0 [i2]
      5) stfld (bool,bool,bool,bool,bool,i2,i2)::_F5:i2
      1) dup
      1) ldloc.1 [i2]
      5) stfld (bool,bool,bool,bool,bool,i2,i2)::_F6:i2
      1) ret
  Total Size: 100

Func sig: (<ctx>:x, xi2_:i2*, yi2_:i2*) to (s, s, i2, i2)*
Sequence: Seq<(str,str,i2,i2)>
 0) (M_M_M, EQ, -3, -3)
 1) (_MM__, LT, -3, 0)
 2) (_MM__, LT, -3, 5)
 3) (___MM, GT, 0, -3)
 4) (M_M_M, EQ, 0, 0)
 5) (_MM__, LT, 0, 5)
 6) (___MM, GT, 5, -3)
 7) (___MM, GT, 5, 0)
 8) (M_M_M, EQ, 5, 5)
*** Ctx ping count: 4
    [0](4): ChainMap(*1: xi2_, ForEach(*2: yi2_, (*1, *2)))
###
> G(xu4_, yu4_)
G(xu4_, yu4_) : (s, s, u4, u4)*
BndKind:Call, Type:(s, s, u4, u4)*, Bnd:(Call(∂.ForEach([map:6] Call(∂.Test.Wrap(Call(∂.ForEach([map:3] Call(∂.Test.Wrap(Call(∂.ChainMap([map:1] Global(xu4_), Call(∂.ForEach([map:2] Global(yu4_), (Scope(1), Scope(2)):(u4, u4)):(u4, u4)*)):(u4, u4)*)):(u4, u4)*), Call(∂.With([with:4] Call(∂.Test.Wrap(GetSlot(Scope(3), 0)):u4), [with:5] Call(∂.Test.Wrap(GetSlot(Scope(3), 1)):u4), (Cmp(Scope(4) @= Scope(5)), Cmp(Scope(4) @< Scope(5)), Cmp(Scope(4) @<= Scope(5)), Cmp(Scope(4) @> Scope(5)), Cmp(Scope(4) @>= Scope(5)), Scope(4), Scope(5)):(b, b, b, b, b, u4, u4)):(b, b, b, b, b, u4, u4))):(b, b, b, b, b, u4, u4)*)):(b, b, b, b, b, u4, u4)*), Call(∂.With([with:7] StrConcat(If(GetSlot(Scope(6), 0), str(M), str(_)), If(GetSlot(Scope(6), 1), str(M), str(_)), If(GetSlot(Scope(6), 2), str(M), str(_)), If(GetSlot(Scope(6), 3), str(M), str(_)), If(GetSlot(Scope(6), 4), str(M), str(_))), TupleConcat((Scope(7), If(Cmp(Scope(7) @= str(_____)), str(__), If(Cmp(Scope(7) @= str(M_M_M)), str(EQ), If(Cmp(Scope(7) @= str(__M__)), str(LE), If(Cmp(Scope(7) @= str(_MM__)), str(LT), If(Cmp(Scope(7) @= str(____M)), str(GE), If(Cmp(Scope(7) @= str(___MM)), str(GT), If(Cmp(Scope(7) @= str(MMMMM)), str(N___), If(Cmp(Scope(7) @= str(_M_M_)), str(N_E_), If(Cmp(Scope(7) @= str(M__MM)), str(N_L_), If(Cmp(Scope(7) @= str(MMM__)), str(N_G_), If(Cmp(Scope(7) @= str(___M_)), str(N_EL), If(Cmp(Scope(7) @= str(_M___)), str(N_EG), If(Cmp(Scope(7) @= str(M____)), str(N_LG), str(***BAD!***))))))))))))))):(s, s), GetSlice(Scope(6), 5:7:1):(u4, u4))):(s, s, u4, u4))):(s, s, u4, u4)*))
ForEach_1(Arr<obj>, (u4,u4)):(bool,bool,bool,bool,bool,u4,u4)
      1) ldarg.1 [(u4,u4)]
      5) ldfld (u4,u4)::_F0:u4
      5) call static WrapFuncGen::Exec(u4):u4
      1) stloc.0 [u4]
      1) ldarg.1 [(u4,u4)]
      5) ldfld (u4,u4)::_F1:u4
      5) call static WrapFuncGen::Exec(u4):u4
      1) stloc.1 [u4]
      5) newobj (bool,bool,bool,bool,bool,u4,u4)()
      1) dup
      1) ldloc.0 [u4]
      1) ldloc.1 [u4]
      2) ceq
      5) stfld (bool,bool,bool,bool,bool,u4,u4)::_F0:bool
      1) dup
      1) ldloc.0 [u4]
      1) ldloc.1 [u4]
      2) clt.un
      5) stfld (bool,bool,bool,bool,bool,u4,u4)::_F1:bool
      1) dup
      1) ldloc.0 [u4]
      1) ldloc.1 [u4]
      2) cgt.un
      1) ldc.i4.0
      2) ceq
      5) stfld (bool,bool,bool,bool,bool,u4,u4)::_F2:bool
      1) dup
      1) ldloc.0 [u4]
      1) ldloc.1 [u4]
      2) cgt.un
      5) stfld (bool,bool,bool,bool,bool,u4,u4)::_F3:bool
      1) dup
      1) ldloc.0 [u4]
      1) ldloc.1 [u4]
      2) clt.un
      1) ldc.i4.0
      2) ceq
      5) stfld (bool,bool,bool,bool,bool,u4,u4)::_F4:bool
      1) dup
      1) ldloc.0 [u4]
      5) stfld (bool,bool,bool,bool,bool,u4,u4)::_F5:u4
      1) dup
      1) ldloc.1 [u4]
      5) stfld (bool,bool,bool,bool,bool,u4,u4)::_F6:u4
      1) ret
  Total Size: 100

Func sig: (<ctx>:x, xu4_:u4*, yu4_:u4*) to (s, s, u4, u4)*
Sequence: Seq<(str,str,u4,u4)>
 0) (M_M_M, EQ, 0, 0)
 1) (_MM__, LT, 0, 3)
 2) (_MM__, LT, 0, 5)
 3) (___MM, GT, 3, 0)
 4) (M_M_M, EQ, 3, 3)
 5) (_MM__, LT, 3, 5)
 6) (___MM, GT, 5, 0)
 7) (___MM, GT, 5, 3)
 8) (M_M_M, EQ, 5, 5)
*** Ctx ping count: 4
    [0](4): ChainMap(*1: xu4_, ForEach(*2: yu4_, (*1, *2)))
###
> G(xd__, yd__)
G(xd__, yd__) : (s, s, d, d)*
BndKind:Call, Type:(s, s, d, d)*, Bnd:(Call(∂.ForEach([map:6] Call(∂.Test.Wrap(Call(∂.ForEach([map:3] Call(∂.Test.Wrap(Call(∂.ChainMap([map:1] Global(xd__), Call(∂.ForEach([map:2] Global(yd__), (Scope(1), Scope(2)):(d, d)):(d, d)*)):(d, d)*)):(d, d)*), Call(∂.With([with:4] Call(∂.Test.Wrap(GetSlot(Scope(3), 0)):d), [with:5] Call(∂.Test.Wrap(GetSlot(Scope(3), 1)):d), (Cmp(Scope(4) @= Scope(5)), Cmp(Scope(4) @< Scope(5)), Cmp(Scope(4) @<= Scope(5)), Cmp(Scope(4) @> Scope(5)), Cmp(Scope(4) @>= Scope(5)), Scope(4), Scope(5)):(b, b, b, b, b, d, d)):(b, b, b, b, b, d, d))):(b, b, b, b, b, d, d)*)):(b, b, b, b, b, d, d)*), Call(∂.With([with:7] StrConcat(If(GetSlot(Scope(6), 0), str(M), str(_)), If(GetSlot(Scope(6), 1), str(M), str(_)), If(GetSlot(Scope(6), 2), str(M), str(_)), If(GetSlot(Scope(6), 3), str(M), str(_)), If(GetSlot(Scope(6), 4), str(M), str(_))), TupleConcat((Scope(7), If(Cmp(Scope(7) @= str(_____)), str(__), If(Cmp(Scope(7) @= str(M_M_M)), str(EQ), If(Cmp(Scope(7) @= str(__M__)), str(LE), If(Cmp(Scope(7) @= str(_MM__)), str(LT), If(Cmp(Scope(7) @= str(____M)), str(GE), If(Cmp(Scope(7) @= str(___MM)), str(GT), If(Cmp(Scope(7) @= str(MMMMM)), str(N___), If(Cmp(Scope(7) @= str(_M_M_)), str(N_E_), If(Cmp(Scope(7) @= str(M__MM)), str(N_L_), If(Cmp(Scope(7) @= str(MMM__)), str(N_G_), If(Cmp(Scope(7) @= str(___M_)), str(N_EL), If(Cmp(Scope(7) @= str(_M___)), str(N_EG), If(Cmp(Scope(7) @= str(M____)), str(N_LG), str(***BAD!***))))))))))))))):(s, s), GetSlice(Scope(6), 5:7:1):(d, d))):(s, s, d, d))):(s, s, d, d)*))
ForEach_1(Arr<obj>, (Date,Date)):(bool,bool,bool,bool,bool,Date,Date)
      1) ldarg.1 [(Date,Date)]
      5) ldfld (Date,Date)::_F0:Date
      5) call static WrapFuncGen::Exec(Date):Date
      1) stloc.0 [Date]
      1) ldarg.1 [(Date,Date)]
      5) ldfld (Date,Date)::_F1:Date
      5) call static WrapFuncGen::Exec(Date):Date
      1) stloc.1 [Date]
      5) newobj (bool,bool,bool,bool,bool,Date,Date)()
      1) dup
      1) ldloc.0 [Date]
      1) ldloc.1 [Date]
      5) call static Date::op_Equality(Date, Date):bool
      5) stfld (bool,bool,bool,bool,bool,Date,Date)::_F0:bool
      1) dup
      1) ldloc.0 [Date]
      1) ldloc.1 [Date]
      5) call static Date::op_LessThan(Date, Date):bool
      5) stfld (bool,bool,bool,bool,bool,Date,Date)::_F1:bool
      1) dup
      1) ldloc.0 [Date]
      1) ldloc.1 [Date]
      5) call static Date::op_LessThanOrEqual(Date, Date):bool
      5) stfld (bool,bool,bool,bool,bool,Date,Date)::_F2:bool
      1) dup
      1) ldloc.0 [Date]
      1) ldloc.1 [Date]
      5) call static Date::op_GreaterThan(Date, Date):bool
      5) stfld (bool,bool,bool,bool,bool,Date,Date)::_F3:bool
      1) dup
      1) ldloc.0 [Date]
      1) ldloc.1 [Date]
      5) call static Date::op_GreaterThanOrEqual(Date, Date):bool
      5) stfld (bool,bool,bool,bool,bool,Date,Date)::_F4:bool
      1) dup
      1) ldloc.0 [Date]
      5) stfld (bool,bool,bool,bool,bool,Date,Date)::_F5:Date
      1) dup
      1) ldloc.1 [Date]
      5) stfld (bool,bool,bool,bool,bool,Date,Date)::_F6:Date
      1) ret
  Total Size: 109

Func sig: (<ctx>:x, xd__:d*, yd__:d*) to (s, s, d, d)*
Sequence: Seq<(str,str,Date,Date)>
 0) (M_M_M, EQ, DT(1900, 1, 1, 0, 0, 0, 0), DT(1900, 1, 1, 0, 0, 0, 0))
 1) (_MM__, LT, DT(1900, 1, 1, 0, 0, 0, 0), DT(2023, 7, 1, 0, 0, 0, 0))
 2) (_MM__, LT, DT(1900, 1, 1, 0, 0, 0, 0), DT(2023, 9, 1, 0, 0, 0, 0))
 3) (___MM, GT, DT(2023, 7, 1, 0, 0, 0, 0), DT(1900, 1, 1, 0, 0, 0, 0))
 4) (M_M_M, EQ, DT(2023, 7, 1, 0, 0, 0, 0), DT(2023, 7, 1, 0, 0, 0, 0))
 5) (_MM__, LT, DT(2023, 7, 1, 0, 0, 0, 0), DT(2023, 9, 1, 0, 0, 0, 0))
 6) (___MM, GT, DT(2023, 9, 1, 0, 0, 0, 0), DT(1900, 1, 1, 0, 0, 0, 0))
 7) (___MM, GT, DT(2023, 9, 1, 0, 0, 0, 0), DT(2023, 7, 1, 0, 0, 0, 0))
 8) (M_M_M, EQ, DT(2023, 9, 1, 0, 0, 0, 0), DT(2023, 9, 1, 0, 0, 0, 0))
*** Ctx ping count: 4
    [0](4): ChainMap(*1: xd__, ForEach(*2: yd__, (*1, *2)))
###
> G(xt__, yt__)
G(xt__, yt__) : (s, s, t, t)*
BndKind:Call, Type:(s, s, t, t)*, Bnd:(Call(∂.ForEach([map:6] Call(∂.Test.Wrap(Call(∂.ForEach([map:3] Call(∂.Test.Wrap(Call(∂.ChainMap([map:1] Global(xt__), Call(∂.ForEach([map:2] Global(yt__), (Scope(1), Scope(2)):(t, t)):(t, t)*)):(t, t)*)):(t, t)*), Call(∂.With([with:4] Call(∂.Test.Wrap(GetSlot(Scope(3), 0)):t), [with:5] Call(∂.Test.Wrap(GetSlot(Scope(3), 1)):t), (Cmp(Scope(4) @= Scope(5)), Cmp(Scope(4) @< Scope(5)), Cmp(Scope(4) @<= Scope(5)), Cmp(Scope(4) @> Scope(5)), Cmp(Scope(4) @>= Scope(5)), Scope(4), Scope(5)):(b, b, b, b, b, t, t)):(b, b, b, b, b, t, t))):(b, b, b, b, b, t, t)*)):(b, b, b, b, b, t, t)*), Call(∂.With([with:7] StrConcat(If(GetSlot(Scope(6), 0), str(M), str(_)), If(GetSlot(Scope(6), 1), str(M), str(_)), If(GetSlot(Scope(6), 2), str(M), str(_)), If(GetSlot(Scope(6), 3), str(M), str(_)), If(GetSlot(Scope(6), 4), str(M), str(_))), TupleConcat((Scope(7), If(Cmp(Scope(7) @= str(_____)), str(__), If(Cmp(Scope(7) @= str(M_M_M)), str(EQ), If(Cmp(Scope(7) @= str(__M__)), str(LE), If(Cmp(Scope(7) @= str(_MM__)), str(LT), If(Cmp(Scope(7) @= str(____M)), str(GE), If(Cmp(Scope(7) @= str(___MM)), str(GT), If(Cmp(Scope(7) @= str(MMMMM)), str(N___), If(Cmp(Scope(7) @= str(_M_M_)), str(N_E_), If(Cmp(Scope(7) @= str(M__MM)), str(N_L_), If(Cmp(Scope(7) @= str(MMM__)), str(N_G_), If(Cmp(Scope(7) @= str(___M_)), str(N_EL), If(Cmp(Scope(7) @= str(_M___)), str(N_EG), If(Cmp(Scope(7) @= str(M____)), str(N_LG), str(***BAD!***))))))))))))))):(s, s), GetSlice(Scope(6), 5:7:1):(t, t))):(s, s, t, t))):(s, s, t, t)*))
ForEach_1(Arr<obj>, (Time,Time)):(bool,bool,bool,bool,bool,Time,Time)
      1) ldarg.1 [(Time,Time)]
      5) ldfld (Time,Time)::_F0:Time
      5) call static WrapFuncGen::Exec(Time):Time
      1) stloc.0 [Time]
      1) ldarg.1 [(Time,Time)]
      5) ldfld (Time,Time)::_F1:Time
      5) call static WrapFuncGen::Exec(Time):Time
      1) stloc.1 [Time]
      5) newobj (bool,bool,bool,bool,bool,Time,Time)()
      1) dup
      1) ldloc.0 [Time]
      1) ldloc.1 [Time]
      5) call static Time::op_Equality(Time, Time):bool
      5) stfld (bool,bool,bool,bool,bool,Time,Time)::_F0:bool
      1) dup
      1) ldloc.0 [Time]
      1) ldloc.1 [Time]
      5) call static Time::op_LessThan(Time, Time):bool
      5) stfld (bool,bool,bool,bool,bool,Time,Time)::_F1:bool
      1) dup
      1) ldloc.0 [Time]
      1) ldloc.1 [Time]
      5) call static Time::op_LessThanOrEqual(Time, Time):bool
      5) stfld (bool,bool,bool,bool,bool,Time,Time)::_F2:bool
      1) dup
      1) ldloc.0 [Time]
      1) ldloc.1 [Time]
      5) call static Time::op_GreaterThan(Time, Time):bool
      5) stfld (bool,bool,bool,bool,bool,Time,Time)::_F3:bool
      1) dup
      1) ldloc.0 [Time]
      1) ldloc.1 [Time]
      5) call static Time::op_GreaterThanOrEqual(Time, Time):bool
      5) stfld (bool,bool,bool,bool,bool,Time,Time)::_F4:bool
      1) dup
      1) ldloc.0 [Time]
      5) stfld (bool,bool,bool,bool,bool,Time,Time)::_F5:Time
      1) dup
      1) ldloc.1 [Time]
      5) stfld (bool,bool,bool,bool,bool,Time,Time)::_F6:Time
      1) ret
  Total Size: 109

Func sig: (<ctx>:x, xt__:t*, yt__:t*) to (s, s, t, t)*
Sequence: Seq<(str,str,Time,Time)>
 0) (M_M_M, EQ, -2.00:00:00, -2.00:00:00)
 1) (_MM__, LT, -2.00:00:00, 00:00:00)
 2) (_MM__, LT, -2.00:00:00, 3.00:00:00)
 3) (___MM, GT, 00:00:00, -2.00:00:00)
 4) (M_M_M, EQ, 00:00:00, 00:00:00)
 5) (_MM__, LT, 00:00:00, 3.00:00:00)
 6) (___MM, GT, 3.00:00:00, -2.00:00:00)
 7) (___MM, GT, 3.00:00:00, 00:00:00)
 8) (M_M_M, EQ, 3.00:00:00, 3.00:00:00)
*** Ctx ping count: 4
    [0](4): ChainMap(*1: xt__, ForEach(*2: yt__, (*1, *2)))
###
> G(xb__, yb_q) // Req with Opt (RQ).
G(xb__, yb_q) : (s, s, b, b?)*
BndKind:Call, Type:(s, s, b, b?)*, Bnd:(Call(∂.ForEach([map:6] Call(∂.Test.Wrap(Call(∂.ForEach([map:3] Call(∂.Test.Wrap(Call(∂.ChainMap([map:1] Global(xb__), Call(∂.ForEach([map:2] Global(yb_q), (Scope(1), Scope(2)):(b, b?)):(b, b?)*)):(b, b?)*)):(b, b?)*), Call(∂.With([with:4] Call(∂.Test.Wrap(GetSlot(Scope(3), 0)):b), [with:5] Call(∂.Test.Wrap(GetSlot(Scope(3), 1)):b?), (Cmp(Scope(4) @= Scope(5)), Cmp(Scope(4) @< Scope(5)), Cmp(Scope(4) @<= Scope(5)), Cmp(Scope(4) @> Scope(5)), Cmp(Scope(4) @>= Scope(5)), Scope(4), Scope(5)):(b, b, b, b, b, b, b?)):(b, b, b, b, b, b, b?))):(b, b, b, b, b, b, b?)*)):(b, b, b, b, b, b, b?)*), Call(∂.With([with:7] StrConcat(If(GetSlot(Scope(6), 0), str(M), str(_)), If(GetSlot(Scope(6), 1), str(M), str(_)), If(GetSlot(Scope(6), 2), str(M), str(_)), If(GetSlot(Scope(6), 3), str(M), str(_)), If(GetSlot(Scope(6), 4), str(M), str(_))), TupleConcat((Scope(7), If(Cmp(Scope(7) @= str(_____)), str(__), If(Cmp(Scope(7) @= str(M_M_M)), str(EQ), If(Cmp(Scope(7) @= str(__M__)), str(LE), If(Cmp(Scope(7) @= str(_MM__)), str(LT), If(Cmp(Scope(7) @= str(____M)), str(GE), If(Cmp(Scope(7) @= str(___MM)), str(GT), If(Cmp(Scope(7) @= str(MMMMM)), str(N___), If(Cmp(Scope(7) @= str(_M_M_)), str(N_E_), If(Cmp(Scope(7) @= str(M__MM)), str(N_L_), If(Cmp(Scope(7) @= str(MMM__)), str(N_G_), If(Cmp(Scope(7) @= str(___M_)), str(N_EL), If(Cmp(Scope(7) @= str(_M___)), str(N_EG), If(Cmp(Scope(7) @= str(M____)), str(N_LG), str(***BAD!***))))))))))))))):(s, s), GetSlice(Scope(6), 5:7:1):(b, b?))):(s, s, b, b?))):(s, s, b, b?)*))
ForEach_1(Arr<obj>, (bool,Opt<bool>)):(bool,bool,bool,bool,bool,bool,Opt<bool>)
      1) ldarg.1 [(bool,Opt<bool>)]
      5) ldfld (bool,Opt<bool>)::_F0:bool
      5) call static WrapFuncGen::Exec(bool):bool
      1) stloc.0 [bool]
      1) ldarg.1 [(bool,Opt<bool>)]
      5) ldfld (bool,Opt<bool>)::_F1:Opt<bool>
      5) call static WrapFuncGen::Exec(Opt<bool>):Opt<bool>
      1) stloc.1 [Opt<bool>]
      5) newobj (bool,bool,bool,bool,bool,bool,Opt<bool>)()
      1) dup
      2) ldloca.s [Opt<bool> (1)]
      5) call Opt<bool>::get_HasValue():bool
      5) brfalse [0]
      1) ldloc.0 [bool]
      2) ldloca.s [Opt<bool> (1)]
      5) call Opt<bool>::GetValueOrDefault():bool
      2) ceq
      5) br [1]
  Label [0]:
      1) ldc.i4.0
  Label [1]:
      5) stfld (bool,bool,bool,bool,bool,bool,Opt<bool>)::_F0:bool
      1) dup
      2) ldloca.s [Opt<bool> (1)]
      5) call Opt<bool>::get_HasValue():bool
      5) brfalse [2]
      1) ldloc.0 [bool]
      2) ldloca.s [Opt<bool> (1)]
      5) call Opt<bool>::GetValueOrDefault():bool
      2) clt.un
      5) br [3]
  Label [2]:
      1) ldc.i4.0
  Label [3]:
      5) stfld (bool,bool,bool,bool,bool,bool,Opt<bool>)::_F1:bool
      1) dup
      2) ldloca.s [Opt<bool> (1)]
      5) call Opt<bool>::get_HasValue():bool
      5) brfalse [4]
      1) ldloc.0 [bool]
      2) ldloca.s [Opt<bool> (1)]
      5) call Opt<bool>::GetValueOrDefault():bool
      2) cgt.un
      1) ldc.i4.0
      2) ceq
      5) br [5]
  Label [4]:
      1) ldc.i4.0
  Label [5]:
      5) stfld (bool,bool,bool,bool,bool,bool,Opt<bool>)::_F2:bool
      1) dup
      2) ldloca.s [Opt<bool> (1)]
      5) call Opt<bool>::get_HasValue():bool
      5) brfalse [6]
      1) ldloc.0 [bool]
      2) ldloca.s [Opt<bool> (1)]
      5) call Opt<bool>::GetValueOrDefault():bool
      2) cgt.un
      5) br [7]
  Label [6]:
      1) ldc.i4.1
  Label [7]:
      5) stfld (bool,bool,bool,bool,bool,bool,Opt<bool>)::_F3:bool
      1) dup
      2) ldloca.s [Opt<bool> (1)]
      5) call Opt<bool>::get_HasValue():bool
      5) brfalse [8]
      1) ldloc.0 [bool]
      2) ldloca.s [Opt<bool> (1)]
      5) call Opt<bool>::GetValueOrDefault():bool
      2) clt.un
      1) ldc.i4.0
      2) ceq
      5) br [9]
  Label [8]:
      1) ldc.i4.1
  Label [9]:
      5) stfld (bool,bool,bool,bool,bool,bool,Opt<bool>)::_F4:bool
      1) dup
      1) ldloc.0 [bool]
      5) stfld (bool,bool,bool,bool,bool,bool,Opt<bool>)::_F5:bool
      1) dup
      1) ldloc.1 [Opt<bool>]
      5) stfld (bool,bool,bool,bool,bool,bool,Opt<bool>)::_F6:Opt<bool>
      1) ret
  Total Size: 220

Func sig: (<ctx>:x, xb__:b*, yb_q:b?*) to (s, s, b, b?)*
Sequence: Seq<(str,str,bool,Opt<bool>)>
 0) (___MM, GT, false, <null>)
 1) (M_M_M, EQ, false, false)
 2) (_MM__, LT, false, true )
 3) (___MM, GT, true , <null>)
 4) (___MM, GT, true , false)
 5) (M_M_M, EQ, true , true )
*** Ctx ping count: 3
    [0](3): ChainMap(*1: xb__, ForEach(*2: yb_q, (*1, *2)))
###
> G(xr8_, yr8q)
G(xr8_, yr8q) : (s, s, r8, r8?)*
BndKind:Call, Type:(s, s, r8, r8?)*, Bnd:(Call(∂.ForEach([map:6] Call(∂.Test.Wrap(Call(∂.ForEach([map:3] Call(∂.Test.Wrap(Call(∂.ChainMap([map:1] Global(xr8_), Call(∂.ForEach([map:2] Global(yr8q), (Scope(1), Scope(2)):(r8, r8?)):(r8, r8?)*)):(r8, r8?)*)):(r8, r8?)*), Call(∂.With([with:4] Call(∂.Test.Wrap(GetSlot(Scope(3), 0)):r8), [with:5] Call(∂.Test.Wrap(GetSlot(Scope(3), 1)):r8?), (Cmp(Scope(4) @= Scope(5)), Cmp(Scope(4) @< Scope(5)), Cmp(Scope(4) @<= Scope(5)), Cmp(Scope(4) @> Scope(5)), Cmp(Scope(4) @>= Scope(5)), Scope(4), Scope(5)):(b, b, b, b, b, r8, r8?)):(b, b, b, b, b, r8, r8?))):(b, b, b, b, b, r8, r8?)*)):(b, b, b, b, b, r8, r8?)*), Call(∂.With([with:7] StrConcat(If(GetSlot(Scope(6), 0), str(M), str(_)), If(GetSlot(Scope(6), 1), str(M), str(_)), If(GetSlot(Scope(6), 2), str(M), str(_)), If(GetSlot(Scope(6), 3), str(M), str(_)), If(GetSlot(Scope(6), 4), str(M), str(_))), TupleConcat((Scope(7), If(Cmp(Scope(7) @= str(_____)), str(__), If(Cmp(Scope(7) @= str(M_M_M)), str(EQ), If(Cmp(Scope(7) @= str(__M__)), str(LE), If(Cmp(Scope(7) @= str(_MM__)), str(LT), If(Cmp(Scope(7) @= str(____M)), str(GE), If(Cmp(Scope(7) @= str(___MM)), str(GT), If(Cmp(Scope(7) @= str(MMMMM)), str(N___), If(Cmp(Scope(7) @= str(_M_M_)), str(N_E_), If(Cmp(Scope(7) @= str(M__MM)), str(N_L_), If(Cmp(Scope(7) @= str(MMM__)), str(N_G_), If(Cmp(Scope(7) @= str(___M_)), str(N_EL), If(Cmp(Scope(7) @= str(_M___)), str(N_EG), If(Cmp(Scope(7) @= str(M____)), str(N_LG), str(***BAD!***))))))))))))))):(s, s), GetSlice(Scope(6), 5:7:1):(r8, r8?))):(s, s, r8, r8?))):(s, s, r8, r8?)*))
ForEach_1(Arr<obj>, (r8,Opt<r8>)):(bool,bool,bool,bool,bool,r8,Opt<r8>)
      1) ldarg.1 [(r8,Opt<r8>)]
      5) ldfld (r8,Opt<r8>)::_F0:r8
      5) call static WrapFuncGen::Exec(r8):r8
      1) stloc.0 [r8]
      1) ldarg.1 [(r8,Opt<r8>)]
      5) ldfld (r8,Opt<r8>)::_F1:Opt<r8>
      5) call static WrapFuncGen::Exec(Opt<r8>):Opt<r8>
      1) stloc.1 [Opt<r8>]
      5) newobj (bool,bool,bool,bool,bool,r8,Opt<r8>)()
      1) dup
      2) ldloca.s [Opt<r8> (1)]
      5) call Opt<r8>::get_HasValue():bool
      5) brfalse [0]
      1) ldloc.0 [r8]
      2) ldloca.s [Opt<r8> (1)]
      5) call Opt<r8>::GetValueOrDefault():r8
      5) call static NumUtil::Eq(r8, r8):bool
      5) br [1]
  Label [0]:
      1) ldc.i4.0
  Label [1]:
      5) stfld (bool,bool,bool,bool,bool,r8,Opt<r8>)::_F0:bool
      1) dup
      2) ldloca.s [Opt<r8> (1)]
      5) call Opt<r8>::get_HasValue():bool
      5) brfalse [2]
      1) ldloc.0 [r8]
      2) ldloca.s [Opt<r8> (1)]
      5) call Opt<r8>::GetValueOrDefault():r8
      5) call static NumUtil::Lt(r8, r8):bool
      5) br [3]
  Label [2]:
      1) ldc.i4.0
  Label [3]:
      5) stfld (bool,bool,bool,bool,bool,r8,Opt<r8>)::_F1:bool
      1) dup
      2) ldloca.s [Opt<r8> (1)]
      5) call Opt<r8>::get_HasValue():bool
      5) brfalse [4]
      1) ldloc.0 [r8]
      2) ldloca.s [Opt<r8> (1)]
      5) call Opt<r8>::GetValueOrDefault():r8
      5) call static NumUtil::Le(r8, r8):bool
      5) br [5]
  Label [4]:
      1) ldc.i4.0
  Label [5]:
      5) stfld (bool,bool,bool,bool,bool,r8,Opt<r8>)::_F2:bool
      1) dup
      2) ldloca.s [Opt<r8> (1)]
      5) call Opt<r8>::get_HasValue():bool
      5) brfalse [6]
      1) ldloc.0 [r8]
      2) ldloca.s [Opt<r8> (1)]
      5) call Opt<r8>::GetValueOrDefault():r8
      5) call static NumUtil::Gt(r8, r8):bool
      5) br [7]
  Label [6]:
      1) ldc.i4.1
  Label [7]:
      5) stfld (bool,bool,bool,bool,bool,r8,Opt<r8>)::_F3:bool
      1) dup
      2) ldloca.s [Opt<r8> (1)]
      5) call Opt<r8>::get_HasValue():bool
      5) brfalse [8]
      1) ldloc.0 [r8]
      2) ldloca.s [Opt<r8> (1)]
      5) call Opt<r8>::GetValueOrDefault():r8
      5) call static NumUtil::Ge(r8, r8):bool
      5) br [9]
  Label [8]:
      1) ldc.i4.1
  Label [9]:
      5) stfld (bool,bool,bool,bool,bool,r8,Opt<r8>)::_F4:bool
      1) dup
      1) ldloc.0 [r8]
      5) stfld (bool,bool,bool,bool,bool,r8,Opt<r8>)::_F5:r8
      1) dup
      1) ldloc.1 [Opt<r8>]
      5) stfld (bool,bool,bool,bool,bool,r8,Opt<r8>)::_F6:Opt<r8>
      1) ret
  Total Size: 229

Func sig: (<ctx>:x, xr8_:r8*, yr8q:r8?*) to (s, s, r8, r8?)*
Sequence: Seq<(str,str,r8,Opt<r8>)>
 0) (___MM, GT, NaN, <null>)
 1) (M_M_M, EQ, NaN, NaN)
 2) (_MM__, LT, NaN, -3)
 3) (_MM__, LT, NaN, 0)
 4) (_MM__, LT, NaN, 5)
 5) (___MM, GT, -3, <null>)
 6) (___MM, GT, -3, NaN)
 7) (M_M_M, EQ, -3, -3)
 8) (_MM__, LT, -3, 0)
 9) (_MM__, LT, -3, 5)
10) (___MM, GT, 0, <null>)
11) (___MM, GT, 0, NaN)
12) (___MM, GT, 0, -3)
13) (M_M_M, EQ, 0, 0)
14) (_MM__, LT, 0, 5)
15) (___MM, GT, 5, <null>)
16) (___MM, GT, 5, NaN)
17) (___MM, GT, 5, -3)
18) (___MM, GT, 5, 0)
19) (M_M_M, EQ, 5, 5)
*** Ctx ping count: 5
    [0](5): ChainMap(*1: xr8_, ForEach(*2: yr8q, (*1, *2)))
###
> G(xr4_, yr4q)
G(xr4_, yr4q) : (s, s, r4, r4?)*
BndKind:Call, Type:(s, s, r4, r4?)*, Bnd:(Call(∂.ForEach([map:6] Call(∂.Test.Wrap(Call(∂.ForEach([map:3] Call(∂.Test.Wrap(Call(∂.ChainMap([map:1] Global(xr4_), Call(∂.ForEach([map:2] Global(yr4q), (Scope(1), Scope(2)):(r4, r4?)):(r4, r4?)*)):(r4, r4?)*)):(r4, r4?)*), Call(∂.With([with:4] Call(∂.Test.Wrap(GetSlot(Scope(3), 0)):r4), [with:5] Call(∂.Test.Wrap(GetSlot(Scope(3), 1)):r4?), (Cmp(Scope(4) @= Scope(5)), Cmp(Scope(4) @< Scope(5)), Cmp(Scope(4) @<= Scope(5)), Cmp(Scope(4) @> Scope(5)), Cmp(Scope(4) @>= Scope(5)), Scope(4), Scope(5)):(b, b, b, b, b, r4, r4?)):(b, b, b, b, b, r4, r4?))):(b, b, b, b, b, r4, r4?)*)):(b, b, b, b, b, r4, r4?)*), Call(∂.With([with:7] StrConcat(If(GetSlot(Scope(6), 0), str(M), str(_)), If(GetSlot(Scope(6), 1), str(M), str(_)), If(GetSlot(Scope(6), 2), str(M), str(_)), If(GetSlot(Scope(6), 3), str(M), str(_)), If(GetSlot(Scope(6), 4), str(M), str(_))), TupleConcat((Scope(7), If(Cmp(Scope(7) @= str(_____)), str(__), If(Cmp(Scope(7) @= str(M_M_M)), str(EQ), If(Cmp(Scope(7) @= str(__M__)), str(LE), If(Cmp(Scope(7) @= str(_MM__)), str(LT), If(Cmp(Scope(7) @= str(____M)), str(GE), If(Cmp(Scope(7) @= str(___MM)), str(GT), If(Cmp(Scope(7) @= str(MMMMM)), str(N___), If(Cmp(Scope(7) @= str(_M_M_)), str(N_E_), If(Cmp(Scope(7) @= str(M__MM)), str(N_L_), If(Cmp(Scope(7) @= str(MMM__)), str(N_G_), If(Cmp(Scope(7) @= str(___M_)), str(N_EL), If(Cmp(Scope(7) @= str(_M___)), str(N_EG), If(Cmp(Scope(7) @= str(M____)), str(N_LG), str(***BAD!***))))))))))))))):(s, s), GetSlice(Scope(6), 5:7:1):(r4, r4?))):(s, s, r4, r4?))):(s, s, r4, r4?)*))
ForEach_1(Arr<obj>, (r4,Opt<r4>)):(bool,bool,bool,bool,bool,r4,Opt<r4>)
      1) ldarg.1 [(r4,Opt<r4>)]
      5) ldfld (r4,Opt<r4>)::_F0:r4
      5) call static WrapFuncGen::Exec(r4):r4
      1) stloc.0 [r4]
      1) ldarg.1 [(r4,Opt<r4>)]
      5) ldfld (r4,Opt<r4>)::_F1:Opt<r4>
      5) call static WrapFuncGen::Exec(Opt<r4>):Opt<r4>
      1) stloc.1 [Opt<r4>]
      5) newobj (bool,bool,bool,bool,bool,r4,Opt<r4>)()
      1) dup
      2) ldloca.s [Opt<r4> (1)]
      5) call Opt<r4>::get_HasValue():bool
      5) brfalse [0]
      1) ldloc.0 [r4]
      2) ldloca.s [Opt<r4> (1)]
      5) call Opt<r4>::GetValueOrDefault():r4
      5) call static NumUtil::Eq(r4, r4):bool
      5) br [1]
  Label [0]:
      1) ldc.i4.0
  Label [1]:
      5) stfld (bool,bool,bool,bool,bool,r4,Opt<r4>)::_F0:bool
      1) dup
      2) ldloca.s [Opt<r4> (1)]
      5) call Opt<r4>::get_HasValue():bool
      5) brfalse [2]
      1) ldloc.0 [r4]
      2) ldloca.s [Opt<r4> (1)]
      5) call Opt<r4>::GetValueOrDefault():r4
      5) call static NumUtil::Lt(r4, r4):bool
      5) br [3]
  Label [2]:
      1) ldc.i4.0
  Label [3]:
      5) stfld (bool,bool,bool,bool,bool,r4,Opt<r4>)::_F1:bool
      1) dup
      2) ldloca.s [Opt<r4> (1)]
      5) call Opt<r4>::get_HasValue():bool
      5) brfalse [4]
      1) ldloc.0 [r4]
      2) ldloca.s [Opt<r4> (1)]
      5) call Opt<r4>::GetValueOrDefault():r4
      5) call static NumUtil::Le(r4, r4):bool
      5) br [5]
  Label [4]:
      1) ldc.i4.0
  Label [5]:
      5) stfld (bool,bool,bool,bool,bool,r4,Opt<r4>)::_F2:bool
      1) dup
      2) ldloca.s [Opt<r4> (1)]
      5) call Opt<r4>::get_HasValue():bool
      5) brfalse [6]
      1) ldloc.0 [r4]
      2) ldloca.s [Opt<r4> (1)]
      5) call Opt<r4>::GetValueOrDefault():r4
      5) call static NumUtil::Gt(r4, r4):bool
      5) br [7]
  Label [6]:
      1) ldc.i4.1
  Label [7]:
      5) stfld (bool,bool,bool,bool,bool,r4,Opt<r4>)::_F3:bool
      1) dup
      2) ldloca.s [Opt<r4> (1)]
      5) call Opt<r4>::get_HasValue():bool
      5) brfalse [8]
      1) ldloc.0 [r4]
      2) ldloca.s [Opt<r4> (1)]
      5) call Opt<r4>::GetValueOrDefault():r4
      5) call static NumUtil::Ge(r4, r4):bool
      5) br [9]
  Label [8]:
      1) ldc.i4.1
  Label [9]:
      5) stfld (bool,bool,bool,bool,bool,r4,Opt<r4>)::_F4:bool
      1) dup
      1) ldloc.0 [r4]
      5) stfld (bool,bool,bool,bool,bool,r4,Opt<r4>)::_F5:r4
      1) dup
      1) ldloc.1 [Opt<r4>]
      5) stfld (bool,bool,bool,bool,bool,r4,Opt<r4>)::_F6:Opt<r4>
      1) ret
  Total Size: 229

Func sig: (<ctx>:x, xr4_:r4*, yr4q:r4?*) to (s, s, r4, r4?)*
Sequence: Seq<(str,str,r4,Opt<r4>)>
 0) (___MM, GT, NaN, <null>)
 1) (M_M_M, EQ, NaN, NaN)
 2) (_MM__, LT, NaN, -3)
 3) (_MM__, LT, NaN, 0)
 4) (_MM__, LT, NaN, 5)
 5) (___MM, GT, -3, <null>)
 6) (___MM, GT, -3, NaN)
 7) (M_M_M, EQ, -3, -3)
 8) (_MM__, LT, -3, 0)
 9) (_MM__, LT, -3, 5)
10) (___MM, GT, 0, <null>)
11) (___MM, GT, 0, NaN)
12) (___MM, GT, 0, -3)
13) (M_M_M, EQ, 0, 0)
14) (_MM__, LT, 0, 5)
15) (___MM, GT, 5, <null>)
16) (___MM, GT, 5, NaN)
17) (___MM, GT, 5, -3)
18) (___MM, GT, 5, 0)
19) (M_M_M, EQ, 5, 5)
*** Ctx ping count: 5
    [0](5): ChainMap(*1: xr4_, ForEach(*2: yr4q, (*1, *2)))
###
> G(xi__, yi_q)
G(xi__, yi_q) : (s, s, i, i?)*
BndKind:Call, Type:(s, s, i, i?)*, Bnd:(Call(∂.ForEach([map:6] Call(∂.Test.Wrap(Call(∂.ForEach([map:3] Call(∂.Test.Wrap(Call(∂.ChainMap([map:1] Global(xi__), Call(∂.ForEach([map:2] Global(yi_q), (Scope(1), Scope(2)):(i, i?)):(i, i?)*)):(i, i?)*)):(i, i?)*), Call(∂.With([with:4] Call(∂.Test.Wrap(GetSlot(Scope(3), 0)):i), [with:5] Call(∂.Test.Wrap(GetSlot(Scope(3), 1)):i?), (Cmp(Scope(4) @= Scope(5)), Cmp(Scope(4) @< Scope(5)), Cmp(Scope(4) @<= Scope(5)), Cmp(Scope(4) @> Scope(5)), Cmp(Scope(4) @>= Scope(5)), Scope(4), Scope(5)):(b, b, b, b, b, i, i?)):(b, b, b, b, b, i, i?))):(b, b, b, b, b, i, i?)*)):(b, b, b, b, b, i, i?)*), Call(∂.With([with:7] StrConcat(If(GetSlot(Scope(6), 0), str(M), str(_)), If(GetSlot(Scope(6), 1), str(M), str(_)), If(GetSlot(Scope(6), 2), str(M), str(_)), If(GetSlot(Scope(6), 3), str(M), str(_)), If(GetSlot(Scope(6), 4), str(M), str(_))), TupleConcat((Scope(7), If(Cmp(Scope(7) @= str(_____)), str(__), If(Cmp(Scope(7) @= str(M_M_M)), str(EQ), If(Cmp(Scope(7) @= str(__M__)), str(LE), If(Cmp(Scope(7) @= str(_MM__)), str(LT), If(Cmp(Scope(7) @= str(____M)), str(GE), If(Cmp(Scope(7) @= str(___MM)), str(GT), If(Cmp(Scope(7) @= str(MMMMM)), str(N___), If(Cmp(Scope(7) @= str(_M_M_)), str(N_E_), If(Cmp(Scope(7) @= str(M__MM)), str(N_L_), If(Cmp(Scope(7) @= str(MMM__)), str(N_G_), If(Cmp(Scope(7) @= str(___M_)), str(N_EL), If(Cmp(Scope(7) @= str(_M___)), str(N_EG), If(Cmp(Scope(7) @= str(M____)), str(N_LG), str(***BAD!***))))))))))))))):(s, s), GetSlice(Scope(6), 5:7:1):(i, i?))):(s, s, i, i?))):(s, s, i, i?)*))
ForEach_1(Arr<obj>, (ia,Opt<ia>)):(bool,bool,bool,bool,bool,ia,Opt<ia>)
      1) ldarg.1 [(ia,Opt<ia>)]
      5) ldfld (ia,Opt<ia>)::_F0:ia
      5) call static WrapFuncGen::Exec(ia):ia
      1) stloc.0 [ia]
      1) ldarg.1 [(ia,Opt<ia>)]
      5) ldfld (ia,Opt<ia>)::_F1:Opt<ia>
      5) call static WrapFuncGen::Exec(Opt<ia>):Opt<ia>
      1) stloc.1 [Opt<ia>]
      5) newobj (bool,bool,bool,bool,bool,ia,Opt<ia>)()
      1) dup
      2) ldloca.s [Opt<ia> (1)]
      5) call Opt<ia>::get_HasValue():bool
      5) brfalse [0]
      1) ldloc.0 [ia]
      2) ldloca.s [Opt<ia> (1)]
      5) call Opt<ia>::GetValueOrDefault():ia
      5) call static ia::op_Equality(ia, ia):bool
      5) br [1]
  Label [0]:
      1) ldc.i4.0
  Label [1]:
      5) stfld (bool,bool,bool,bool,bool,ia,Opt<ia>)::_F0:bool
      1) dup
      2) ldloca.s [Opt<ia> (1)]
      5) call Opt<ia>::get_HasValue():bool
      5) brfalse [2]
      1) ldloc.0 [ia]
      2) ldloca.s [Opt<ia> (1)]
      5) call Opt<ia>::GetValueOrDefault():ia
      5) call static ia::op_LessThan(ia, ia):bool
      5) br [3]
  Label [2]:
      1) ldc.i4.0
  Label [3]:
      5) stfld (bool,bool,bool,bool,bool,ia,Opt<ia>)::_F1:bool
      1) dup
      2) ldloca.s [Opt<ia> (1)]
      5) call Opt<ia>::get_HasValue():bool
      5) brfalse [4]
      1) ldloc.0 [ia]
      2) ldloca.s [Opt<ia> (1)]
      5) call Opt<ia>::GetValueOrDefault():ia
      5) call static ia::op_LessThanOrEqual(ia, ia):bool
      5) br [5]
  Label [4]:
      1) ldc.i4.0
  Label [5]:
      5) stfld (bool,bool,bool,bool,bool,ia,Opt<ia>)::_F2:bool
      1) dup
      2) ldloca.s [Opt<ia> (1)]
      5) call Opt<ia>::get_HasValue():bool
      5) brfalse [6]
      1) ldloc.0 [ia]
      2) ldloca.s [Opt<ia> (1)]
      5) call Opt<ia>::GetValueOrDefault():ia
      5) call static ia::op_GreaterThan(ia, ia):bool
      5) br [7]
  Label [6]:
      1) ldc.i4.1
  Label [7]:
      5) stfld (bool,bool,bool,bool,bool,ia,Opt<ia>)::_F3:bool
      1) dup
      2) ldloca.s [Opt<ia> (1)]
      5) call Opt<ia>::get_HasValue():bool
      5) brfalse [8]
      1) ldloc.0 [ia]
      2) ldloca.s [Opt<ia> (1)]
      5) call Opt<ia>::GetValueOrDefault():ia
      5) call static ia::op_GreaterThanOrEqual(ia, ia):bool
      5) br [9]
  Label [8]:
      1) ldc.i4.1
  Label [9]:
      5) stfld (bool,bool,bool,bool,bool,ia,Opt<ia>)::_F4:bool
      1) dup
      1) ldloc.0 [ia]
      5) stfld (bool,bool,bool,bool,bool,ia,Opt<ia>)::_F5:ia
      1) dup
      1) ldloc.1 [Opt<ia>]
      5) stfld (bool,bool,bool,bool,bool,ia,Opt<ia>)::_F6:Opt<ia>
      1) ret
  Total Size: 229

Func sig: (<ctx>:x, xi__:i*, yi_q:i?*) to (s, s, i, i?)*
Sequence: Seq<(str,str,ia,Opt<ia>)>
 0) (___MM, GT, -3, <null>)
 1) (M_M_M, EQ, -3, -3)
 2) (_MM__, LT, -3, 0)
 3) (_MM__, LT, -3, 5)
 4) (___MM, GT, 0, <null>)
 5) (___MM, GT, 0, -3)
 6) (M_M_M, EQ, 0, 0)
 7) (_MM__, LT, 0, 5)
 8) (___MM, GT, 5, <null>)
 9) (___MM, GT, 5, -3)
10) (___MM, GT, 5, 0)
11) (M_M_M, EQ, 5, 5)
*** Ctx ping count: 4
    [0](4): ChainMap(*1: xi__, ForEach(*2: yi_q, (*1, *2)))
###
> G(xi2_, yi2q)
G(xi2_, yi2q) : (s, s, i2, i2?)*
BndKind:Call, Type:(s, s, i2, i2?)*, Bnd:(Call(∂.ForEach([map:6] Call(∂.Test.Wrap(Call(∂.ForEach([map:3] Call(∂.Test.Wrap(Call(∂.ChainMap([map:1] Global(xi2_), Call(∂.ForEach([map:2] Global(yi2q), (Scope(1), Scope(2)):(i2, i2?)):(i2, i2?)*)):(i2, i2?)*)):(i2, i2?)*), Call(∂.With([with:4] Call(∂.Test.Wrap(GetSlot(Scope(3), 0)):i2), [with:5] Call(∂.Test.Wrap(GetSlot(Scope(3), 1)):i2?), (Cmp(Scope(4) @= Scope(5)), Cmp(Scope(4) @< Scope(5)), Cmp(Scope(4) @<= Scope(5)), Cmp(Scope(4) @> Scope(5)), Cmp(Scope(4) @>= Scope(5)), Scope(4), Scope(5)):(b, b, b, b, b, i2, i2?)):(b, b, b, b, b, i2, i2?))):(b, b, b, b, b, i2, i2?)*)):(b, b, b, b, b, i2, i2?)*), Call(∂.With([with:7] StrConcat(If(GetSlot(Scope(6), 0), str(M), str(_)), If(GetSlot(Scope(6), 1), str(M), str(_)), If(GetSlot(Scope(6), 2), str(M), str(_)), If(GetSlot(Scope(6), 3), str(M), str(_)), If(GetSlot(Scope(6), 4), str(M), str(_))), TupleConcat((Scope(7), If(Cmp(Scope(7) @= str(_____)), str(__), If(Cmp(Scope(7) @= str(M_M_M)), str(EQ), If(Cmp(Scope(7) @= str(__M__)), str(LE), If(Cmp(Scope(7) @= str(_MM__)), str(LT), If(Cmp(Scope(7) @= str(____M)), str(GE), If(Cmp(Scope(7) @= str(___MM)), str(GT), If(Cmp(Scope(7) @= str(MMMMM)), str(N___), If(Cmp(Scope(7) @= str(_M_M_)), str(N_E_), If(Cmp(Scope(7) @= str(M__MM)), str(N_L_), If(Cmp(Scope(7) @= str(MMM__)), str(N_G_), If(Cmp(Scope(7) @= str(___M_)), str(N_EL), If(Cmp(Scope(7) @= str(_M___)), str(N_EG), If(Cmp(Scope(7) @= str(M____)), str(N_LG), str(***BAD!***))))))))))))))):(s, s), GetSlice(Scope(6), 5:7:1):(i2, i2?))):(s, s, i2, i2?))):(s, s, i2, i2?)*))
ForEach_1(Arr<obj>, (i2,Opt<i2>)):(bool,bool,bool,bool,bool,i2,Opt<i2>)
      1) ldarg.1 [(i2,Opt<i2>)]
      5) ldfld (i2,Opt<i2>)::_F0:i2
      5) call static WrapFuncGen::Exec(i2):i2
      1) stloc.0 [i2]
      1) ldarg.1 [(i2,Opt<i2>)]
      5) ldfld (i2,Opt<i2>)::_F1:Opt<i2>
      5) call static WrapFuncGen::Exec(Opt<i2>):Opt<i2>
      1) stloc.1 [Opt<i2>]
      5) newobj (bool,bool,bool,bool,bool,i2,Opt<i2>)()
      1) dup
      2) ldloca.s [Opt<i2> (1)]
      5) call Opt<i2>::get_HasValue():bool
      5) brfalse [0]
      1) ldloc.0 [i2]
      2) ldloca.s [Opt<i2> (1)]
      5) call Opt<i2>::GetValueOrDefault():i2
      2) ceq
      5) br [1]
  Label [0]:
      1) ldc.i4.0
  Label [1]:
      5) stfld (bool,bool,bool,bool,bool,i2,Opt<i2>)::_F0:bool
      1) dup
      2) ldloca.s [Opt<i2> (1)]
      5) call Opt<i2>::get_HasValue():bool
      5) brfalse [2]
      1) ldloc.0 [i2]
      2) ldloca.s [Opt<i2> (1)]
      5) call Opt<i2>::GetValueOrDefault():i2
      2) clt
      5) br [3]
  Label [2]:
      1) ldc.i4.0
  Label [3]:
      5) stfld (bool,bool,bool,bool,bool,i2,Opt<i2>)::_F1:bool
      1) dup
      2) ldloca.s [Opt<i2> (1)]
      5) call Opt<i2>::get_HasValue():bool
      5) brfalse [4]
      1) ldloc.0 [i2]
      2) ldloca.s [Opt<i2> (1)]
      5) call Opt<i2>::GetValueOrDefault():i2
      2) cgt
      1) ldc.i4.0
      2) ceq
      5) br [5]
  Label [4]:
      1) ldc.i4.0
  Label [5]:
      5) stfld (bool,bool,bool,bool,bool,i2,Opt<i2>)::_F2:bool
      1) dup
      2) ldloca.s [Opt<i2> (1)]
      5) call Opt<i2>::get_HasValue():bool
      5) brfalse [6]
      1) ldloc.0 [i2]
      2) ldloca.s [Opt<i2> (1)]
      5) call Opt<i2>::GetValueOrDefault():i2
      2) cgt
      5) br [7]
  Label [6]:
      1) ldc.i4.1
  Label [7]:
      5) stfld (bool,bool,bool,bool,bool,i2,Opt<i2>)::_F3:bool
      1) dup
      2) ldloca.s [Opt<i2> (1)]
      5) call Opt<i2>::get_HasValue():bool
      5) brfalse [8]
      1) ldloc.0 [i2]
      2) ldloca.s [Opt<i2> (1)]
      5) call Opt<i2>::GetValueOrDefault():i2
      2) clt
      1) ldc.i4.0
      2) ceq
      5) br [9]
  Label [8]:
      1) ldc.i4.1
  Label [9]:
      5) stfld (bool,bool,bool,bool,bool,i2,Opt<i2>)::_F4:bool
      1) dup
      1) ldloc.0 [i2]
      5) stfld (bool,bool,bool,bool,bool,i2,Opt<i2>)::_F5:i2
      1) dup
      1) ldloc.1 [Opt<i2>]
      5) stfld (bool,bool,bool,bool,bool,i2,Opt<i2>)::_F6:Opt<i2>
      1) ret
  Total Size: 220

Func sig: (<ctx>:x, xi2_:i2*, yi2q:i2?*) to (s, s, i2, i2?)*
Sequence: Seq<(str,str,i2,Opt<i2>)>
 0) (___MM, GT, -3, <null>)
 1) (M_M_M, EQ, -3, -3)
 2) (_MM__, LT, -3, 0)
 3) (_MM__, LT, -3, 5)
 4) (___MM, GT, 0, <null>)
 5) (___MM, GT, 0, -3)
 6) (M_M_M, EQ, 0, 0)
 7) (_MM__, LT, 0, 5)
 8) (___MM, GT, 5, <null>)
 9) (___MM, GT, 5, -3)
10) (___MM, GT, 5, 0)
11) (M_M_M, EQ, 5, 5)
*** Ctx ping count: 4
    [0](4): ChainMap(*1: xi2_, ForEach(*2: yi2q, (*1, *2)))
###
> G(xu4_, yu4q)
G(xu4_, yu4q) : (s, s, u4, u4?)*
BndKind:Call, Type:(s, s, u4, u4?)*, Bnd:(Call(∂.ForEach([map:6] Call(∂.Test.Wrap(Call(∂.ForEach([map:3] Call(∂.Test.Wrap(Call(∂.ChainMap([map:1] Global(xu4_), Call(∂.ForEach([map:2] Global(yu4q), (Scope(1), Scope(2)):(u4, u4?)):(u4, u4?)*)):(u4, u4?)*)):(u4, u4?)*), Call(∂.With([with:4] Call(∂.Test.Wrap(GetSlot(Scope(3), 0)):u4), [with:5] Call(∂.Test.Wrap(GetSlot(Scope(3), 1)):u4?), (Cmp(Scope(4) @= Scope(5)), Cmp(Scope(4) @< Scope(5)), Cmp(Scope(4) @<= Scope(5)), Cmp(Scope(4) @> Scope(5)), Cmp(Scope(4) @>= Scope(5)), Scope(4), Scope(5)):(b, b, b, b, b, u4, u4?)):(b, b, b, b, b, u4, u4?))):(b, b, b, b, b, u4, u4?)*)):(b, b, b, b, b, u4, u4?)*), Call(∂.With([with:7] StrConcat(If(GetSlot(Scope(6), 0), str(M), str(_)), If(GetSlot(Scope(6), 1), str(M), str(_)), If(GetSlot(Scope(6), 2), str(M), str(_)), If(GetSlot(Scope(6), 3), str(M), str(_)), If(GetSlot(Scope(6), 4), str(M), str(_))), TupleConcat((Scope(7), If(Cmp(Scope(7) @= str(_____)), str(__), If(Cmp(Scope(7) @= str(M_M_M)), str(EQ), If(Cmp(Scope(7) @= str(__M__)), str(LE), If(Cmp(Scope(7) @= str(_MM__)), str(LT), If(Cmp(Scope(7) @= str(____M)), str(GE), If(Cmp(Scope(7) @= str(___MM)), str(GT), If(Cmp(Scope(7) @= str(MMMMM)), str(N___), If(Cmp(Scope(7) @= str(_M_M_)), str(N_E_), If(Cmp(Scope(7) @= str(M__MM)), str(N_L_), If(Cmp(Scope(7) @= str(MMM__)), str(N_G_), If(Cmp(Scope(7) @= str(___M_)), str(N_EL), If(Cmp(Scope(7) @= str(_M___)), str(N_EG), If(Cmp(Scope(7) @= str(M____)), str(N_LG), str(***BAD!***))))))))))))))):(s, s), GetSlice(Scope(6), 5:7:1):(u4, u4?))):(s, s, u4, u4?))):(s, s, u4, u4?)*))
ForEach_1(Arr<obj>, (u4,Opt<u4>)):(bool,bool,bool,bool,bool,u4,Opt<u4>)
      1) ldarg.1 [(u4,Opt<u4>)]
      5) ldfld (u4,Opt<u4>)::_F0:u4
      5) call static WrapFuncGen::Exec(u4):u4
      1) stloc.0 [u4]
      1) ldarg.1 [(u4,Opt<u4>)]
      5) ldfld (u4,Opt<u4>)::_F1:Opt<u4>
      5) call static WrapFuncGen::Exec(Opt<u4>):Opt<u4>
      1) stloc.1 [Opt<u4>]
      5) newobj (bool,bool,bool,bool,bool,u4,Opt<u4>)()
      1) dup
      2) ldloca.s [Opt<u4> (1)]
      5) call Opt<u4>::get_HasValue():bool
      5) brfalse [0]
      1) ldloc.0 [u4]
      2) ldloca.s [Opt<u4> (1)]
      5) call Opt<u4>::GetValueOrDefault():u4
      2) ceq
      5) br [1]
  Label [0]:
      1) ldc.i4.0
  Label [1]:
      5) stfld (bool,bool,bool,bool,bool,u4,Opt<u4>)::_F0:bool
      1) dup
      2) ldloca.s [Opt<u4> (1)]
      5) call Opt<u4>::get_HasValue():bool
      5) brfalse [2]
      1) ldloc.0 [u4]
      2) ldloca.s [Opt<u4> (1)]
      5) call Opt<u4>::GetValueOrDefault():u4
      2) clt.un
      5) br [3]
  Label [2]:
      1) ldc.i4.0
  Label [3]:
      5) stfld (bool,bool,bool,bool,bool,u4,Opt<u4>)::_F1:bool
      1) dup
      2) ldloca.s [Opt<u4> (1)]
      5) call Opt<u4>::get_HasValue():bool
      5) brfalse [4]
      1) ldloc.0 [u4]
      2) ldloca.s [Opt<u4> (1)]
      5) call Opt<u4>::GetValueOrDefault():u4
      2) cgt.un
      1) ldc.i4.0
      2) ceq
      5) br [5]
  Label [4]:
      1) ldc.i4.0
  Label [5]:
      5) stfld (bool,bool,bool,bool,bool,u4,Opt<u4>)::_F2:bool
      1) dup
      2) ldloca.s [Opt<u4> (1)]
      5) call Opt<u4>::get_HasValue():bool
      5) brfalse [6]
      1) ldloc.0 [u4]
      2) ldloca.s [Opt<u4> (1)]
      5) call Opt<u4>::GetValueOrDefault():u4
      2) cgt.un
      5) br [7]
  Label [6]:
      1) ldc.i4.1
  Label [7]:
      5) stfld (bool,bool,bool,bool,bool,u4,Opt<u4>)::_F3:bool
      1) dup
      2) ldloca.s [Opt<u4> (1)]
      5) call Opt<u4>::get_HasValue():bool
      5) brfalse [8]
      1) ldloc.0 [u4]
      2) ldloca.s [Opt<u4> (1)]
      5) call Opt<u4>::GetValueOrDefault():u4
      2) clt.un
      1) ldc.i4.0
      2) ceq
      5) br [9]
  Label [8]:
      1) ldc.i4.1
  Label [9]:
      5) stfld (bool,bool,bool,bool,bool,u4,Opt<u4>)::_F4:bool
      1) dup
      1) ldloc.0 [u4]
      5) stfld (bool,bool,bool,bool,bool,u4,Opt<u4>)::_F5:u4
      1) dup
      1) ldloc.1 [Opt<u4>]
      5) stfld (bool,bool,bool,bool,bool,u4,Opt<u4>)::_F6:Opt<u4>
      1) ret
  Total Size: 220

Func sig: (<ctx>:x, xu4_:u4*, yu4q:u4?*) to (s, s, u4, u4?)*
Sequence: Seq<(str,str,u4,Opt<u4>)>
 0) (___MM, GT, 0, <null>)
 1) (M_M_M, EQ, 0, 0)
 2) (_MM__, LT, 0, 3)
 3) (_MM__, LT, 0, 5)
 4) (___MM, GT, 3, <null>)
 5) (___MM, GT, 3, 0)
 6) (M_M_M, EQ, 3, 3)
 7) (_MM__, LT, 3, 5)
 8) (___MM, GT, 5, <null>)
 9) (___MM, GT, 5, 0)
10) (___MM, GT, 5, 3)
11) (M_M_M, EQ, 5, 5)
*** Ctx ping count: 4
    [0](4): ChainMap(*1: xu4_, ForEach(*2: yu4q, (*1, *2)))
###
> G(xd__, yd_q)
G(xd__, yd_q) : (s, s, d, d?)*
BndKind:Call, Type:(s, s, d, d?)*, Bnd:(Call(∂.ForEach([map:6] Call(∂.Test.Wrap(Call(∂.ForEach([map:3] Call(∂.Test.Wrap(Call(∂.ChainMap([map:1] Global(xd__), Call(∂.ForEach([map:2] Global(yd_q), (Scope(1), Scope(2)):(d, d?)):(d, d?)*)):(d, d?)*)):(d, d?)*), Call(∂.With([with:4] Call(∂.Test.Wrap(GetSlot(Scope(3), 0)):d), [with:5] Call(∂.Test.Wrap(GetSlot(Scope(3), 1)):d?), (Cmp(Scope(4) @= Scope(5)), Cmp(Scope(4) @< Scope(5)), Cmp(Scope(4) @<= Scope(5)), Cmp(Scope(4) @> Scope(5)), Cmp(Scope(4) @>= Scope(5)), Scope(4), Scope(5)):(b, b, b, b, b, d, d?)):(b, b, b, b, b, d, d?))):(b, b, b, b, b, d, d?)*)):(b, b, b, b, b, d, d?)*), Call(∂.With([with:7] StrConcat(If(GetSlot(Scope(6), 0), str(M), str(_)), If(GetSlot(Scope(6), 1), str(M), str(_)), If(GetSlot(Scope(6), 2), str(M), str(_)), If(GetSlot(Scope(6), 3), str(M), str(_)), If(GetSlot(Scope(6), 4), str(M), str(_))), TupleConcat((Scope(7), If(Cmp(Scope(7) @= str(_____)), str(__), If(Cmp(Scope(7) @= str(M_M_M)), str(EQ), If(Cmp(Scope(7) @= str(__M__)), str(LE), If(Cmp(Scope(7) @= str(_MM__)), str(LT), If(Cmp(Scope(7) @= str(____M)), str(GE), If(Cmp(Scope(7) @= str(___MM)), str(GT), If(Cmp(Scope(7) @= str(MMMMM)), str(N___), If(Cmp(Scope(7) @= str(_M_M_)), str(N_E_), If(Cmp(Scope(7) @= str(M__MM)), str(N_L_), If(Cmp(Scope(7) @= str(MMM__)), str(N_G_), If(Cmp(Scope(7) @= str(___M_)), str(N_EL), If(Cmp(Scope(7) @= str(_M___)), str(N_EG), If(Cmp(Scope(7) @= str(M____)), str(N_LG), str(***BAD!***))))))))))))))):(s, s), GetSlice(Scope(6), 5:7:1):(d, d?))):(s, s, d, d?))):(s, s, d, d?)*))
ForEach_1(Arr<obj>, (Date,Opt<Date>)):(bool,bool,bool,bool,bool,Date,Opt<Date>)
      1) ldarg.1 [(Date,Opt<Date>)]
      5) ldfld (Date,Opt<Date>)::_F0:Date
      5) call static WrapFuncGen::Exec(Date):Date
      1) stloc.0 [Date]
      1) ldarg.1 [(Date,Opt<Date>)]
      5) ldfld (Date,Opt<Date>)::_F1:Opt<Date>
      5) call static WrapFuncGen::Exec(Opt<Date>):Opt<Date>
      1) stloc.1 [Opt<Date>]
      5) newobj (bool,bool,bool,bool,bool,Date,Opt<Date>)()
      1) dup
      2) ldloca.s [Opt<Date> (1)]
      5) call Opt<Date>::get_HasValue():bool
      5) brfalse [0]
      1) ldloc.0 [Date]
      2) ldloca.s [Opt<Date> (1)]
      5) call Opt<Date>::GetValueOrDefault():Date
      5) call static Date::op_Equality(Date, Date):bool
      5) br [1]
  Label [0]:
      1) ldc.i4.0
  Label [1]:
      5) stfld (bool,bool,bool,bool,bool,Date,Opt<Date>)::_F0:bool
      1) dup
      2) ldloca.s [Opt<Date> (1)]
      5) call Opt<Date>::get_HasValue():bool
      5) brfalse [2]
      1) ldloc.0 [Date]
      2) ldloca.s [Opt<Date> (1)]
      5) call Opt<Date>::GetValueOrDefault():Date
      5) call static Date::op_LessThan(Date, Date):bool
      5) br [3]
  Label [2]:
      1) ldc.i4.0
  Label [3]:
      5) stfld (bool,bool,bool,bool,bool,Date,Opt<Date>)::_F1:bool
      1) dup
      2) ldloca.s [Opt<Date> (1)]
      5) call Opt<Date>::get_HasValue():bool
      5) brfalse [4]
      1) ldloc.0 [Date]
      2) ldloca.s [Opt<Date> (1)]
      5) call Opt<Date>::GetValueOrDefault():Date
      5) call static Date::op_LessThanOrEqual(Date, Date):bool
      5) br [5]
  Label [4]:
      1) ldc.i4.0
  Label [5]:
      5) stfld (bool,bool,bool,bool,bool,Date,Opt<Date>)::_F2:bool
      1) dup
      2) ldloca.s [Opt<Date> (1)]
      5) call Opt<Date>::get_HasValue():bool
      5) brfalse [6]
      1) ldloc.0 [Date]
      2) ldloca.s [Opt<Date> (1)]
      5) call Opt<Date>::GetValueOrDefault():Date
      5) call static Date::op_GreaterThan(Date, Date):bool
      5) br [7]
  Label [6]:
      1) ldc.i4.1
  Label [7]:
      5) stfld (bool,bool,bool,bool,bool,Date,Opt<Date>)::_F3:bool
      1) dup
      2) ldloca.s [Opt<Date> (1)]
      5) call Opt<Date>::get_HasValue():bool
      5) brfalse [8]
      1) ldloc.0 [Date]
      2) ldloca.s [Opt<Date> (1)]
      5) call Opt<Date>::GetValueOrDefault():Date
      5) call static Date::op_GreaterThanOrEqual(Date, Date):bool
      5) br [9]
  Label [8]:
      1) ldc.i4.1
  Label [9]:
      5) stfld (bool,bool,bool,bool,bool,Date,Opt<Date>)::_F4:bool
      1) dup
      1) ldloc.0 [Date]
      5) stfld (bool,bool,bool,bool,bool,Date,Opt<Date>)::_F5:Date
      1) dup
      1) ldloc.1 [Opt<Date>]
      5) stfld (bool,bool,bool,bool,bool,Date,Opt<Date>)::_F6:Opt<Date>
      1) ret
  Total Size: 229

Func sig: (<ctx>:x, xd__:d*, yd_q:d?*) to (s, s, d, d?)*
Sequence: Seq<(str,str,Date,Opt<Date>)>
 0) (___MM, GT, DT(1900, 1, 1, 0, 0, 0, 0), <null>)
 1) (M_M_M, EQ, DT(1900, 1, 1, 0, 0, 0, 0), DT(1900, 1, 1, 0, 0, 0, 0))
 2) (_MM__, LT, DT(1900, 1, 1, 0, 0, 0, 0), DT(2023, 7, 1, 0, 0, 0, 0))
 3) (_MM__, LT, DT(1900, 1, 1, 0, 0, 0, 0), DT(2023, 9, 1, 0, 0, 0, 0))
 4) (___MM, GT, DT(2023, 7, 1, 0, 0, 0, 0), <null>)
 5) (___MM, GT, DT(2023, 7, 1, 0, 0, 0, 0), DT(1900, 1, 1, 0, 0, 0, 0))
 6) (M_M_M, EQ, DT(2023, 7, 1, 0, 0, 0, 0), DT(2023, 7, 1, 0, 0, 0, 0))
 7) (_MM__, LT, DT(2023, 7, 1, 0, 0, 0, 0), DT(2023, 9, 1, 0, 0, 0, 0))
 8) (___MM, GT, DT(2023, 9, 1, 0, 0, 0, 0), <null>)
 9) (___MM, GT, DT(2023, 9, 1, 0, 0, 0, 0), DT(1900, 1, 1, 0, 0, 0, 0))
10) (___MM, GT, DT(2023, 9, 1, 0, 0, 0, 0), DT(2023, 7, 1, 0, 0, 0, 0))
11) (M_M_M, EQ, DT(2023, 9, 1, 0, 0, 0, 0), DT(2023, 9, 1, 0, 0, 0, 0))
*** Ctx ping count: 4
    [0](4): ChainMap(*1: xd__, ForEach(*2: yd_q, (*1, *2)))
###
> G(xt__, yt_q)
G(xt__, yt_q) : (s, s, t, t?)*
BndKind:Call, Type:(s, s, t, t?)*, Bnd:(Call(∂.ForEach([map:6] Call(∂.Test.Wrap(Call(∂.ForEach([map:3] Call(∂.Test.Wrap(Call(∂.ChainMap([map:1] Global(xt__), Call(∂.ForEach([map:2] Global(yt_q), (Scope(1), Scope(2)):(t, t?)):(t, t?)*)):(t, t?)*)):(t, t?)*), Call(∂.With([with:4] Call(∂.Test.Wrap(GetSlot(Scope(3), 0)):t), [with:5] Call(∂.Test.Wrap(GetSlot(Scope(3), 1)):t?), (Cmp(Scope(4) @= Scope(5)), Cmp(Scope(4) @< Scope(5)), Cmp(Scope(4) @<= Scope(5)), Cmp(Scope(4) @> Scope(5)), Cmp(Scope(4) @>= Scope(5)), Scope(4), Scope(5)):(b, b, b, b, b, t, t?)):(b, b, b, b, b, t, t?))):(b, b, b, b, b, t, t?)*)):(b, b, b, b, b, t, t?)*), Call(∂.With([with:7] StrConcat(If(GetSlot(Scope(6), 0), str(M), str(_)), If(GetSlot(Scope(6), 1), str(M), str(_)), If(GetSlot(Scope(6), 2), str(M), str(_)), If(GetSlot(Scope(6), 3), str(M), str(_)), If(GetSlot(Scope(6), 4), str(M), str(_))), TupleConcat((Scope(7), If(Cmp(Scope(7) @= str(_____)), str(__), If(Cmp(Scope(7) @= str(M_M_M)), str(EQ), If(Cmp(Scope(7) @= str(__M__)), str(LE), If(Cmp(Scope(7) @= str(_MM__)), str(LT), If(Cmp(Scope(7) @= str(____M)), str(GE), If(Cmp(Scope(7) @= str(___MM)), str(GT), If(Cmp(Scope(7) @= str(MMMMM)), str(N___), If(Cmp(Scope(7) @= str(_M_M_)), str(N_E_), If(Cmp(Scope(7) @= str(M__MM)), str(N_L_), If(Cmp(Scope(7) @= str(MMM__)), str(N_G_), If(Cmp(Scope(7) @= str(___M_)), str(N_EL), If(Cmp(Scope(7) @= str(_M___)), str(N_EG), If(Cmp(Scope(7) @= str(M____)), str(N_LG), str(***BAD!***))))))))))))))):(s, s), GetSlice(Scope(6), 5:7:1):(t, t?))):(s, s, t, t?))):(s, s, t, t?)*))
ForEach_1(Arr<obj>, (Time,Opt<Time>)):(bool,bool,bool,bool,bool,Time,Opt<Time>)
      1) ldarg.1 [(Time,Opt<Time>)]
      5) ldfld (Time,Opt<Time>)::_F0:Time
      5) call static WrapFuncGen::Exec(Time):Time
      1) stloc.0 [Time]
      1) ldarg.1 [(Time,Opt<Time>)]
      5) ldfld (Time,Opt<Time>)::_F1:Opt<Time>
      5) call static WrapFuncGen::Exec(Opt<Time>):Opt<Time>
      1) stloc.1 [Opt<Time>]
      5) newobj (bool,bool,bool,bool,bool,Time,Opt<Time>)()
      1) dup
      2) ldloca.s [Opt<Time> (1)]
      5) call Opt<Time>::get_HasValue():bool
      5) brfalse [0]
      1) ldloc.0 [Time]
      2) ldloca.s [Opt<Time> (1)]
      5) call Opt<Time>::GetValueOrDefault():Time
      5) call static Time::op_Equality(Time, Time):bool
      5) br [1]
  Label [0]:
      1) ldc.i4.0
  Label [1]:
      5) stfld (bool,bool,bool,bool,bool,Time,Opt<Time>)::_F0:bool
      1) dup
      2) ldloca.s [Opt<Time> (1)]
      5) call Opt<Time>::get_HasValue():bool
      5) brfalse [2]
      1) ldloc.0 [Time]
      2) ldloca.s [Opt<Time> (1)]
      5) call Opt<Time>::GetValueOrDefault():Time
      5) call static Time::op_LessThan(Time, Time):bool
      5) br [3]
  Label [2]:
      1) ldc.i4.0
  Label [3]:
      5) stfld (bool,bool,bool,bool,bool,Time,Opt<Time>)::_F1:bool
      1) dup
      2) ldloca.s [Opt<Time> (1)]
      5) call Opt<Time>::get_HasValue():bool
      5) brfalse [4]
      1) ldloc.0 [Time]
      2) ldloca.s [Opt<Time> (1)]
      5) call Opt<Time>::GetValueOrDefault():Time
      5) call static Time::op_LessThanOrEqual(Time, Time):bool
      5) br [5]
  Label [4]:
      1) ldc.i4.0
  Label [5]:
      5) stfld (bool,bool,bool,bool,bool,Time,Opt<Time>)::_F2:bool
      1) dup
      2) ldloca.s [Opt<Time> (1)]
      5) call Opt<Time>::get_HasValue():bool
      5) brfalse [6]
      1) ldloc.0 [Time]
      2) ldloca.s [Opt<Time> (1)]
      5) call Opt<Time>::GetValueOrDefault():Time
      5) call static Time::op_GreaterThan(Time, Time):bool
      5) br [7]
  Label [6]:
      1) ldc.i4.1
  Label [7]:
      5) stfld (bool,bool,bool,bool,bool,Time,Opt<Time>)::_F3:bool
      1) dup
      2) ldloca.s [Opt<Time> (1)]
      5) call Opt<Time>::get_HasValue():bool
      5) brfalse [8]
      1) ldloc.0 [Time]
      2) ldloca.s [Opt<Time> (1)]
      5) call Opt<Time>::GetValueOrDefault():Time
      5) call static Time::op_GreaterThanOrEqual(Time, Time):bool
      5) br [9]
  Label [8]:
      1) ldc.i4.1
  Label [9]:
      5) stfld (bool,bool,bool,bool,bool,Time,Opt<Time>)::_F4:bool
      1) dup
      1) ldloc.0 [Time]
      5) stfld (bool,bool,bool,bool,bool,Time,Opt<Time>)::_F5:Time
      1) dup
      1) ldloc.1 [Opt<Time>]
      5) stfld (bool,bool,bool,bool,bool,Time,Opt<Time>)::_F6:Opt<Time>
      1) ret
  Total Size: 229

Func sig: (<ctx>:x, xt__:t*, yt_q:t?*) to (s, s, t, t?)*
Sequence: Seq<(str,str,Time,Opt<Time>)>
 0) (___MM, GT, -2.00:00:00, <null>)
 1) (M_M_M, EQ, -2.00:00:00, -2.00:00:00)
 2) (_MM__, LT, -2.00:00:00, 00:00:00)
 3) (_MM__, LT, -2.00:00:00, 3.00:00:00)
 4) (___MM, GT, 00:00:00, <null>)
 5) (___MM, GT, 00:00:00, -2.00:00:00)
 6) (M_M_M, EQ, 00:00:00, 00:00:00)
 7) (_MM__, LT, 00:00:00, 3.00:00:00)
 8) (___MM, GT, 3.00:00:00, <null>)
 9) (___MM, GT, 3.00:00:00, -2.00:00:00)
10) (___MM, GT, 3.00:00:00, 00:00:00)
11) (M_M_M, EQ, 3.00:00:00, 3.00:00:00)
*** Ctx ping count: 4
    [0](4): ChainMap(*1: xt__, ForEach(*2: yt_q, (*1, *2)))
###
> G(xb_q, yb__) // Opt with Req (QR).
G(xb_q, yb__) : (s, s, b?, b)*
BndKind:Call, Type:(s, s, b?, b)*, Bnd:(Call(∂.ForEach([map:6] Call(∂.Test.Wrap(Call(∂.ForEach([map:3] Call(∂.Test.Wrap(Call(∂.ChainMap([map:1] Global(xb_q), Call(∂.ForEach([map:2] Global(yb__), (Scope(1), Scope(2)):(b?, b)):(b?, b)*)):(b?, b)*)):(b?, b)*), Call(∂.With([with:4] Call(∂.Test.Wrap(GetSlot(Scope(3), 0)):b?), [with:5] Call(∂.Test.Wrap(GetSlot(Scope(3), 1)):b), (Cmp(Scope(4) @= Scope(5)), Cmp(Scope(4) @< Scope(5)), Cmp(Scope(4) @<= Scope(5)), Cmp(Scope(4) @> Scope(5)), Cmp(Scope(4) @>= Scope(5)), Scope(4), Scope(5)):(b, b, b, b, b, b?, b)):(b, b, b, b, b, b?, b))):(b, b, b, b, b, b?, b)*)):(b, b, b, b, b, b?, b)*), Call(∂.With([with:7] StrConcat(If(GetSlot(Scope(6), 0), str(M), str(_)), If(GetSlot(Scope(6), 1), str(M), str(_)), If(GetSlot(Scope(6), 2), str(M), str(_)), If(GetSlot(Scope(6), 3), str(M), str(_)), If(GetSlot(Scope(6), 4), str(M), str(_))), TupleConcat((Scope(7), If(Cmp(Scope(7) @= str(_____)), str(__), If(Cmp(Scope(7) @= str(M_M_M)), str(EQ), If(Cmp(Scope(7) @= str(__M__)), str(LE), If(Cmp(Scope(7) @= str(_MM__)), str(LT), If(Cmp(Scope(7) @= str(____M)), str(GE), If(Cmp(Scope(7) @= str(___MM)), str(GT), If(Cmp(Scope(7) @= str(MMMMM)), str(N___), If(Cmp(Scope(7) @= str(_M_M_)), str(N_E_), If(Cmp(Scope(7) @= str(M__MM)), str(N_L_), If(Cmp(Scope(7) @= str(MMM__)), str(N_G_), If(Cmp(Scope(7) @= str(___M_)), str(N_EL), If(Cmp(Scope(7) @= str(_M___)), str(N_EG), If(Cmp(Scope(7) @= str(M____)), str(N_LG), str(***BAD!***))))))))))))))):(s, s), GetSlice(Scope(6), 5:7:1):(b?, b))):(s, s, b?, b))):(s, s, b?, b)*))
ForEach_1(Arr<obj>, (Opt<bool>,bool)):(bool,bool,bool,bool,bool,Opt<bool>,bool)
      1) ldarg.1 [(Opt<bool>,bool)]
      5) ldfld (Opt<bool>,bool)::_F0:Opt<bool>
      5) call static WrapFuncGen::Exec(Opt<bool>):Opt<bool>
      1) stloc.0 [Opt<bool>]
      1) ldarg.1 [(Opt<bool>,bool)]
      5) ldfld (Opt<bool>,bool)::_F1:bool
      5) call static WrapFuncGen::Exec(bool):bool
      1) stloc.1 [bool]
      5) newobj (bool,bool,bool,bool,bool,Opt<bool>,bool)()
      1) dup
      2) ldloca.s [Opt<bool> (0)]
      5) call Opt<bool>::get_HasValue():bool
      5) brfalse [0]
      2) ldloca.s [Opt<bool> (0)]
      5) call Opt<bool>::GetValueOrDefault():bool
      1) ldloc.1 [bool]
      2) ceq
      5) br [1]
  Label [0]:
      1) ldc.i4.0
  Label [1]:
      5) stfld (bool,bool,bool,bool,bool,Opt<bool>,bool)::_F0:bool
      1) dup
      2) ldloca.s [Opt<bool> (0)]
      5) call Opt<bool>::get_HasValue():bool
      5) brfalse [2]
      2) ldloca.s [Opt<bool> (0)]
      5) call Opt<bool>::GetValueOrDefault():bool
      1) ldloc.1 [bool]
      2) clt.un
      5) br [3]
  Label [2]:
      1) ldc.i4.1
  Label [3]:
      5) stfld (bool,bool,bool,bool,bool,Opt<bool>,bool)::_F1:bool
      1) dup
      2) ldloca.s [Opt<bool> (0)]
      5) call Opt<bool>::get_HasValue():bool
      5) brfalse [4]
      2) ldloca.s [Opt<bool> (0)]
      5) call Opt<bool>::GetValueOrDefault():bool
      1) ldloc.1 [bool]
      2) cgt.un
      1) ldc.i4.0
      2) ceq
      5) br [5]
  Label [4]:
      1) ldc.i4.1
  Label [5]:
      5) stfld (bool,bool,bool,bool,bool,Opt<bool>,bool)::_F2:bool
      1) dup
      2) ldloca.s [Opt<bool> (0)]
      5) call Opt<bool>::get_HasValue():bool
      5) brfalse [6]
      2) ldloca.s [Opt<bool> (0)]
      5) call Opt<bool>::GetValueOrDefault():bool
      1) ldloc.1 [bool]
      2) cgt.un
      5) br [7]
  Label [6]:
      1) ldc.i4.0
  Label [7]:
      5) stfld (bool,bool,bool,bool,bool,Opt<bool>,bool)::_F3:bool
      1) dup
      2) ldloca.s [Opt<bool> (0)]
      5) call Opt<bool>::get_HasValue():bool
      5) brfalse [8]
      2) ldloca.s [Opt<bool> (0)]
      5) call Opt<bool>::GetValueOrDefault():bool
      1) ldloc.1 [bool]
      2) clt.un
      1) ldc.i4.0
      2) ceq
      5) br [9]
  Label [8]:
      1) ldc.i4.0
  Label [9]:
      5) stfld (bool,bool,bool,bool,bool,Opt<bool>,bool)::_F4:bool
      1) dup
      1) ldloc.0 [Opt<bool>]
      5) stfld (bool,bool,bool,bool,bool,Opt<bool>,bool)::_F5:Opt<bool>
      1) dup
      1) ldloc.1 [bool]
      5) stfld (bool,bool,bool,bool,bool,Opt<bool>,bool)::_F6:bool
      1) ret
  Total Size: 220

Func sig: (<ctx>:x, xb_q:b?*, yb__:b*) to (s, s, b?, b)*
Sequence: Seq<(str,str,Opt<bool>,bool)>
 0) (_MM__, LT, <null>, false)
 1) (_MM__, LT, <null>, true )
 2) (M_M_M, EQ, false, false)
 3) (_MM__, LT, false, true )
 4) (___MM, GT, true , false)
 5) (M_M_M, EQ, true , true )
*** Ctx ping count: 4
    [0](4): ChainMap(*1: xb_q, ForEach(*2: yb__, (*1, *2)))
###
> G(xr8q, yr8_)
G(xr8q, yr8_) : (s, s, r8?, r8)*
BndKind:Call, Type:(s, s, r8?, r8)*, Bnd:(Call(∂.ForEach([map:6] Call(∂.Test.Wrap(Call(∂.ForEach([map:3] Call(∂.Test.Wrap(Call(∂.ChainMap([map:1] Global(xr8q), Call(∂.ForEach([map:2] Global(yr8_), (Scope(1), Scope(2)):(r8?, r8)):(r8?, r8)*)):(r8?, r8)*)):(r8?, r8)*), Call(∂.With([with:4] Call(∂.Test.Wrap(GetSlot(Scope(3), 0)):r8?), [with:5] Call(∂.Test.Wrap(GetSlot(Scope(3), 1)):r8), (Cmp(Scope(4) @= Scope(5)), Cmp(Scope(4) @< Scope(5)), Cmp(Scope(4) @<= Scope(5)), Cmp(Scope(4) @> Scope(5)), Cmp(Scope(4) @>= Scope(5)), Scope(4), Scope(5)):(b, b, b, b, b, r8?, r8)):(b, b, b, b, b, r8?, r8))):(b, b, b, b, b, r8?, r8)*)):(b, b, b, b, b, r8?, r8)*), Call(∂.With([with:7] StrConcat(If(GetSlot(Scope(6), 0), str(M), str(_)), If(GetSlot(Scope(6), 1), str(M), str(_)), If(GetSlot(Scope(6), 2), str(M), str(_)), If(GetSlot(Scope(6), 3), str(M), str(_)), If(GetSlot(Scope(6), 4), str(M), str(_))), TupleConcat((Scope(7), If(Cmp(Scope(7) @= str(_____)), str(__), If(Cmp(Scope(7) @= str(M_M_M)), str(EQ), If(Cmp(Scope(7) @= str(__M__)), str(LE), If(Cmp(Scope(7) @= str(_MM__)), str(LT), If(Cmp(Scope(7) @= str(____M)), str(GE), If(Cmp(Scope(7) @= str(___MM)), str(GT), If(Cmp(Scope(7) @= str(MMMMM)), str(N___), If(Cmp(Scope(7) @= str(_M_M_)), str(N_E_), If(Cmp(Scope(7) @= str(M__MM)), str(N_L_), If(Cmp(Scope(7) @= str(MMM__)), str(N_G_), If(Cmp(Scope(7) @= str(___M_)), str(N_EL), If(Cmp(Scope(7) @= str(_M___)), str(N_EG), If(Cmp(Scope(7) @= str(M____)), str(N_LG), str(***BAD!***))))))))))))))):(s, s), GetSlice(Scope(6), 5:7:1):(r8?, r8))):(s, s, r8?, r8))):(s, s, r8?, r8)*))
ForEach_1(Arr<obj>, (Opt<r8>,r8)):(bool,bool,bool,bool,bool,Opt<r8>,r8)
      1) ldarg.1 [(Opt<r8>,r8)]
      5) ldfld (Opt<r8>,r8)::_F0:Opt<r8>
      5) call static WrapFuncGen::Exec(Opt<r8>):Opt<r8>
      1) stloc.0 [Opt<r8>]
      1) ldarg.1 [(Opt<r8>,r8)]
      5) ldfld (Opt<r8>,r8)::_F1:r8
      5) call static WrapFuncGen::Exec(r8):r8
      1) stloc.1 [r8]
      5) newobj (bool,bool,bool,bool,bool,Opt<r8>,r8)()
      1) dup
      2) ldloca.s [Opt<r8> (0)]
      5) call Opt<r8>::get_HasValue():bool
      5) brfalse [0]
      2) ldloca.s [Opt<r8> (0)]
      5) call Opt<r8>::GetValueOrDefault():r8
      1) ldloc.1 [r8]
      5) call static NumUtil::Eq(r8, r8):bool
      5) br [1]
  Label [0]:
      1) ldc.i4.0
  Label [1]:
      5) stfld (bool,bool,bool,bool,bool,Opt<r8>,r8)::_F0:bool
      1) dup
      2) ldloca.s [Opt<r8> (0)]
      5) call Opt<r8>::get_HasValue():bool
      5) brfalse [2]
      2) ldloca.s [Opt<r8> (0)]
      5) call Opt<r8>::GetValueOrDefault():r8
      1) ldloc.1 [r8]
      5) call static NumUtil::Lt(r8, r8):bool
      5) br [3]
  Label [2]:
      1) ldc.i4.1
  Label [3]:
      5) stfld (bool,bool,bool,bool,bool,Opt<r8>,r8)::_F1:bool
      1) dup
      2) ldloca.s [Opt<r8> (0)]
      5) call Opt<r8>::get_HasValue():bool
      5) brfalse [4]
      2) ldloca.s [Opt<r8> (0)]
      5) call Opt<r8>::GetValueOrDefault():r8
      1) ldloc.1 [r8]
      5) call static NumUtil::Le(r8, r8):bool
      5) br [5]
  Label [4]:
      1) ldc.i4.1
  Label [5]:
      5) stfld (bool,bool,bool,bool,bool,Opt<r8>,r8)::_F2:bool
      1) dup
      2) ldloca.s [Opt<r8> (0)]
      5) call Opt<r8>::get_HasValue():bool
      5) brfalse [6]
      2) ldloca.s [Opt<r8> (0)]
      5) call Opt<r8>::GetValueOrDefault():r8
      1) ldloc.1 [r8]
      5) call static NumUtil::Gt(r8, r8):bool
      5) br [7]
  Label [6]:
      1) ldc.i4.0
  Label [7]:
      5) stfld (bool,bool,bool,bool,bool,Opt<r8>,r8)::_F3:bool
      1) dup
      2) ldloca.s [Opt<r8> (0)]
      5) call Opt<r8>::get_HasValue():bool
      5) brfalse [8]
      2) ldloca.s [Opt<r8> (0)]
      5) call Opt<r8>::GetValueOrDefault():r8
      1) ldloc.1 [r8]
      5) call static NumUtil::Ge(r8, r8):bool
      5) br [9]
  Label [8]:
      1) ldc.i4.0
  Label [9]:
      5) stfld (bool,bool,bool,bool,bool,Opt<r8>,r8)::_F4:bool
      1) dup
      1) ldloc.0 [Opt<r8>]
      5) stfld (bool,bool,bool,bool,bool,Opt<r8>,r8)::_F5:Opt<r8>
      1) dup
      1) ldloc.1 [r8]
      5) stfld (bool,bool,bool,bool,bool,Opt<r8>,r8)::_F6:r8
      1) ret
  Total Size: 229

Func sig: (<ctx>:x, xr8q:r8?*, yr8_:r8*) to (s, s, r8?, r8)*
Sequence: Seq<(str,str,Opt<r8>,r8)>
 0) (_MM__, LT, <null>, NaN)
 1) (_MM__, LT, <null>, -3)
 2) (_MM__, LT, <null>, 0)
 3) (_MM__, LT, <null>, 5)
 4) (M_M_M, EQ, NaN, NaN)
 5) (_MM__, LT, NaN, -3)
 6) (_MM__, LT, NaN, 0)
 7) (_MM__, LT, NaN, 5)
 8) (___MM, GT, -3, NaN)
 9) (M_M_M, EQ, -3, -3)
10) (_MM__, LT, -3, 0)
11) (_MM__, LT, -3, 5)
12) (___MM, GT, 0, NaN)
13) (___MM, GT, 0, -3)
14) (M_M_M, EQ, 0, 0)
15) (_MM__, LT, 0, 5)
16) (___MM, GT, 5, NaN)
17) (___MM, GT, 5, -3)
18) (___MM, GT, 5, 0)
19) (M_M_M, EQ, 5, 5)
*** Ctx ping count: 6
    [0](6): ChainMap(*1: xr8q, ForEach(*2: yr8_, (*1, *2)))
###
> G(xr4q, yr4_)
G(xr4q, yr4_) : (s, s, r4?, r4)*
BndKind:Call, Type:(s, s, r4?, r4)*, Bnd:(Call(∂.ForEach([map:6] Call(∂.Test.Wrap(Call(∂.ForEach([map:3] Call(∂.Test.Wrap(Call(∂.ChainMap([map:1] Global(xr4q), Call(∂.ForEach([map:2] Global(yr4_), (Scope(1), Scope(2)):(r4?, r4)):(r4?, r4)*)):(r4?, r4)*)):(r4?, r4)*), Call(∂.With([with:4] Call(∂.Test.Wrap(GetSlot(Scope(3), 0)):r4?), [with:5] Call(∂.Test.Wrap(GetSlot(Scope(3), 1)):r4), (Cmp(Scope(4) @= Scope(5)), Cmp(Scope(4) @< Scope(5)), Cmp(Scope(4) @<= Scope(5)), Cmp(Scope(4) @> Scope(5)), Cmp(Scope(4) @>= Scope(5)), Scope(4), Scope(5)):(b, b, b, b, b, r4?, r4)):(b, b, b, b, b, r4?, r4))):(b, b, b, b, b, r4?, r4)*)):(b, b, b, b, b, r4?, r4)*), Call(∂.With([with:7] StrConcat(If(GetSlot(Scope(6), 0), str(M), str(_)), If(GetSlot(Scope(6), 1), str(M), str(_)), If(GetSlot(Scope(6), 2), str(M), str(_)), If(GetSlot(Scope(6), 3), str(M), str(_)), If(GetSlot(Scope(6), 4), str(M), str(_))), TupleConcat((Scope(7), If(Cmp(Scope(7) @= str(_____)), str(__), If(Cmp(Scope(7) @= str(M_M_M)), str(EQ), If(Cmp(Scope(7) @= str(__M__)), str(LE), If(Cmp(Scope(7) @= str(_MM__)), str(LT), If(Cmp(Scope(7) @= str(____M)), str(GE), If(Cmp(Scope(7) @= str(___MM)), str(GT), If(Cmp(Scope(7) @= str(MMMMM)), str(N___), If(Cmp(Scope(7) @= str(_M_M_)), str(N_E_), If(Cmp(Scope(7) @= str(M__MM)), str(N_L_), If(Cmp(Scope(7) @= str(MMM__)), str(N_G_), If(Cmp(Scope(7) @= str(___M_)), str(N_EL), If(Cmp(Scope(7) @= str(_M___)), str(N_EG), If(Cmp(Scope(7) @= str(M____)), str(N_LG), str(***BAD!***))))))))))))))):(s, s), GetSlice(Scope(6), 5:7:1):(r4?, r4))):(s, s, r4?, r4))):(s, s, r4?, r4)*))
ForEach_1(Arr<obj>, (Opt<r4>,r4)):(bool,bool,bool,bool,bool,Opt<r4>,r4)
      1) ldarg.1 [(Opt<r4>,r4)]
      5) ldfld (Opt<r4>,r4)::_F0:Opt<r4>
      5) call static WrapFuncGen::Exec(Opt<r4>):Opt<r4>
      1) stloc.0 [Opt<r4>]
      1) ldarg.1 [(Opt<r4>,r4)]
      5) ldfld (Opt<r4>,r4)::_F1:r4
      5) call static WrapFuncGen::Exec(r4):r4
      1) stloc.1 [r4]
      5) newobj (bool,bool,bool,bool,bool,Opt<r4>,r4)()
      1) dup
      2) ldloca.s [Opt<r4> (0)]
      5) call Opt<r4>::get_HasValue():bool
      5) brfalse [0]
      2) ldloca.s [Opt<r4> (0)]
      5) call Opt<r4>::GetValueOrDefault():r4
      1) ldloc.1 [r4]
      5) call static NumUtil::Eq(r4, r4):bool
      5) br [1]
  Label [0]:
      1) ldc.i4.0
  Label [1]:
      5) stfld (bool,bool,bool,bool,bool,Opt<r4>,r4)::_F0:bool
      1) dup
      2) ldloca.s [Opt<r4> (0)]
      5) call Opt<r4>::get_HasValue():bool
      5) brfalse [2]
      2) ldloca.s [Opt<r4> (0)]
      5) call Opt<r4>::GetValueOrDefault():r4
      1) ldloc.1 [r4]
      5) call static NumUtil::Lt(r4, r4):bool
      5) br [3]
  Label [2]:
      1) ldc.i4.1
  Label [3]:
      5) stfld (bool,bool,bool,bool,bool,Opt<r4>,r4)::_F1:bool
      1) dup
      2) ldloca.s [Opt<r4> (0)]
      5) call Opt<r4>::get_HasValue():bool
      5) brfalse [4]
      2) ldloca.s [Opt<r4> (0)]
      5) call Opt<r4>::GetValueOrDefault():r4
      1) ldloc.1 [r4]
      5) call static NumUtil::Le(r4, r4):bool
      5) br [5]
  Label [4]:
      1) ldc.i4.1
  Label [5]:
      5) stfld (bool,bool,bool,bool,bool,Opt<r4>,r4)::_F2:bool
      1) dup
      2) ldloca.s [Opt<r4> (0)]
      5) call Opt<r4>::get_HasValue():bool
      5) brfalse [6]
      2) ldloca.s [Opt<r4> (0)]
      5) call Opt<r4>::GetValueOrDefault():r4
      1) ldloc.1 [r4]
      5) call static NumUtil::Gt(r4, r4):bool
      5) br [7]
  Label [6]:
      1) ldc.i4.0
  Label [7]:
      5) stfld (bool,bool,bool,bool,bool,Opt<r4>,r4)::_F3:bool
      1) dup
      2) ldloca.s [Opt<r4> (0)]
      5) call Opt<r4>::get_HasValue():bool
      5) brfalse [8]
      2) ldloca.s [Opt<r4> (0)]
      5) call Opt<r4>::GetValueOrDefault():r4
      1) ldloc.1 [r4]
      5) call static NumUtil::Ge(r4, r4):bool
      5) br [9]
  Label [8]:
      1) ldc.i4.0
  Label [9]:
      5) stfld (bool,bool,bool,bool,bool,Opt<r4>,r4)::_F4:bool
      1) dup
      1) ldloc.0 [Opt<r4>]
      5) stfld (bool,bool,bool,bool,bool,Opt<r4>,r4)::_F5:Opt<r4>
      1) dup
      1) ldloc.1 [r4]
      5) stfld (bool,bool,bool,bool,bool,Opt<r4>,r4)::_F6:r4
      1) ret
  Total Size: 229

Func sig: (<ctx>:x, xr4q:r4?*, yr4_:r4*) to (s, s, r4?, r4)*
Sequence: Seq<(str,str,Opt<r4>,r4)>
 0) (_MM__, LT, <null>, NaN)
 1) (_MM__, LT, <null>, -3)
 2) (_MM__, LT, <null>, 0)
 3) (_MM__, LT, <null>, 5)
 4) (M_M_M, EQ, NaN, NaN)
 5) (_MM__, LT, NaN, -3)
 6) (_MM__, LT, NaN, 0)
 7) (_MM__, LT, NaN, 5)
 8) (___MM, GT, -3, NaN)
 9) (M_M_M, EQ, -3, -3)
10) (_MM__, LT, -3, 0)
11) (_MM__, LT, -3, 5)
12) (___MM, GT, 0, NaN)
13) (___MM, GT, 0, -3)
14) (M_M_M, EQ, 0, 0)
15) (_MM__, LT, 0, 5)
16) (___MM, GT, 5, NaN)
17) (___MM, GT, 5, -3)
18) (___MM, GT, 5, 0)
19) (M_M_M, EQ, 5, 5)
*** Ctx ping count: 6
    [0](6): ChainMap(*1: xr4q, ForEach(*2: yr4_, (*1, *2)))
###
> G(xi_q, yi__)
G(xi_q, yi__) : (s, s, i?, i)*
BndKind:Call, Type:(s, s, i?, i)*, Bnd:(Call(∂.ForEach([map:6] Call(∂.Test.Wrap(Call(∂.ForEach([map:3] Call(∂.Test.Wrap(Call(∂.ChainMap([map:1] Global(xi_q), Call(∂.ForEach([map:2] Global(yi__), (Scope(1), Scope(2)):(i?, i)):(i?, i)*)):(i?, i)*)):(i?, i)*), Call(∂.With([with:4] Call(∂.Test.Wrap(GetSlot(Scope(3), 0)):i?), [with:5] Call(∂.Test.Wrap(GetSlot(Scope(3), 1)):i), (Cmp(Scope(4) @= Scope(5)), Cmp(Scope(4) @< Scope(5)), Cmp(Scope(4) @<= Scope(5)), Cmp(Scope(4) @> Scope(5)), Cmp(Scope(4) @>= Scope(5)), Scope(4), Scope(5)):(b, b, b, b, b, i?, i)):(b, b, b, b, b, i?, i))):(b, b, b, b, b, i?, i)*)):(b, b, b, b, b, i?, i)*), Call(∂.With([with:7] StrConcat(If(GetSlot(Scope(6), 0), str(M), str(_)), If(GetSlot(Scope(6), 1), str(M), str(_)), If(GetSlot(Scope(6), 2), str(M), str(_)), If(GetSlot(Scope(6), 3), str(M), str(_)), If(GetSlot(Scope(6), 4), str(M), str(_))), TupleConcat((Scope(7), If(Cmp(Scope(7) @= str(_____)), str(__), If(Cmp(Scope(7) @= str(M_M_M)), str(EQ), If(Cmp(Scope(7) @= str(__M__)), str(LE), If(Cmp(Scope(7) @= str(_MM__)), str(LT), If(Cmp(Scope(7) @= str(____M)), str(GE), If(Cmp(Scope(7) @= str(___MM)), str(GT), If(Cmp(Scope(7) @= str(MMMMM)), str(N___), If(Cmp(Scope(7) @= str(_M_M_)), str(N_E_), If(Cmp(Scope(7) @= str(M__MM)), str(N_L_), If(Cmp(Scope(7) @= str(MMM__)), str(N_G_), If(Cmp(Scope(7) @= str(___M_)), str(N_EL), If(Cmp(Scope(7) @= str(_M___)), str(N_EG), If(Cmp(Scope(7) @= str(M____)), str(N_LG), str(***BAD!***))))))))))))))):(s, s), GetSlice(Scope(6), 5:7:1):(i?, i))):(s, s, i?, i))):(s, s, i?, i)*))
ForEach_1(Arr<obj>, (Opt<ia>,ia)):(bool,bool,bool,bool,bool,Opt<ia>,ia)
      1) ldarg.1 [(Opt<ia>,ia)]
      5) ldfld (Opt<ia>,ia)::_F0:Opt<ia>
      5) call static WrapFuncGen::Exec(Opt<ia>):Opt<ia>
      1) stloc.0 [Opt<ia>]
      1) ldarg.1 [(Opt<ia>,ia)]
      5) ldfld (Opt<ia>,ia)::_F1:ia
      5) call static WrapFuncGen::Exec(ia):ia
      1) stloc.1 [ia]
      5) newobj (bool,bool,bool,bool,bool,Opt<ia>,ia)()
      1) dup
      2) ldloca.s [Opt<ia> (0)]
      5) call Opt<ia>::get_HasValue():bool
      5) brfalse [0]
      2) ldloca.s [Opt<ia> (0)]
      5) call Opt<ia>::GetValueOrDefault():ia
      1) ldloc.1 [ia]
      5) call static ia::op_Equality(ia, ia):bool
      5) br [1]
  Label [0]:
      1) ldc.i4.0
  Label [1]:
      5) stfld (bool,bool,bool,bool,bool,Opt<ia>,ia)::_F0:bool
      1) dup
      2) ldloca.s [Opt<ia> (0)]
      5) call Opt<ia>::get_HasValue():bool
      5) brfalse [2]
      2) ldloca.s [Opt<ia> (0)]
      5) call Opt<ia>::GetValueOrDefault():ia
      1) ldloc.1 [ia]
      5) call static ia::op_LessThan(ia, ia):bool
      5) br [3]
  Label [2]:
      1) ldc.i4.1
  Label [3]:
      5) stfld (bool,bool,bool,bool,bool,Opt<ia>,ia)::_F1:bool
      1) dup
      2) ldloca.s [Opt<ia> (0)]
      5) call Opt<ia>::get_HasValue():bool
      5) brfalse [4]
      2) ldloca.s [Opt<ia> (0)]
      5) call Opt<ia>::GetValueOrDefault():ia
      1) ldloc.1 [ia]
      5) call static ia::op_LessThanOrEqual(ia, ia):bool
      5) br [5]
  Label [4]:
      1) ldc.i4.1
  Label [5]:
      5) stfld (bool,bool,bool,bool,bool,Opt<ia>,ia)::_F2:bool
      1) dup
      2) ldloca.s [Opt<ia> (0)]
      5) call Opt<ia>::get_HasValue():bool
      5) brfalse [6]
      2) ldloca.s [Opt<ia> (0)]
      5) call Opt<ia>::GetValueOrDefault():ia
      1) ldloc.1 [ia]
      5) call static ia::op_GreaterThan(ia, ia):bool
      5) br [7]
  Label [6]:
      1) ldc.i4.0
  Label [7]:
      5) stfld (bool,bool,bool,bool,bool,Opt<ia>,ia)::_F3:bool
      1) dup
      2) ldloca.s [Opt<ia> (0)]
      5) call Opt<ia>::get_HasValue():bool
      5) brfalse [8]
      2) ldloca.s [Opt<ia> (0)]
      5) call Opt<ia>::GetValueOrDefault():ia
      1) ldloc.1 [ia]
      5) call static ia::op_GreaterThanOrEqual(ia, ia):bool
      5) br [9]
  Label [8]:
      1) ldc.i4.0
  Label [9]:
      5) stfld (bool,bool,bool,bool,bool,Opt<ia>,ia)::_F4:bool
      1) dup
      1) ldloc.0 [Opt<ia>]
      5) stfld (bool,bool,bool,bool,bool,Opt<ia>,ia)::_F5:Opt<ia>
      1) dup
      1) ldloc.1 [ia]
      5) stfld (bool,bool,bool,bool,bool,Opt<ia>,ia)::_F6:ia
      1) ret
  Total Size: 229

Func sig: (<ctx>:x, xi_q:i?*, yi__:i*) to (s, s, i?, i)*
Sequence: Seq<(str,str,Opt<ia>,ia)>
 0) (_MM__, LT, <null>, -3)
 1) (_MM__, LT, <null>, 0)
 2) (_MM__, LT, <null>, 5)
 3) (M_M_M, EQ, -3, -3)
 4) (_MM__, LT, -3, 0)
 5) (_MM__, LT, -3, 5)
 6) (___MM, GT, 0, -3)
 7) (M_M_M, EQ, 0, 0)
 8) (_MM__, LT, 0, 5)
 9) (___MM, GT, 5, -3)
10) (___MM, GT, 5, 0)
11) (M_M_M, EQ, 5, 5)
*** Ctx ping count: 5
    [0](5): ChainMap(*1: xi_q, ForEach(*2: yi__, (*1, *2)))
###
> G(xi2q, yi2_)
G(xi2q, yi2_) : (s, s, i2?, i2)*
BndKind:Call, Type:(s, s, i2?, i2)*, Bnd:(Call(∂.ForEach([map:6] Call(∂.Test.Wrap(Call(∂.ForEach([map:3] Call(∂.Test.Wrap(Call(∂.ChainMap([map:1] Global(xi2q), Call(∂.ForEach([map:2] Global(yi2_), (Scope(1), Scope(2)):(i2?, i2)):(i2?, i2)*)):(i2?, i2)*)):(i2?, i2)*), Call(∂.With([with:4] Call(∂.Test.Wrap(GetSlot(Scope(3), 0)):i2?), [with:5] Call(∂.Test.Wrap(GetSlot(Scope(3), 1)):i2), (Cmp(Scope(4) @= Scope(5)), Cmp(Scope(4) @< Scope(5)), Cmp(Scope(4) @<= Scope(5)), Cmp(Scope(4) @> Scope(5)), Cmp(Scope(4) @>= Scope(5)), Scope(4), Scope(5)):(b, b, b, b, b, i2?, i2)):(b, b, b, b, b, i2?, i2))):(b, b, b, b, b, i2?, i2)*)):(b, b, b, b, b, i2?, i2)*), Call(∂.With([with:7] StrConcat(If(GetSlot(Scope(6), 0), str(M), str(_)), If(GetSlot(Scope(6), 1), str(M), str(_)), If(GetSlot(Scope(6), 2), str(M), str(_)), If(GetSlot(Scope(6), 3), str(M), str(_)), If(GetSlot(Scope(6), 4), str(M), str(_))), TupleConcat((Scope(7), If(Cmp(Scope(7) @= str(_____)), str(__), If(Cmp(Scope(7) @= str(M_M_M)), str(EQ), If(Cmp(Scope(7) @= str(__M__)), str(LE), If(Cmp(Scope(7) @= str(_MM__)), str(LT), If(Cmp(Scope(7) @= str(____M)), str(GE), If(Cmp(Scope(7) @= str(___MM)), str(GT), If(Cmp(Scope(7) @= str(MMMMM)), str(N___), If(Cmp(Scope(7) @= str(_M_M_)), str(N_E_), If(Cmp(Scope(7) @= str(M__MM)), str(N_L_), If(Cmp(Scope(7) @= str(MMM__)), str(N_G_), If(Cmp(Scope(7) @= str(___M_)), str(N_EL), If(Cmp(Scope(7) @= str(_M___)), str(N_EG), If(Cmp(Scope(7) @= str(M____)), str(N_LG), str(***BAD!***))))))))))))))):(s, s), GetSlice(Scope(6), 5:7:1):(i2?, i2))):(s, s, i2?, i2))):(s, s, i2?, i2)*))
ForEach_1(Arr<obj>, (Opt<i2>,i2)):(bool,bool,bool,bool,bool,Opt<i2>,i2)
      1) ldarg.1 [(Opt<i2>,i2)]
      5) ldfld (Opt<i2>,i2)::_F0:Opt<i2>
      5) call static WrapFuncGen::Exec(Opt<i2>):Opt<i2>
      1) stloc.0 [Opt<i2>]
      1) ldarg.1 [(Opt<i2>,i2)]
      5) ldfld (Opt<i2>,i2)::_F1:i2
      5) call static WrapFuncGen::Exec(i2):i2
      1) stloc.1 [i2]
      5) newobj (bool,bool,bool,bool,bool,Opt<i2>,i2)()
      1) dup
      2) ldloca.s [Opt<i2> (0)]
      5) call Opt<i2>::get_HasValue():bool
      5) brfalse [0]
      2) ldloca.s [Opt<i2> (0)]
      5) call Opt<i2>::GetValueOrDefault():i2
      1) ldloc.1 [i2]
      2) ceq
      5) br [1]
  Label [0]:
      1) ldc.i4.0
  Label [1]:
      5) stfld (bool,bool,bool,bool,bool,Opt<i2>,i2)::_F0:bool
      1) dup
      2) ldloca.s [Opt<i2> (0)]
      5) call Opt<i2>::get_HasValue():bool
      5) brfalse [2]
      2) ldloca.s [Opt<i2> (0)]
      5) call Opt<i2>::GetValueOrDefault():i2
      1) ldloc.1 [i2]
      2) clt
      5) br [3]
  Label [2]:
      1) ldc.i4.1
  Label [3]:
      5) stfld (bool,bool,bool,bool,bool,Opt<i2>,i2)::_F1:bool
      1) dup
      2) ldloca.s [Opt<i2> (0)]
      5) call Opt<i2>::get_HasValue():bool
      5) brfalse [4]
      2) ldloca.s [Opt<i2> (0)]
      5) call Opt<i2>::GetValueOrDefault():i2
      1) ldloc.1 [i2]
      2) cgt
      1) ldc.i4.0
      2) ceq
      5) br [5]
  Label [4]:
      1) ldc.i4.1
  Label [5]:
      5) stfld (bool,bool,bool,bool,bool,Opt<i2>,i2)::_F2:bool
      1) dup
      2) ldloca.s [Opt<i2> (0)]
      5) call Opt<i2>::get_HasValue():bool
      5) brfalse [6]
      2) ldloca.s [Opt<i2> (0)]
      5) call Opt<i2>::GetValueOrDefault():i2
      1) ldloc.1 [i2]
      2) cgt
      5) br [7]
  Label [6]:
      1) ldc.i4.0
  Label [7]:
      5) stfld (bool,bool,bool,bool,bool,Opt<i2>,i2)::_F3:bool
      1) dup
      2) ldloca.s [Opt<i2> (0)]
      5) call Opt<i2>::get_HasValue():bool
      5) brfalse [8]
      2) ldloca.s [Opt<i2> (0)]
      5) call Opt<i2>::GetValueOrDefault():i2
      1) ldloc.1 [i2]
      2) clt
      1) ldc.i4.0
      2) ceq
      5) br [9]
  Label [8]:
      1) ldc.i4.0
  Label [9]:
      5) stfld (bool,bool,bool,bool,bool,Opt<i2>,i2)::_F4:bool
      1) dup
      1) ldloc.0 [Opt<i2>]
      5) stfld (bool,bool,bool,bool,bool,Opt<i2>,i2)::_F5:Opt<i2>
      1) dup
      1) ldloc.1 [i2]
      5) stfld (bool,bool,bool,bool,bool,Opt<i2>,i2)::_F6:i2
      1) ret
  Total Size: 220

Func sig: (<ctx>:x, xi2q:i2?*, yi2_:i2*) to (s, s, i2?, i2)*
Sequence: Seq<(str,str,Opt<i2>,i2)>
 0) (_MM__, LT, <null>, -3)
 1) (_MM__, LT, <null>, 0)
 2) (_MM__, LT, <null>, 5)
 3) (M_M_M, EQ, -3, -3)
 4) (_MM__, LT, -3, 0)
 5) (_MM__, LT, -3, 5)
 6) (___MM, GT, 0, -3)
 7) (M_M_M, EQ, 0, 0)
 8) (_MM__, LT, 0, 5)
 9) (___MM, GT, 5, -3)
10) (___MM, GT, 5, 0)
11) (M_M_M, EQ, 5, 5)
*** Ctx ping count: 5
    [0](5): ChainMap(*1: xi2q, ForEach(*2: yi2_, (*1, *2)))
###
> G(xu4q, yu4_)
G(xu4q, yu4_) : (s, s, u4?, u4)*
BndKind:Call, Type:(s, s, u4?, u4)*, Bnd:(Call(∂.ForEach([map:6] Call(∂.Test.Wrap(Call(∂.ForEach([map:3] Call(∂.Test.Wrap(Call(∂.ChainMap([map:1] Global(xu4q), Call(∂.ForEach([map:2] Global(yu4_), (Scope(1), Scope(2)):(u4?, u4)):(u4?, u4)*)):(u4?, u4)*)):(u4?, u4)*), Call(∂.With([with:4] Call(∂.Test.Wrap(GetSlot(Scope(3), 0)):u4?), [with:5] Call(∂.Test.Wrap(GetSlot(Scope(3), 1)):u4), (Cmp(Scope(4) @= Scope(5)), Cmp(Scope(4) @< Scope(5)), Cmp(Scope(4) @<= Scope(5)), Cmp(Scope(4) @> Scope(5)), Cmp(Scope(4) @>= Scope(5)), Scope(4), Scope(5)):(b, b, b, b, b, u4?, u4)):(b, b, b, b, b, u4?, u4))):(b, b, b, b, b, u4?, u4)*)):(b, b, b, b, b, u4?, u4)*), Call(∂.With([with:7] StrConcat(If(GetSlot(Scope(6), 0), str(M), str(_)), If(GetSlot(Scope(6), 1), str(M), str(_)), If(GetSlot(Scope(6), 2), str(M), str(_)), If(GetSlot(Scope(6), 3), str(M), str(_)), If(GetSlot(Scope(6), 4), str(M), str(_))), TupleConcat((Scope(7), If(Cmp(Scope(7) @= str(_____)), str(__), If(Cmp(Scope(7) @= str(M_M_M)), str(EQ), If(Cmp(Scope(7) @= str(__M__)), str(LE), If(Cmp(Scope(7) @= str(_MM__)), str(LT), If(Cmp(Scope(7) @= str(____M)), str(GE), If(Cmp(Scope(7) @= str(___MM)), str(GT), If(Cmp(Scope(7) @= str(MMMMM)), str(N___), If(Cmp(Scope(7) @= str(_M_M_)), str(N_E_), If(Cmp(Scope(7) @= str(M__MM)), str(N_L_), If(Cmp(Scope(7) @= str(MMM__)), str(N_G_), If(Cmp(Scope(7) @= str(___M_)), str(N_EL), If(Cmp(Scope(7) @= str(_M___)), str(N_EG), If(Cmp(Scope(7) @= str(M____)), str(N_LG), str(***BAD!***))))))))))))))):(s, s), GetSlice(Scope(6), 5:7:1):(u4?, u4))):(s, s, u4?, u4))):(s, s, u4?, u4)*))
ForEach_1(Arr<obj>, (Opt<u4>,u4)):(bool,bool,bool,bool,bool,Opt<u4>,u4)
      1) ldarg.1 [(Opt<u4>,u4)]
      5) ldfld (Opt<u4>,u4)::_F0:Opt<u4>
      5) call static WrapFuncGen::Exec(Opt<u4>):Opt<u4>
      1) stloc.0 [Opt<u4>]
      1) ldarg.1 [(Opt<u4>,u4)]
      5) ldfld (Opt<u4>,u4)::_F1:u4
      5) call static WrapFuncGen::Exec(u4):u4
      1) stloc.1 [u4]
      5) newobj (bool,bool,bool,bool,bool,Opt<u4>,u4)()
      1) dup
      2) ldloca.s [Opt<u4> (0)]
      5) call Opt<u4>::get_HasValue():bool
      5) brfalse [0]
      2) ldloca.s [Opt<u4> (0)]
      5) call Opt<u4>::GetValueOrDefault():u4
      1) ldloc.1 [u4]
      2) ceq
      5) br [1]
  Label [0]:
      1) ldc.i4.0
  Label [1]:
      5) stfld (bool,bool,bool,bool,bool,Opt<u4>,u4)::_F0:bool
      1) dup
      2) ldloca.s [Opt<u4> (0)]
      5) call Opt<u4>::get_HasValue():bool
      5) brfalse [2]
      2) ldloca.s [Opt<u4> (0)]
      5) call Opt<u4>::GetValueOrDefault():u4
      1) ldloc.1 [u4]
      2) clt.un
      5) br [3]
  Label [2]:
      1) ldc.i4.1
  Label [3]:
      5) stfld (bool,bool,bool,bool,bool,Opt<u4>,u4)::_F1:bool
      1) dup
      2) ldloca.s [Opt<u4> (0)]
      5) call Opt<u4>::get_HasValue():bool
      5) brfalse [4]
      2) ldloca.s [Opt<u4> (0)]
      5) call Opt<u4>::GetValueOrDefault():u4
      1) ldloc.1 [u4]
      2) cgt.un
      1) ldc.i4.0
      2) ceq
      5) br [5]
  Label [4]:
      1) ldc.i4.1
  Label [5]:
      5) stfld (bool,bool,bool,bool,bool,Opt<u4>,u4)::_F2:bool
      1) dup
      2) ldloca.s [Opt<u4> (0)]
      5) call Opt<u4>::get_HasValue():bool
      5) brfalse [6]
      2) ldloca.s [Opt<u4> (0)]
      5) call Opt<u4>::GetValueOrDefault():u4
      1) ldloc.1 [u4]
      2) cgt.un
      5) br [7]
  Label [6]:
      1) ldc.i4.0
  Label [7]:
      5) stfld (bool,bool,bool,bool,bool,Opt<u4>,u4)::_F3:bool
      1) dup
      2) ldloca.s [Opt<u4> (0)]
      5) call Opt<u4>::get_HasValue():bool
      5) brfalse [8]
      2) ldloca.s [Opt<u4> (0)]
      5) call Opt<u4>::GetValueOrDefault():u4
      1) ldloc.1 [u4]
      2) clt.un
      1) ldc.i4.0
      2) ceq
      5) br [9]
  Label [8]:
      1) ldc.i4.0
  Label [9]:
      5) stfld (bool,bool,bool,bool,bool,Opt<u4>,u4)::_F4:bool
      1) dup
      1) ldloc.0 [Opt<u4>]
      5) stfld (bool,bool,bool,bool,bool,Opt<u4>,u4)::_F5:Opt<u4>
      1) dup
      1) ldloc.1 [u4]
      5) stfld (bool,bool,bool,bool,bool,Opt<u4>,u4)::_F6:u4
      1) ret
  Total Size: 220

Func sig: (<ctx>:x, xu4q:u4?*, yu4_:u4*) to (s, s, u4?, u4)*
Sequence: Seq<(str,str,Opt<u4>,u4)>
 0) (_MM__, LT, <null>, 0)
 1) (_MM__, LT, <null>, 3)
 2) (_MM__, LT, <null>, 5)
 3) (M_M_M, EQ, 0, 0)
 4) (_MM__, LT, 0, 3)
 5) (_MM__, LT, 0, 5)
 6) (___MM, GT, 3, 0)
 7) (M_M_M, EQ, 3, 3)
 8) (_MM__, LT, 3, 5)
 9) (___MM, GT, 5, 0)
10) (___MM, GT, 5, 3)
11) (M_M_M, EQ, 5, 5)
*** Ctx ping count: 5
    [0](5): ChainMap(*1: xu4q, ForEach(*2: yu4_, (*1, *2)))
###
> G(xd_q, yd__)
G(xd_q, yd__) : (s, s, d?, d)*
BndKind:Call, Type:(s, s, d?, d)*, Bnd:(Call(∂.ForEach([map:6] Call(∂.Test.Wrap(Call(∂.ForEach([map:3] Call(∂.Test.Wrap(Call(∂.ChainMap([map:1] Global(xd_q), Call(∂.ForEach([map:2] Global(yd__), (Scope(1), Scope(2)):(d?, d)):(d?, d)*)):(d?, d)*)):(d?, d)*), Call(∂.With([with:4] Call(∂.Test.Wrap(GetSlot(Scope(3), 0)):d?), [with:5] Call(∂.Test.Wrap(GetSlot(Scope(3), 1)):d), (Cmp(Scope(4) @= Scope(5)), Cmp(Scope(4) @< Scope(5)), Cmp(Scope(4) @<= Scope(5)), Cmp(Scope(4) @> Scope(5)), Cmp(Scope(4) @>= Scope(5)), Scope(4), Scope(5)):(b, b, b, b, b, d?, d)):(b, b, b, b, b, d?, d))):(b, b, b, b, b, d?, d)*)):(b, b, b, b, b, d?, d)*), Call(∂.With([with:7] StrConcat(If(GetSlot(Scope(6), 0), str(M), str(_)), If(GetSlot(Scope(6), 1), str(M), str(_)), If(GetSlot(Scope(6), 2), str(M), str(_)), If(GetSlot(Scope(6), 3), str(M), str(_)), If(GetSlot(Scope(6), 4), str(M), str(_))), TupleConcat((Scope(7), If(Cmp(Scope(7) @= str(_____)), str(__), If(Cmp(Scope(7) @= str(M_M_M)), str(EQ), If(Cmp(Scope(7) @= str(__M__)), str(LE), If(Cmp(Scope(7) @= str(_MM__)), str(LT), If(Cmp(Scope(7) @= str(____M)), str(GE), If(Cmp(Scope(7) @= str(___MM)), str(GT), If(Cmp(Scope(7) @= str(MMMMM)), str(N___), If(Cmp(Scope(7) @= str(_M_M_)), str(N_E_), If(Cmp(Scope(7) @= str(M__MM)), str(N_L_), If(Cmp(Scope(7) @= str(MMM__)), str(N_G_), If(Cmp(Scope(7) @= str(___M_)), str(N_EL), If(Cmp(Scope(7) @= str(_M___)), str(N_EG), If(Cmp(Scope(7) @= str(M____)), str(N_LG), str(***BAD!***))))))))))))))):(s, s), GetSlice(Scope(6), 5:7:1):(d?, d))):(s, s, d?, d))):(s, s, d?, d)*))
ForEach_1(Arr<obj>, (Opt<Date>,Date)):(bool,bool,bool,bool,bool,Opt<Date>,Date)
      1) ldarg.1 [(Opt<Date>,Date)]
      5) ldfld (Opt<Date>,Date)::_F0:Opt<Date>
      5) call static WrapFuncGen::Exec(Opt<Date>):Opt<Date>
      1) stloc.0 [Opt<Date>]
      1) ldarg.1 [(Opt<Date>,Date)]
      5) ldfld (Opt<Date>,Date)::_F1:Date
      5) call static WrapFuncGen::Exec(Date):Date
      1) stloc.1 [Date]
      5) newobj (bool,bool,bool,bool,bool,Opt<Date>,Date)()
      1) dup
      2) ldloca.s [Opt<Date> (0)]
      5) call Opt<Date>::get_HasValue():bool
      5) brfalse [0]
      2) ldloca.s [Opt<Date> (0)]
      5) call Opt<Date>::GetValueOrDefault():Date
      1) ldloc.1 [Date]
      5) call static Date::op_Equality(Date, Date):bool
      5) br [1]
  Label [0]:
      1) ldc.i4.0
  Label [1]:
      5) stfld (bool,bool,bool,bool,bool,Opt<Date>,Date)::_F0:bool
      1) dup
      2) ldloca.s [Opt<Date> (0)]
      5) call Opt<Date>::get_HasValue():bool
      5) brfalse [2]
      2) ldloca.s [Opt<Date> (0)]
      5) call Opt<Date>::GetValueOrDefault():Date
      1) ldloc.1 [Date]
      5) call static Date::op_LessThan(Date, Date):bool
      5) br [3]
  Label [2]:
      1) ldc.i4.1
  Label [3]:
      5) stfld (bool,bool,bool,bool,bool,Opt<Date>,Date)::_F1:bool
      1) dup
      2) ldloca.s [Opt<Date> (0)]
      5) call Opt<Date>::get_HasValue():bool
      5) brfalse [4]
      2) ldloca.s [Opt<Date> (0)]
      5) call Opt<Date>::GetValueOrDefault():Date
      1) ldloc.1 [Date]
      5) call static Date::op_LessThanOrEqual(Date, Date):bool
      5) br [5]
  Label [4]:
      1) ldc.i4.1
  Label [5]:
      5) stfld (bool,bool,bool,bool,bool,Opt<Date>,Date)::_F2:bool
      1) dup
      2) ldloca.s [Opt<Date> (0)]
      5) call Opt<Date>::get_HasValue():bool
      5) brfalse [6]
      2) ldloca.s [Opt<Date> (0)]
      5) call Opt<Date>::GetValueOrDefault():Date
      1) ldloc.1 [Date]
      5) call static Date::op_GreaterThan(Date, Date):bool
      5) br [7]
  Label [6]:
      1) ldc.i4.0
  Label [7]:
      5) stfld (bool,bool,bool,bool,bool,Opt<Date>,Date)::_F3:bool
      1) dup
      2) ldloca.s [Opt<Date> (0)]
      5) call Opt<Date>::get_HasValue():bool
      5) brfalse [8]
      2) ldloca.s [Opt<Date> (0)]
      5) call Opt<Date>::GetValueOrDefault():Date
      1) ldloc.1 [Date]
      5) call static Date::op_GreaterThanOrEqual(Date, Date):bool
      5) br [9]
  Label [8]:
      1) ldc.i4.0
  Label [9]:
      5) stfld (bool,bool,bool,bool,bool,Opt<Date>,Date)::_F4:bool
      1) dup
      1) ldloc.0 [Opt<Date>]
      5) stfld (bool,bool,bool,bool,bool,Opt<Date>,Date)::_F5:Opt<Date>
      1) dup
      1) ldloc.1 [Date]
      5) stfld (bool,bool,bool,bool,bool,Opt<Date>,Date)::_F6:Date
      1) ret
  Total Size: 229

Func sig: (<ctx>:x, xd_q:d?*, yd__:d*) to (s, s, d?, d)*
Sequence: Seq<(str,str,Opt<Date>,Date)>
 0) (_MM__, LT, <null>, DT(1900, 1, 1, 0, 0, 0, 0))
 1) (_MM__, LT, <null>, DT(2023, 7, 1, 0, 0, 0, 0))
 2) (_MM__, LT, <null>, DT(2023, 9, 1, 0, 0, 0, 0))
 3) (M_M_M, EQ, DT(1900, 1, 1, 0, 0, 0, 0), DT(1900, 1, 1, 0, 0, 0, 0))
 4) (_MM__, LT, DT(1900, 1, 1, 0, 0, 0, 0), DT(2023, 7, 1, 0, 0, 0, 0))
 5) (_MM__, LT, DT(1900, 1, 1, 0, 0, 0, 0), DT(2023, 9, 1, 0, 0, 0, 0))
 6) (___MM, GT, DT(2023, 7, 1, 0, 0, 0, 0), DT(1900, 1, 1, 0, 0, 0, 0))
 7) (M_M_M, EQ, DT(2023, 7, 1, 0, 0, 0, 0), DT(2023, 7, 1, 0, 0, 0, 0))
 8) (_MM__, LT, DT(2023, 7, 1, 0, 0, 0, 0), DT(2023, 9, 1, 0, 0, 0, 0))
 9) (___MM, GT, DT(2023, 9, 1, 0, 0, 0, 0), DT(1900, 1, 1, 0, 0, 0, 0))
10) (___MM, GT, DT(2023, 9, 1, 0, 0, 0, 0), DT(2023, 7, 1, 0, 0, 0, 0))
11) (M_M_M, EQ, DT(2023, 9, 1, 0, 0, 0, 0), DT(2023, 9, 1, 0, 0, 0, 0))
*** Ctx ping count: 5
    [0](5): ChainMap(*1: xd_q, ForEach(*2: yd__, (*1, *2)))
###
> G(xt_q, yt__)
G(xt_q, yt__) : (s, s, t?, t)*
BndKind:Call, Type:(s, s, t?, t)*, Bnd:(Call(∂.ForEach([map:6] Call(∂.Test.Wrap(Call(∂.ForEach([map:3] Call(∂.Test.Wrap(Call(∂.ChainMap([map:1] Global(xt_q), Call(∂.ForEach([map:2] Global(yt__), (Scope(1), Scope(2)):(t?, t)):(t?, t)*)):(t?, t)*)):(t?, t)*), Call(∂.With([with:4] Call(∂.Test.Wrap(GetSlot(Scope(3), 0)):t?), [with:5] Call(∂.Test.Wrap(GetSlot(Scope(3), 1)):t), (Cmp(Scope(4) @= Scope(5)), Cmp(Scope(4) @< Scope(5)), Cmp(Scope(4) @<= Scope(5)), Cmp(Scope(4) @> Scope(5)), Cmp(Scope(4) @>= Scope(5)), Scope(4), Scope(5)):(b, b, b, b, b, t?, t)):(b, b, b, b, b, t?, t))):(b, b, b, b, b, t?, t)*)):(b, b, b, b, b, t?, t)*), Call(∂.With([with:7] StrConcat(If(GetSlot(Scope(6), 0), str(M), str(_)), If(GetSlot(Scope(6), 1), str(M), str(_)), If(GetSlot(Scope(6), 2), str(M), str(_)), If(GetSlot(Scope(6), 3), str(M), str(_)), If(GetSlot(Scope(6), 4), str(M), str(_))), TupleConcat((Scope(7), If(Cmp(Scope(7) @= str(_____)), str(__), If(Cmp(Scope(7) @= str(M_M_M)), str(EQ), If(Cmp(Scope(7) @= str(__M__)), str(LE), If(Cmp(Scope(7) @= str(_MM__)), str(LT), If(Cmp(Scope(7) @= str(____M)), str(GE), If(Cmp(Scope(7) @= str(___MM)), str(GT), If(Cmp(Scope(7) @= str(MMMMM)), str(N___), If(Cmp(Scope(7) @= str(_M_M_)), str(N_E_), If(Cmp(Scope(7) @= str(M__MM)), str(N_L_), If(Cmp(Scope(7) @= str(MMM__)), str(N_G_), If(Cmp(Scope(7) @= str(___M_)), str(N_EL), If(Cmp(Scope(7) @= str(_M___)), str(N_EG), If(Cmp(Scope(7) @= str(M____)), str(N_LG), str(***BAD!***))))))))))))))):(s, s), GetSlice(Scope(6), 5:7:1):(t?, t))):(s, s, t?, t))):(s, s, t?, t)*))
ForEach_1(Arr<obj>, (Opt<Time>,Time)):(bool,bool,bool,bool,bool,Opt<Time>,Time)
      1) ldarg.1 [(Opt<Time>,Time)]
      5) ldfld (Opt<Time>,Time)::_F0:Opt<Time>
      5) call static WrapFuncGen::Exec(Opt<Time>):Opt<Time>
      1) stloc.0 [Opt<Time>]
      1) ldarg.1 [(Opt<Time>,Time)]
      5) ldfld (Opt<Time>,Time)::_F1:Time
      5) call static WrapFuncGen::Exec(Time):Time
      1) stloc.1 [Time]
      5) newobj (bool,bool,bool,bool,bool,Opt<Time>,Time)()
      1) dup
      2) ldloca.s [Opt<Time> (0)]
      5) call Opt<Time>::get_HasValue():bool
      5) brfalse [0]
      2) ldloca.s [Opt<Time> (0)]
      5) call Opt<Time>::GetValueOrDefault():Time
      1) ldloc.1 [Time]
      5) call static Time::op_Equality(Time, Time):bool
      5) br [1]
  Label [0]:
      1) ldc.i4.0
  Label [1]:
      5) stfld (bool,bool,bool,bool,bool,Opt<Time>,Time)::_F0:bool
      1) dup
      2) ldloca.s [Opt<Time> (0)]
      5) call Opt<Time>::get_HasValue():bool
      5) brfalse [2]
      2) ldloca.s [Opt<Time> (0)]
      5) call Opt<Time>::GetValueOrDefault():Time
      1) ldloc.1 [Time]
      5) call static Time::op_LessThan(Time, Time):bool
      5) br [3]
  Label [2]:
      1) ldc.i4.1
  Label [3]:
      5) stfld (bool,bool,bool,bool,bool,Opt<Time>,Time)::_F1:bool
      1) dup
      2) ldloca.s [Opt<Time> (0)]
      5) call Opt<Time>::get_HasValue():bool
      5) brfalse [4]
      2) ldloca.s [Opt<Time> (0)]
      5) call Opt<Time>::GetValueOrDefault():Time
      1) ldloc.1 [Time]
      5) call static Time::op_LessThanOrEqual(Time, Time):bool
      5) br [5]
  Label [4]:
      1) ldc.i4.1
  Label [5]:
      5) stfld (bool,bool,bool,bool,bool,Opt<Time>,Time)::_F2:bool
      1) dup
      2) ldloca.s [Opt<Time> (0)]
      5) call Opt<Time>::get_HasValue():bool
      5) brfalse [6]
      2) ldloca.s [Opt<Time> (0)]
      5) call Opt<Time>::GetValueOrDefault():Time
      1) ldloc.1 [Time]
      5) call static Time::op_GreaterThan(Time, Time):bool
      5) br [7]
  Label [6]:
      1) ldc.i4.0
  Label [7]:
      5) stfld (bool,bool,bool,bool,bool,Opt<Time>,Time)::_F3:bool
      1) dup
      2) ldloca.s [Opt<Time> (0)]
      5) call Opt<Time>::get_HasValue():bool
      5) brfalse [8]
      2) ldloca.s [Opt<Time> (0)]
      5) call Opt<Time>::GetValueOrDefault():Time
      1) ldloc.1 [Time]
      5) call static Time::op_GreaterThanOrEqual(Time, Time):bool
      5) br [9]
  Label [8]:
      1) ldc.i4.0
  Label [9]:
      5) stfld (bool,bool,bool,bool,bool,Opt<Time>,Time)::_F4:bool
      1) dup
      1) ldloc.0 [Opt<Time>]
      5) stfld (bool,bool,bool,bool,bool,Opt<Time>,Time)::_F5:Opt<Time>
      1) dup
      1) ldloc.1 [Time]
      5) stfld (bool,bool,bool,bool,bool,Opt<Time>,Time)::_F6:Time
      1) ret
  Total Size: 229

Func sig: (<ctx>:x, xt_q:t?*, yt__:t*) to (s, s, t?, t)*
Sequence: Seq<(str,str,Opt<Time>,Time)>
 0) (_MM__, LT, <null>, -2.00:00:00)
 1) (_MM__, LT, <null>, 00:00:00)
 2) (_MM__, LT, <null>, 3.00:00:00)
 3) (M_M_M, EQ, -2.00:00:00, -2.00:00:00)
 4) (_MM__, LT, -2.00:00:00, 00:00:00)
 5) (_MM__, LT, -2.00:00:00, 3.00:00:00)
 6) (___MM, GT, 00:00:00, -2.00:00:00)
 7) (M_M_M, EQ, 00:00:00, 00:00:00)
 8) (_MM__, LT, 00:00:00, 3.00:00:00)
 9) (___MM, GT, 3.00:00:00, -2.00:00:00)
10) (___MM, GT, 3.00:00:00, 00:00:00)
11) (M_M_M, EQ, 3.00:00:00, 3.00:00:00)
*** Ctx ping count: 5
    [0](5): ChainMap(*1: xt_q, ForEach(*2: yt__, (*1, *2)))
###
> G(xb_q, yb_q) // Opt with Opt (QQ).
G(xb_q, yb_q) : (s, s, b?, b?)*
BndKind:Call, Type:(s, s, b?, b?)*, Bnd:(Call(∂.ForEach([map:6] Call(∂.Test.Wrap(Call(∂.ForEach([map:3] Call(∂.Test.Wrap(Call(∂.ChainMap([map:1] Global(xb_q), Call(∂.ForEach([map:2] Global(yb_q), (Scope(1), Scope(2)):(b?, b?)):(b?, b?)*)):(b?, b?)*)):(b?, b?)*), Call(∂.With([with:4] Call(∂.Test.Wrap(GetSlot(Scope(3), 0)):b?), [with:5] Call(∂.Test.Wrap(GetSlot(Scope(3), 1)):b?), (Cmp(Scope(4) @= Scope(5)), Cmp(Scope(4) @< Scope(5)), Cmp(Scope(4) @<= Scope(5)), Cmp(Scope(4) @> Scope(5)), Cmp(Scope(4) @>= Scope(5)), Scope(4), Scope(5)):(b, b, b, b, b, b?, b?)):(b, b, b, b, b, b?, b?))):(b, b, b, b, b, b?, b?)*)):(b, b, b, b, b, b?, b?)*), Call(∂.With([with:7] StrConcat(If(GetSlot(Scope(6), 0), str(M), str(_)), If(GetSlot(Scope(6), 1), str(M), str(_)), If(GetSlot(Scope(6), 2), str(M), str(_)), If(GetSlot(Scope(6), 3), str(M), str(_)), If(GetSlot(Scope(6), 4), str(M), str(_))), TupleConcat((Scope(7), If(Cmp(Scope(7) @= str(_____)), str(__), If(Cmp(Scope(7) @= str(M_M_M)), str(EQ), If(Cmp(Scope(7) @= str(__M__)), str(LE), If(Cmp(Scope(7) @= str(_MM__)), str(LT), If(Cmp(Scope(7) @= str(____M)), str(GE), If(Cmp(Scope(7) @= str(___MM)), str(GT), If(Cmp(Scope(7) @= str(MMMMM)), str(N___), If(Cmp(Scope(7) @= str(_M_M_)), str(N_E_), If(Cmp(Scope(7) @= str(M__MM)), str(N_L_), If(Cmp(Scope(7) @= str(MMM__)), str(N_G_), If(Cmp(Scope(7) @= str(___M_)), str(N_EL), If(Cmp(Scope(7) @= str(_M___)), str(N_EG), If(Cmp(Scope(7) @= str(M____)), str(N_LG), str(***BAD!***))))))))))))))):(s, s), GetSlice(Scope(6), 5:7:1):(b?, b?))):(s, s, b?, b?))):(s, s, b?, b?)*))
ForEach_1(Arr<obj>, (Opt<bool>,Opt<bool>)):(bool,bool,bool,bool,bool,Opt<bool>,Opt<bool>)
      1) ldarg.1 [(Opt<bool>,Opt<bool>)]
      5) ldfld (Opt<bool>,Opt<bool>)::_F0:Opt<bool>
      5) call static WrapFuncGen::Exec(Opt<bool>):Opt<bool>
      1) stloc.0 [Opt<bool>]
      1) ldarg.1 [(Opt<bool>,Opt<bool>)]
      5) ldfld (Opt<bool>,Opt<bool>)::_F1:Opt<bool>
      5) call static WrapFuncGen::Exec(Opt<bool>):Opt<bool>
      1) stloc.1 [Opt<bool>]
      5) newobj (bool,bool,bool,bool,bool,Opt<bool>,Opt<bool>)()
      1) dup
      2) ldloca.s [Opt<bool> (0)]
      5) call Opt<bool>::get_HasValue():bool
      2) ldloca.s [Opt<bool> (1)]
      5) call Opt<bool>::get_HasValue():bool
      5) bne.un [0]
      2) ldloca.s [Opt<bool> (0)]
      5) call Opt<bool>::GetValueOrDefault():bool
      2) ldloca.s [Opt<bool> (1)]
      5) call Opt<bool>::GetValueOrDefault():bool
      2) ceq
      5) br [1]
  Label [0]:
      1) ldc.i4.0
  Label [1]:
      5) stfld (bool,bool,bool,bool,bool,Opt<bool>,Opt<bool>)::_F0:bool
      1) dup
      2) ldloca.s [Opt<bool> (1)]
      5) call Opt<bool>::get_HasValue():bool
      5) brfalse [2]
      2) ldloca.s [Opt<bool> (0)]
      5) call Opt<bool>::get_HasValue():bool
      5) brfalse [3]
      2) ldloca.s [Opt<bool> (0)]
      5) call Opt<bool>::GetValueOrDefault():bool
      2) ldloca.s [Opt<bool> (1)]
      5) call Opt<bool>::GetValueOrDefault():bool
      2) clt.un
      5) br [4]
  Label [3]:
      1) ldc.i4.1
      5) br [4]
  Label [2]:
      1) ldc.i4.0
  Label [4]:
      5) stfld (bool,bool,bool,bool,bool,Opt<bool>,Opt<bool>)::_F1:bool
      1) dup
      2) ldloca.s [Opt<bool> (0)]
      5) call Opt<bool>::get_HasValue():bool
      5) brfalse [5]
      2) ldloca.s [Opt<bool> (1)]
      5) call Opt<bool>::get_HasValue():bool
      5) brfalse [6]
      2) ldloca.s [Opt<bool> (0)]
      5) call Opt<bool>::GetValueOrDefault():bool
      2) ldloca.s [Opt<bool> (1)]
      5) call Opt<bool>::GetValueOrDefault():bool
      2) cgt.un
      1) ldc.i4.0
      2) ceq
      5) br [7]
  Label [5]:
      1) ldc.i4.1
      5) br [7]
  Label [6]:
      1) ldc.i4.0
  Label [7]:
      5) stfld (bool,bool,bool,bool,bool,Opt<bool>,Opt<bool>)::_F2:bool
      1) dup
      2) ldloca.s [Opt<bool> (0)]
      5) call Opt<bool>::get_HasValue():bool
      5) brfalse [8]
      2) ldloca.s [Opt<bool> (1)]
      5) call Opt<bool>::get_HasValue():bool
      5) brfalse [9]
      2) ldloca.s [Opt<bool> (0)]
      5) call Opt<bool>::GetValueOrDefault():bool
      2) ldloca.s [Opt<bool> (1)]
      5) call Opt<bool>::GetValueOrDefault():bool
      2) cgt.un
      5) br [10]
  Label [9]:
      1) ldc.i4.1
      5) br [10]
  Label [8]:
      1) ldc.i4.0
  Label [10]:
      5) stfld (bool,bool,bool,bool,bool,Opt<bool>,Opt<bool>)::_F3:bool
      1) dup
      2) ldloca.s [Opt<bool> (1)]
      5) call Opt<bool>::get_HasValue():bool
      5) brfalse [11]
      2) ldloca.s [Opt<bool> (0)]
      5) call Opt<bool>::get_HasValue():bool
      5) brfalse [12]
      2) ldloca.s [Opt<bool> (0)]
      5) call Opt<bool>::GetValueOrDefault():bool
      2) ldloca.s [Opt<bool> (1)]
      5) call Opt<bool>::GetValueOrDefault():bool
      2) clt.un
      1) ldc.i4.0
      2) ceq
      5) br [13]
  Label [11]:
      1) ldc.i4.1
      5) br [13]
  Label [12]:
      1) ldc.i4.0
  Label [13]:
      5) stfld (bool,bool,bool,bool,bool,Opt<bool>,Opt<bool>)::_F4:bool
      1) dup
      1) ldloc.0 [Opt<bool>]
      5) stfld (bool,bool,bool,bool,bool,Opt<bool>,Opt<bool>)::_F5:Opt<bool>
      1) dup
      1) ldloc.1 [Opt<bool>]
      5) stfld (bool,bool,bool,bool,bool,Opt<bool>,Opt<bool>)::_F6:Opt<bool>
      1) ret
  Total Size: 329

Func sig: (<ctx>:x, xb_q:b?*, yb_q:b?*) to (s, s, b?, b?)*
Sequence: Seq<(str,str,Opt<bool>,Opt<bool>)>
 0) (M_M_M, EQ, <null>, <null>)
 1) (_MM__, LT, <null>, false)
 2) (_MM__, LT, <null>, true )
 3) (___MM, GT, false, <null>)
 4) (M_M_M, EQ, false, false)
 5) (_MM__, LT, false, true )
 6) (___MM, GT, true , <null>)
 7) (___MM, GT, true , false)
 8) (M_M_M, EQ, true , true )
*** Ctx ping count: 4
    [0](4): ChainMap(*1: xb_q, ForEach(*2: yb_q, (*1, *2)))
###
> G(xr8q, yr8q)
G(xr8q, yr8q) : (s, s, r8?, r8?)*
BndKind:Call, Type:(s, s, r8?, r8?)*, Bnd:(Call(∂.ForEach([map:6] Call(∂.Test.Wrap(Call(∂.ForEach([map:3] Call(∂.Test.Wrap(Call(∂.ChainMap([map:1] Global(xr8q), Call(∂.ForEach([map:2] Global(yr8q), (Scope(1), Scope(2)):(r8?, r8?)):(r8?, r8?)*)):(r8?, r8?)*)):(r8?, r8?)*), Call(∂.With([with:4] Call(∂.Test.Wrap(GetSlot(Scope(3), 0)):r8?), [with:5] Call(∂.Test.Wrap(GetSlot(Scope(3), 1)):r8?), (Cmp(Scope(4) @= Scope(5)), Cmp(Scope(4) @< Scope(5)), Cmp(Scope(4) @<= Scope(5)), Cmp(Scope(4) @> Scope(5)), Cmp(Scope(4) @>= Scope(5)), Scope(4), Scope(5)):(b, b, b, b, b, r8?, r8?)):(b, b, b, b, b, r8?, r8?))):(b, b, b, b, b, r8?, r8?)*)):(b, b, b, b, b, r8?, r8?)*), Call(∂.With([with:7] StrConcat(If(GetSlot(Scope(6), 0), str(M), str(_)), If(GetSlot(Scope(6), 1), str(M), str(_)), If(GetSlot(Scope(6), 2), str(M), str(_)), If(GetSlot(Scope(6), 3), str(M), str(_)), If(GetSlot(Scope(6), 4), str(M), str(_))), TupleConcat((Scope(7), If(Cmp(Scope(7) @= str(_____)), str(__), If(Cmp(Scope(7) @= str(M_M_M)), str(EQ), If(Cmp(Scope(7) @= str(__M__)), str(LE), If(Cmp(Scope(7) @= str(_MM__)), str(LT), If(Cmp(Scope(7) @= str(____M)), str(GE), If(Cmp(Scope(7) @= str(___MM)), str(GT), If(Cmp(Scope(7) @= str(MMMMM)), str(N___), If(Cmp(Scope(7) @= str(_M_M_)), str(N_E_), If(Cmp(Scope(7) @= str(M__MM)), str(N_L_), If(Cmp(Scope(7) @= str(MMM__)), str(N_G_), If(Cmp(Scope(7) @= str(___M_)), str(N_EL), If(Cmp(Scope(7) @= str(_M___)), str(N_EG), If(Cmp(Scope(7) @= str(M____)), str(N_LG), str(***BAD!***))))))))))))))):(s, s), GetSlice(Scope(6), 5:7:1):(r8?, r8?))):(s, s, r8?, r8?))):(s, s, r8?, r8?)*))
ForEach_1(Arr<obj>, (Opt<r8>,Opt<r8>)):(bool,bool,bool,bool,bool,Opt<r8>,Opt<r8>)
      1) ldarg.1 [(Opt<r8>,Opt<r8>)]
      5) ldfld (Opt<r8>,Opt<r8>)::_F0:Opt<r8>
      5) call static WrapFuncGen::Exec(Opt<r8>):Opt<r8>
      1) stloc.0 [Opt<r8>]
      1) ldarg.1 [(Opt<r8>,Opt<r8>)]
      5) ldfld (Opt<r8>,Opt<r8>)::_F1:Opt<r8>
      5) call static WrapFuncGen::Exec(Opt<r8>):Opt<r8>
      1) stloc.1 [Opt<r8>]
      5) newobj (bool,bool,bool,bool,bool,Opt<r8>,Opt<r8>)()
      1) dup
      2) ldloca.s [Opt<r8> (0)]
      5) call Opt<r8>::get_HasValue():bool
      2) ldloca.s [Opt<r8> (1)]
      5) call Opt<r8>::get_HasValue():bool
      5) bne.un [0]
      2) ldloca.s [Opt<r8> (0)]
      5) call Opt<r8>::GetValueOrDefault():r8
      2) ldloca.s [Opt<r8> (1)]
      5) call Opt<r8>::GetValueOrDefault():r8
      5) call static NumUtil::Eq(r8, r8):bool
      5) br [1]
  Label [0]:
      1) ldc.i4.0
  Label [1]:
      5) stfld (bool,bool,bool,bool,bool,Opt<r8>,Opt<r8>)::_F0:bool
      1) dup
      2) ldloca.s [Opt<r8> (1)]
      5) call Opt<r8>::get_HasValue():bool
      5) brfalse [2]
      2) ldloca.s [Opt<r8> (0)]
      5) call Opt<r8>::get_HasValue():bool
      5) brfalse [3]
      2) ldloca.s [Opt<r8> (0)]
      5) call Opt<r8>::GetValueOrDefault():r8
      2) ldloca.s [Opt<r8> (1)]
      5) call Opt<r8>::GetValueOrDefault():r8
      5) call static NumUtil::Lt(r8, r8):bool
      5) br [4]
  Label [3]:
      1) ldc.i4.1
      5) br [4]
  Label [2]:
      1) ldc.i4.0
  Label [4]:
      5) stfld (bool,bool,bool,bool,bool,Opt<r8>,Opt<r8>)::_F1:bool
      1) dup
      2) ldloca.s [Opt<r8> (0)]
      5) call Opt<r8>::get_HasValue():bool
      5) brfalse [5]
      2) ldloca.s [Opt<r8> (1)]
      5) call Opt<r8>::get_HasValue():bool
      5) brfalse [6]
      2) ldloca.s [Opt<r8> (0)]
      5) call Opt<r8>::GetValueOrDefault():r8
      2) ldloca.s [Opt<r8> (1)]
      5) call Opt<r8>::GetValueOrDefault():r8
      5) call static NumUtil::Le(r8, r8):bool
      5) br [7]
  Label [5]:
      1) ldc.i4.1
      5) br [7]
  Label [6]:
      1) ldc.i4.0
  Label [7]:
      5) stfld (bool,bool,bool,bool,bool,Opt<r8>,Opt<r8>)::_F2:bool
      1) dup
      2) ldloca.s [Opt<r8> (0)]
      5) call Opt<r8>::get_HasValue():bool
      5) brfalse [8]
      2) ldloca.s [Opt<r8> (1)]
      5) call Opt<r8>::get_HasValue():bool
      5) brfalse [9]
      2) ldloca.s [Opt<r8> (0)]
      5) call Opt<r8>::GetValueOrDefault():r8
      2) ldloca.s [Opt<r8> (1)]
      5) call Opt<r8>::GetValueOrDefault():r8
      5) call static NumUtil::Gt(r8, r8):bool
      5) br [10]
  Label [9]:
      1) ldc.i4.1
      5) br [10]
  Label [8]:
      1) ldc.i4.0
  Label [10]:
      5) stfld (bool,bool,bool,bool,bool,Opt<r8>,Opt<r8>)::_F3:bool
      1) dup
      2) ldloca.s [Opt<r8> (1)]
      5) call Opt<r8>::get_HasValue():bool
      5) brfalse [11]
      2) ldloca.s [Opt<r8> (0)]
      5) call Opt<r8>::get_HasValue():bool
      5) brfalse [12]
      2) ldloca.s [Opt<r8> (0)]
      5) call Opt<r8>::GetValueOrDefault():r8
      2) ldloca.s [Opt<r8> (1)]
      5) call Opt<r8>::GetValueOrDefault():r8
      5) call static NumUtil::Ge(r8, r8):bool
      5) br [13]
  Label [11]:
      1) ldc.i4.1
      5) br [13]
  Label [12]:
      1) ldc.i4.0
  Label [13]:
      5) stfld (bool,bool,bool,bool,bool,Opt<r8>,Opt<r8>)::_F4:bool
      1) dup
      1) ldloc.0 [Opt<r8>]
      5) stfld (bool,bool,bool,bool,bool,Opt<r8>,Opt<r8>)::_F5:Opt<r8>
      1) dup
      1) ldloc.1 [Opt<r8>]
      5) stfld (bool,bool,bool,bool,bool,Opt<r8>,Opt<r8>)::_F6:Opt<r8>
      1) ret
  Total Size: 338

Func sig: (<ctx>:x, xr8q:r8?*, yr8q:r8?*) to (s, s, r8?, r8?)*
Sequence: Seq<(str,str,Opt<r8>,Opt<r8>)>
 0) (M_M_M, EQ, <null>, <null>)
 1) (_MM__, LT, <null>, NaN)
 2) (_MM__, LT, <null>, -3)
 3) (_MM__, LT, <null>, 0)
 4) (_MM__, LT, <null>, 5)
 5) (___MM, GT, NaN, <null>)
 6) (M_M_M, EQ, NaN, NaN)
 7) (_MM__, LT, NaN, -3)
 8) (_MM__, LT, NaN, 0)
 9) (_MM__, LT, NaN, 5)
10) (___MM, GT, -3, <null>)
11) (___MM, GT, -3, NaN)
12) (M_M_M, EQ, -3, -3)
13) (_MM__, LT, -3, 0)
14) (_MM__, LT, -3, 5)
15) (___MM, GT, 0, <null>)
16) (___MM, GT, 0, NaN)
17) (___MM, GT, 0, -3)
18) (M_M_M, EQ, 0, 0)
19) (_MM__, LT, 0, 5)
20) (___MM, GT, 5, <null>)
21) (___MM, GT, 5, NaN)
22) (___MM, GT, 5, -3)
23) (___MM, GT, 5, 0)
24) (M_M_M, EQ, 5, 5)
*** Ctx ping count: 6
    [0](6): ChainMap(*1: xr8q, ForEach(*2: yr8q, (*1, *2)))
###
> G(xr4q, yr4q)
G(xr4q, yr4q) : (s, s, r4?, r4?)*
BndKind:Call, Type:(s, s, r4?, r4?)*, Bnd:(Call(∂.ForEach([map:6] Call(∂.Test.Wrap(Call(∂.ForEach([map:3] Call(∂.Test.Wrap(Call(∂.ChainMap([map:1] Global(xr4q), Call(∂.ForEach([map:2] Global(yr4q), (Scope(1), Scope(2)):(r4?, r4?)):(r4?, r4?)*)):(r4?, r4?)*)):(r4?, r4?)*), Call(∂.With([with:4] Call(∂.Test.Wrap(GetSlot(Scope(3), 0)):r4?), [with:5] Call(∂.Test.Wrap(GetSlot(Scope(3), 1)):r4?), (Cmp(Scope(4) @= Scope(5)), Cmp(Scope(4) @< Scope(5)), Cmp(Scope(4) @<= Scope(5)), Cmp(Scope(4) @> Scope(5)), Cmp(Scope(4) @>= Scope(5)), Scope(4), Scope(5)):(b, b, b, b, b, r4?, r4?)):(b, b, b, b, b, r4?, r4?))):(b, b, b, b, b, r4?, r4?)*)):(b, b, b, b, b, r4?, r4?)*), Call(∂.With([with:7] StrConcat(If(GetSlot(Scope(6), 0), str(M), str(_)), If(GetSlot(Scope(6), 1), str(M), str(_)), If(GetSlot(Scope(6), 2), str(M), str(_)), If(GetSlot(Scope(6), 3), str(M), str(_)), If(GetSlot(Scope(6), 4), str(M), str(_))), TupleConcat((Scope(7), If(Cmp(Scope(7) @= str(_____)), str(__), If(Cmp(Scope(7) @= str(M_M_M)), str(EQ), If(Cmp(Scope(7) @= str(__M__)), str(LE), If(Cmp(Scope(7) @= str(_MM__)), str(LT), If(Cmp(Scope(7) @= str(____M)), str(GE), If(Cmp(Scope(7) @= str(___MM)), str(GT), If(Cmp(Scope(7) @= str(MMMMM)), str(N___), If(Cmp(Scope(7) @= str(_M_M_)), str(N_E_), If(Cmp(Scope(7) @= str(M__MM)), str(N_L_), If(Cmp(Scope(7) @= str(MMM__)), str(N_G_), If(Cmp(Scope(7) @= str(___M_)), str(N_EL), If(Cmp(Scope(7) @= str(_M___)), str(N_EG), If(Cmp(Scope(7) @= str(M____)), str(N_LG), str(***BAD!***))))))))))))))):(s, s), GetSlice(Scope(6), 5:7:1):(r4?, r4?))):(s, s, r4?, r4?))):(s, s, r4?, r4?)*))
ForEach_1(Arr<obj>, (Opt<r4>,Opt<r4>)):(bool,bool,bool,bool,bool,Opt<r4>,Opt<r4>)
      1) ldarg.1 [(Opt<r4>,Opt<r4>)]
      5) ldfld (Opt<r4>,Opt<r4>)::_F0:Opt<r4>
      5) call static WrapFuncGen::Exec(Opt<r4>):Opt<r4>
      1) stloc.0 [Opt<r4>]
      1) ldarg.1 [(Opt<r4>,Opt<r4>)]
      5) ldfld (Opt<r4>,Opt<r4>)::_F1:Opt<r4>
      5) call static WrapFuncGen::Exec(Opt<r4>):Opt<r4>
      1) stloc.1 [Opt<r4>]
      5) newobj (bool,bool,bool,bool,bool,Opt<r4>,Opt<r4>)()
      1) dup
      2) ldloca.s [Opt<r4> (0)]
      5) call Opt<r4>::get_HasValue():bool
      2) ldloca.s [Opt<r4> (1)]
      5) call Opt<r4>::get_HasValue():bool
      5) bne.un [0]
      2) ldloca.s [Opt<r4> (0)]
      5) call Opt<r4>::GetValueOrDefault():r4
      2) ldloca.s [Opt<r4> (1)]
      5) call Opt<r4>::GetValueOrDefault():r4
      5) call static NumUtil::Eq(r4, r4):bool
      5) br [1]
  Label [0]:
      1) ldc.i4.0
  Label [1]:
      5) stfld (bool,bool,bool,bool,bool,Opt<r4>,Opt<r4>)::_F0:bool
      1) dup
      2) ldloca.s [Opt<r4> (1)]
      5) call Opt<r4>::get_HasValue():bool
      5) brfalse [2]
      2) ldloca.s [Opt<r4> (0)]
      5) call Opt<r4>::get_HasValue():bool
      5) brfalse [3]
      2) ldloca.s [Opt<r4> (0)]
      5) call Opt<r4>::GetValueOrDefault():r4
      2) ldloca.s [Opt<r4> (1)]
      5) call Opt<r4>::GetValueOrDefault():r4
      5) call static NumUtil::Lt(r4, r4):bool
      5) br [4]
  Label [3]:
      1) ldc.i4.1
      5) br [4]
  Label [2]:
      1) ldc.i4.0
  Label [4]:
      5) stfld (bool,bool,bool,bool,bool,Opt<r4>,Opt<r4>)::_F1:bool
      1) dup
      2) ldloca.s [Opt<r4> (0)]
      5) call Opt<r4>::get_HasValue():bool
      5) brfalse [5]
      2) ldloca.s [Opt<r4> (1)]
      5) call Opt<r4>::get_HasValue():bool
      5) brfalse [6]
      2) ldloca.s [Opt<r4> (0)]
      5) call Opt<r4>::GetValueOrDefault():r4
      2) ldloca.s [Opt<r4> (1)]
      5) call Opt<r4>::GetValueOrDefault():r4
      5) call static NumUtil::Le(r4, r4):bool
      5) br [7]
  Label [5]:
      1) ldc.i4.1
      5) br [7]
  Label [6]:
      1) ldc.i4.0
  Label [7]:
      5) stfld (bool,bool,bool,bool,bool,Opt<r4>,Opt<r4>)::_F2:bool
      1) dup
      2) ldloca.s [Opt<r4> (0)]
      5) call Opt<r4>::get_HasValue():bool
      5) brfalse [8]
      2) ldloca.s [Opt<r4> (1)]
      5) call Opt<r4>::get_HasValue():bool
      5) brfalse [9]
      2) ldloca.s [Opt<r4> (0)]
      5) call Opt<r4>::GetValueOrDefault():r4
      2) ldloca.s [Opt<r4> (1)]
      5) call Opt<r4>::GetValueOrDefault():r4
      5) call static NumUtil::Gt(r4, r4):bool
      5) br [10]
  Label [9]:
      1) ldc.i4.1
      5) br [10]
  Label [8]:
      1) ldc.i4.0
  Label [10]:
      5) stfld (bool,bool,bool,bool,bool,Opt<r4>,Opt<r4>)::_F3:bool
      1) dup
      2) ldloca.s [Opt<r4> (1)]
      5) call Opt<r4>::get_HasValue():bool
      5) brfalse [11]
      2) ldloca.s [Opt<r4> (0)]
      5) call Opt<r4>::get_HasValue():bool
      5) brfalse [12]
      2) ldloca.s [Opt<r4> (0)]
      5) call Opt<r4>::GetValueOrDefault():r4
      2) ldloca.s [Opt<r4> (1)]
      5) call Opt<r4>::GetValueOrDefault():r4
      5) call static NumUtil::Ge(r4, r4):bool
      5) br [13]
  Label [11]:
      1) ldc.i4.1
      5) br [13]
  Label [12]:
      1) ldc.i4.0
  Label [13]:
      5) stfld (bool,bool,bool,bool,bool,Opt<r4>,Opt<r4>)::_F4:bool
      1) dup
      1) ldloc.0 [Opt<r4>]
      5) stfld (bool,bool,bool,bool,bool,Opt<r4>,Opt<r4>)::_F5:Opt<r4>
      1) dup
      1) ldloc.1 [Opt<r4>]
      5) stfld (bool,bool,bool,bool,bool,Opt<r4>,Opt<r4>)::_F6:Opt<r4>
      1) ret
  Total Size: 338

Func sig: (<ctx>:x, xr4q:r4?*, yr4q:r4?*) to (s, s, r4?, r4?)*
Sequence: Seq<(str,str,Opt<r4>,Opt<r4>)>
 0) (M_M_M, EQ, <null>, <null>)
 1) (_MM__, LT, <null>, NaN)
 2) (_MM__, LT, <null>, -3)
 3) (_MM__, LT, <null>, 0)
 4) (_MM__, LT, <null>, 5)
 5) (___MM, GT, NaN, <null>)
 6) (M_M_M, EQ, NaN, NaN)
 7) (_MM__, LT, NaN, -3)
 8) (_MM__, LT, NaN, 0)
 9) (_MM__, LT, NaN, 5)
10) (___MM, GT, -3, <null>)
11) (___MM, GT, -3, NaN)
12) (M_M_M, EQ, -3, -3)
13) (_MM__, LT, -3, 0)
14) (_MM__, LT, -3, 5)
15) (___MM, GT, 0, <null>)
16) (___MM, GT, 0, NaN)
17) (___MM, GT, 0, -3)
18) (M_M_M, EQ, 0, 0)
19) (_MM__, LT, 0, 5)
20) (___MM, GT, 5, <null>)
21) (___MM, GT, 5, NaN)
22) (___MM, GT, 5, -3)
23) (___MM, GT, 5, 0)
24) (M_M_M, EQ, 5, 5)
*** Ctx ping count: 6
    [0](6): ChainMap(*1: xr4q, ForEach(*2: yr4q, (*1, *2)))
###
> G(xi_q, yi_q)
G(xi_q, yi_q) : (s, s, i?, i?)*
BndKind:Call, Type:(s, s, i?, i?)*, Bnd:(Call(∂.ForEach([map:6] Call(∂.Test.Wrap(Call(∂.ForEach([map:3] Call(∂.Test.Wrap(Call(∂.ChainMap([map:1] Global(xi_q), Call(∂.ForEach([map:2] Global(yi_q), (Scope(1), Scope(2)):(i?, i?)):(i?, i?)*)):(i?, i?)*)):(i?, i?)*), Call(∂.With([with:4] Call(∂.Test.Wrap(GetSlot(Scope(3), 0)):i?), [with:5] Call(∂.Test.Wrap(GetSlot(Scope(3), 1)):i?), (Cmp(Scope(4) @= Scope(5)), Cmp(Scope(4) @< Scope(5)), Cmp(Scope(4) @<= Scope(5)), Cmp(Scope(4) @> Scope(5)), Cmp(Scope(4) @>= Scope(5)), Scope(4), Scope(5)):(b, b, b, b, b, i?, i?)):(b, b, b, b, b, i?, i?))):(b, b, b, b, b, i?, i?)*)):(b, b, b, b, b, i?, i?)*), Call(∂.With([with:7] StrConcat(If(GetSlot(Scope(6), 0), str(M), str(_)), If(GetSlot(Scope(6), 1), str(M), str(_)), If(GetSlot(Scope(6), 2), str(M), str(_)), If(GetSlot(Scope(6), 3), str(M), str(_)), If(GetSlot(Scope(6), 4), str(M), str(_))), TupleConcat((Scope(7), If(Cmp(Scope(7) @= str(_____)), str(__), If(Cmp(Scope(7) @= str(M_M_M)), str(EQ), If(Cmp(Scope(7) @= str(__M__)), str(LE), If(Cmp(Scope(7) @= str(_MM__)), str(LT), If(Cmp(Scope(7) @= str(____M)), str(GE), If(Cmp(Scope(7) @= str(___MM)), str(GT), If(Cmp(Scope(7) @= str(MMMMM)), str(N___), If(Cmp(Scope(7) @= str(_M_M_)), str(N_E_), If(Cmp(Scope(7) @= str(M__MM)), str(N_L_), If(Cmp(Scope(7) @= str(MMM__)), str(N_G_), If(Cmp(Scope(7) @= str(___M_)), str(N_EL), If(Cmp(Scope(7) @= str(_M___)), str(N_EG), If(Cmp(Scope(7) @= str(M____)), str(N_LG), str(***BAD!***))))))))))))))):(s, s), GetSlice(Scope(6), 5:7:1):(i?, i?))):(s, s, i?, i?))):(s, s, i?, i?)*))
ForEach_1(Arr<obj>, (Opt<ia>,Opt<ia>)):(bool,bool,bool,bool,bool,Opt<ia>,Opt<ia>)
      1) ldarg.1 [(Opt<ia>,Opt<ia>)]
      5) ldfld (Opt<ia>,Opt<ia>)::_F0:Opt<ia>
      5) call static WrapFuncGen::Exec(Opt<ia>):Opt<ia>
      1) stloc.0 [Opt<ia>]
      1) ldarg.1 [(Opt<ia>,Opt<ia>)]
      5) ldfld (Opt<ia>,Opt<ia>)::_F1:Opt<ia>
      5) call static WrapFuncGen::Exec(Opt<ia>):Opt<ia>
      1) stloc.1 [Opt<ia>]
      5) newobj (bool,bool,bool,bool,bool,Opt<ia>,Opt<ia>)()
      1) dup
      2) ldloca.s [Opt<ia> (0)]
      5) call Opt<ia>::get_HasValue():bool
      2) ldloca.s [Opt<ia> (1)]
      5) call Opt<ia>::get_HasValue():bool
      5) bne.un [0]
      2) ldloca.s [Opt<ia> (0)]
      5) call Opt<ia>::GetValueOrDefault():ia
      2) ldloca.s [Opt<ia> (1)]
      5) call Opt<ia>::GetValueOrDefault():ia
      5) call static ia::op_Equality(ia, ia):bool
      5) br [1]
  Label [0]:
      1) ldc.i4.0
  Label [1]:
      5) stfld (bool,bool,bool,bool,bool,Opt<ia>,Opt<ia>)::_F0:bool
      1) dup
      2) ldloca.s [Opt<ia> (1)]
      5) call Opt<ia>::get_HasValue():bool
      5) brfalse [2]
      2) ldloca.s [Opt<ia> (0)]
      5) call Opt<ia>::get_HasValue():bool
      5) brfalse [3]
      2) ldloca.s [Opt<ia> (0)]
      5) call Opt<ia>::GetValueOrDefault():ia
      2) ldloca.s [Opt<ia> (1)]
      5) call Opt<ia>::GetValueOrDefault():ia
      5) call static ia::op_LessThan(ia, ia):bool
      5) br [4]
  Label [3]:
      1) ldc.i4.1
      5) br [4]
  Label [2]:
      1) ldc.i4.0
  Label [4]:
      5) stfld (bool,bool,bool,bool,bool,Opt<ia>,Opt<ia>)::_F1:bool
      1) dup
      2) ldloca.s [Opt<ia> (0)]
      5) call Opt<ia>::get_HasValue():bool
      5) brfalse [5]
      2) ldloca.s [Opt<ia> (1)]
      5) call Opt<ia>::get_HasValue():bool
      5) brfalse [6]
      2) ldloca.s [Opt<ia> (0)]
      5) call Opt<ia>::GetValueOrDefault():ia
      2) ldloca.s [Opt<ia> (1)]
      5) call Opt<ia>::GetValueOrDefault():ia
      5) call static ia::op_LessThanOrEqual(ia, ia):bool
      5) br [7]
  Label [5]:
      1) ldc.i4.1
      5) br [7]
  Label [6]:
      1) ldc.i4.0
  Label [7]:
      5) stfld (bool,bool,bool,bool,bool,Opt<ia>,Opt<ia>)::_F2:bool
      1) dup
      2) ldloca.s [Opt<ia> (0)]
      5) call Opt<ia>::get_HasValue():bool
      5) brfalse [8]
      2) ldloca.s [Opt<ia> (1)]
      5) call Opt<ia>::get_HasValue():bool
      5) brfalse [9]
      2) ldloca.s [Opt<ia> (0)]
      5) call Opt<ia>::GetValueOrDefault():ia
      2) ldloca.s [Opt<ia> (1)]
      5) call Opt<ia>::GetValueOrDefault():ia
      5) call static ia::op_GreaterThan(ia, ia):bool
      5) br [10]
  Label [9]:
      1) ldc.i4.1
      5) br [10]
  Label [8]:
      1) ldc.i4.0
  Label [10]:
      5) stfld (bool,bool,bool,bool,bool,Opt<ia>,Opt<ia>)::_F3:bool
      1) dup
      2) ldloca.s [Opt<ia> (1)]
      5) call Opt<ia>::get_HasValue():bool
      5) brfalse [11]
      2) ldloca.s [Opt<ia> (0)]
      5) call Opt<ia>::get_HasValue():bool
      5) brfalse [12]
      2) ldloca.s [Opt<ia> (0)]
      5) call Opt<ia>::GetValueOrDefault():ia
      2) ldloca.s [Opt<ia> (1)]
      5) call Opt<ia>::GetValueOrDefault():ia
      5) call static ia::op_GreaterThanOrEqual(ia, ia):bool
      5) br [13]
  Label [11]:
      1) ldc.i4.1
      5) br [13]
  Label [12]:
      1) ldc.i4.0
  Label [13]:
      5) stfld (bool,bool,bool,bool,bool,Opt<ia>,Opt<ia>)::_F4:bool
      1) dup
      1) ldloc.0 [Opt<ia>]
      5) stfld (bool,bool,bool,bool,bool,Opt<ia>,Opt<ia>)::_F5:Opt<ia>
      1) dup
      1) ldloc.1 [Opt<ia>]
      5) stfld (bool,bool,bool,bool,bool,Opt<ia>,Opt<ia>)::_F6:Opt<ia>
      1) ret
  Total Size: 338

Func sig: (<ctx>:x, xi_q:i?*, yi_q:i?*) to (s, s, i?, i?)*
Sequence: Seq<(str,str,Opt<ia>,Opt<ia>)>
 0) (M_M_M, EQ, <null>, <null>)
 1) (_MM__, LT, <null>, -3)
 2) (_MM__, LT, <null>, 0)
 3) (_MM__, LT, <null>, 5)
 4) (___MM, GT, -3, <null>)
 5) (M_M_M, EQ, -3, -3)
 6) (_MM__, LT, -3, 0)
 7) (_MM__, LT, -3, 5)
 8) (___MM, GT, 0, <null>)
 9) (___MM, GT, 0, -3)
10) (M_M_M, EQ, 0, 0)
11) (_MM__, LT, 0, 5)
12) (___MM, GT, 5, <null>)
13) (___MM, GT, 5, -3)
14) (___MM, GT, 5, 0)
15) (M_M_M, EQ, 5, 5)
*** Ctx ping count: 5
    [0](5): ChainMap(*1: xi_q, ForEach(*2: yi_q, (*1, *2)))
###
> G(xi2q, yi2q)
G(xi2q, yi2q) : (s, s, i2?, i2?)*
BndKind:Call, Type:(s, s, i2?, i2?)*, Bnd:(Call(∂.ForEach([map:6] Call(∂.Test.Wrap(Call(∂.ForEach([map:3] Call(∂.Test.Wrap(Call(∂.ChainMap([map:1] Global(xi2q), Call(∂.ForEach([map:2] Global(yi2q), (Scope(1), Scope(2)):(i2?, i2?)):(i2?, i2?)*)):(i2?, i2?)*)):(i2?, i2?)*), Call(∂.With([with:4] Call(∂.Test.Wrap(GetSlot(Scope(3), 0)):i2?), [with:5] Call(∂.Test.Wrap(GetSlot(Scope(3), 1)):i2?), (Cmp(Scope(4) @= Scope(5)), Cmp(Scope(4) @< Scope(5)), Cmp(Scope(4) @<= Scope(5)), Cmp(Scope(4) @> Scope(5)), Cmp(Scope(4) @>= Scope(5)), Scope(4), Scope(5)):(b, b, b, b, b, i2?, i2?)):(b, b, b, b, b, i2?, i2?))):(b, b, b, b, b, i2?, i2?)*)):(b, b, b, b, b, i2?, i2?)*), Call(∂.With([with:7] StrConcat(If(GetSlot(Scope(6), 0), str(M), str(_)), If(GetSlot(Scope(6), 1), str(M), str(_)), If(GetSlot(Scope(6), 2), str(M), str(_)), If(GetSlot(Scope(6), 3), str(M), str(_)), If(GetSlot(Scope(6), 4), str(M), str(_))), TupleConcat((Scope(7), If(Cmp(Scope(7) @= str(_____)), str(__), If(Cmp(Scope(7) @= str(M_M_M)), str(EQ), If(Cmp(Scope(7) @= str(__M__)), str(LE), If(Cmp(Scope(7) @= str(_MM__)), str(LT), If(Cmp(Scope(7) @= str(____M)), str(GE), If(Cmp(Scope(7) @= str(___MM)), str(GT), If(Cmp(Scope(7) @= str(MMMMM)), str(N___), If(Cmp(Scope(7) @= str(_M_M_)), str(N_E_), If(Cmp(Scope(7) @= str(M__MM)), str(N_L_), If(Cmp(Scope(7) @= str(MMM__)), str(N_G_), If(Cmp(Scope(7) @= str(___M_)), str(N_EL), If(Cmp(Scope(7) @= str(_M___)), str(N_EG), If(Cmp(Scope(7) @= str(M____)), str(N_LG), str(***BAD!***))))))))))))))):(s, s), GetSlice(Scope(6), 5:7:1):(i2?, i2?))):(s, s, i2?, i2?))):(s, s, i2?, i2?)*))
ForEach_1(Arr<obj>, (Opt<i2>,Opt<i2>)):(bool,bool,bool,bool,bool,Opt<i2>,Opt<i2>)
      1) ldarg.1 [(Opt<i2>,Opt<i2>)]
      5) ldfld (Opt<i2>,Opt<i2>)::_F0:Opt<i2>
      5) call static WrapFuncGen::Exec(Opt<i2>):Opt<i2>
      1) stloc.0 [Opt<i2>]
      1) ldarg.1 [(Opt<i2>,Opt<i2>)]
      5) ldfld (Opt<i2>,Opt<i2>)::_F1:Opt<i2>
      5) call static WrapFuncGen::Exec(Opt<i2>):Opt<i2>
      1) stloc.1 [Opt<i2>]
      5) newobj (bool,bool,bool,bool,bool,Opt<i2>,Opt<i2>)()
      1) dup
      2) ldloca.s [Opt<i2> (0)]
      5) call Opt<i2>::get_HasValue():bool
      2) ldloca.s [Opt<i2> (1)]
      5) call Opt<i2>::get_HasValue():bool
      5) bne.un [0]
      2) ldloca.s [Opt<i2> (0)]
      5) call Opt<i2>::GetValueOrDefault():i2
      2) ldloca.s [Opt<i2> (1)]
      5) call Opt<i2>::GetValueOrDefault():i2
      2) ceq
      5) br [1]
  Label [0]:
      1) ldc.i4.0
  Label [1]:
      5) stfld (bool,bool,bool,bool,bool,Opt<i2>,Opt<i2>)::_F0:bool
      1) dup
      2) ldloca.s [Opt<i2> (1)]
      5) call Opt<i2>::get_HasValue():bool
      5) brfalse [2]
      2) ldloca.s [Opt<i2> (0)]
      5) call Opt<i2>::get_HasValue():bool
      5) brfalse [3]
      2) ldloca.s [Opt<i2> (0)]
      5) call Opt<i2>::GetValueOrDefault():i2
      2) ldloca.s [Opt<i2> (1)]
      5) call Opt<i2>::GetValueOrDefault():i2
      2) clt
      5) br [4]
  Label [3]:
      1) ldc.i4.1
      5) br [4]
  Label [2]:
      1) ldc.i4.0
  Label [4]:
      5) stfld (bool,bool,bool,bool,bool,Opt<i2>,Opt<i2>)::_F1:bool
      1) dup
      2) ldloca.s [Opt<i2> (0)]
      5) call Opt<i2>::get_HasValue():bool
      5) brfalse [5]
      2) ldloca.s [Opt<i2> (1)]
      5) call Opt<i2>::get_HasValue():bool
      5) brfalse [6]
      2) ldloca.s [Opt<i2> (0)]
      5) call Opt<i2>::GetValueOrDefault():i2
      2) ldloca.s [Opt<i2> (1)]
      5) call Opt<i2>::GetValueOrDefault():i2
      2) cgt
      1) ldc.i4.0
      2) ceq
      5) br [7]
  Label [5]:
      1) ldc.i4.1
      5) br [7]
  Label [6]:
      1) ldc.i4.0
  Label [7]:
      5) stfld (bool,bool,bool,bool,bool,Opt<i2>,Opt<i2>)::_F2:bool
      1) dup
      2) ldloca.s [Opt<i2> (0)]
      5) call Opt<i2>::get_HasValue():bool
      5) brfalse [8]
      2) ldloca.s [Opt<i2> (1)]
      5) call Opt<i2>::get_HasValue():bool
      5) brfalse [9]
      2) ldloca.s [Opt<i2> (0)]
      5) call Opt<i2>::GetValueOrDefault():i2
      2) ldloca.s [Opt<i2> (1)]
      5) call Opt<i2>::GetValueOrDefault():i2
      2) cgt
      5) br [10]
  Label [9]:
      1) ldc.i4.1
      5) br [10]
  Label [8]:
      1) ldc.i4.0
  Label [10]:
      5) stfld (bool,bool,bool,bool,bool,Opt<i2>,Opt<i2>)::_F3:bool
      1) dup
      2) ldloca.s [Opt<i2> (1)]
      5) call Opt<i2>::get_HasValue():bool
      5) brfalse [11]
      2) ldloca.s [Opt<i2> (0)]
      5) call Opt<i2>::get_HasValue():bool
      5) brfalse [12]
      2) ldloca.s [Opt<i2> (0)]
      5) call Opt<i2>::GetValueOrDefault():i2
      2) ldloca.s [Opt<i2> (1)]
      5) call Opt<i2>::GetValueOrDefault():i2
      2) clt
      1) ldc.i4.0
      2) ceq
      5) br [13]
  Label [11]:
      1) ldc.i4.1
      5) br [13]
  Label [12]:
      1) ldc.i4.0
  Label [13]:
      5) stfld (bool,bool,bool,bool,bool,Opt<i2>,Opt<i2>)::_F4:bool
      1) dup
      1) ldloc.0 [Opt<i2>]
      5) stfld (bool,bool,bool,bool,bool,Opt<i2>,Opt<i2>)::_F5:Opt<i2>
      1) dup
      1) ldloc.1 [Opt<i2>]
      5) stfld (bool,bool,bool,bool,bool,Opt<i2>,Opt<i2>)::_F6:Opt<i2>
      1) ret
  Total Size: 329

Func sig: (<ctx>:x, xi2q:i2?*, yi2q:i2?*) to (s, s, i2?, i2?)*
Sequence: Seq<(str,str,Opt<i2>,Opt<i2>)>
 0) (M_M_M, EQ, <null>, <null>)
 1) (_MM__, LT, <null>, -3)
 2) (_MM__, LT, <null>, 0)
 3) (_MM__, LT, <null>, 5)
 4) (___MM, GT, -3, <null>)
 5) (M_M_M, EQ, -3, -3)
 6) (_MM__, LT, -3, 0)
 7) (_MM__, LT, -3, 5)
 8) (___MM, GT, 0, <null>)
 9) (___MM, GT, 0, -3)
10) (M_M_M, EQ, 0, 0)
11) (_MM__, LT, 0, 5)
12) (___MM, GT, 5, <null>)
13) (___MM, GT, 5, -3)
14) (___MM, GT, 5, 0)
15) (M_M_M, EQ, 5, 5)
*** Ctx ping count: 5
    [0](5): ChainMap(*1: xi2q, ForEach(*2: yi2q, (*1, *2)))
###
> G(xu4q, yu4q)
G(xu4q, yu4q) : (s, s, u4?, u4?)*
BndKind:Call, Type:(s, s, u4?, u4?)*, Bnd:(Call(∂.ForEach([map:6] Call(∂.Test.Wrap(Call(∂.ForEach([map:3] Call(∂.Test.Wrap(Call(∂.ChainMap([map:1] Global(xu4q), Call(∂.ForEach([map:2] Global(yu4q), (Scope(1), Scope(2)):(u4?, u4?)):(u4?, u4?)*)):(u4?, u4?)*)):(u4?, u4?)*), Call(∂.With([with:4] Call(∂.Test.Wrap(GetSlot(Scope(3), 0)):u4?), [with:5] Call(∂.Test.Wrap(GetSlot(Scope(3), 1)):u4?), (Cmp(Scope(4) @= Scope(5)), Cmp(Scope(4) @< Scope(5)), Cmp(Scope(4) @<= Scope(5)), Cmp(Scope(4) @> Scope(5)), Cmp(Scope(4) @>= Scope(5)), Scope(4), Scope(5)):(b, b, b, b, b, u4?, u4?)):(b, b, b, b, b, u4?, u4?))):(b, b, b, b, b, u4?, u4?)*)):(b, b, b, b, b, u4?, u4?)*), Call(∂.With([with:7] StrConcat(If(GetSlot(Scope(6), 0), str(M), str(_)), If(GetSlot(Scope(6), 1), str(M), str(_)), If(GetSlot(Scope(6), 2), str(M), str(_)), If(GetSlot(Scope(6), 3), str(M), str(_)), If(GetSlot(Scope(6), 4), str(M), str(_))), TupleConcat((Scope(7), If(Cmp(Scope(7) @= str(_____)), str(__), If(Cmp(Scope(7) @= str(M_M_M)), str(EQ), If(Cmp(Scope(7) @= str(__M__)), str(LE), If(Cmp(Scope(7) @= str(_MM__)), str(LT), If(Cmp(Scope(7) @= str(____M)), str(GE), If(Cmp(Scope(7) @= str(___MM)), str(GT), If(Cmp(Scope(7) @= str(MMMMM)), str(N___), If(Cmp(Scope(7) @= str(_M_M_)), str(N_E_), If(Cmp(Scope(7) @= str(M__MM)), str(N_L_), If(Cmp(Scope(7) @= str(MMM__)), str(N_G_), If(Cmp(Scope(7) @= str(___M_)), str(N_EL), If(Cmp(Scope(7) @= str(_M___)), str(N_EG), If(Cmp(Scope(7) @= str(M____)), str(N_LG), str(***BAD!***))))))))))))))):(s, s), GetSlice(Scope(6), 5:7:1):(u4?, u4?))):(s, s, u4?, u4?))):(s, s, u4?, u4?)*))
ForEach_1(Arr<obj>, (Opt<u4>,Opt<u4>)):(bool,bool,bool,bool,bool,Opt<u4>,Opt<u4>)
      1) ldarg.1 [(Opt<u4>,Opt<u4>)]
      5) ldfld (Opt<u4>,Opt<u4>)::_F0:Opt<u4>
      5) call static WrapFuncGen::Exec(Opt<u4>):Opt<u4>
      1) stloc.0 [Opt<u4>]
      1) ldarg.1 [(Opt<u4>,Opt<u4>)]
      5) ldfld (Opt<u4>,Opt<u4>)::_F1:Opt<u4>
      5) call static WrapFuncGen::Exec(Opt<u4>):Opt<u4>
      1) stloc.1 [Opt<u4>]
      5) newobj (bool,bool,bool,bool,bool,Opt<u4>,Opt<u4>)()
      1) dup
      2) ldloca.s [Opt<u4> (0)]
      5) call Opt<u4>::get_HasValue():bool
      2) ldloca.s [Opt<u4> (1)]
      5) call Opt<u4>::get_HasValue():bool
      5) bne.un [0]
      2) ldloca.s [Opt<u4> (0)]
      5) call Opt<u4>::GetValueOrDefault():u4
      2) ldloca.s [Opt<u4> (1)]
      5) call Opt<u4>::GetValueOrDefault():u4
      2) ceq
      5) br [1]
  Label [0]:
      1) ldc.i4.0
  Label [1]:
      5) stfld (bool,bool,bool,bool,bool,Opt<u4>,Opt<u4>)::_F0:bool
      1) dup
      2) ldloca.s [Opt<u4> (1)]
      5) call Opt<u4>::get_HasValue():bool
      5) brfalse [2]
      2) ldloca.s [Opt<u4> (0)]
      5) call Opt<u4>::get_HasValue():bool
      5) brfalse [3]
      2) ldloca.s [Opt<u4> (0)]
      5) call Opt<u4>::GetValueOrDefault():u4
      2) ldloca.s [Opt<u4> (1)]
      5) call Opt<u4>::GetValueOrDefault():u4
      2) clt.un
      5) br [4]
  Label [3]:
      1) ldc.i4.1
      5) br [4]
  Label [2]:
      1) ldc.i4.0
  Label [4]:
      5) stfld (bool,bool,bool,bool,bool,Opt<u4>,Opt<u4>)::_F1:bool
      1) dup
      2) ldloca.s [Opt<u4> (0)]
      5) call Opt<u4>::get_HasValue():bool
      5) brfalse [5]
      2) ldloca.s [Opt<u4> (1)]
      5) call Opt<u4>::get_HasValue():bool
      5) brfalse [6]
      2) ldloca.s [Opt<u4> (0)]
      5) call Opt<u4>::GetValueOrDefault():u4
      2) ldloca.s [Opt<u4> (1)]
      5) call Opt<u4>::GetValueOrDefault():u4
      2) cgt.un
      1) ldc.i4.0
      2) ceq
      5) br [7]
  Label [5]:
      1) ldc.i4.1
      5) br [7]
  Label [6]:
      1) ldc.i4.0
  Label [7]:
      5) stfld (bool,bool,bool,bool,bool,Opt<u4>,Opt<u4>)::_F2:bool
      1) dup
      2) ldloca.s [Opt<u4> (0)]
      5) call Opt<u4>::get_HasValue():bool
      5) brfalse [8]
      2) ldloca.s [Opt<u4> (1)]
      5) call Opt<u4>::get_HasValue():bool
      5) brfalse [9]
      2) ldloca.s [Opt<u4> (0)]
      5) call Opt<u4>::GetValueOrDefault():u4
      2) ldloca.s [Opt<u4> (1)]
      5) call Opt<u4>::GetValueOrDefault():u4
      2) cgt.un
      5) br [10]
  Label [9]:
      1) ldc.i4.1
      5) br [10]
  Label [8]:
      1) ldc.i4.0
  Label [10]:
      5) stfld (bool,bool,bool,bool,bool,Opt<u4>,Opt<u4>)::_F3:bool
      1) dup
      2) ldloca.s [Opt<u4> (1)]
      5) call Opt<u4>::get_HasValue():bool
      5) brfalse [11]
      2) ldloca.s [Opt<u4> (0)]
      5) call Opt<u4>::get_HasValue():bool
      5) brfalse [12]
      2) ldloca.s [Opt<u4> (0)]
      5) call Opt<u4>::GetValueOrDefault():u4
      2) ldloca.s [Opt<u4> (1)]
      5) call Opt<u4>::GetValueOrDefault():u4
      2) clt.un
      1) ldc.i4.0
      2) ceq
      5) br [13]
  Label [11]:
      1) ldc.i4.1
      5) br [13]
  Label [12]:
      1) ldc.i4.0
  Label [13]:
      5) stfld (bool,bool,bool,bool,bool,Opt<u4>,Opt<u4>)::_F4:bool
      1) dup
      1) ldloc.0 [Opt<u4>]
      5) stfld (bool,bool,bool,bool,bool,Opt<u4>,Opt<u4>)::_F5:Opt<u4>
      1) dup
      1) ldloc.1 [Opt<u4>]
      5) stfld (bool,bool,bool,bool,bool,Opt<u4>,Opt<u4>)::_F6:Opt<u4>
      1) ret
  Total Size: 329

Func sig: (<ctx>:x, xu4q:u4?*, yu4q:u4?*) to (s, s, u4?, u4?)*
Sequence: Seq<(str,str,Opt<u4>,Opt<u4>)>
 0) (M_M_M, EQ, <null>, <null>)
 1) (_MM__, LT, <null>, 0)
 2) (_MM__, LT, <null>, 3)
 3) (_MM__, LT, <null>, 5)
 4) (___MM, GT, 0, <null>)
 5) (M_M_M, EQ, 0, 0)
 6) (_MM__, LT, 0, 3)
 7) (_MM__, LT, 0, 5)
 8) (___MM, GT, 3, <null>)
 9) (___MM, GT, 3, 0)
10) (M_M_M, EQ, 3, 3)
11) (_MM__, LT, 3, 5)
12) (___MM, GT, 5, <null>)
13) (___MM, GT, 5, 0)
14) (___MM, GT, 5, 3)
15) (M_M_M, EQ, 5, 5)
*** Ctx ping count: 5
    [0](5): ChainMap(*1: xu4q, ForEach(*2: yu4q, (*1, *2)))
###
> G(xd_q, yd_q)
G(xd_q, yd_q) : (s, s, d?, d?)*
BndKind:Call, Type:(s, s, d?, d?)*, Bnd:(Call(∂.ForEach([map:6] Call(∂.Test.Wrap(Call(∂.ForEach([map:3] Call(∂.Test.Wrap(Call(∂.ChainMap([map:1] Global(xd_q), Call(∂.ForEach([map:2] Global(yd_q), (Scope(1), Scope(2)):(d?, d?)):(d?, d?)*)):(d?, d?)*)):(d?, d?)*), Call(∂.With([with:4] Call(∂.Test.Wrap(GetSlot(Scope(3), 0)):d?), [with:5] Call(∂.Test.Wrap(GetSlot(Scope(3), 1)):d?), (Cmp(Scope(4) @= Scope(5)), Cmp(Scope(4) @< Scope(5)), Cmp(Scope(4) @<= Scope(5)), Cmp(Scope(4) @> Scope(5)), Cmp(Scope(4) @>= Scope(5)), Scope(4), Scope(5)):(b, b, b, b, b, d?, d?)):(b, b, b, b, b, d?, d?))):(b, b, b, b, b, d?, d?)*)):(b, b, b, b, b, d?, d?)*), Call(∂.With([with:7] StrConcat(If(GetSlot(Scope(6), 0), str(M), str(_)), If(GetSlot(Scope(6), 1), str(M), str(_)), If(GetSlot(Scope(6), 2), str(M), str(_)), If(GetSlot(Scope(6), 3), str(M), str(_)), If(GetSlot(Scope(6), 4), str(M), str(_))), TupleConcat((Scope(7), If(Cmp(Scope(7) @= str(_____)), str(__), If(Cmp(Scope(7) @= str(M_M_M)), str(EQ), If(Cmp(Scope(7) @= str(__M__)), str(LE), If(Cmp(Scope(7) @= str(_MM__)), str(LT), If(Cmp(Scope(7) @= str(____M)), str(GE), If(Cmp(Scope(7) @= str(___MM)), str(GT), If(Cmp(Scope(7) @= str(MMMMM)), str(N___), If(Cmp(Scope(7) @= str(_M_M_)), str(N_E_), If(Cmp(Scope(7) @= str(M__MM)), str(N_L_), If(Cmp(Scope(7) @= str(MMM__)), str(N_G_), If(Cmp(Scope(7) @= str(___M_)), str(N_EL), If(Cmp(Scope(7) @= str(_M___)), str(N_EG), If(Cmp(Scope(7) @= str(M____)), str(N_LG), str(***BAD!***))))))))))))))):(s, s), GetSlice(Scope(6), 5:7:1):(d?, d?))):(s, s, d?, d?))):(s, s, d?, d?)*))
ForEach_1(Arr<obj>, (Opt<Date>,Opt<Date>)):(bool,bool,bool,bool,bool,Opt<Date>,Opt<Date>)
      1) ldarg.1 [(Opt<Date>,Opt<Date>)]
      5) ldfld (Opt<Date>,Opt<Date>)::_F0:Opt<Date>
      5) call static WrapFuncGen::Exec(Opt<Date>):Opt<Date>
      1) stloc.0 [Opt<Date>]
      1) ldarg.1 [(Opt<Date>,Opt<Date>)]
      5) ldfld (Opt<Date>,Opt<Date>)::_F1:Opt<Date>
      5) call static WrapFuncGen::Exec(Opt<Date>):Opt<Date>
      1) stloc.1 [Opt<Date>]
      5) newobj (bool,bool,bool,bool,bool,Opt<Date>,Opt<Date>)()
      1) dup
      2) ldloca.s [Opt<Date> (0)]
      5) call Opt<Date>::get_HasValue():bool
      2) ldloca.s [Opt<Date> (1)]
      5) call Opt<Date>::get_HasValue():bool
      5) bne.un [0]
      2) ldloca.s [Opt<Date> (0)]
      5) call Opt<Date>::GetValueOrDefault():Date
      2) ldloca.s [Opt<Date> (1)]
      5) call Opt<Date>::GetValueOrDefault():Date
      5) call static Date::op_Equality(Date, Date):bool
      5) br [1]
  Label [0]:
      1) ldc.i4.0
  Label [1]:
      5) stfld (bool,bool,bool,bool,bool,Opt<Date>,Opt<Date>)::_F0:bool
      1) dup
      2) ldloca.s [Opt<Date> (1)]
      5) call Opt<Date>::get_HasValue():bool
      5) brfalse [2]
      2) ldloca.s [Opt<Date> (0)]
      5) call Opt<Date>::get_HasValue():bool
      5) brfalse [3]
      2) ldloca.s [Opt<Date> (0)]
      5) call Opt<Date>::GetValueOrDefault():Date
      2) ldloca.s [Opt<Date> (1)]
      5) call Opt<Date>::GetValueOrDefault():Date
      5) call static Date::op_LessThan(Date, Date):bool
      5) br [4]
  Label [3]:
      1) ldc.i4.1
      5) br [4]
  Label [2]:
      1) ldc.i4.0
  Label [4]:
      5) stfld (bool,bool,bool,bool,bool,Opt<Date>,Opt<Date>)::_F1:bool
      1) dup
      2) ldloca.s [Opt<Date> (0)]
      5) call Opt<Date>::get_HasValue():bool
      5) brfalse [5]
      2) ldloca.s [Opt<Date> (1)]
      5) call Opt<Date>::get_HasValue():bool
      5) brfalse [6]
      2) ldloca.s [Opt<Date> (0)]
      5) call Opt<Date>::GetValueOrDefault():Date
      2) ldloca.s [Opt<Date> (1)]
      5) call Opt<Date>::GetValueOrDefault():Date
      5) call static Date::op_LessThanOrEqual(Date, Date):bool
      5) br [7]
  Label [5]:
      1) ldc.i4.1
      5) br [7]
  Label [6]:
      1) ldc.i4.0
  Label [7]:
      5) stfld (bool,bool,bool,bool,bool,Opt<Date>,Opt<Date>)::_F2:bool
      1) dup
      2) ldloca.s [Opt<Date> (0)]
      5) call Opt<Date>::get_HasValue():bool
      5) brfalse [8]
      2) ldloca.s [Opt<Date> (1)]
      5) call Opt<Date>::get_HasValue():bool
      5) brfalse [9]
      2) ldloca.s [Opt<Date> (0)]
      5) call Opt<Date>::GetValueOrDefault():Date
      2) ldloca.s [Opt<Date> (1)]
      5) call Opt<Date>::GetValueOrDefault():Date
      5) call static Date::op_GreaterThan(Date, Date):bool
      5) br [10]
  Label [9]:
      1) ldc.i4.1
      5) br [10]
  Label [8]:
      1) ldc.i4.0
  Label [10]:
      5) stfld (bool,bool,bool,bool,bool,Opt<Date>,Opt<Date>)::_F3:bool
      1) dup
      2) ldloca.s [Opt<Date> (1)]
      5) call Opt<Date>::get_HasValue():bool
      5) brfalse [11]
      2) ldloca.s [Opt<Date> (0)]
      5) call Opt<Date>::get_HasValue():bool
      5) brfalse [12]
      2) ldloca.s [Opt<Date> (0)]
      5) call Opt<Date>::GetValueOrDefault():Date
      2) ldloca.s [Opt<Date> (1)]
      5) call Opt<Date>::GetValueOrDefault():Date
      5) call static Date::op_GreaterThanOrEqual(Date, Date):bool
      5) br [13]
  Label [11]:
      1) ldc.i4.1
      5) br [13]
  Label [12]:
      1) ldc.i4.0
  Label [13]:
      5) stfld (bool,bool,bool,bool,bool,Opt<Date>,Opt<Date>)::_F4:bool
      1) dup
      1) ldloc.0 [Opt<Date>]
      5) stfld (bool,bool,bool,bool,bool,Opt<Date>,Opt<Date>)::_F5:Opt<Date>
      1) dup
      1) ldloc.1 [Opt<Date>]
      5) stfld (bool,bool,bool,bool,bool,Opt<Date>,Opt<Date>)::_F6:Opt<Date>
      1) ret
  Total Size: 338

Func sig: (<ctx>:x, xd_q:d?*, yd_q:d?*) to (s, s, d?, d?)*
Sequence: Seq<(str,str,Opt<Date>,Opt<Date>)>
 0) (M_M_M, EQ, <null>, <null>)
 1) (_MM__, LT, <null>, DT(1900, 1, 1, 0, 0, 0, 0))
 2) (_MM__, LT, <null>, DT(2023, 7, 1, 0, 0, 0, 0))
 3) (_MM__, LT, <null>, DT(2023, 9, 1, 0, 0, 0, 0))
 4) (___MM, GT, DT(1900, 1, 1, 0, 0, 0, 0), <null>)
 5) (M_M_M, EQ, DT(1900, 1, 1, 0, 0, 0, 0), DT(1900, 1, 1, 0, 0, 0, 0))
 6) (_MM__, LT, DT(1900, 1, 1, 0, 0, 0, 0), DT(2023, 7, 1, 0, 0, 0, 0))
 7) (_MM__, LT, DT(1900, 1, 1, 0, 0, 0, 0), DT(2023, 9, 1, 0, 0, 0, 0))
 8) (___MM, GT, DT(2023, 7, 1, 0, 0, 0, 0), <null>)
 9) (___MM, GT, DT(2023, 7, 1, 0, 0, 0, 0), DT(1900, 1, 1, 0, 0, 0, 0))
10) (M_M_M, EQ, DT(2023, 7, 1, 0, 0, 0, 0), DT(2023, 7, 1, 0, 0, 0, 0))
11) (_MM__, LT, DT(2023, 7, 1, 0, 0, 0, 0), DT(2023, 9, 1, 0, 0, 0, 0))
12) (___MM, GT, DT(2023, 9, 1, 0, 0, 0, 0), <null>)
13) (___MM, GT, DT(2023, 9, 1, 0, 0, 0, 0), DT(1900, 1, 1, 0, 0, 0, 0))
14) (___MM, GT, DT(2023, 9, 1, 0, 0, 0, 0), DT(2023, 7, 1, 0, 0, 0, 0))
15) (M_M_M, EQ, DT(2023, 9, 1, 0, 0, 0, 0), DT(2023, 9, 1, 0, 0, 0, 0))
*** Ctx ping count: 5
    [0](5): ChainMap(*1: xd_q, ForEach(*2: yd_q, (*1, *2)))
###
> G(xt_q, yt_q)
G(xt_q, yt_q) : (s, s, t?, t?)*
BndKind:Call, Type:(s, s, t?, t?)*, Bnd:(Call(∂.ForEach([map:6] Call(∂.Test.Wrap(Call(∂.ForEach([map:3] Call(∂.Test.Wrap(Call(∂.ChainMap([map:1] Global(xt_q), Call(∂.ForEach([map:2] Global(yt_q), (Scope(1), Scope(2)):(t?, t?)):(t?, t?)*)):(t?, t?)*)):(t?, t?)*), Call(∂.With([with:4] Call(∂.Test.Wrap(GetSlot(Scope(3), 0)):t?), [with:5] Call(∂.Test.Wrap(GetSlot(Scope(3), 1)):t?), (Cmp(Scope(4) @= Scope(5)), Cmp(Scope(4) @< Scope(5)), Cmp(Scope(4) @<= Scope(5)), Cmp(Scope(4) @> Scope(5)), Cmp(Scope(4) @>= Scope(5)), Scope(4), Scope(5)):(b, b, b, b, b, t?, t?)):(b, b, b, b, b, t?, t?))):(b, b, b, b, b, t?, t?)*)):(b, b, b, b, b, t?, t?)*), Call(∂.With([with:7] StrConcat(If(GetSlot(Scope(6), 0), str(M), str(_)), If(GetSlot(Scope(6), 1), str(M), str(_)), If(GetSlot(Scope(6), 2), str(M), str(_)), If(GetSlot(Scope(6), 3), str(M), str(_)), If(GetSlot(Scope(6), 4), str(M), str(_))), TupleConcat((Scope(7), If(Cmp(Scope(7) @= str(_____)), str(__), If(Cmp(Scope(7) @= str(M_M_M)), str(EQ), If(Cmp(Scope(7) @= str(__M__)), str(LE), If(Cmp(Scope(7) @= str(_MM__)), str(LT), If(Cmp(Scope(7) @= str(____M)), str(GE), If(Cmp(Scope(7) @= str(___MM)), str(GT), If(Cmp(Scope(7) @= str(MMMMM)), str(N___), If(Cmp(Scope(7) @= str(_M_M_)), str(N_E_), If(Cmp(Scope(7) @= str(M__MM)), str(N_L_), If(Cmp(Scope(7) @= str(MMM__)), str(N_G_), If(Cmp(Scope(7) @= str(___M_)), str(N_EL), If(Cmp(Scope(7) @= str(_M___)), str(N_EG), If(Cmp(Scope(7) @= str(M____)), str(N_LG), str(***BAD!***))))))))))))))):(s, s), GetSlice(Scope(6), 5:7:1):(t?, t?))):(s, s, t?, t?))):(s, s, t?, t?)*))
ForEach_1(Arr<obj>, (Opt<Time>,Opt<Time>)):(bool,bool,bool,bool,bool,Opt<Time>,Opt<Time>)
      1) ldarg.1 [(Opt<Time>,Opt<Time>)]
      5) ldfld (Opt<Time>,Opt<Time>)::_F0:Opt<Time>
      5) call static WrapFuncGen::Exec(Opt<Time>):Opt<Time>
      1) stloc.0 [Opt<Time>]
      1) ldarg.1 [(Opt<Time>,Opt<Time>)]
      5) ldfld (Opt<Time>,Opt<Time>)::_F1:Opt<Time>
      5) call static WrapFuncGen::Exec(Opt<Time>):Opt<Time>
      1) stloc.1 [Opt<Time>]
      5) newobj (bool,bool,bool,bool,bool,Opt<Time>,Opt<Time>)()
      1) dup
      2) ldloca.s [Opt<Time> (0)]
      5) call Opt<Time>::get_HasValue():bool
      2) ldloca.s [Opt<Time> (1)]
      5) call Opt<Time>::get_HasValue():bool
      5) bne.un [0]
      2) ldloca.s [Opt<Time> (0)]
      5) call Opt<Time>::GetValueOrDefault():Time
      2) ldloca.s [Opt<Time> (1)]
      5) call Opt<Time>::GetValueOrDefault():Time
      5) call static Time::op_Equality(Time, Time):bool
      5) br [1]
  Label [0]:
      1) ldc.i4.0
  Label [1]:
      5) stfld (bool,bool,bool,bool,bool,Opt<Time>,Opt<Time>)::_F0:bool
      1) dup
      2) ldloca.s [Opt<Time> (1)]
      5) call Opt<Time>::get_HasValue():bool
      5) brfalse [2]
      2) ldloca.s [Opt<Time> (0)]
      5) call Opt<Time>::get_HasValue():bool
      5) brfalse [3]
      2) ldloca.s [Opt<Time> (0)]
      5) call Opt<Time>::GetValueOrDefault():Time
      2) ldloca.s [Opt<Time> (1)]
      5) call Opt<Time>::GetValueOrDefault():Time
      5) call static Time::op_LessThan(Time, Time):bool
      5) br [4]
  Label [3]:
      1) ldc.i4.1
      5) br [4]
  Label [2]:
      1) ldc.i4.0
  Label [4]:
      5) stfld (bool,bool,bool,bool,bool,Opt<Time>,Opt<Time>)::_F1:bool
      1) dup
      2) ldloca.s [Opt<Time> (0)]
      5) call Opt<Time>::get_HasValue():bool
      5) brfalse [5]
      2) ldloca.s [Opt<Time> (1)]
      5) call Opt<Time>::get_HasValue():bool
      5) brfalse [6]
      2) ldloca.s [Opt<Time> (0)]
      5) call Opt<Time>::GetValueOrDefault():Time
      2) ldloca.s [Opt<Time> (1)]
      5) call Opt<Time>::GetValueOrDefault():Time
      5) call static Time::op_LessThanOrEqual(Time, Time):bool
      5) br [7]
  Label [5]:
      1) ldc.i4.1
      5) br [7]
  Label [6]:
      1) ldc.i4.0
  Label [7]:
      5) stfld (bool,bool,bool,bool,bool,Opt<Time>,Opt<Time>)::_F2:bool
      1) dup
      2) ldloca.s [Opt<Time> (0)]
      5) call Opt<Time>::get_HasValue():bool
      5) brfalse [8]
      2) ldloca.s [Opt<Time> (1)]
      5) call Opt<Time>::get_HasValue():bool
      5) brfalse [9]
      2) ldloca.s [Opt<Time> (0)]
      5) call Opt<Time>::GetValueOrDefault():Time
      2) ldloca.s [Opt<Time> (1)]
      5) call Opt<Time>::GetValueOrDefault():Time
      5) call static Time::op_GreaterThan(Time, Time):bool
      5) br [10]
  Label [9]:
      1) ldc.i4.1
      5) br [10]
  Label [8]:
      1) ldc.i4.0
  Label [10]:
      5) stfld (bool,bool,bool,bool,bool,Opt<Time>,Opt<Time>)::_F3:bool
      1) dup
      2) ldloca.s [Opt<Time> (1)]
      5) call Opt<Time>::get_HasValue():bool
      5) brfalse [11]
      2) ldloca.s [Opt<Time> (0)]
      5) call Opt<Time>::get_HasValue():bool
      5) brfalse [12]
      2) ldloca.s [Opt<Time> (0)]
      5) call Opt<Time>::GetValueOrDefault():Time
      2) ldloca.s [Opt<Time> (1)]
      5) call Opt<Time>::GetValueOrDefault():Time
      5) call static Time::op_GreaterThanOrEqual(Time, Time):bool
      5) br [13]
  Label [11]:
      1) ldc.i4.1
      5) br [13]
  Label [12]:
      1) ldc.i4.0
  Label [13]:
      5) stfld (bool,bool,bool,bool,bool,Opt<Time>,Opt<Time>)::_F4:bool
      1) dup
      1) ldloc.0 [Opt<Time>]
      5) stfld (bool,bool,bool,bool,bool,Opt<Time>,Opt<Time>)::_F5:Opt<Time>
      1) dup
      1) ldloc.1 [Opt<Time>]
      5) stfld (bool,bool,bool,bool,bool,Opt<Time>,Opt<Time>)::_F6:Opt<Time>
      1) ret
  Total Size: 338

Func sig: (<ctx>:x, xt_q:t?*, yt_q:t?*) to (s, s, t?, t?)*
Sequence: Seq<(str,str,Opt<Time>,Opt<Time>)>
 0) (M_M_M, EQ, <null>, <null>)
 1) (_MM__, LT, <null>, -2.00:00:00)
 2) (_MM__, LT, <null>, 00:00:00)
 3) (_MM__, LT, <null>, 3.00:00:00)
 4) (___MM, GT, -2.00:00:00, <null>)
 5) (M_M_M, EQ, -2.00:00:00, -2.00:00:00)
 6) (_MM__, LT, -2.00:00:00, 00:00:00)
 7) (_MM__, LT, -2.00:00:00, 3.00:00:00)
 8) (___MM, GT, 00:00:00, <null>)
 9) (___MM, GT, 00:00:00, -2.00:00:00)
10) (M_M_M, EQ, 00:00:00, 00:00:00)
11) (_MM__, LT, 00:00:00, 3.00:00:00)
12) (___MM, GT, 3.00:00:00, <null>)
13) (___MM, GT, 3.00:00:00, -2.00:00:00)
14) (___MM, GT, 3.00:00:00, 00:00:00)
15) (M_M_M, EQ, 3.00:00:00, 3.00:00:00)
*** Ctx ping count: 5
    [0](5): ChainMap(*1: xt_q, ForEach(*2: yt_q, (*1, *2)))
###
