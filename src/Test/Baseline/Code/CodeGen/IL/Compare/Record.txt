**** New definitions: RA, type: {X:i8, Y:s}
**** New definitions: QA, type: {X:i8, Y:s}?
**** New definitions: NA, type: {X:i8, Y:s}?
**** New definitions: RBs, type: {X:i8, Y:s}*
**** New definitions: QBs, type: {X:i8, Y:s}?*
**** New definitions: RCs, type: {X:i8, Y:s}*
**** New definitions: __IL_Func_Ind, type: i8

> RA   = RBs
RA @= RBs : b*
BndKind:Call, Type:b*, Bnd:(Call(∂.ForEach([map:1] Global(RBs), Cmp(Global(RA) @= Scope(1))):b*))
// (∂.RBs:{X:i8, Y:s}*, ∂.RA:{X:i8, Y:s}) : b*
ForEach_1(Arr<obj>, {i8,str}):bool
      1) ldarg.0 [Arr<obj>]
      1) ldc.i4.2
      5) ldelem [({i8,str})]
      5) ldfld ({i8,str})::_F0:{i8,str}
      1) ldarg.1 [{i8,str}]
      5) call static {i8,str}::Equals2({i8,str}, {i8,str}):bool
      1) ret
  Total Size: 19

Func sig: (RBs:{X:i8, Y:s}*, RA:{X:i8, Y:s}) to b*
Sequence: Seq<bool>
 0) true 
 1) false
 2) false
 3) false
###
> RA   = QBs
RA @= QBs : b*
BndKind:Call, Type:b*, Bnd:(Call(∂.ForEach([map:1] Global(QBs), Cmp(Global(RA) @= Scope(1))):b*))
// (∂.QBs:{X:i8, Y:s}?*, ∂.RA:{X:i8, Y:s}) : b*
ForEach_1(Arr<obj>, {i8,str}):bool
      1) ldarg.0 [Arr<obj>]
      1) ldc.i4.2
      5) ldelem [({i8,str})]
      5) ldfld ({i8,str})::_F0:{i8,str}
      1) ldarg.1 [{i8,str}]
      5) call static {i8,str}::Equals2({i8,str}, {i8,str}):bool
      1) ret
  Total Size: 19

Func sig: (QBs:{X:i8, Y:s}?*, RA:{X:i8, Y:s}) to b*
Sequence: Seq<bool>
 0) true 
 1) false
 2) false
 3) false
 4) false
###
> QA   = RBs
QA @= RBs : b*
BndKind:Call, Type:b*, Bnd:(Call(∂.ForEach([map:1] Global(RBs), Cmp(Global(QA) @= Scope(1))):b*))
// (∂.RBs:{X:i8, Y:s}*, ∂.QA:{X:i8, Y:s}?) : b*
ForEach_1(Arr<obj>, {i8,str}):bool
      1) ldarg.0 [Arr<obj>]
      1) ldc.i4.2
      5) ldelem [({i8,str})]
      5) ldfld ({i8,str})::_F0:{i8,str}
      1) ldarg.1 [{i8,str}]
      5) call static {i8,str}::Equals2({i8,str}, {i8,str}):bool
      1) ret
  Total Size: 19

Func sig: (RBs:{X:i8, Y:s}*, QA:{X:i8, Y:s}?) to b*
Sequence: Seq<bool>
 0) true 
 1) false
 2) false
 3) false
###
> QA   = QBs
QA @= QBs : b*
BndKind:Call, Type:b*, Bnd:(Call(∂.ForEach([map:1] Global(QBs), Cmp(Global(QA) @= Scope(1))):b*))
// (∂.QBs:{X:i8, Y:s}?*, ∂.QA:{X:i8, Y:s}?) : b*
ForEach_1(Arr<obj>, {i8,str}):bool
      1) ldarg.0 [Arr<obj>]
      1) ldc.i4.2
      5) ldelem [({i8,str})]
      5) ldfld ({i8,str})::_F0:{i8,str}
      1) ldarg.1 [{i8,str}]
      5) call static {i8,str}::Equals2({i8,str}, {i8,str}):bool
      1) ret
  Total Size: 19

Func sig: (QBs:{X:i8, Y:s}?*, QA:{X:i8, Y:s}?) to b*
Sequence: Seq<bool>
 0) true 
 1) false
 2) false
 3) false
 4) false
###
> NA   = RBs
NA @= RBs : b*
BndKind:Call, Type:b*, Bnd:(Call(∂.ForEach([map:1] Global(RBs), Cmp(Global(NA) @= Scope(1))):b*))
// (∂.RBs:{X:i8, Y:s}*, ∂.NA:{X:i8, Y:s}?) : b*
ForEach_1(Arr<obj>, {i8,str}):bool
      1) ldarg.0 [Arr<obj>]
      1) ldc.i4.2
      5) ldelem [({i8,str})]
      5) ldfld ({i8,str})::_F0:{i8,str}
      1) ldarg.1 [{i8,str}]
      5) call static {i8,str}::Equals2({i8,str}, {i8,str}):bool
      1) ret
  Total Size: 19

Func sig: (RBs:{X:i8, Y:s}*, NA:{X:i8, Y:s}?) to b*
Sequence: Seq<bool>
 0) false
 1) false
 2) false
 3) false
###
> NA   = QBs
NA @= QBs : b*
BndKind:Call, Type:b*, Bnd:(Call(∂.ForEach([map:1] Global(QBs), Cmp(Global(NA) @= Scope(1))):b*))
// (∂.QBs:{X:i8, Y:s}?*, ∂.NA:{X:i8, Y:s}?) : b*
ForEach_1(Arr<obj>, {i8,str}):bool
      1) ldarg.0 [Arr<obj>]
      1) ldc.i4.2
      5) ldelem [({i8,str})]
      5) ldfld ({i8,str})::_F0:{i8,str}
      1) ldarg.1 [{i8,str}]
      5) call static {i8,str}::Equals2({i8,str}, {i8,str}):bool
      1) ret
  Total Size: 19

Func sig: (QBs:{X:i8, Y:s}?*, NA:{X:i8, Y:s}?) to b*
Sequence: Seq<bool>
 0) false
 1) false
 2) false
 3) false
 4) true 
###
> RA ! = RBs
RA !@= RBs : b*
BndKind:Call, Type:b*, Bnd:(Call(∂.ForEach([map:1] Global(RBs), Cmp(Global(RA) !@= Scope(1))):b*))
// (∂.RBs:{X:i8, Y:s}*, ∂.RA:{X:i8, Y:s}) : b*
ForEach_1(Arr<obj>, {i8,str}):bool
      1) ldarg.0 [Arr<obj>]
      1) ldc.i4.2
      5) ldelem [({i8,str})]
      5) ldfld ({i8,str})::_F0:{i8,str}
      1) ldarg.1 [{i8,str}]
      5) call static {i8,str}::Equals2({i8,str}, {i8,str}):bool
      1) ldc.i4.0
      2) ceq
      1) ret
  Total Size: 22

Func sig: (RBs:{X:i8, Y:s}*, RA:{X:i8, Y:s}) to b*
Sequence: Seq<bool>
 0) false
 1) true 
 2) true 
 3) true 
###
> RA ! = QBs
RA !@= QBs : b*
BndKind:Call, Type:b*, Bnd:(Call(∂.ForEach([map:1] Global(QBs), Cmp(Global(RA) !@= Scope(1))):b*))
// (∂.QBs:{X:i8, Y:s}?*, ∂.RA:{X:i8, Y:s}) : b*
ForEach_1(Arr<obj>, {i8,str}):bool
      1) ldarg.0 [Arr<obj>]
      1) ldc.i4.2
      5) ldelem [({i8,str})]
      5) ldfld ({i8,str})::_F0:{i8,str}
      1) ldarg.1 [{i8,str}]
      5) call static {i8,str}::Equals2({i8,str}, {i8,str}):bool
      1) ldc.i4.0
      2) ceq
      1) ret
  Total Size: 22

Func sig: (QBs:{X:i8, Y:s}?*, RA:{X:i8, Y:s}) to b*
Sequence: Seq<bool>
 0) false
 1) true 
 2) true 
 3) true 
 4) true 
###
> QA ! = RBs
QA !@= RBs : b*
BndKind:Call, Type:b*, Bnd:(Call(∂.ForEach([map:1] Global(RBs), Cmp(Global(QA) !@= Scope(1))):b*))
// (∂.RBs:{X:i8, Y:s}*, ∂.QA:{X:i8, Y:s}?) : b*
ForEach_1(Arr<obj>, {i8,str}):bool
      1) ldarg.0 [Arr<obj>]
      1) ldc.i4.2
      5) ldelem [({i8,str})]
      5) ldfld ({i8,str})::_F0:{i8,str}
      1) ldarg.1 [{i8,str}]
      5) call static {i8,str}::Equals2({i8,str}, {i8,str}):bool
      1) ldc.i4.0
      2) ceq
      1) ret
  Total Size: 22

Func sig: (RBs:{X:i8, Y:s}*, QA:{X:i8, Y:s}?) to b*
Sequence: Seq<bool>
 0) false
 1) true 
 2) true 
 3) true 
###
> QA ! = QBs
QA !@= QBs : b*
BndKind:Call, Type:b*, Bnd:(Call(∂.ForEach([map:1] Global(QBs), Cmp(Global(QA) !@= Scope(1))):b*))
// (∂.QBs:{X:i8, Y:s}?*, ∂.QA:{X:i8, Y:s}?) : b*
ForEach_1(Arr<obj>, {i8,str}):bool
      1) ldarg.0 [Arr<obj>]
      1) ldc.i4.2
      5) ldelem [({i8,str})]
      5) ldfld ({i8,str})::_F0:{i8,str}
      1) ldarg.1 [{i8,str}]
      5) call static {i8,str}::Equals2({i8,str}, {i8,str}):bool
      1) ldc.i4.0
      2) ceq
      1) ret
  Total Size: 22

Func sig: (QBs:{X:i8, Y:s}?*, QA:{X:i8, Y:s}?) to b*
Sequence: Seq<bool>
 0) false
 1) true 
 2) true 
 3) true 
 4) true 
###
> NA ! = RBs
NA !@= RBs : b*
BndKind:Call, Type:b*, Bnd:(Call(∂.ForEach([map:1] Global(RBs), Cmp(Global(NA) !@= Scope(1))):b*))
// (∂.RBs:{X:i8, Y:s}*, ∂.NA:{X:i8, Y:s}?) : b*
ForEach_1(Arr<obj>, {i8,str}):bool
      1) ldarg.0 [Arr<obj>]
      1) ldc.i4.2
      5) ldelem [({i8,str})]
      5) ldfld ({i8,str})::_F0:{i8,str}
      1) ldarg.1 [{i8,str}]
      5) call static {i8,str}::Equals2({i8,str}, {i8,str}):bool
      1) ldc.i4.0
      2) ceq
      1) ret
  Total Size: 22

Func sig: (RBs:{X:i8, Y:s}*, NA:{X:i8, Y:s}?) to b*
Sequence: Seq<bool>
 0) true 
 1) true 
 2) true 
 3) true 
###
> NA ! = QBs
NA !@= QBs : b*
BndKind:Call, Type:b*, Bnd:(Call(∂.ForEach([map:1] Global(QBs), Cmp(Global(NA) !@= Scope(1))):b*))
// (∂.QBs:{X:i8, Y:s}?*, ∂.NA:{X:i8, Y:s}?) : b*
ForEach_1(Arr<obj>, {i8,str}):bool
      1) ldarg.0 [Arr<obj>]
      1) ldc.i4.2
      5) ldelem [({i8,str})]
      5) ldfld ({i8,str})::_F0:{i8,str}
      1) ldarg.1 [{i8,str}]
      5) call static {i8,str}::Equals2({i8,str}, {i8,str}):bool
      1) ldc.i4.0
      2) ceq
      1) ret
  Total Size: 22

Func sig: (QBs:{X:i8, Y:s}?*, NA:{X:i8, Y:s}?) to b*
Sequence: Seq<bool>
 0) true 
 1) true 
 2) true 
 3) true 
 4) false
###
> RA  ~= RBs
RA ~@= RBs : b*
BndKind:Call, Type:b*, Bnd:(Call(∂.ForEach([map:1] Global(RBs), Cmp(Global(RA) ~@= Scope(1))):b*))
// (∂.RBs:{X:i8, Y:s}*, ∂.RA:{X:i8, Y:s}) : b*
ForEach_1(Arr<obj>, {i8,str}):bool
      1) ldarg.0 [Arr<obj>]
      1) ldc.i4.0
      5) ldelem [Arr<obj>]
      1) ldc.i4.0
      5) ldelem [EqualityComparer<{i8,str}>]
      1) ldarg.0 [Arr<obj>]
      1) ldc.i4.2
      5) ldelem [({i8,str})]
      5) ldfld ({i8,str})::_F0:{i8,str}
      1) ldarg.1 [{i8,str}]
      5) callvirt EqualityComparer<{i8,str}>::Equals({i8,str}, {i8,str}):bool
      1) ret
  Total Size: 32

Func sig: (RBs:{X:i8, Y:s}*, RA:{X:i8, Y:s}) to b*
Sequence: Seq<bool>
 0) true 
 1) false
 2) true 
 3) false
###
> RA  ~= QBs
RA ~@= QBs : b*
BndKind:Call, Type:b*, Bnd:(Call(∂.ForEach([map:1] Global(QBs), Cmp(Global(RA) ~@= Scope(1))):b*))
// (∂.QBs:{X:i8, Y:s}?*, ∂.RA:{X:i8, Y:s}) : b*
ForEach_1(Arr<obj>, {i8,str}):bool
      1) ldarg.0 [Arr<obj>]
      1) ldc.i4.0
      5) ldelem [Arr<obj>]
      1) ldc.i4.0
      5) ldelem [EqualityComparer<{i8,str}>]
      1) ldarg.0 [Arr<obj>]
      1) ldc.i4.2
      5) ldelem [({i8,str})]
      5) ldfld ({i8,str})::_F0:{i8,str}
      1) ldarg.1 [{i8,str}]
      5) callvirt EqualityComparer<{i8,str}>::Equals({i8,str}, {i8,str}):bool
      1) ret
  Total Size: 32

Func sig: (QBs:{X:i8, Y:s}?*, RA:{X:i8, Y:s}) to b*
Sequence: Seq<bool>
 0) true 
 1) false
 2) true 
 3) false
 4) false
###
> QA  ~= RBs
QA ~@= RBs : b*
BndKind:Call, Type:b*, Bnd:(Call(∂.ForEach([map:1] Global(RBs), Cmp(Global(QA) ~@= Scope(1))):b*))
// (∂.RBs:{X:i8, Y:s}*, ∂.QA:{X:i8, Y:s}?) : b*
ForEach_1(Arr<obj>, {i8,str}):bool
      1) ldarg.0 [Arr<obj>]
      1) ldc.i4.0
      5) ldelem [Arr<obj>]
      1) ldc.i4.0
      5) ldelem [EqualityComparer<{i8,str}>]
      1) ldarg.0 [Arr<obj>]
      1) ldc.i4.2
      5) ldelem [({i8,str})]
      5) ldfld ({i8,str})::_F0:{i8,str}
      1) ldarg.1 [{i8,str}]
      5) callvirt EqualityComparer<{i8,str}>::Equals({i8,str}, {i8,str}):bool
      1) ret
  Total Size: 32

Func sig: (RBs:{X:i8, Y:s}*, QA:{X:i8, Y:s}?) to b*
Sequence: Seq<bool>
 0) true 
 1) false
 2) true 
 3) false
###
> QA  ~= QBs
QA ~@= QBs : b*
BndKind:Call, Type:b*, Bnd:(Call(∂.ForEach([map:1] Global(QBs), Cmp(Global(QA) ~@= Scope(1))):b*))
// (∂.QBs:{X:i8, Y:s}?*, ∂.QA:{X:i8, Y:s}?) : b*
ForEach_1(Arr<obj>, {i8,str}):bool
      1) ldarg.0 [Arr<obj>]
      1) ldc.i4.0
      5) ldelem [Arr<obj>]
      1) ldc.i4.0
      5) ldelem [EqualityComparer<{i8,str}>]
      1) ldarg.0 [Arr<obj>]
      1) ldc.i4.2
      5) ldelem [({i8,str})]
      5) ldfld ({i8,str})::_F0:{i8,str}
      1) ldarg.1 [{i8,str}]
      5) callvirt EqualityComparer<{i8,str}>::Equals({i8,str}, {i8,str}):bool
      1) ret
  Total Size: 32

Func sig: (QBs:{X:i8, Y:s}?*, QA:{X:i8, Y:s}?) to b*
Sequence: Seq<bool>
 0) true 
 1) false
 2) true 
 3) false
 4) false
###
> NA  ~= RBs
NA ~@= RBs : b*
BndKind:Call, Type:b*, Bnd:(Call(∂.ForEach([map:1] Global(RBs), Cmp(Global(NA) ~@= Scope(1))):b*))
// (∂.RBs:{X:i8, Y:s}*, ∂.NA:{X:i8, Y:s}?) : b*
ForEach_1(Arr<obj>, {i8,str}):bool
      1) ldarg.0 [Arr<obj>]
      1) ldc.i4.0
      5) ldelem [Arr<obj>]
      1) ldc.i4.0
      5) ldelem [EqualityComparer<{i8,str}>]
      1) ldarg.0 [Arr<obj>]
      1) ldc.i4.2
      5) ldelem [({i8,str})]
      5) ldfld ({i8,str})::_F0:{i8,str}
      1) ldarg.1 [{i8,str}]
      5) callvirt EqualityComparer<{i8,str}>::Equals({i8,str}, {i8,str}):bool
      1) ret
  Total Size: 32

Func sig: (RBs:{X:i8, Y:s}*, NA:{X:i8, Y:s}?) to b*
Sequence: Seq<bool>
 0) false
 1) false
 2) false
 3) false
###
> NA  ~= QBs
NA ~@= QBs : b*
BndKind:Call, Type:b*, Bnd:(Call(∂.ForEach([map:1] Global(QBs), Cmp(Global(NA) ~@= Scope(1))):b*))
// (∂.QBs:{X:i8, Y:s}?*, ∂.NA:{X:i8, Y:s}?) : b*
ForEach_1(Arr<obj>, {i8,str}):bool
      1) ldarg.0 [Arr<obj>]
      1) ldc.i4.0
      5) ldelem [Arr<obj>]
      1) ldc.i4.0
      5) ldelem [EqualityComparer<{i8,str}>]
      1) ldarg.0 [Arr<obj>]
      1) ldc.i4.2
      5) ldelem [({i8,str})]
      5) ldfld ({i8,str})::_F0:{i8,str}
      1) ldarg.1 [{i8,str}]
      5) callvirt EqualityComparer<{i8,str}>::Equals({i8,str}, {i8,str}):bool
      1) ret
  Total Size: 32

Func sig: (QBs:{X:i8, Y:s}?*, NA:{X:i8, Y:s}?) to b*
Sequence: Seq<bool>
 0) false
 1) false
 2) false
 3) false
 4) true 
###
> RA !~= RBs
RA !~@= RBs : b*
BndKind:Call, Type:b*, Bnd:(Call(∂.ForEach([map:1] Global(RBs), Cmp(Global(RA) !~@= Scope(1))):b*))
// (∂.RBs:{X:i8, Y:s}*, ∂.RA:{X:i8, Y:s}) : b*
ForEach_1(Arr<obj>, {i8,str}):bool
      1) ldarg.0 [Arr<obj>]
      1) ldc.i4.0
      5) ldelem [Arr<obj>]
      1) ldc.i4.0
      5) ldelem [EqualityComparer<{i8,str}>]
      1) ldarg.0 [Arr<obj>]
      1) ldc.i4.2
      5) ldelem [({i8,str})]
      5) ldfld ({i8,str})::_F0:{i8,str}
      1) ldarg.1 [{i8,str}]
      5) callvirt EqualityComparer<{i8,str}>::Equals({i8,str}, {i8,str}):bool
      1) ldc.i4.0
      2) ceq
      1) ret
  Total Size: 35

Func sig: (RBs:{X:i8, Y:s}*, RA:{X:i8, Y:s}) to b*
Sequence: Seq<bool>
 0) false
 1) true 
 2) false
 3) true 
###
> RA !~= QBs
RA !~@= QBs : b*
BndKind:Call, Type:b*, Bnd:(Call(∂.ForEach([map:1] Global(QBs), Cmp(Global(RA) !~@= Scope(1))):b*))
// (∂.QBs:{X:i8, Y:s}?*, ∂.RA:{X:i8, Y:s}) : b*
ForEach_1(Arr<obj>, {i8,str}):bool
      1) ldarg.0 [Arr<obj>]
      1) ldc.i4.0
      5) ldelem [Arr<obj>]
      1) ldc.i4.0
      5) ldelem [EqualityComparer<{i8,str}>]
      1) ldarg.0 [Arr<obj>]
      1) ldc.i4.2
      5) ldelem [({i8,str})]
      5) ldfld ({i8,str})::_F0:{i8,str}
      1) ldarg.1 [{i8,str}]
      5) callvirt EqualityComparer<{i8,str}>::Equals({i8,str}, {i8,str}):bool
      1) ldc.i4.0
      2) ceq
      1) ret
  Total Size: 35

Func sig: (QBs:{X:i8, Y:s}?*, RA:{X:i8, Y:s}) to b*
Sequence: Seq<bool>
 0) false
 1) true 
 2) false
 3) true 
 4) true 
###
> QA !~= RBs
QA !~@= RBs : b*
BndKind:Call, Type:b*, Bnd:(Call(∂.ForEach([map:1] Global(RBs), Cmp(Global(QA) !~@= Scope(1))):b*))
// (∂.RBs:{X:i8, Y:s}*, ∂.QA:{X:i8, Y:s}?) : b*
ForEach_1(Arr<obj>, {i8,str}):bool
      1) ldarg.0 [Arr<obj>]
      1) ldc.i4.0
      5) ldelem [Arr<obj>]
      1) ldc.i4.0
      5) ldelem [EqualityComparer<{i8,str}>]
      1) ldarg.0 [Arr<obj>]
      1) ldc.i4.2
      5) ldelem [({i8,str})]
      5) ldfld ({i8,str})::_F0:{i8,str}
      1) ldarg.1 [{i8,str}]
      5) callvirt EqualityComparer<{i8,str}>::Equals({i8,str}, {i8,str}):bool
      1) ldc.i4.0
      2) ceq
      1) ret
  Total Size: 35

Func sig: (RBs:{X:i8, Y:s}*, QA:{X:i8, Y:s}?) to b*
Sequence: Seq<bool>
 0) false
 1) true 
 2) false
 3) true 
###
> QA !~= QBs
QA !~@= QBs : b*
BndKind:Call, Type:b*, Bnd:(Call(∂.ForEach([map:1] Global(QBs), Cmp(Global(QA) !~@= Scope(1))):b*))
// (∂.QBs:{X:i8, Y:s}?*, ∂.QA:{X:i8, Y:s}?) : b*
ForEach_1(Arr<obj>, {i8,str}):bool
      1) ldarg.0 [Arr<obj>]
      1) ldc.i4.0
      5) ldelem [Arr<obj>]
      1) ldc.i4.0
      5) ldelem [EqualityComparer<{i8,str}>]
      1) ldarg.0 [Arr<obj>]
      1) ldc.i4.2
      5) ldelem [({i8,str})]
      5) ldfld ({i8,str})::_F0:{i8,str}
      1) ldarg.1 [{i8,str}]
      5) callvirt EqualityComparer<{i8,str}>::Equals({i8,str}, {i8,str}):bool
      1) ldc.i4.0
      2) ceq
      1) ret
  Total Size: 35

Func sig: (QBs:{X:i8, Y:s}?*, QA:{X:i8, Y:s}?) to b*
Sequence: Seq<bool>
 0) false
 1) true 
 2) false
 3) true 
 4) true 
###
> NA !~= RBs
NA !~@= RBs : b*
BndKind:Call, Type:b*, Bnd:(Call(∂.ForEach([map:1] Global(RBs), Cmp(Global(NA) !~@= Scope(1))):b*))
// (∂.RBs:{X:i8, Y:s}*, ∂.NA:{X:i8, Y:s}?) : b*
ForEach_1(Arr<obj>, {i8,str}):bool
      1) ldarg.0 [Arr<obj>]
      1) ldc.i4.0
      5) ldelem [Arr<obj>]
      1) ldc.i4.0
      5) ldelem [EqualityComparer<{i8,str}>]
      1) ldarg.0 [Arr<obj>]
      1) ldc.i4.2
      5) ldelem [({i8,str})]
      5) ldfld ({i8,str})::_F0:{i8,str}
      1) ldarg.1 [{i8,str}]
      5) callvirt EqualityComparer<{i8,str}>::Equals({i8,str}, {i8,str}):bool
      1) ldc.i4.0
      2) ceq
      1) ret
  Total Size: 35

Func sig: (RBs:{X:i8, Y:s}*, NA:{X:i8, Y:s}?) to b*
Sequence: Seq<bool>
 0) true 
 1) true 
 2) true 
 3) true 
###
> NA !~= QBs
NA !~@= QBs : b*
BndKind:Call, Type:b*, Bnd:(Call(∂.ForEach([map:1] Global(QBs), Cmp(Global(NA) !~@= Scope(1))):b*))
// (∂.QBs:{X:i8, Y:s}?*, ∂.NA:{X:i8, Y:s}?) : b*
ForEach_1(Arr<obj>, {i8,str}):bool
      1) ldarg.0 [Arr<obj>]
      1) ldc.i4.0
      5) ldelem [Arr<obj>]
      1) ldc.i4.0
      5) ldelem [EqualityComparer<{i8,str}>]
      1) ldarg.0 [Arr<obj>]
      1) ldc.i4.2
      5) ldelem [({i8,str})]
      5) ldfld ({i8,str})::_F0:{i8,str}
      1) ldarg.1 [{i8,str}]
      5) callvirt EqualityComparer<{i8,str}>::Equals({i8,str}, {i8,str}):bool
      1) ldc.i4.0
      2) ceq
      1) ret
  Total Size: 35

Func sig: (QBs:{X:i8, Y:s}?*, NA:{X:i8, Y:s}?) to b*
Sequence: Seq<bool>
 0) true 
 1) true 
 2) true 
 3) true 
 4) false
###
> RA   = RBs = RBs
RA @= RBs @= RBs : b*
BndKind:Call, Type:b*, Bnd:(Call(∂.ForEach([map:1] Global(RBs), Cmp(Global(RA) @= Scope(1) @= Scope(1))):b*))
// (∂.RBs:{X:i8, Y:s}*, ∂.RA:{X:i8, Y:s}) : b*
ForEach_1(Arr<obj>, {i8,str}):bool
      1) ldarg.0 [Arr<obj>]
      1) ldc.i4.2
      5) ldelem [({i8,str})]
      5) ldfld ({i8,str})::_F0:{i8,str}
      1) ldarg.1 [{i8,str}]
      5) call static {i8,str}::Equals2({i8,str}, {i8,str}):bool
      5) brfalse [0]
      1) ldarg.1 [{i8,str}]
      1) ldarg.1 [{i8,str}]
      5) call static {i8,str}::Equals2({i8,str}, {i8,str}):bool
      5) br [1]
  Label [0]:
      1) ldc.i4.0
  Label [1]:
      1) ret
  Total Size: 37

Func sig: (RBs:{X:i8, Y:s}*, RA:{X:i8, Y:s}) to b*
Sequence: Seq<bool>
 0) true 
 1) false
 2) false
 3) false
###
> RA   = QBs = QBs
RA @= QBs @= QBs : b*
BndKind:Call, Type:b*, Bnd:(Call(∂.ForEach([map:1] Global(QBs), Cmp(Global(RA) @= Scope(1) @= Scope(1))):b*))
// (∂.QBs:{X:i8, Y:s}?*, ∂.RA:{X:i8, Y:s}) : b*
ForEach_1(Arr<obj>, {i8,str}):bool
      1) ldarg.0 [Arr<obj>]
      1) ldc.i4.2
      5) ldelem [({i8,str})]
      5) ldfld ({i8,str})::_F0:{i8,str}
      1) ldarg.1 [{i8,str}]
      5) call static {i8,str}::Equals2({i8,str}, {i8,str}):bool
      5) brfalse [0]
      1) ldarg.1 [{i8,str}]
      1) ldarg.1 [{i8,str}]
      5) call static {i8,str}::Equals2({i8,str}, {i8,str}):bool
      5) br [1]
  Label [0]:
      1) ldc.i4.0
  Label [1]:
      1) ret
  Total Size: 37

Func sig: (QBs:{X:i8, Y:s}?*, RA:{X:i8, Y:s}) to b*
Sequence: Seq<bool>
 0) true 
 1) false
 2) false
 3) false
 4) false
###
> QA   = RBs = RBs
QA @= RBs @= RBs : b*
BndKind:Call, Type:b*, Bnd:(Call(∂.ForEach([map:1] Global(RBs), Cmp(Global(QA) @= Scope(1) @= Scope(1))):b*))
// (∂.RBs:{X:i8, Y:s}*, ∂.QA:{X:i8, Y:s}?) : b*
ForEach_1(Arr<obj>, {i8,str}):bool
      1) ldarg.0 [Arr<obj>]
      1) ldc.i4.2
      5) ldelem [({i8,str})]
      5) ldfld ({i8,str})::_F0:{i8,str}
      1) ldarg.1 [{i8,str}]
      5) call static {i8,str}::Equals2({i8,str}, {i8,str}):bool
      5) brfalse [0]
      1) ldarg.1 [{i8,str}]
      1) ldarg.1 [{i8,str}]
      5) call static {i8,str}::Equals2({i8,str}, {i8,str}):bool
      5) br [1]
  Label [0]:
      1) ldc.i4.0
  Label [1]:
      1) ret
  Total Size: 37

Func sig: (RBs:{X:i8, Y:s}*, QA:{X:i8, Y:s}?) to b*
Sequence: Seq<bool>
 0) true 
 1) false
 2) false
 3) false
###
> QA   = QBs = QBs
QA @= QBs @= QBs : b*
BndKind:Call, Type:b*, Bnd:(Call(∂.ForEach([map:1] Global(QBs), Cmp(Global(QA) @= Scope(1) @= Scope(1))):b*))
// (∂.QBs:{X:i8, Y:s}?*, ∂.QA:{X:i8, Y:s}?) : b*
ForEach_1(Arr<obj>, {i8,str}):bool
      1) ldarg.0 [Arr<obj>]
      1) ldc.i4.2
      5) ldelem [({i8,str})]
      5) ldfld ({i8,str})::_F0:{i8,str}
      1) ldarg.1 [{i8,str}]
      5) call static {i8,str}::Equals2({i8,str}, {i8,str}):bool
      5) brfalse [0]
      1) ldarg.1 [{i8,str}]
      1) ldarg.1 [{i8,str}]
      5) call static {i8,str}::Equals2({i8,str}, {i8,str}):bool
      5) br [1]
  Label [0]:
      1) ldc.i4.0
  Label [1]:
      1) ret
  Total Size: 37

Func sig: (QBs:{X:i8, Y:s}?*, QA:{X:i8, Y:s}?) to b*
Sequence: Seq<bool>
 0) true 
 1) false
 2) false
 3) false
 4) false
###
> NA   = RBs = RBs
NA @= RBs @= RBs : b*
BndKind:Call, Type:b*, Bnd:(Call(∂.ForEach([map:1] Global(RBs), Cmp(Global(NA) @= Scope(1) @= Scope(1))):b*))
// (∂.RBs:{X:i8, Y:s}*, ∂.NA:{X:i8, Y:s}?) : b*
ForEach_1(Arr<obj>, {i8,str}):bool
      1) ldarg.0 [Arr<obj>]
      1) ldc.i4.2
      5) ldelem [({i8,str})]
      5) ldfld ({i8,str})::_F0:{i8,str}
      1) ldarg.1 [{i8,str}]
      5) call static {i8,str}::Equals2({i8,str}, {i8,str}):bool
      5) brfalse [0]
      1) ldarg.1 [{i8,str}]
      1) ldarg.1 [{i8,str}]
      5) call static {i8,str}::Equals2({i8,str}, {i8,str}):bool
      5) br [1]
  Label [0]:
      1) ldc.i4.0
  Label [1]:
      1) ret
  Total Size: 37

Func sig: (RBs:{X:i8, Y:s}*, NA:{X:i8, Y:s}?) to b*
Sequence: Seq<bool>
 0) false
 1) false
 2) false
 3) false
###
> NA   = QBs = QBs
NA @= QBs @= QBs : b*
BndKind:Call, Type:b*, Bnd:(Call(∂.ForEach([map:1] Global(QBs), Cmp(Global(NA) @= Scope(1) @= Scope(1))):b*))
// (∂.QBs:{X:i8, Y:s}?*, ∂.NA:{X:i8, Y:s}?) : b*
ForEach_1(Arr<obj>, {i8,str}):bool
      1) ldarg.0 [Arr<obj>]
      1) ldc.i4.2
      5) ldelem [({i8,str})]
      5) ldfld ({i8,str})::_F0:{i8,str}
      1) ldarg.1 [{i8,str}]
      5) call static {i8,str}::Equals2({i8,str}, {i8,str}):bool
      5) brfalse [0]
      1) ldarg.1 [{i8,str}]
      1) ldarg.1 [{i8,str}]
      5) call static {i8,str}::Equals2({i8,str}, {i8,str}):bool
      5) br [1]
  Label [0]:
      1) ldc.i4.0
  Label [1]:
      1) ret
  Total Size: 37

Func sig: (QBs:{X:i8, Y:s}?*, NA:{X:i8, Y:s}?) to b*
Sequence: Seq<bool>
 0) false
 1) false
 2) false
 3) false
 4) true 
###
> RA ! = RBs = RBs
RA !@= RBs @= RBs : b*
BndKind:Call, Type:b*, Bnd:(Call(∂.ForEach([map:1] Global(RBs), Cmp(Global(RA) !@= Scope(1) @= Scope(1))):b*))
// (∂.RBs:{X:i8, Y:s}*, ∂.RA:{X:i8, Y:s}) : b*
ForEach_1(Arr<obj>, {i8,str}):bool
      1) ldarg.0 [Arr<obj>]
      1) ldc.i4.2
      5) ldelem [({i8,str})]
      5) ldfld ({i8,str})::_F0:{i8,str}
      1) ldarg.1 [{i8,str}]
      5) call static {i8,str}::Equals2({i8,str}, {i8,str}):bool
      5) brtrue [0]
      1) ldarg.1 [{i8,str}]
      1) ldarg.1 [{i8,str}]
      5) call static {i8,str}::Equals2({i8,str}, {i8,str}):bool
      5) br [1]
  Label [0]:
      1) ldc.i4.0
  Label [1]:
      1) ret
  Total Size: 37

Func sig: (RBs:{X:i8, Y:s}*, RA:{X:i8, Y:s}) to b*
Sequence: Seq<bool>
 0) false
 1) true 
 2) true 
 3) true 
###
> RA ! = QBs = QBs
RA !@= QBs @= QBs : b*
BndKind:Call, Type:b*, Bnd:(Call(∂.ForEach([map:1] Global(QBs), Cmp(Global(RA) !@= Scope(1) @= Scope(1))):b*))
// (∂.QBs:{X:i8, Y:s}?*, ∂.RA:{X:i8, Y:s}) : b*
ForEach_1(Arr<obj>, {i8,str}):bool
      1) ldarg.0 [Arr<obj>]
      1) ldc.i4.2
      5) ldelem [({i8,str})]
      5) ldfld ({i8,str})::_F0:{i8,str}
      1) ldarg.1 [{i8,str}]
      5) call static {i8,str}::Equals2({i8,str}, {i8,str}):bool
      5) brtrue [0]
      1) ldarg.1 [{i8,str}]
      1) ldarg.1 [{i8,str}]
      5) call static {i8,str}::Equals2({i8,str}, {i8,str}):bool
      5) br [1]
  Label [0]:
      1) ldc.i4.0
  Label [1]:
      1) ret
  Total Size: 37

Func sig: (QBs:{X:i8, Y:s}?*, RA:{X:i8, Y:s}) to b*
Sequence: Seq<bool>
 0) false
 1) true 
 2) true 
 3) true 
 4) true 
###
> QA ! = RBs = RBs
QA !@= RBs @= RBs : b*
BndKind:Call, Type:b*, Bnd:(Call(∂.ForEach([map:1] Global(RBs), Cmp(Global(QA) !@= Scope(1) @= Scope(1))):b*))
// (∂.RBs:{X:i8, Y:s}*, ∂.QA:{X:i8, Y:s}?) : b*
ForEach_1(Arr<obj>, {i8,str}):bool
      1) ldarg.0 [Arr<obj>]
      1) ldc.i4.2
      5) ldelem [({i8,str})]
      5) ldfld ({i8,str})::_F0:{i8,str}
      1) ldarg.1 [{i8,str}]
      5) call static {i8,str}::Equals2({i8,str}, {i8,str}):bool
      5) brtrue [0]
      1) ldarg.1 [{i8,str}]
      1) ldarg.1 [{i8,str}]
      5) call static {i8,str}::Equals2({i8,str}, {i8,str}):bool
      5) br [1]
  Label [0]:
      1) ldc.i4.0
  Label [1]:
      1) ret
  Total Size: 37

Func sig: (RBs:{X:i8, Y:s}*, QA:{X:i8, Y:s}?) to b*
Sequence: Seq<bool>
 0) false
 1) true 
 2) true 
 3) true 
###
> QA ! = QBs = QBs
QA !@= QBs @= QBs : b*
BndKind:Call, Type:b*, Bnd:(Call(∂.ForEach([map:1] Global(QBs), Cmp(Global(QA) !@= Scope(1) @= Scope(1))):b*))
// (∂.QBs:{X:i8, Y:s}?*, ∂.QA:{X:i8, Y:s}?) : b*
ForEach_1(Arr<obj>, {i8,str}):bool
      1) ldarg.0 [Arr<obj>]
      1) ldc.i4.2
      5) ldelem [({i8,str})]
      5) ldfld ({i8,str})::_F0:{i8,str}
      1) ldarg.1 [{i8,str}]
      5) call static {i8,str}::Equals2({i8,str}, {i8,str}):bool
      5) brtrue [0]
      1) ldarg.1 [{i8,str}]
      1) ldarg.1 [{i8,str}]
      5) call static {i8,str}::Equals2({i8,str}, {i8,str}):bool
      5) br [1]
  Label [0]:
      1) ldc.i4.0
  Label [1]:
      1) ret
  Total Size: 37

Func sig: (QBs:{X:i8, Y:s}?*, QA:{X:i8, Y:s}?) to b*
Sequence: Seq<bool>
 0) false
 1) true 
 2) true 
 3) true 
 4) true 
###
> NA ! = RBs = RBs
NA !@= RBs @= RBs : b*
BndKind:Call, Type:b*, Bnd:(Call(∂.ForEach([map:1] Global(RBs), Cmp(Global(NA) !@= Scope(1) @= Scope(1))):b*))
// (∂.RBs:{X:i8, Y:s}*, ∂.NA:{X:i8, Y:s}?) : b*
ForEach_1(Arr<obj>, {i8,str}):bool
      1) ldarg.0 [Arr<obj>]
      1) ldc.i4.2
      5) ldelem [({i8,str})]
      5) ldfld ({i8,str})::_F0:{i8,str}
      1) ldarg.1 [{i8,str}]
      5) call static {i8,str}::Equals2({i8,str}, {i8,str}):bool
      5) brtrue [0]
      1) ldarg.1 [{i8,str}]
      1) ldarg.1 [{i8,str}]
      5) call static {i8,str}::Equals2({i8,str}, {i8,str}):bool
      5) br [1]
  Label [0]:
      1) ldc.i4.0
  Label [1]:
      1) ret
  Total Size: 37

Func sig: (RBs:{X:i8, Y:s}*, NA:{X:i8, Y:s}?) to b*
Sequence: Seq<bool>
 0) true 
 1) true 
 2) true 
 3) true 
###
> NA ! = QBs = QBs
NA !@= QBs @= QBs : b*
BndKind:Call, Type:b*, Bnd:(Call(∂.ForEach([map:1] Global(QBs), Cmp(Global(NA) !@= Scope(1) @= Scope(1))):b*))
// (∂.QBs:{X:i8, Y:s}?*, ∂.NA:{X:i8, Y:s}?) : b*
ForEach_1(Arr<obj>, {i8,str}):bool
      1) ldarg.0 [Arr<obj>]
      1) ldc.i4.2
      5) ldelem [({i8,str})]
      5) ldfld ({i8,str})::_F0:{i8,str}
      1) ldarg.1 [{i8,str}]
      5) call static {i8,str}::Equals2({i8,str}, {i8,str}):bool
      5) brtrue [0]
      1) ldarg.1 [{i8,str}]
      1) ldarg.1 [{i8,str}]
      5) call static {i8,str}::Equals2({i8,str}, {i8,str}):bool
      5) br [1]
  Label [0]:
      1) ldc.i4.0
  Label [1]:
      1) ret
  Total Size: 37

Func sig: (QBs:{X:i8, Y:s}?*, NA:{X:i8, Y:s}?) to b*
Sequence: Seq<bool>
 0) true 
 1) true 
 2) true 
 3) true 
 4) false
###
> RA  ~= RBs = RBs
RA ~@= RBs @= RBs : b*
BndKind:Call, Type:b*, Bnd:(Call(∂.ForEach([map:1] Global(RBs), Cmp(Global(RA) ~@= Scope(1) @= Scope(1))):b*))
// (∂.RBs:{X:i8, Y:s}*, ∂.RA:{X:i8, Y:s}) : b*
ForEach_1(Arr<obj>, {i8,str}):bool
      1) ldarg.0 [Arr<obj>]
      1) ldc.i4.0
      5) ldelem [Arr<obj>]
      1) ldc.i4.0
      5) ldelem [EqualityComparer<{i8,str}>]
      1) ldarg.0 [Arr<obj>]
      1) ldc.i4.2
      5) ldelem [({i8,str})]
      5) ldfld ({i8,str})::_F0:{i8,str}
      1) ldarg.1 [{i8,str}]
      5) callvirt EqualityComparer<{i8,str}>::Equals({i8,str}, {i8,str}):bool
      5) brfalse [0]
      1) ldarg.1 [{i8,str}]
      1) ldarg.1 [{i8,str}]
      5) call static {i8,str}::Equals2({i8,str}, {i8,str}):bool
      5) br [1]
  Label [0]:
      1) ldc.i4.0
  Label [1]:
      1) ret
  Total Size: 50

Func sig: (RBs:{X:i8, Y:s}*, RA:{X:i8, Y:s}) to b*
Sequence: Seq<bool>
 0) true 
 1) false
 2) true 
 3) false
###
> RA  ~= QBs = QBs
RA ~@= QBs @= QBs : b*
BndKind:Call, Type:b*, Bnd:(Call(∂.ForEach([map:1] Global(QBs), Cmp(Global(RA) ~@= Scope(1) @= Scope(1))):b*))
// (∂.QBs:{X:i8, Y:s}?*, ∂.RA:{X:i8, Y:s}) : b*
ForEach_1(Arr<obj>, {i8,str}):bool
      1) ldarg.0 [Arr<obj>]
      1) ldc.i4.0
      5) ldelem [Arr<obj>]
      1) ldc.i4.0
      5) ldelem [EqualityComparer<{i8,str}>]
      1) ldarg.0 [Arr<obj>]
      1) ldc.i4.2
      5) ldelem [({i8,str})]
      5) ldfld ({i8,str})::_F0:{i8,str}
      1) ldarg.1 [{i8,str}]
      5) callvirt EqualityComparer<{i8,str}>::Equals({i8,str}, {i8,str}):bool
      5) brfalse [0]
      1) ldarg.1 [{i8,str}]
      1) ldarg.1 [{i8,str}]
      5) call static {i8,str}::Equals2({i8,str}, {i8,str}):bool
      5) br [1]
  Label [0]:
      1) ldc.i4.0
  Label [1]:
      1) ret
  Total Size: 50

Func sig: (QBs:{X:i8, Y:s}?*, RA:{X:i8, Y:s}) to b*
Sequence: Seq<bool>
 0) true 
 1) false
 2) true 
 3) false
 4) false
###
> QA  ~= RBs = RBs
QA ~@= RBs @= RBs : b*
BndKind:Call, Type:b*, Bnd:(Call(∂.ForEach([map:1] Global(RBs), Cmp(Global(QA) ~@= Scope(1) @= Scope(1))):b*))
// (∂.RBs:{X:i8, Y:s}*, ∂.QA:{X:i8, Y:s}?) : b*
ForEach_1(Arr<obj>, {i8,str}):bool
      1) ldarg.0 [Arr<obj>]
      1) ldc.i4.0
      5) ldelem [Arr<obj>]
      1) ldc.i4.0
      5) ldelem [EqualityComparer<{i8,str}>]
      1) ldarg.0 [Arr<obj>]
      1) ldc.i4.2
      5) ldelem [({i8,str})]
      5) ldfld ({i8,str})::_F0:{i8,str}
      1) ldarg.1 [{i8,str}]
      5) callvirt EqualityComparer<{i8,str}>::Equals({i8,str}, {i8,str}):bool
      5) brfalse [0]
      1) ldarg.1 [{i8,str}]
      1) ldarg.1 [{i8,str}]
      5) call static {i8,str}::Equals2({i8,str}, {i8,str}):bool
      5) br [1]
  Label [0]:
      1) ldc.i4.0
  Label [1]:
      1) ret
  Total Size: 50

Func sig: (RBs:{X:i8, Y:s}*, QA:{X:i8, Y:s}?) to b*
Sequence: Seq<bool>
 0) true 
 1) false
 2) true 
 3) false
###
> QA  ~= QBs = QBs
QA ~@= QBs @= QBs : b*
BndKind:Call, Type:b*, Bnd:(Call(∂.ForEach([map:1] Global(QBs), Cmp(Global(QA) ~@= Scope(1) @= Scope(1))):b*))
// (∂.QBs:{X:i8, Y:s}?*, ∂.QA:{X:i8, Y:s}?) : b*
ForEach_1(Arr<obj>, {i8,str}):bool
      1) ldarg.0 [Arr<obj>]
      1) ldc.i4.0
      5) ldelem [Arr<obj>]
      1) ldc.i4.0
      5) ldelem [EqualityComparer<{i8,str}>]
      1) ldarg.0 [Arr<obj>]
      1) ldc.i4.2
      5) ldelem [({i8,str})]
      5) ldfld ({i8,str})::_F0:{i8,str}
      1) ldarg.1 [{i8,str}]
      5) callvirt EqualityComparer<{i8,str}>::Equals({i8,str}, {i8,str}):bool
      5) brfalse [0]
      1) ldarg.1 [{i8,str}]
      1) ldarg.1 [{i8,str}]
      5) call static {i8,str}::Equals2({i8,str}, {i8,str}):bool
      5) br [1]
  Label [0]:
      1) ldc.i4.0
  Label [1]:
      1) ret
  Total Size: 50

Func sig: (QBs:{X:i8, Y:s}?*, QA:{X:i8, Y:s}?) to b*
Sequence: Seq<bool>
 0) true 
 1) false
 2) true 
 3) false
 4) false
###
> NA  ~= RBs = RBs
NA ~@= RBs @= RBs : b*
BndKind:Call, Type:b*, Bnd:(Call(∂.ForEach([map:1] Global(RBs), Cmp(Global(NA) ~@= Scope(1) @= Scope(1))):b*))
// (∂.RBs:{X:i8, Y:s}*, ∂.NA:{X:i8, Y:s}?) : b*
ForEach_1(Arr<obj>, {i8,str}):bool
      1) ldarg.0 [Arr<obj>]
      1) ldc.i4.0
      5) ldelem [Arr<obj>]
      1) ldc.i4.0
      5) ldelem [EqualityComparer<{i8,str}>]
      1) ldarg.0 [Arr<obj>]
      1) ldc.i4.2
      5) ldelem [({i8,str})]
      5) ldfld ({i8,str})::_F0:{i8,str}
      1) ldarg.1 [{i8,str}]
      5) callvirt EqualityComparer<{i8,str}>::Equals({i8,str}, {i8,str}):bool
      5) brfalse [0]
      1) ldarg.1 [{i8,str}]
      1) ldarg.1 [{i8,str}]
      5) call static {i8,str}::Equals2({i8,str}, {i8,str}):bool
      5) br [1]
  Label [0]:
      1) ldc.i4.0
  Label [1]:
      1) ret
  Total Size: 50

Func sig: (RBs:{X:i8, Y:s}*, NA:{X:i8, Y:s}?) to b*
Sequence: Seq<bool>
 0) false
 1) false
 2) false
 3) false
###
> NA  ~= QBs = QBs
NA ~@= QBs @= QBs : b*
BndKind:Call, Type:b*, Bnd:(Call(∂.ForEach([map:1] Global(QBs), Cmp(Global(NA) ~@= Scope(1) @= Scope(1))):b*))
// (∂.QBs:{X:i8, Y:s}?*, ∂.NA:{X:i8, Y:s}?) : b*
ForEach_1(Arr<obj>, {i8,str}):bool
      1) ldarg.0 [Arr<obj>]
      1) ldc.i4.0
      5) ldelem [Arr<obj>]
      1) ldc.i4.0
      5) ldelem [EqualityComparer<{i8,str}>]
      1) ldarg.0 [Arr<obj>]
      1) ldc.i4.2
      5) ldelem [({i8,str})]
      5) ldfld ({i8,str})::_F0:{i8,str}
      1) ldarg.1 [{i8,str}]
      5) callvirt EqualityComparer<{i8,str}>::Equals({i8,str}, {i8,str}):bool
      5) brfalse [0]
      1) ldarg.1 [{i8,str}]
      1) ldarg.1 [{i8,str}]
      5) call static {i8,str}::Equals2({i8,str}, {i8,str}):bool
      5) br [1]
  Label [0]:
      1) ldc.i4.0
  Label [1]:
      1) ret
  Total Size: 50

Func sig: (QBs:{X:i8, Y:s}?*, NA:{X:i8, Y:s}?) to b*
Sequence: Seq<bool>
 0) false
 1) false
 2) false
 3) false
 4) true 
###
> RA !~= RBs = RBs
RA !~@= RBs @= RBs : b*
BndKind:Call, Type:b*, Bnd:(Call(∂.ForEach([map:1] Global(RBs), Cmp(Global(RA) !~@= Scope(1) @= Scope(1))):b*))
// (∂.RBs:{X:i8, Y:s}*, ∂.RA:{X:i8, Y:s}) : b*
ForEach_1(Arr<obj>, {i8,str}):bool
      1) ldarg.0 [Arr<obj>]
      1) ldc.i4.0
      5) ldelem [Arr<obj>]
      1) ldc.i4.0
      5) ldelem [EqualityComparer<{i8,str}>]
      1) ldarg.0 [Arr<obj>]
      1) ldc.i4.2
      5) ldelem [({i8,str})]
      5) ldfld ({i8,str})::_F0:{i8,str}
      1) ldarg.1 [{i8,str}]
      5) callvirt EqualityComparer<{i8,str}>::Equals({i8,str}, {i8,str}):bool
      5) brtrue [0]
      1) ldarg.1 [{i8,str}]
      1) ldarg.1 [{i8,str}]
      5) call static {i8,str}::Equals2({i8,str}, {i8,str}):bool
      5) br [1]
  Label [0]:
      1) ldc.i4.0
  Label [1]:
      1) ret
  Total Size: 50

Func sig: (RBs:{X:i8, Y:s}*, RA:{X:i8, Y:s}) to b*
Sequence: Seq<bool>
 0) false
 1) true 
 2) false
 3) true 
###
> RA !~= QBs = QBs
RA !~@= QBs @= QBs : b*
BndKind:Call, Type:b*, Bnd:(Call(∂.ForEach([map:1] Global(QBs), Cmp(Global(RA) !~@= Scope(1) @= Scope(1))):b*))
// (∂.QBs:{X:i8, Y:s}?*, ∂.RA:{X:i8, Y:s}) : b*
ForEach_1(Arr<obj>, {i8,str}):bool
      1) ldarg.0 [Arr<obj>]
      1) ldc.i4.0
      5) ldelem [Arr<obj>]
      1) ldc.i4.0
      5) ldelem [EqualityComparer<{i8,str}>]
      1) ldarg.0 [Arr<obj>]
      1) ldc.i4.2
      5) ldelem [({i8,str})]
      5) ldfld ({i8,str})::_F0:{i8,str}
      1) ldarg.1 [{i8,str}]
      5) callvirt EqualityComparer<{i8,str}>::Equals({i8,str}, {i8,str}):bool
      5) brtrue [0]
      1) ldarg.1 [{i8,str}]
      1) ldarg.1 [{i8,str}]
      5) call static {i8,str}::Equals2({i8,str}, {i8,str}):bool
      5) br [1]
  Label [0]:
      1) ldc.i4.0
  Label [1]:
      1) ret
  Total Size: 50

Func sig: (QBs:{X:i8, Y:s}?*, RA:{X:i8, Y:s}) to b*
Sequence: Seq<bool>
 0) false
 1) true 
 2) false
 3) true 
 4) true 
###
> QA !~= RBs = RBs
QA !~@= RBs @= RBs : b*
BndKind:Call, Type:b*, Bnd:(Call(∂.ForEach([map:1] Global(RBs), Cmp(Global(QA) !~@= Scope(1) @= Scope(1))):b*))
// (∂.RBs:{X:i8, Y:s}*, ∂.QA:{X:i8, Y:s}?) : b*
ForEach_1(Arr<obj>, {i8,str}):bool
      1) ldarg.0 [Arr<obj>]
      1) ldc.i4.0
      5) ldelem [Arr<obj>]
      1) ldc.i4.0
      5) ldelem [EqualityComparer<{i8,str}>]
      1) ldarg.0 [Arr<obj>]
      1) ldc.i4.2
      5) ldelem [({i8,str})]
      5) ldfld ({i8,str})::_F0:{i8,str}
      1) ldarg.1 [{i8,str}]
      5) callvirt EqualityComparer<{i8,str}>::Equals({i8,str}, {i8,str}):bool
      5) brtrue [0]
      1) ldarg.1 [{i8,str}]
      1) ldarg.1 [{i8,str}]
      5) call static {i8,str}::Equals2({i8,str}, {i8,str}):bool
      5) br [1]
  Label [0]:
      1) ldc.i4.0
  Label [1]:
      1) ret
  Total Size: 50

Func sig: (RBs:{X:i8, Y:s}*, QA:{X:i8, Y:s}?) to b*
Sequence: Seq<bool>
 0) false
 1) true 
 2) false
 3) true 
###
> QA !~= QBs = QBs
QA !~@= QBs @= QBs : b*
BndKind:Call, Type:b*, Bnd:(Call(∂.ForEach([map:1] Global(QBs), Cmp(Global(QA) !~@= Scope(1) @= Scope(1))):b*))
// (∂.QBs:{X:i8, Y:s}?*, ∂.QA:{X:i8, Y:s}?) : b*
ForEach_1(Arr<obj>, {i8,str}):bool
      1) ldarg.0 [Arr<obj>]
      1) ldc.i4.0
      5) ldelem [Arr<obj>]
      1) ldc.i4.0
      5) ldelem [EqualityComparer<{i8,str}>]
      1) ldarg.0 [Arr<obj>]
      1) ldc.i4.2
      5) ldelem [({i8,str})]
      5) ldfld ({i8,str})::_F0:{i8,str}
      1) ldarg.1 [{i8,str}]
      5) callvirt EqualityComparer<{i8,str}>::Equals({i8,str}, {i8,str}):bool
      5) brtrue [0]
      1) ldarg.1 [{i8,str}]
      1) ldarg.1 [{i8,str}]
      5) call static {i8,str}::Equals2({i8,str}, {i8,str}):bool
      5) br [1]
  Label [0]:
      1) ldc.i4.0
  Label [1]:
      1) ret
  Total Size: 50

Func sig: (QBs:{X:i8, Y:s}?*, QA:{X:i8, Y:s}?) to b*
Sequence: Seq<bool>
 0) false
 1) true 
 2) false
 3) true 
 4) true 
###
> NA !~= RBs = RBs
NA !~@= RBs @= RBs : b*
BndKind:Call, Type:b*, Bnd:(Call(∂.ForEach([map:1] Global(RBs), Cmp(Global(NA) !~@= Scope(1) @= Scope(1))):b*))
// (∂.RBs:{X:i8, Y:s}*, ∂.NA:{X:i8, Y:s}?) : b*
ForEach_1(Arr<obj>, {i8,str}):bool
      1) ldarg.0 [Arr<obj>]
      1) ldc.i4.0
      5) ldelem [Arr<obj>]
      1) ldc.i4.0
      5) ldelem [EqualityComparer<{i8,str}>]
      1) ldarg.0 [Arr<obj>]
      1) ldc.i4.2
      5) ldelem [({i8,str})]
      5) ldfld ({i8,str})::_F0:{i8,str}
      1) ldarg.1 [{i8,str}]
      5) callvirt EqualityComparer<{i8,str}>::Equals({i8,str}, {i8,str}):bool
      5) brtrue [0]
      1) ldarg.1 [{i8,str}]
      1) ldarg.1 [{i8,str}]
      5) call static {i8,str}::Equals2({i8,str}, {i8,str}):bool
      5) br [1]
  Label [0]:
      1) ldc.i4.0
  Label [1]:
      1) ret
  Total Size: 50

Func sig: (RBs:{X:i8, Y:s}*, NA:{X:i8, Y:s}?) to b*
Sequence: Seq<bool>
 0) true 
 1) true 
 2) true 
 3) true 
###
> NA !~= QBs = QBs
NA !~@= QBs @= QBs : b*
BndKind:Call, Type:b*, Bnd:(Call(∂.ForEach([map:1] Global(QBs), Cmp(Global(NA) !~@= Scope(1) @= Scope(1))):b*))
// (∂.QBs:{X:i8, Y:s}?*, ∂.NA:{X:i8, Y:s}?) : b*
ForEach_1(Arr<obj>, {i8,str}):bool
      1) ldarg.0 [Arr<obj>]
      1) ldc.i4.0
      5) ldelem [Arr<obj>]
      1) ldc.i4.0
      5) ldelem [EqualityComparer<{i8,str}>]
      1) ldarg.0 [Arr<obj>]
      1) ldc.i4.2
      5) ldelem [({i8,str})]
      5) ldfld ({i8,str})::_F0:{i8,str}
      1) ldarg.1 [{i8,str}]
      5) callvirt EqualityComparer<{i8,str}>::Equals({i8,str}, {i8,str}):bool
      5) brtrue [0]
      1) ldarg.1 [{i8,str}]
      1) ldarg.1 [{i8,str}]
      5) call static {i8,str}::Equals2({i8,str}, {i8,str}):bool
      5) br [1]
  Label [0]:
      1) ldc.i4.0
  Label [1]:
      1) ret
  Total Size: 50

Func sig: (QBs:{X:i8, Y:s}?*, NA:{X:i8, Y:s}?) to b*
Sequence: Seq<bool>
 0) true 
 1) true 
 2) true 
 3) true 
 4) false
###
> RA = RA   = RBs
RA @= RA @= RBs : b*
BndKind:Call, Type:b*, Bnd:(Call(∂.ForEach([map:1] Global(RBs), Cmp(Global(RA) @= Global(RA) @= Scope(1))):b*))
// (∂.RBs:{X:i8, Y:s}*, ∂.RA:{X:i8, Y:s}) : b*
ForEach_1(Arr<obj>, {i8,str}):bool
      1) ldarg.0 [Arr<obj>]
      1) ldc.i4.2
      5) ldelem [({i8,str})]
      5) ldfld ({i8,str})::_F0:{i8,str}
      1) ldarg.0 [Arr<obj>]
      1) ldc.i4.2
      5) ldelem [({i8,str})]
      5) ldfld ({i8,str})::_F0:{i8,str}
      1) dup
      1) stloc.0 [{i8,str}]
      5) call static {i8,str}::Equals2({i8,str}, {i8,str}):bool
      5) brfalse [0]
      1) ldloc.0 [{i8,str}]
      1) ldarg.1 [{i8,str}]
      5) call static {i8,str}::Equals2({i8,str}, {i8,str}):bool
      5) br [1]
  Label [0]:
      1) ldc.i4.0
  Label [1]:
      1) ret
  Total Size: 50

Func sig: (RBs:{X:i8, Y:s}*, RA:{X:i8, Y:s}) to b*
Sequence: Seq<bool>
 0) true 
 1) false
 2) false
 3) false
###
> RA = RA   = QBs
RA @= RA @= QBs : b*
BndKind:Call, Type:b*, Bnd:(Call(∂.ForEach([map:1] Global(QBs), Cmp(Global(RA) @= Global(RA) @= Scope(1))):b*))
// (∂.QBs:{X:i8, Y:s}?*, ∂.RA:{X:i8, Y:s}) : b*
ForEach_1(Arr<obj>, {i8,str}):bool
      1) ldarg.0 [Arr<obj>]
      1) ldc.i4.2
      5) ldelem [({i8,str})]
      5) ldfld ({i8,str})::_F0:{i8,str}
      1) ldarg.0 [Arr<obj>]
      1) ldc.i4.2
      5) ldelem [({i8,str})]
      5) ldfld ({i8,str})::_F0:{i8,str}
      1) dup
      1) stloc.0 [{i8,str}]
      5) call static {i8,str}::Equals2({i8,str}, {i8,str}):bool
      5) brfalse [0]
      1) ldloc.0 [{i8,str}]
      1) ldarg.1 [{i8,str}]
      5) call static {i8,str}::Equals2({i8,str}, {i8,str}):bool
      5) br [1]
  Label [0]:
      1) ldc.i4.0
  Label [1]:
      1) ret
  Total Size: 50

Func sig: (QBs:{X:i8, Y:s}?*, RA:{X:i8, Y:s}) to b*
Sequence: Seq<bool>
 0) true 
 1) false
 2) false
 3) false
 4) false
###
> QA = QA   = RBs
QA @= QA @= RBs : b*
BndKind:Call, Type:b*, Bnd:(Call(∂.ForEach([map:1] Global(RBs), Cmp(Global(QA) @= Global(QA) @= Scope(1))):b*))
// (∂.RBs:{X:i8, Y:s}*, ∂.QA:{X:i8, Y:s}?) : b*
ForEach_1(Arr<obj>, {i8,str}):bool
      1) ldarg.0 [Arr<obj>]
      1) ldc.i4.2
      5) ldelem [({i8,str})]
      5) ldfld ({i8,str})::_F0:{i8,str}
      1) ldarg.0 [Arr<obj>]
      1) ldc.i4.2
      5) ldelem [({i8,str})]
      5) ldfld ({i8,str})::_F0:{i8,str}
      1) dup
      1) stloc.0 [{i8,str}]
      5) call static {i8,str}::Equals2({i8,str}, {i8,str}):bool
      5) brfalse [0]
      1) ldloc.0 [{i8,str}]
      1) ldarg.1 [{i8,str}]
      5) call static {i8,str}::Equals2({i8,str}, {i8,str}):bool
      5) br [1]
  Label [0]:
      1) ldc.i4.0
  Label [1]:
      1) ret
  Total Size: 50

Func sig: (RBs:{X:i8, Y:s}*, QA:{X:i8, Y:s}?) to b*
Sequence: Seq<bool>
 0) true 
 1) false
 2) false
 3) false
###
> QA = QA   = QBs
QA @= QA @= QBs : b*
BndKind:Call, Type:b*, Bnd:(Call(∂.ForEach([map:1] Global(QBs), Cmp(Global(QA) @= Global(QA) @= Scope(1))):b*))
// (∂.QBs:{X:i8, Y:s}?*, ∂.QA:{X:i8, Y:s}?) : b*
ForEach_1(Arr<obj>, {i8,str}):bool
      1) ldarg.0 [Arr<obj>]
      1) ldc.i4.2
      5) ldelem [({i8,str})]
      5) ldfld ({i8,str})::_F0:{i8,str}
      1) ldarg.0 [Arr<obj>]
      1) ldc.i4.2
      5) ldelem [({i8,str})]
      5) ldfld ({i8,str})::_F0:{i8,str}
      1) dup
      1) stloc.0 [{i8,str}]
      5) call static {i8,str}::Equals2({i8,str}, {i8,str}):bool
      5) brfalse [0]
      1) ldloc.0 [{i8,str}]
      1) ldarg.1 [{i8,str}]
      5) call static {i8,str}::Equals2({i8,str}, {i8,str}):bool
      5) br [1]
  Label [0]:
      1) ldc.i4.0
  Label [1]:
      1) ret
  Total Size: 50

Func sig: (QBs:{X:i8, Y:s}?*, QA:{X:i8, Y:s}?) to b*
Sequence: Seq<bool>
 0) true 
 1) false
 2) false
 3) false
 4) false
###
> NA = NA   = RBs
NA @= NA @= RBs : b*
BndKind:Call, Type:b*, Bnd:(Call(∂.ForEach([map:1] Global(RBs), Cmp(Global(NA) @= Global(NA) @= Scope(1))):b*))
// (∂.RBs:{X:i8, Y:s}*, ∂.NA:{X:i8, Y:s}?) : b*
ForEach_1(Arr<obj>, {i8,str}):bool
      1) ldarg.0 [Arr<obj>]
      1) ldc.i4.2
      5) ldelem [({i8,str})]
      5) ldfld ({i8,str})::_F0:{i8,str}
      1) ldarg.0 [Arr<obj>]
      1) ldc.i4.2
      5) ldelem [({i8,str})]
      5) ldfld ({i8,str})::_F0:{i8,str}
      1) dup
      1) stloc.0 [{i8,str}]
      5) call static {i8,str}::Equals2({i8,str}, {i8,str}):bool
      5) brfalse [0]
      1) ldloc.0 [{i8,str}]
      1) ldarg.1 [{i8,str}]
      5) call static {i8,str}::Equals2({i8,str}, {i8,str}):bool
      5) br [1]
  Label [0]:
      1) ldc.i4.0
  Label [1]:
      1) ret
  Total Size: 50

Func sig: (RBs:{X:i8, Y:s}*, NA:{X:i8, Y:s}?) to b*
Sequence: Seq<bool>
 0) false
 1) false
 2) false
 3) false
###
> NA = NA   = QBs
NA @= NA @= QBs : b*
BndKind:Call, Type:b*, Bnd:(Call(∂.ForEach([map:1] Global(QBs), Cmp(Global(NA) @= Global(NA) @= Scope(1))):b*))
// (∂.QBs:{X:i8, Y:s}?*, ∂.NA:{X:i8, Y:s}?) : b*
ForEach_1(Arr<obj>, {i8,str}):bool
      1) ldarg.0 [Arr<obj>]
      1) ldc.i4.2
      5) ldelem [({i8,str})]
      5) ldfld ({i8,str})::_F0:{i8,str}
      1) ldarg.0 [Arr<obj>]
      1) ldc.i4.2
      5) ldelem [({i8,str})]
      5) ldfld ({i8,str})::_F0:{i8,str}
      1) dup
      1) stloc.0 [{i8,str}]
      5) call static {i8,str}::Equals2({i8,str}, {i8,str}):bool
      5) brfalse [0]
      1) ldloc.0 [{i8,str}]
      1) ldarg.1 [{i8,str}]
      5) call static {i8,str}::Equals2({i8,str}, {i8,str}):bool
      5) br [1]
  Label [0]:
      1) ldc.i4.0
  Label [1]:
      1) ret
  Total Size: 50

Func sig: (QBs:{X:i8, Y:s}?*, NA:{X:i8, Y:s}?) to b*
Sequence: Seq<bool>
 0) false
 1) false
 2) false
 3) false
 4) true 
###
> RA = RA ! = RBs
RA @= RA !@= RBs : b*
BndKind:Call, Type:b*, Bnd:(Call(∂.ForEach([map:1] Global(RBs), Cmp(Global(RA) @= Global(RA) !@= Scope(1))):b*))
// (∂.RBs:{X:i8, Y:s}*, ∂.RA:{X:i8, Y:s}) : b*
ForEach_1(Arr<obj>, {i8,str}):bool
      1) ldarg.0 [Arr<obj>]
      1) ldc.i4.2
      5) ldelem [({i8,str})]
      5) ldfld ({i8,str})::_F0:{i8,str}
      1) ldarg.0 [Arr<obj>]
      1) ldc.i4.2
      5) ldelem [({i8,str})]
      5) ldfld ({i8,str})::_F0:{i8,str}
      1) dup
      1) stloc.0 [{i8,str}]
      5) call static {i8,str}::Equals2({i8,str}, {i8,str}):bool
      5) brfalse [0]
      1) ldloc.0 [{i8,str}]
      1) ldarg.1 [{i8,str}]
      5) call static {i8,str}::Equals2({i8,str}, {i8,str}):bool
      1) ldc.i4.0
      2) ceq
      5) br [1]
  Label [0]:
      1) ldc.i4.0
  Label [1]:
      1) ret
  Total Size: 53

Func sig: (RBs:{X:i8, Y:s}*, RA:{X:i8, Y:s}) to b*
Sequence: Seq<bool>
 0) false
 1) true 
 2) true 
 3) true 
###
> RA = RA ! = QBs
RA @= RA !@= QBs : b*
BndKind:Call, Type:b*, Bnd:(Call(∂.ForEach([map:1] Global(QBs), Cmp(Global(RA) @= Global(RA) !@= Scope(1))):b*))
// (∂.QBs:{X:i8, Y:s}?*, ∂.RA:{X:i8, Y:s}) : b*
ForEach_1(Arr<obj>, {i8,str}):bool
      1) ldarg.0 [Arr<obj>]
      1) ldc.i4.2
      5) ldelem [({i8,str})]
      5) ldfld ({i8,str})::_F0:{i8,str}
      1) ldarg.0 [Arr<obj>]
      1) ldc.i4.2
      5) ldelem [({i8,str})]
      5) ldfld ({i8,str})::_F0:{i8,str}
      1) dup
      1) stloc.0 [{i8,str}]
      5) call static {i8,str}::Equals2({i8,str}, {i8,str}):bool
      5) brfalse [0]
      1) ldloc.0 [{i8,str}]
      1) ldarg.1 [{i8,str}]
      5) call static {i8,str}::Equals2({i8,str}, {i8,str}):bool
      1) ldc.i4.0
      2) ceq
      5) br [1]
  Label [0]:
      1) ldc.i4.0
  Label [1]:
      1) ret
  Total Size: 53

Func sig: (QBs:{X:i8, Y:s}?*, RA:{X:i8, Y:s}) to b*
Sequence: Seq<bool>
 0) false
 1) true 
 2) true 
 3) true 
 4) true 
###
> QA = QA ! = RBs
QA @= QA !@= RBs : b*
BndKind:Call, Type:b*, Bnd:(Call(∂.ForEach([map:1] Global(RBs), Cmp(Global(QA) @= Global(QA) !@= Scope(1))):b*))
// (∂.RBs:{X:i8, Y:s}*, ∂.QA:{X:i8, Y:s}?) : b*
ForEach_1(Arr<obj>, {i8,str}):bool
      1) ldarg.0 [Arr<obj>]
      1) ldc.i4.2
      5) ldelem [({i8,str})]
      5) ldfld ({i8,str})::_F0:{i8,str}
      1) ldarg.0 [Arr<obj>]
      1) ldc.i4.2
      5) ldelem [({i8,str})]
      5) ldfld ({i8,str})::_F0:{i8,str}
      1) dup
      1) stloc.0 [{i8,str}]
      5) call static {i8,str}::Equals2({i8,str}, {i8,str}):bool
      5) brfalse [0]
      1) ldloc.0 [{i8,str}]
      1) ldarg.1 [{i8,str}]
      5) call static {i8,str}::Equals2({i8,str}, {i8,str}):bool
      1) ldc.i4.0
      2) ceq
      5) br [1]
  Label [0]:
      1) ldc.i4.0
  Label [1]:
      1) ret
  Total Size: 53

Func sig: (RBs:{X:i8, Y:s}*, QA:{X:i8, Y:s}?) to b*
Sequence: Seq<bool>
 0) false
 1) true 
 2) true 
 3) true 
###
> QA = QA ! = QBs
QA @= QA !@= QBs : b*
BndKind:Call, Type:b*, Bnd:(Call(∂.ForEach([map:1] Global(QBs), Cmp(Global(QA) @= Global(QA) !@= Scope(1))):b*))
// (∂.QBs:{X:i8, Y:s}?*, ∂.QA:{X:i8, Y:s}?) : b*
ForEach_1(Arr<obj>, {i8,str}):bool
      1) ldarg.0 [Arr<obj>]
      1) ldc.i4.2
      5) ldelem [({i8,str})]
      5) ldfld ({i8,str})::_F0:{i8,str}
      1) ldarg.0 [Arr<obj>]
      1) ldc.i4.2
      5) ldelem [({i8,str})]
      5) ldfld ({i8,str})::_F0:{i8,str}
      1) dup
      1) stloc.0 [{i8,str}]
      5) call static {i8,str}::Equals2({i8,str}, {i8,str}):bool
      5) brfalse [0]
      1) ldloc.0 [{i8,str}]
      1) ldarg.1 [{i8,str}]
      5) call static {i8,str}::Equals2({i8,str}, {i8,str}):bool
      1) ldc.i4.0
      2) ceq
      5) br [1]
  Label [0]:
      1) ldc.i4.0
  Label [1]:
      1) ret
  Total Size: 53

Func sig: (QBs:{X:i8, Y:s}?*, QA:{X:i8, Y:s}?) to b*
Sequence: Seq<bool>
 0) false
 1) true 
 2) true 
 3) true 
 4) true 
###
> NA = NA ! = RBs
NA @= NA !@= RBs : b*
BndKind:Call, Type:b*, Bnd:(Call(∂.ForEach([map:1] Global(RBs), Cmp(Global(NA) @= Global(NA) !@= Scope(1))):b*))
// (∂.RBs:{X:i8, Y:s}*, ∂.NA:{X:i8, Y:s}?) : b*
ForEach_1(Arr<obj>, {i8,str}):bool
      1) ldarg.0 [Arr<obj>]
      1) ldc.i4.2
      5) ldelem [({i8,str})]
      5) ldfld ({i8,str})::_F0:{i8,str}
      1) ldarg.0 [Arr<obj>]
      1) ldc.i4.2
      5) ldelem [({i8,str})]
      5) ldfld ({i8,str})::_F0:{i8,str}
      1) dup
      1) stloc.0 [{i8,str}]
      5) call static {i8,str}::Equals2({i8,str}, {i8,str}):bool
      5) brfalse [0]
      1) ldloc.0 [{i8,str}]
      1) ldarg.1 [{i8,str}]
      5) call static {i8,str}::Equals2({i8,str}, {i8,str}):bool
      1) ldc.i4.0
      2) ceq
      5) br [1]
  Label [0]:
      1) ldc.i4.0
  Label [1]:
      1) ret
  Total Size: 53

Func sig: (RBs:{X:i8, Y:s}*, NA:{X:i8, Y:s}?) to b*
Sequence: Seq<bool>
 0) true 
 1) true 
 2) true 
 3) true 
###
> NA = NA ! = QBs
NA @= NA !@= QBs : b*
BndKind:Call, Type:b*, Bnd:(Call(∂.ForEach([map:1] Global(QBs), Cmp(Global(NA) @= Global(NA) !@= Scope(1))):b*))
// (∂.QBs:{X:i8, Y:s}?*, ∂.NA:{X:i8, Y:s}?) : b*
ForEach_1(Arr<obj>, {i8,str}):bool
      1) ldarg.0 [Arr<obj>]
      1) ldc.i4.2
      5) ldelem [({i8,str})]
      5) ldfld ({i8,str})::_F0:{i8,str}
      1) ldarg.0 [Arr<obj>]
      1) ldc.i4.2
      5) ldelem [({i8,str})]
      5) ldfld ({i8,str})::_F0:{i8,str}
      1) dup
      1) stloc.0 [{i8,str}]
      5) call static {i8,str}::Equals2({i8,str}, {i8,str}):bool
      5) brfalse [0]
      1) ldloc.0 [{i8,str}]
      1) ldarg.1 [{i8,str}]
      5) call static {i8,str}::Equals2({i8,str}, {i8,str}):bool
      1) ldc.i4.0
      2) ceq
      5) br [1]
  Label [0]:
      1) ldc.i4.0
  Label [1]:
      1) ret
  Total Size: 53

Func sig: (QBs:{X:i8, Y:s}?*, NA:{X:i8, Y:s}?) to b*
Sequence: Seq<bool>
 0) true 
 1) true 
 2) true 
 3) true 
 4) false
###
> RA = RA  ~= RBs
RA @= RA ~@= RBs : b*
BndKind:Call, Type:b*, Bnd:(Call(∂.ForEach([map:1] Global(RBs), Cmp(Global(RA) @= Global(RA) ~@= Scope(1))):b*))
// (∂.RBs:{X:i8, Y:s}*, ∂.RA:{X:i8, Y:s}) : b*
ForEach_1(Arr<obj>, {i8,str}):bool
      1) ldarg.0 [Arr<obj>]
      1) ldc.i4.2
      5) ldelem [({i8,str})]
      5) ldfld ({i8,str})::_F0:{i8,str}
      1) ldarg.0 [Arr<obj>]
      1) ldc.i4.2
      5) ldelem [({i8,str})]
      5) ldfld ({i8,str})::_F0:{i8,str}
      1) dup
      1) stloc.0 [{i8,str}]
      5) call static {i8,str}::Equals2({i8,str}, {i8,str}):bool
      5) brfalse [0]
      1) ldarg.0 [Arr<obj>]
      1) ldc.i4.0
      5) ldelem [Arr<obj>]
      1) ldc.i4.0
      5) ldelem [EqualityComparer<{i8,str}>]
      1) ldloc.0 [{i8,str}]
      1) ldarg.1 [{i8,str}]
      5) callvirt EqualityComparer<{i8,str}>::Equals({i8,str}, {i8,str}):bool
      5) br [1]
  Label [0]:
      1) ldc.i4.0
  Label [1]:
      1) ret
  Total Size: 63

Func sig: (RBs:{X:i8, Y:s}*, RA:{X:i8, Y:s}) to b*
Sequence: Seq<bool>
 0) true 
 1) false
 2) true 
 3) false
###
> RA = RA  ~= QBs
RA @= RA ~@= QBs : b*
BndKind:Call, Type:b*, Bnd:(Call(∂.ForEach([map:1] Global(QBs), Cmp(Global(RA) @= Global(RA) ~@= Scope(1))):b*))
// (∂.QBs:{X:i8, Y:s}?*, ∂.RA:{X:i8, Y:s}) : b*
ForEach_1(Arr<obj>, {i8,str}):bool
      1) ldarg.0 [Arr<obj>]
      1) ldc.i4.2
      5) ldelem [({i8,str})]
      5) ldfld ({i8,str})::_F0:{i8,str}
      1) ldarg.0 [Arr<obj>]
      1) ldc.i4.2
      5) ldelem [({i8,str})]
      5) ldfld ({i8,str})::_F0:{i8,str}
      1) dup
      1) stloc.0 [{i8,str}]
      5) call static {i8,str}::Equals2({i8,str}, {i8,str}):bool
      5) brfalse [0]
      1) ldarg.0 [Arr<obj>]
      1) ldc.i4.0
      5) ldelem [Arr<obj>]
      1) ldc.i4.0
      5) ldelem [EqualityComparer<{i8,str}>]
      1) ldloc.0 [{i8,str}]
      1) ldarg.1 [{i8,str}]
      5) callvirt EqualityComparer<{i8,str}>::Equals({i8,str}, {i8,str}):bool
      5) br [1]
  Label [0]:
      1) ldc.i4.0
  Label [1]:
      1) ret
  Total Size: 63

Func sig: (QBs:{X:i8, Y:s}?*, RA:{X:i8, Y:s}) to b*
Sequence: Seq<bool>
 0) true 
 1) false
 2) true 
 3) false
 4) false
###
> QA = QA  ~= RBs
QA @= QA ~@= RBs : b*
BndKind:Call, Type:b*, Bnd:(Call(∂.ForEach([map:1] Global(RBs), Cmp(Global(QA) @= Global(QA) ~@= Scope(1))):b*))
// (∂.RBs:{X:i8, Y:s}*, ∂.QA:{X:i8, Y:s}?) : b*
ForEach_1(Arr<obj>, {i8,str}):bool
      1) ldarg.0 [Arr<obj>]
      1) ldc.i4.2
      5) ldelem [({i8,str})]
      5) ldfld ({i8,str})::_F0:{i8,str}
      1) ldarg.0 [Arr<obj>]
      1) ldc.i4.2
      5) ldelem [({i8,str})]
      5) ldfld ({i8,str})::_F0:{i8,str}
      1) dup
      1) stloc.0 [{i8,str}]
      5) call static {i8,str}::Equals2({i8,str}, {i8,str}):bool
      5) brfalse [0]
      1) ldarg.0 [Arr<obj>]
      1) ldc.i4.0
      5) ldelem [Arr<obj>]
      1) ldc.i4.0
      5) ldelem [EqualityComparer<{i8,str}>]
      1) ldloc.0 [{i8,str}]
      1) ldarg.1 [{i8,str}]
      5) callvirt EqualityComparer<{i8,str}>::Equals({i8,str}, {i8,str}):bool
      5) br [1]
  Label [0]:
      1) ldc.i4.0
  Label [1]:
      1) ret
  Total Size: 63

Func sig: (RBs:{X:i8, Y:s}*, QA:{X:i8, Y:s}?) to b*
Sequence: Seq<bool>
 0) true 
 1) false
 2) true 
 3) false
###
> QA = QA  ~= QBs
QA @= QA ~@= QBs : b*
BndKind:Call, Type:b*, Bnd:(Call(∂.ForEach([map:1] Global(QBs), Cmp(Global(QA) @= Global(QA) ~@= Scope(1))):b*))
// (∂.QBs:{X:i8, Y:s}?*, ∂.QA:{X:i8, Y:s}?) : b*
ForEach_1(Arr<obj>, {i8,str}):bool
      1) ldarg.0 [Arr<obj>]
      1) ldc.i4.2
      5) ldelem [({i8,str})]
      5) ldfld ({i8,str})::_F0:{i8,str}
      1) ldarg.0 [Arr<obj>]
      1) ldc.i4.2
      5) ldelem [({i8,str})]
      5) ldfld ({i8,str})::_F0:{i8,str}
      1) dup
      1) stloc.0 [{i8,str}]
      5) call static {i8,str}::Equals2({i8,str}, {i8,str}):bool
      5) brfalse [0]
      1) ldarg.0 [Arr<obj>]
      1) ldc.i4.0
      5) ldelem [Arr<obj>]
      1) ldc.i4.0
      5) ldelem [EqualityComparer<{i8,str}>]
      1) ldloc.0 [{i8,str}]
      1) ldarg.1 [{i8,str}]
      5) callvirt EqualityComparer<{i8,str}>::Equals({i8,str}, {i8,str}):bool
      5) br [1]
  Label [0]:
      1) ldc.i4.0
  Label [1]:
      1) ret
  Total Size: 63

Func sig: (QBs:{X:i8, Y:s}?*, QA:{X:i8, Y:s}?) to b*
Sequence: Seq<bool>
 0) true 
 1) false
 2) true 
 3) false
 4) false
###
> NA = NA  ~= RBs
NA @= NA ~@= RBs : b*
BndKind:Call, Type:b*, Bnd:(Call(∂.ForEach([map:1] Global(RBs), Cmp(Global(NA) @= Global(NA) ~@= Scope(1))):b*))
// (∂.RBs:{X:i8, Y:s}*, ∂.NA:{X:i8, Y:s}?) : b*
ForEach_1(Arr<obj>, {i8,str}):bool
      1) ldarg.0 [Arr<obj>]
      1) ldc.i4.2
      5) ldelem [({i8,str})]
      5) ldfld ({i8,str})::_F0:{i8,str}
      1) ldarg.0 [Arr<obj>]
      1) ldc.i4.2
      5) ldelem [({i8,str})]
      5) ldfld ({i8,str})::_F0:{i8,str}
      1) dup
      1) stloc.0 [{i8,str}]
      5) call static {i8,str}::Equals2({i8,str}, {i8,str}):bool
      5) brfalse [0]
      1) ldarg.0 [Arr<obj>]
      1) ldc.i4.0
      5) ldelem [Arr<obj>]
      1) ldc.i4.0
      5) ldelem [EqualityComparer<{i8,str}>]
      1) ldloc.0 [{i8,str}]
      1) ldarg.1 [{i8,str}]
      5) callvirt EqualityComparer<{i8,str}>::Equals({i8,str}, {i8,str}):bool
      5) br [1]
  Label [0]:
      1) ldc.i4.0
  Label [1]:
      1) ret
  Total Size: 63

Func sig: (RBs:{X:i8, Y:s}*, NA:{X:i8, Y:s}?) to b*
Sequence: Seq<bool>
 0) false
 1) false
 2) false
 3) false
###
> NA = NA  ~= QBs
NA @= NA ~@= QBs : b*
BndKind:Call, Type:b*, Bnd:(Call(∂.ForEach([map:1] Global(QBs), Cmp(Global(NA) @= Global(NA) ~@= Scope(1))):b*))
// (∂.QBs:{X:i8, Y:s}?*, ∂.NA:{X:i8, Y:s}?) : b*
ForEach_1(Arr<obj>, {i8,str}):bool
      1) ldarg.0 [Arr<obj>]
      1) ldc.i4.2
      5) ldelem [({i8,str})]
      5) ldfld ({i8,str})::_F0:{i8,str}
      1) ldarg.0 [Arr<obj>]
      1) ldc.i4.2
      5) ldelem [({i8,str})]
      5) ldfld ({i8,str})::_F0:{i8,str}
      1) dup
      1) stloc.0 [{i8,str}]
      5) call static {i8,str}::Equals2({i8,str}, {i8,str}):bool
      5) brfalse [0]
      1) ldarg.0 [Arr<obj>]
      1) ldc.i4.0
      5) ldelem [Arr<obj>]
      1) ldc.i4.0
      5) ldelem [EqualityComparer<{i8,str}>]
      1) ldloc.0 [{i8,str}]
      1) ldarg.1 [{i8,str}]
      5) callvirt EqualityComparer<{i8,str}>::Equals({i8,str}, {i8,str}):bool
      5) br [1]
  Label [0]:
      1) ldc.i4.0
  Label [1]:
      1) ret
  Total Size: 63

Func sig: (QBs:{X:i8, Y:s}?*, NA:{X:i8, Y:s}?) to b*
Sequence: Seq<bool>
 0) false
 1) false
 2) false
 3) false
 4) true 
###
> RA = RA !~= RBs
RA @= RA !~@= RBs : b*
BndKind:Call, Type:b*, Bnd:(Call(∂.ForEach([map:1] Global(RBs), Cmp(Global(RA) @= Global(RA) !~@= Scope(1))):b*))
// (∂.RBs:{X:i8, Y:s}*, ∂.RA:{X:i8, Y:s}) : b*
ForEach_1(Arr<obj>, {i8,str}):bool
      1) ldarg.0 [Arr<obj>]
      1) ldc.i4.2
      5) ldelem [({i8,str})]
      5) ldfld ({i8,str})::_F0:{i8,str}
      1) ldarg.0 [Arr<obj>]
      1) ldc.i4.2
      5) ldelem [({i8,str})]
      5) ldfld ({i8,str})::_F0:{i8,str}
      1) dup
      1) stloc.0 [{i8,str}]
      5) call static {i8,str}::Equals2({i8,str}, {i8,str}):bool
      5) brfalse [0]
      1) ldarg.0 [Arr<obj>]
      1) ldc.i4.0
      5) ldelem [Arr<obj>]
      1) ldc.i4.0
      5) ldelem [EqualityComparer<{i8,str}>]
      1) ldloc.0 [{i8,str}]
      1) ldarg.1 [{i8,str}]
      5) callvirt EqualityComparer<{i8,str}>::Equals({i8,str}, {i8,str}):bool
      1) ldc.i4.0
      2) ceq
      5) br [1]
  Label [0]:
      1) ldc.i4.0
  Label [1]:
      1) ret
  Total Size: 66

Func sig: (RBs:{X:i8, Y:s}*, RA:{X:i8, Y:s}) to b*
Sequence: Seq<bool>
 0) false
 1) true 
 2) false
 3) true 
###
> RA = RA !~= QBs
RA @= RA !~@= QBs : b*
BndKind:Call, Type:b*, Bnd:(Call(∂.ForEach([map:1] Global(QBs), Cmp(Global(RA) @= Global(RA) !~@= Scope(1))):b*))
// (∂.QBs:{X:i8, Y:s}?*, ∂.RA:{X:i8, Y:s}) : b*
ForEach_1(Arr<obj>, {i8,str}):bool
      1) ldarg.0 [Arr<obj>]
      1) ldc.i4.2
      5) ldelem [({i8,str})]
      5) ldfld ({i8,str})::_F0:{i8,str}
      1) ldarg.0 [Arr<obj>]
      1) ldc.i4.2
      5) ldelem [({i8,str})]
      5) ldfld ({i8,str})::_F0:{i8,str}
      1) dup
      1) stloc.0 [{i8,str}]
      5) call static {i8,str}::Equals2({i8,str}, {i8,str}):bool
      5) brfalse [0]
      1) ldarg.0 [Arr<obj>]
      1) ldc.i4.0
      5) ldelem [Arr<obj>]
      1) ldc.i4.0
      5) ldelem [EqualityComparer<{i8,str}>]
      1) ldloc.0 [{i8,str}]
      1) ldarg.1 [{i8,str}]
      5) callvirt EqualityComparer<{i8,str}>::Equals({i8,str}, {i8,str}):bool
      1) ldc.i4.0
      2) ceq
      5) br [1]
  Label [0]:
      1) ldc.i4.0
  Label [1]:
      1) ret
  Total Size: 66

Func sig: (QBs:{X:i8, Y:s}?*, RA:{X:i8, Y:s}) to b*
Sequence: Seq<bool>
 0) false
 1) true 
 2) false
 3) true 
 4) true 
###
> QA = QA !~= RBs
QA @= QA !~@= RBs : b*
BndKind:Call, Type:b*, Bnd:(Call(∂.ForEach([map:1] Global(RBs), Cmp(Global(QA) @= Global(QA) !~@= Scope(1))):b*))
// (∂.RBs:{X:i8, Y:s}*, ∂.QA:{X:i8, Y:s}?) : b*
ForEach_1(Arr<obj>, {i8,str}):bool
      1) ldarg.0 [Arr<obj>]
      1) ldc.i4.2
      5) ldelem [({i8,str})]
      5) ldfld ({i8,str})::_F0:{i8,str}
      1) ldarg.0 [Arr<obj>]
      1) ldc.i4.2
      5) ldelem [({i8,str})]
      5) ldfld ({i8,str})::_F0:{i8,str}
      1) dup
      1) stloc.0 [{i8,str}]
      5) call static {i8,str}::Equals2({i8,str}, {i8,str}):bool
      5) brfalse [0]
      1) ldarg.0 [Arr<obj>]
      1) ldc.i4.0
      5) ldelem [Arr<obj>]
      1) ldc.i4.0
      5) ldelem [EqualityComparer<{i8,str}>]
      1) ldloc.0 [{i8,str}]
      1) ldarg.1 [{i8,str}]
      5) callvirt EqualityComparer<{i8,str}>::Equals({i8,str}, {i8,str}):bool
      1) ldc.i4.0
      2) ceq
      5) br [1]
  Label [0]:
      1) ldc.i4.0
  Label [1]:
      1) ret
  Total Size: 66

Func sig: (RBs:{X:i8, Y:s}*, QA:{X:i8, Y:s}?) to b*
Sequence: Seq<bool>
 0) false
 1) true 
 2) false
 3) true 
###
> QA = QA !~= QBs
QA @= QA !~@= QBs : b*
BndKind:Call, Type:b*, Bnd:(Call(∂.ForEach([map:1] Global(QBs), Cmp(Global(QA) @= Global(QA) !~@= Scope(1))):b*))
// (∂.QBs:{X:i8, Y:s}?*, ∂.QA:{X:i8, Y:s}?) : b*
ForEach_1(Arr<obj>, {i8,str}):bool
      1) ldarg.0 [Arr<obj>]
      1) ldc.i4.2
      5) ldelem [({i8,str})]
      5) ldfld ({i8,str})::_F0:{i8,str}
      1) ldarg.0 [Arr<obj>]
      1) ldc.i4.2
      5) ldelem [({i8,str})]
      5) ldfld ({i8,str})::_F0:{i8,str}
      1) dup
      1) stloc.0 [{i8,str}]
      5) call static {i8,str}::Equals2({i8,str}, {i8,str}):bool
      5) brfalse [0]
      1) ldarg.0 [Arr<obj>]
      1) ldc.i4.0
      5) ldelem [Arr<obj>]
      1) ldc.i4.0
      5) ldelem [EqualityComparer<{i8,str}>]
      1) ldloc.0 [{i8,str}]
      1) ldarg.1 [{i8,str}]
      5) callvirt EqualityComparer<{i8,str}>::Equals({i8,str}, {i8,str}):bool
      1) ldc.i4.0
      2) ceq
      5) br [1]
  Label [0]:
      1) ldc.i4.0
  Label [1]:
      1) ret
  Total Size: 66

Func sig: (QBs:{X:i8, Y:s}?*, QA:{X:i8, Y:s}?) to b*
Sequence: Seq<bool>
 0) false
 1) true 
 2) false
 3) true 
 4) true 
###
> NA = NA !~= RBs
NA @= NA !~@= RBs : b*
BndKind:Call, Type:b*, Bnd:(Call(∂.ForEach([map:1] Global(RBs), Cmp(Global(NA) @= Global(NA) !~@= Scope(1))):b*))
// (∂.RBs:{X:i8, Y:s}*, ∂.NA:{X:i8, Y:s}?) : b*
ForEach_1(Arr<obj>, {i8,str}):bool
      1) ldarg.0 [Arr<obj>]
      1) ldc.i4.2
      5) ldelem [({i8,str})]
      5) ldfld ({i8,str})::_F0:{i8,str}
      1) ldarg.0 [Arr<obj>]
      1) ldc.i4.2
      5) ldelem [({i8,str})]
      5) ldfld ({i8,str})::_F0:{i8,str}
      1) dup
      1) stloc.0 [{i8,str}]
      5) call static {i8,str}::Equals2({i8,str}, {i8,str}):bool
      5) brfalse [0]
      1) ldarg.0 [Arr<obj>]
      1) ldc.i4.0
      5) ldelem [Arr<obj>]
      1) ldc.i4.0
      5) ldelem [EqualityComparer<{i8,str}>]
      1) ldloc.0 [{i8,str}]
      1) ldarg.1 [{i8,str}]
      5) callvirt EqualityComparer<{i8,str}>::Equals({i8,str}, {i8,str}):bool
      1) ldc.i4.0
      2) ceq
      5) br [1]
  Label [0]:
      1) ldc.i4.0
  Label [1]:
      1) ret
  Total Size: 66

Func sig: (RBs:{X:i8, Y:s}*, NA:{X:i8, Y:s}?) to b*
Sequence: Seq<bool>
 0) true 
 1) true 
 2) true 
 3) true 
###
> NA = NA !~= QBs
NA @= NA !~@= QBs : b*
BndKind:Call, Type:b*, Bnd:(Call(∂.ForEach([map:1] Global(QBs), Cmp(Global(NA) @= Global(NA) !~@= Scope(1))):b*))
// (∂.QBs:{X:i8, Y:s}?*, ∂.NA:{X:i8, Y:s}?) : b*
ForEach_1(Arr<obj>, {i8,str}):bool
      1) ldarg.0 [Arr<obj>]
      1) ldc.i4.2
      5) ldelem [({i8,str})]
      5) ldfld ({i8,str})::_F0:{i8,str}
      1) ldarg.0 [Arr<obj>]
      1) ldc.i4.2
      5) ldelem [({i8,str})]
      5) ldfld ({i8,str})::_F0:{i8,str}
      1) dup
      1) stloc.0 [{i8,str}]
      5) call static {i8,str}::Equals2({i8,str}, {i8,str}):bool
      5) brfalse [0]
      1) ldarg.0 [Arr<obj>]
      1) ldc.i4.0
      5) ldelem [Arr<obj>]
      1) ldc.i4.0
      5) ldelem [EqualityComparer<{i8,str}>]
      1) ldloc.0 [{i8,str}]
      1) ldarg.1 [{i8,str}]
      5) callvirt EqualityComparer<{i8,str}>::Equals({i8,str}, {i8,str}):bool
      1) ldc.i4.0
      2) ceq
      5) br [1]
  Label [0]:
      1) ldc.i4.0
  Label [1]:
      1) ret
  Total Size: 66

Func sig: (QBs:{X:i8, Y:s}?*, NA:{X:i8, Y:s}?) to b*
Sequence: Seq<bool>
 0) true 
 1) true 
 2) true 
 3) true 
 4) false
###
> RA   in RBs
RA in RBs : b
BndKind:BinaryOp, Type:b, Bnd:(In(Global(RA), Global(RBs)))
// (<ctx>, ∂.RA:{X:i8, Y:s}, ∂.RBs:{X:i8, Y:s}*) : b
top(Arr<obj>, Arr<obj>):obj
      1) ldarg.1 [Arr<obj>]
      1) ldc.i4.0
      1) ldelem.ref
      5) call static CodeGenUtil::ToRef(obj):ExecCtx
      1) stloc.0 [ExecCtx]
      1) ldarg.1 [Arr<obj>]
      1) ldc.i4.1
      1) ldelem.ref
      5) call static CodeGenUtil::ToRef(obj):{i8,str}
      1) stloc.1 [{i8,str}]
      1) ldarg.1 [Arr<obj>]
      1) ldc.i4.2
      1) ldelem.ref
      5) call static CodeGenUtil::ToRef(obj):Seq<{i8,str}>
      1) stloc.2 [Seq<{i8,str}>]
      1) ldloc.1 [{i8,str}]
      1) ldloc.2 [Seq<{i8,str}>]
      1) ldloc.0 [ExecCtx]
      1) ldc.i4.0
      5) call static CodeGenUtil::InImpl({i8,str}, Seq<{i8,str}>, ExecCtx, i4):bool
      5) box [bool]
      1) ret
  Total Size: 42

Func sig: (<ctx>:x, RA:{X:i8, Y:s}, RBs:{X:i8, Y:s}*) to b
Type: bool, Value: true 
*** Ctx ping count: 0
###
> RA   in RCs
RA in RCs : b
BndKind:BinaryOp, Type:b, Bnd:(In(Global(RA), Global(RCs)))
// (<ctx>, ∂.RA:{X:i8, Y:s}, ∂.RCs:{X:i8, Y:s}*) : b
top(Arr<obj>, Arr<obj>):obj
      1) ldarg.1 [Arr<obj>]
      1) ldc.i4.0
      1) ldelem.ref
      5) call static CodeGenUtil::ToRef(obj):ExecCtx
      1) stloc.0 [ExecCtx]
      1) ldarg.1 [Arr<obj>]
      1) ldc.i4.1
      1) ldelem.ref
      5) call static CodeGenUtil::ToRef(obj):{i8,str}
      1) stloc.1 [{i8,str}]
      1) ldarg.1 [Arr<obj>]
      1) ldc.i4.2
      1) ldelem.ref
      5) call static CodeGenUtil::ToRef(obj):Seq<{i8,str}>
      1) stloc.2 [Seq<{i8,str}>]
      1) ldloc.1 [{i8,str}]
      1) ldloc.2 [Seq<{i8,str}>]
      1) ldloc.0 [ExecCtx]
      1) ldc.i4.0
      5) call static CodeGenUtil::InImpl({i8,str}, Seq<{i8,str}>, ExecCtx, i4):bool
      5) box [bool]
      1) ret
  Total Size: 42

Func sig: (<ctx>:x, RA:{X:i8, Y:s}, RCs:{X:i8, Y:s}*) to b
Type: bool, Value: false
*** Ctx ping count: 3
    [0](3): In(RA, RCs)
###
> RA ! in RBs
RA !in RBs : b
BndKind:BinaryOp, Type:b, Bnd:(InNot(Global(RA), Global(RBs)))
// (<ctx>, ∂.RA:{X:i8, Y:s}, ∂.RBs:{X:i8, Y:s}*) : b
top(Arr<obj>, Arr<obj>):obj
      1) ldarg.1 [Arr<obj>]
      1) ldc.i4.0
      1) ldelem.ref
      5) call static CodeGenUtil::ToRef(obj):ExecCtx
      1) stloc.0 [ExecCtx]
      1) ldarg.1 [Arr<obj>]
      1) ldc.i4.1
      1) ldelem.ref
      5) call static CodeGenUtil::ToRef(obj):{i8,str}
      1) stloc.1 [{i8,str}]
      1) ldarg.1 [Arr<obj>]
      1) ldc.i4.2
      1) ldelem.ref
      5) call static CodeGenUtil::ToRef(obj):Seq<{i8,str}>
      1) stloc.2 [Seq<{i8,str}>]
      1) ldloc.1 [{i8,str}]
      1) ldloc.2 [Seq<{i8,str}>]
      1) ldloc.0 [ExecCtx]
      1) ldc.i4.0
      5) call static CodeGenUtil::InImpl({i8,str}, Seq<{i8,str}>, ExecCtx, i4):bool
      1) ldc.i4.0
      2) ceq
      5) box [bool]
      1) ret
  Total Size: 45

Func sig: (<ctx>:x, RA:{X:i8, Y:s}, RBs:{X:i8, Y:s}*) to b
Type: bool, Value: false
*** Ctx ping count: 0
###
> RA ! in RCs
RA !in RCs : b
BndKind:BinaryOp, Type:b, Bnd:(InNot(Global(RA), Global(RCs)))
// (<ctx>, ∂.RA:{X:i8, Y:s}, ∂.RCs:{X:i8, Y:s}*) : b
top(Arr<obj>, Arr<obj>):obj
      1) ldarg.1 [Arr<obj>]
      1) ldc.i4.0
      1) ldelem.ref
      5) call static CodeGenUtil::ToRef(obj):ExecCtx
      1) stloc.0 [ExecCtx]
      1) ldarg.1 [Arr<obj>]
      1) ldc.i4.1
      1) ldelem.ref
      5) call static CodeGenUtil::ToRef(obj):{i8,str}
      1) stloc.1 [{i8,str}]
      1) ldarg.1 [Arr<obj>]
      1) ldc.i4.2
      1) ldelem.ref
      5) call static CodeGenUtil::ToRef(obj):Seq<{i8,str}>
      1) stloc.2 [Seq<{i8,str}>]
      1) ldloc.1 [{i8,str}]
      1) ldloc.2 [Seq<{i8,str}>]
      1) ldloc.0 [ExecCtx]
      1) ldc.i4.0
      5) call static CodeGenUtil::InImpl({i8,str}, Seq<{i8,str}>, ExecCtx, i4):bool
      1) ldc.i4.0
      2) ceq
      5) box [bool]
      1) ret
  Total Size: 45

Func sig: (<ctx>:x, RA:{X:i8, Y:s}, RCs:{X:i8, Y:s}*) to b
Type: bool, Value: true 
*** Ctx ping count: 3
    [0](3): InNot(RA, RCs)
###
> RA  ~in RBs
RA ~in RBs : b
BndKind:BinaryOp, Type:b, Bnd:(InCi(Global(RA), Global(RBs)))
// (<ctx>, ∂.RA:{X:i8, Y:s}, ∂.RBs:{X:i8, Y:s}*) : b
top(Arr<obj>, Arr<obj>):obj
      1) ldarg.1 [Arr<obj>]
      1) ldc.i4.0
      1) ldelem.ref
      5) call static CodeGenUtil::ToRef(obj):ExecCtx
      1) stloc.0 [ExecCtx]
      1) ldarg.1 [Arr<obj>]
      1) ldc.i4.1
      1) ldelem.ref
      5) call static CodeGenUtil::ToRef(obj):{i8,str}
      1) stloc.1 [{i8,str}]
      1) ldarg.1 [Arr<obj>]
      1) ldc.i4.2
      1) ldelem.ref
      5) call static CodeGenUtil::ToRef(obj):Seq<{i8,str}>
      1) stloc.2 [Seq<{i8,str}>]
      1) ldloc.1 [{i8,str}]
      1) ldloc.2 [Seq<{i8,str}>]
      1) ldarg.0 [Arr<obj>]
      1) ldc.i4.0
      5) ldelem [EqualityComparer<{i8,str}>]
      1) ldloc.0 [ExecCtx]
      1) ldc.i4.0
      5) call static CodeGenUtil::InImpl({i8,str}, Seq<{i8,str}>, IEqualityComparer<{i8,str}>, ExecCtx, i4):bool
      5) box [bool]
      1) ret
  Total Size: 49

Func sig: (<ctx>:x, RA:{X:i8, Y:s}, RBs:{X:i8, Y:s}*) to b
Type: bool, Value: true 
*** Ctx ping count: 0
###
> RA  ~in RCs
RA ~in RCs : b
BndKind:BinaryOp, Type:b, Bnd:(InCi(Global(RA), Global(RCs)))
// (<ctx>, ∂.RA:{X:i8, Y:s}, ∂.RCs:{X:i8, Y:s}*) : b
top(Arr<obj>, Arr<obj>):obj
      1) ldarg.1 [Arr<obj>]
      1) ldc.i4.0
      1) ldelem.ref
      5) call static CodeGenUtil::ToRef(obj):ExecCtx
      1) stloc.0 [ExecCtx]
      1) ldarg.1 [Arr<obj>]
      1) ldc.i4.1
      1) ldelem.ref
      5) call static CodeGenUtil::ToRef(obj):{i8,str}
      1) stloc.1 [{i8,str}]
      1) ldarg.1 [Arr<obj>]
      1) ldc.i4.2
      1) ldelem.ref
      5) call static CodeGenUtil::ToRef(obj):Seq<{i8,str}>
      1) stloc.2 [Seq<{i8,str}>]
      1) ldloc.1 [{i8,str}]
      1) ldloc.2 [Seq<{i8,str}>]
      1) ldarg.0 [Arr<obj>]
      1) ldc.i4.0
      5) ldelem [EqualityComparer<{i8,str}>]
      1) ldloc.0 [ExecCtx]
      1) ldc.i4.0
      5) call static CodeGenUtil::InImpl({i8,str}, Seq<{i8,str}>, IEqualityComparer<{i8,str}>, ExecCtx, i4):bool
      5) box [bool]
      1) ret
  Total Size: 49

Func sig: (<ctx>:x, RA:{X:i8, Y:s}, RCs:{X:i8, Y:s}*) to b
Type: bool, Value: true 
*** Ctx ping count: 1
    [0](1): InCi(RA, RCs)
###
> RA !~in RBs
RA !~in RBs : b
BndKind:BinaryOp, Type:b, Bnd:(InCiNot(Global(RA), Global(RBs)))
// (<ctx>, ∂.RA:{X:i8, Y:s}, ∂.RBs:{X:i8, Y:s}*) : b
top(Arr<obj>, Arr<obj>):obj
      1) ldarg.1 [Arr<obj>]
      1) ldc.i4.0
      1) ldelem.ref
      5) call static CodeGenUtil::ToRef(obj):ExecCtx
      1) stloc.0 [ExecCtx]
      1) ldarg.1 [Arr<obj>]
      1) ldc.i4.1
      1) ldelem.ref
      5) call static CodeGenUtil::ToRef(obj):{i8,str}
      1) stloc.1 [{i8,str}]
      1) ldarg.1 [Arr<obj>]
      1) ldc.i4.2
      1) ldelem.ref
      5) call static CodeGenUtil::ToRef(obj):Seq<{i8,str}>
      1) stloc.2 [Seq<{i8,str}>]
      1) ldloc.1 [{i8,str}]
      1) ldloc.2 [Seq<{i8,str}>]
      1) ldarg.0 [Arr<obj>]
      1) ldc.i4.0
      5) ldelem [EqualityComparer<{i8,str}>]
      1) ldloc.0 [ExecCtx]
      1) ldc.i4.0
      5) call static CodeGenUtil::InImpl({i8,str}, Seq<{i8,str}>, IEqualityComparer<{i8,str}>, ExecCtx, i4):bool
      1) ldc.i4.0
      2) ceq
      5) box [bool]
      1) ret
  Total Size: 52

Func sig: (<ctx>:x, RA:{X:i8, Y:s}, RBs:{X:i8, Y:s}*) to b
Type: bool, Value: false
*** Ctx ping count: 0
###
> RA !~in RCs
RA !~in RCs : b
BndKind:BinaryOp, Type:b, Bnd:(InCiNot(Global(RA), Global(RCs)))
// (<ctx>, ∂.RA:{X:i8, Y:s}, ∂.RCs:{X:i8, Y:s}*) : b
top(Arr<obj>, Arr<obj>):obj
      1) ldarg.1 [Arr<obj>]
      1) ldc.i4.0
      1) ldelem.ref
      5) call static CodeGenUtil::ToRef(obj):ExecCtx
      1) stloc.0 [ExecCtx]
      1) ldarg.1 [Arr<obj>]
      1) ldc.i4.1
      1) ldelem.ref
      5) call static CodeGenUtil::ToRef(obj):{i8,str}
      1) stloc.1 [{i8,str}]
      1) ldarg.1 [Arr<obj>]
      1) ldc.i4.2
      1) ldelem.ref
      5) call static CodeGenUtil::ToRef(obj):Seq<{i8,str}>
      1) stloc.2 [Seq<{i8,str}>]
      1) ldloc.1 [{i8,str}]
      1) ldloc.2 [Seq<{i8,str}>]
      1) ldarg.0 [Arr<obj>]
      1) ldc.i4.0
      5) ldelem [EqualityComparer<{i8,str}>]
      1) ldloc.0 [ExecCtx]
      1) ldc.i4.0
      5) call static CodeGenUtil::InImpl({i8,str}, Seq<{i8,str}>, IEqualityComparer<{i8,str}>, ExecCtx, i4):bool
      1) ldc.i4.0
      2) ceq
      5) box [bool]
      1) ret
  Total Size: 52

Func sig: (<ctx>:x, RA:{X:i8, Y:s}, RCs:{X:i8, Y:s}*) to b
Type: bool, Value: false
*** Ctx ping count: 1
    [0](1): InCiNot(RA, RCs)
###
> NA = null != RA = RBs
NA @= null !@= RA @= RBs : b*
BndKind:Call, Type:b*, Bnd:(Call(∂.ForEach([map:1] Global(RBs), Cmp(Global(NA) @= null:{X:i8, Y:s}? && Global(RA) @= Scope(1))):b*))
// (∂.RBs:{X:i8, Y:s}*, ∂.NA:{X:i8, Y:s}?, ∂.RA:{X:i8, Y:s}) : b*
ForEach_1(Arr<obj>, {i8,str}):bool
      1) ldarg.0 [Arr<obj>]
      1) ldc.i4.2
      5) ldelem [({i8,str},{i8,str})]
      5) ldfld ({i8,str},{i8,str})::_F0:{i8,str}
      1) ldnull
      5) call static {i8,str}::Equals2({i8,str}, {i8,str}):bool
      5) brfalse [0]
      1) ldarg.0 [Arr<obj>]
      1) ldc.i4.2
      5) ldelem [({i8,str},{i8,str})]
      5) ldfld ({i8,str},{i8,str})::_F1:{i8,str}
      1) ldarg.1 [{i8,str}]
      5) call static {i8,str}::Equals2({i8,str}, {i8,str}):bool
      5) br [1]
  Label [0]:
      1) ldc.i4.0
  Label [1]:
      1) ret
  Total Size: 48

Func sig: (RBs:{X:i8, Y:s}*, NA:{X:i8, Y:s}?, RA:{X:i8, Y:s}) to b*
Sequence: Seq<bool>
 0) true 
 1) false
 2) false
 3) false
###

**** New definitions: RAs, type: {X:r8, Y:s}*
**** New definitions: QAs, type: {X:r8, Y:s}?*
**** New definitions: RBs, type: {X:r8, Y:s}*
**** New definitions: DAs, type: {X:r8, Y:s}*
**** New definitions: QBs, type: {X:r8, Y:s}?*
**** New udf: F, arity: 2

> F(RAs, RBs)
F(RAs, RBs) : (s, {X:r8, Y:s}, {X:r8, Y:s})**
BndKind:Call, Type:(s, {X:r8, Y:s}, {X:r8, Y:s})**, Bnd:(Call(∂.ForEach([map:1] Global(RAs), Call(∂.ForEach([map:2] Global(RBs), (StrConcat(If(Cmp(Scope(1) @= Scope(2)), str(M), str(_)), If(Cmp(Scope(1) ~@= Scope(2)), str(M), str(_)), If(Cmp(Scope(1) $= Scope(2)), str(M), str(_)), If(Cmp(Scope(1) ~$= Scope(2)), str(M), str(_))), Scope(1), Scope(2)):(s, {X:r8, Y:s}, {X:r8, Y:s})):(s, {X:r8, Y:s}, {X:r8, Y:s})*)):(s, {X:r8, Y:s}, {X:r8, Y:s})**))
// (∂.RAs:{X:r8, Y:s}*, ∂.RBs:{X:r8, Y:s}*) : (s, {X:r8, Y:s}, {X:r8, Y:s})**
ForEach_1(Arr<obj>, {r8,str}):(str,{r8,str},{r8,str})
      5) newobj (str,{r8,str},{r8,str})()
      1) dup
      1) ldarg.0 [Arr<obj>]
      1) ldc.i4.3
      5) ldelem [({r8,str})]
      5) ldfld ({r8,str})::_F0:{r8,str}
      1) ldarg.1 [{r8,str}]
      5) call static {r8,str}::Equals2({r8,str}, {r8,str}):bool
      5) brfalse [0]
      5) ldstr [M]
      5) br [1]
  Label [0]:
      5) ldstr [_]
  Label [1]:
      1) ldarg.0 [Arr<obj>]
      1) ldc.i4.0
      5) ldelem [Arr<obj>]
      1) ldc.i4.0
      5) ldelem [EqualityComparer<{r8,str}>]
      1) ldarg.0 [Arr<obj>]
      1) ldc.i4.3
      5) ldelem [({r8,str})]
      5) ldfld ({r8,str})::_F0:{r8,str}
      1) ldarg.1 [{r8,str}]
      5) callvirt EqualityComparer<{r8,str}>::Equals({r8,str}, {r8,str}):bool
      5) brfalse [2]
      5) ldstr [M]
      5) br [3]
  Label [2]:
      5) ldstr [_]
  Label [3]:
      1) ldarg.0 [Arr<obj>]
      1) ldc.i4.0
      5) ldelem [Arr<obj>]
      1) ldc.i4.1
      5) ldelem [EqualityComparer<{r8,str}>]
      1) ldarg.0 [Arr<obj>]
      1) ldc.i4.3
      5) ldelem [({r8,str})]
      5) ldfld ({r8,str})::_F0:{r8,str}
      1) ldarg.1 [{r8,str}]
      5) callvirt EqualityComparer<{r8,str}>::Equals({r8,str}, {r8,str}):bool
      5) brfalse [4]
      5) ldstr [M]
      5) br [5]
  Label [4]:
      5) ldstr [_]
  Label [5]:
      1) ldarg.0 [Arr<obj>]
      1) ldc.i4.0
      5) ldelem [Arr<obj>]
      1) ldc.i4.2
      5) ldelem [EqualityComparer<{r8,str}>]
      1) ldarg.0 [Arr<obj>]
      1) ldc.i4.3
      5) ldelem [({r8,str})]
      5) ldfld ({r8,str})::_F0:{r8,str}
      1) ldarg.1 [{r8,str}]
      5) callvirt EqualityComparer<{r8,str}>::Equals({r8,str}, {r8,str}):bool
      5) brfalse [6]
      5) ldstr [M]
      5) br [7]
  Label [6]:
      5) ldstr [_]
  Label [7]:
      5) call static str::Concat(str, str, str, str):str
      5) stfld (str,{r8,str},{r8,str})::_F0:str
      1) dup
      1) ldarg.0 [Arr<obj>]
      1) ldc.i4.3
      5) ldelem [({r8,str})]
      5) ldfld ({r8,str})::_F0:{r8,str}
      5) stfld (str,{r8,str},{r8,str})::_F1:{r8,str}
      1) dup
      1) ldarg.1 [{r8,str}]
      5) stfld (str,{r8,str},{r8,str})::_F2:{r8,str}
      1) ret
  Total Size: 233

Func sig: (RAs:{X:r8, Y:s}*, RBs:{X:r8, Y:s}*) to (s, {X:r8, Y:s}, {X:r8, Y:s})**
Sequence: Seq<Seq<(str,{r8,str},{r8,str})>>
 0) Sequence: Seq<(str,{r8,str},{r8,str})>
     0) (MMMM, { X: 3.5, Y: hi }, { X: 3.5, Y: hi })
     1) (____, { X: 3.5, Y: hi }, { X: 5, Y: hi })
     2) (_M_M, { X: 3.5, Y: hi }, { X: 3.5, Y: HI })
     3) (____, { X: 3.5, Y: hi }, { X: 3.5, Y: hj })
     4) (____, { X: 3.5, Y: hi }, { X: NaN, Y: hi })
     5) (____, { X: 3.5, Y: hi }, { X: NaN, Y: HI })
 1) Sequence: Seq<(str,{r8,str},{r8,str})>
     0) (____, { X: NaN, Y: hi }, { X: 3.5, Y: hi })
     1) (____, { X: NaN, Y: hi }, { X: 5, Y: hi })
     2) (____, { X: NaN, Y: hi }, { X: 3.5, Y: HI })
     3) (____, { X: NaN, Y: hi }, { X: 3.5, Y: hj })
     4) (MM__, { X: NaN, Y: hi }, { X: NaN, Y: hi })
     5) (_M__, { X: NaN, Y: hi }, { X: NaN, Y: HI })
###
> F(RAs, QBs)
F(RAs, QBs) : (s, {X:r8, Y:s}, {X:r8, Y:s}?)**
BndKind:Call, Type:(s, {X:r8, Y:s}, {X:r8, Y:s}?)**, Bnd:(Call(∂.ForEach([map:1] Global(RAs), Call(∂.ForEach([map:2] Global(QBs), (StrConcat(If(Cmp(Scope(1) @= Scope(2)), str(M), str(_)), If(Cmp(Scope(1) ~@= Scope(2)), str(M), str(_)), If(Cmp(Scope(1) $= Scope(2)), str(M), str(_)), If(Cmp(Scope(1) ~$= Scope(2)), str(M), str(_))), Scope(1), Scope(2)):(s, {X:r8, Y:s}, {X:r8, Y:s}?)):(s, {X:r8, Y:s}, {X:r8, Y:s}?)*)):(s, {X:r8, Y:s}, {X:r8, Y:s}?)**))
// (∂.RAs:{X:r8, Y:s}*, ∂.QBs:{X:r8, Y:s}?*) : (s, {X:r8, Y:s}, {X:r8, Y:s}?)**
ForEach_1(Arr<obj>, {r8,str}):(str,{r8,str},{r8,str})
      5) newobj (str,{r8,str},{r8,str})()
      1) dup
      1) ldarg.0 [Arr<obj>]
      1) ldc.i4.3
      5) ldelem [({r8,str})]
      5) ldfld ({r8,str})::_F0:{r8,str}
      1) ldarg.1 [{r8,str}]
      5) call static {r8,str}::Equals2({r8,str}, {r8,str}):bool
      5) brfalse [0]
      5) ldstr [M]
      5) br [1]
  Label [0]:
      5) ldstr [_]
  Label [1]:
      1) ldarg.0 [Arr<obj>]
      1) ldc.i4.0
      5) ldelem [Arr<obj>]
      1) ldc.i4.0
      5) ldelem [EqualityComparer<{r8,str}>]
      1) ldarg.0 [Arr<obj>]
      1) ldc.i4.3
      5) ldelem [({r8,str})]
      5) ldfld ({r8,str})::_F0:{r8,str}
      1) ldarg.1 [{r8,str}]
      5) callvirt EqualityComparer<{r8,str}>::Equals({r8,str}, {r8,str}):bool
      5) brfalse [2]
      5) ldstr [M]
      5) br [3]
  Label [2]:
      5) ldstr [_]
  Label [3]:
      1) ldarg.0 [Arr<obj>]
      1) ldc.i4.0
      5) ldelem [Arr<obj>]
      1) ldc.i4.1
      5) ldelem [EqualityComparer<{r8,str}>]
      1) ldarg.0 [Arr<obj>]
      1) ldc.i4.3
      5) ldelem [({r8,str})]
      5) ldfld ({r8,str})::_F0:{r8,str}
      1) ldarg.1 [{r8,str}]
      5) callvirt EqualityComparer<{r8,str}>::Equals({r8,str}, {r8,str}):bool
      5) brfalse [4]
      5) ldstr [M]
      5) br [5]
  Label [4]:
      5) ldstr [_]
  Label [5]:
      1) ldarg.0 [Arr<obj>]
      1) ldc.i4.0
      5) ldelem [Arr<obj>]
      1) ldc.i4.2
      5) ldelem [EqualityComparer<{r8,str}>]
      1) ldarg.0 [Arr<obj>]
      1) ldc.i4.3
      5) ldelem [({r8,str})]
      5) ldfld ({r8,str})::_F0:{r8,str}
      1) ldarg.1 [{r8,str}]
      5) callvirt EqualityComparer<{r8,str}>::Equals({r8,str}, {r8,str}):bool
      5) brfalse [6]
      5) ldstr [M]
      5) br [7]
  Label [6]:
      5) ldstr [_]
  Label [7]:
      5) call static str::Concat(str, str, str, str):str
      5) stfld (str,{r8,str},{r8,str})::_F0:str
      1) dup
      1) ldarg.0 [Arr<obj>]
      1) ldc.i4.3
      5) ldelem [({r8,str})]
      5) ldfld ({r8,str})::_F0:{r8,str}
      5) stfld (str,{r8,str},{r8,str})::_F1:{r8,str}
      1) dup
      1) ldarg.1 [{r8,str}]
      5) stfld (str,{r8,str},{r8,str})::_F2:{r8,str}
      1) ret
  Total Size: 233

Func sig: (RAs:{X:r8, Y:s}*, QBs:{X:r8, Y:s}?*) to (s, {X:r8, Y:s}, {X:r8, Y:s}?)**
Sequence: Seq<Seq<(str,{r8,str},{r8,str})>>
 0) Sequence: Seq<(str,{r8,str},{r8,str})>
     0) (MMMM, { X: 3.5, Y: hi }, { X: 3.5, Y: hi })
     1) (____, { X: 3.5, Y: hi }, { X: 5, Y: hi })
     2) (_M_M, { X: 3.5, Y: hi }, { X: 3.5, Y: HI })
     3) (____, { X: 3.5, Y: hi }, { X: 3.5, Y: hj })
     4) (____, { X: 3.5, Y: hi }, { X: NaN, Y: hi })
     5) (____, { X: 3.5, Y: hi }, { X: NaN, Y: HI })
     6) (____, { X: 3.5, Y: hi }, <null>)
 1) Sequence: Seq<(str,{r8,str},{r8,str})>
     0) (____, { X: NaN, Y: hi }, { X: 3.5, Y: hi })
     1) (____, { X: NaN, Y: hi }, { X: 5, Y: hi })
     2) (____, { X: NaN, Y: hi }, { X: 3.5, Y: HI })
     3) (____, { X: NaN, Y: hi }, { X: 3.5, Y: hj })
     4) (MM__, { X: NaN, Y: hi }, { X: NaN, Y: hi })
     5) (_M__, { X: NaN, Y: hi }, { X: NaN, Y: HI })
     6) (____, { X: NaN, Y: hi }, <null>)
###
> F(QAs, RBs)
F(QAs, RBs) : (s, {X:r8, Y:s}?, {X:r8, Y:s})**
BndKind:Call, Type:(s, {X:r8, Y:s}?, {X:r8, Y:s})**, Bnd:(Call(∂.ForEach([map:1] Global(QAs), Call(∂.ForEach([map:2] Global(RBs), (StrConcat(If(Cmp(Scope(1) @= Scope(2)), str(M), str(_)), If(Cmp(Scope(1) ~@= Scope(2)), str(M), str(_)), If(Cmp(Scope(1) $= Scope(2)), str(M), str(_)), If(Cmp(Scope(1) ~$= Scope(2)), str(M), str(_))), Scope(1), Scope(2)):(s, {X:r8, Y:s}?, {X:r8, Y:s})):(s, {X:r8, Y:s}?, {X:r8, Y:s})*)):(s, {X:r8, Y:s}?, {X:r8, Y:s})**))
// (∂.QAs:{X:r8, Y:s}?*, ∂.RBs:{X:r8, Y:s}*) : (s, {X:r8, Y:s}?, {X:r8, Y:s})**
ForEach_1(Arr<obj>, {r8,str}):(str,{r8,str},{r8,str})
      5) newobj (str,{r8,str},{r8,str})()
      1) dup
      1) ldarg.0 [Arr<obj>]
      1) ldc.i4.3
      5) ldelem [({r8,str})]
      5) ldfld ({r8,str})::_F0:{r8,str}
      1) ldarg.1 [{r8,str}]
      5) call static {r8,str}::Equals2({r8,str}, {r8,str}):bool
      5) brfalse [0]
      5) ldstr [M]
      5) br [1]
  Label [0]:
      5) ldstr [_]
  Label [1]:
      1) ldarg.0 [Arr<obj>]
      1) ldc.i4.0
      5) ldelem [Arr<obj>]
      1) ldc.i4.0
      5) ldelem [EqualityComparer<{r8,str}>]
      1) ldarg.0 [Arr<obj>]
      1) ldc.i4.3
      5) ldelem [({r8,str})]
      5) ldfld ({r8,str})::_F0:{r8,str}
      1) ldarg.1 [{r8,str}]
      5) callvirt EqualityComparer<{r8,str}>::Equals({r8,str}, {r8,str}):bool
      5) brfalse [2]
      5) ldstr [M]
      5) br [3]
  Label [2]:
      5) ldstr [_]
  Label [3]:
      1) ldarg.0 [Arr<obj>]
      1) ldc.i4.0
      5) ldelem [Arr<obj>]
      1) ldc.i4.1
      5) ldelem [EqualityComparer<{r8,str}>]
      1) ldarg.0 [Arr<obj>]
      1) ldc.i4.3
      5) ldelem [({r8,str})]
      5) ldfld ({r8,str})::_F0:{r8,str}
      1) ldarg.1 [{r8,str}]
      5) callvirt EqualityComparer<{r8,str}>::Equals({r8,str}, {r8,str}):bool
      5) brfalse [4]
      5) ldstr [M]
      5) br [5]
  Label [4]:
      5) ldstr [_]
  Label [5]:
      1) ldarg.0 [Arr<obj>]
      1) ldc.i4.0
      5) ldelem [Arr<obj>]
      1) ldc.i4.2
      5) ldelem [EqualityComparer<{r8,str}>]
      1) ldarg.0 [Arr<obj>]
      1) ldc.i4.3
      5) ldelem [({r8,str})]
      5) ldfld ({r8,str})::_F0:{r8,str}
      1) ldarg.1 [{r8,str}]
      5) callvirt EqualityComparer<{r8,str}>::Equals({r8,str}, {r8,str}):bool
      5) brfalse [6]
      5) ldstr [M]
      5) br [7]
  Label [6]:
      5) ldstr [_]
  Label [7]:
      5) call static str::Concat(str, str, str, str):str
      5) stfld (str,{r8,str},{r8,str})::_F0:str
      1) dup
      1) ldarg.0 [Arr<obj>]
      1) ldc.i4.3
      5) ldelem [({r8,str})]
      5) ldfld ({r8,str})::_F0:{r8,str}
      5) stfld (str,{r8,str},{r8,str})::_F1:{r8,str}
      1) dup
      1) ldarg.1 [{r8,str}]
      5) stfld (str,{r8,str},{r8,str})::_F2:{r8,str}
      1) ret
  Total Size: 233

Func sig: (QAs:{X:r8, Y:s}?*, RBs:{X:r8, Y:s}*) to (s, {X:r8, Y:s}?, {X:r8, Y:s})**
Sequence: Seq<Seq<(str,{r8,str},{r8,str})>>
 0) Sequence: Seq<(str,{r8,str},{r8,str})>
     0) (MMMM, { X: 3.5, Y: hi }, { X: 3.5, Y: hi })
     1) (____, { X: 3.5, Y: hi }, { X: 5, Y: hi })
     2) (_M_M, { X: 3.5, Y: hi }, { X: 3.5, Y: HI })
     3) (____, { X: 3.5, Y: hi }, { X: 3.5, Y: hj })
     4) (____, { X: 3.5, Y: hi }, { X: NaN, Y: hi })
     5) (____, { X: 3.5, Y: hi }, { X: NaN, Y: HI })
 1) Sequence: Seq<(str,{r8,str},{r8,str})>
     0) (____, { X: NaN, Y: hi }, { X: 3.5, Y: hi })
     1) (____, { X: NaN, Y: hi }, { X: 5, Y: hi })
     2) (____, { X: NaN, Y: hi }, { X: 3.5, Y: HI })
     3) (____, { X: NaN, Y: hi }, { X: 3.5, Y: hj })
     4) (MM__, { X: NaN, Y: hi }, { X: NaN, Y: hi })
     5) (_M__, { X: NaN, Y: hi }, { X: NaN, Y: HI })
 2) Sequence: Seq<(str,{r8,str},{r8,str})>
     0) (____, <null>, { X: 3.5, Y: hi })
     1) (____, <null>, { X: 5, Y: hi })
     2) (____, <null>, { X: 3.5, Y: HI })
     3) (____, <null>, { X: 3.5, Y: hj })
     4) (____, <null>, { X: NaN, Y: hi })
     5) (____, <null>, { X: NaN, Y: HI })
###
> F(QAs, QBs)
F(QAs, QBs) : (s, {X:r8, Y:s}?, {X:r8, Y:s}?)**
BndKind:Call, Type:(s, {X:r8, Y:s}?, {X:r8, Y:s}?)**, Bnd:(Call(∂.ForEach([map:1] Global(QAs), Call(∂.ForEach([map:2] Global(QBs), (StrConcat(If(Cmp(Scope(1) @= Scope(2)), str(M), str(_)), If(Cmp(Scope(1) ~@= Scope(2)), str(M), str(_)), If(Cmp(Scope(1) $= Scope(2)), str(M), str(_)), If(Cmp(Scope(1) ~$= Scope(2)), str(M), str(_))), Scope(1), Scope(2)):(s, {X:r8, Y:s}?, {X:r8, Y:s}?)):(s, {X:r8, Y:s}?, {X:r8, Y:s}?)*)):(s, {X:r8, Y:s}?, {X:r8, Y:s}?)**))
// (∂.QAs:{X:r8, Y:s}?*, ∂.QBs:{X:r8, Y:s}?*) : (s, {X:r8, Y:s}?, {X:r8, Y:s}?)**
ForEach_1(Arr<obj>, {r8,str}):(str,{r8,str},{r8,str})
      5) newobj (str,{r8,str},{r8,str})()
      1) dup
      1) ldarg.0 [Arr<obj>]
      1) ldc.i4.3
      5) ldelem [({r8,str})]
      5) ldfld ({r8,str})::_F0:{r8,str}
      1) ldarg.1 [{r8,str}]
      5) call static {r8,str}::Equals2({r8,str}, {r8,str}):bool
      5) brfalse [0]
      5) ldstr [M]
      5) br [1]
  Label [0]:
      5) ldstr [_]
  Label [1]:
      1) ldarg.0 [Arr<obj>]
      1) ldc.i4.0
      5) ldelem [Arr<obj>]
      1) ldc.i4.0
      5) ldelem [EqualityComparer<{r8,str}>]
      1) ldarg.0 [Arr<obj>]
      1) ldc.i4.3
      5) ldelem [({r8,str})]
      5) ldfld ({r8,str})::_F0:{r8,str}
      1) ldarg.1 [{r8,str}]
      5) callvirt EqualityComparer<{r8,str}>::Equals({r8,str}, {r8,str}):bool
      5) brfalse [2]
      5) ldstr [M]
      5) br [3]
  Label [2]:
      5) ldstr [_]
  Label [3]:
      1) ldarg.0 [Arr<obj>]
      1) ldc.i4.0
      5) ldelem [Arr<obj>]
      1) ldc.i4.1
      5) ldelem [EqualityComparer<{r8,str}>]
      1) ldarg.0 [Arr<obj>]
      1) ldc.i4.3
      5) ldelem [({r8,str})]
      5) ldfld ({r8,str})::_F0:{r8,str}
      1) ldarg.1 [{r8,str}]
      5) callvirt EqualityComparer<{r8,str}>::Equals({r8,str}, {r8,str}):bool
      5) brfalse [4]
      5) ldstr [M]
      5) br [5]
  Label [4]:
      5) ldstr [_]
  Label [5]:
      1) ldarg.0 [Arr<obj>]
      1) ldc.i4.0
      5) ldelem [Arr<obj>]
      1) ldc.i4.2
      5) ldelem [EqualityComparer<{r8,str}>]
      1) ldarg.0 [Arr<obj>]
      1) ldc.i4.3
      5) ldelem [({r8,str})]
      5) ldfld ({r8,str})::_F0:{r8,str}
      1) ldarg.1 [{r8,str}]
      5) callvirt EqualityComparer<{r8,str}>::Equals({r8,str}, {r8,str}):bool
      5) brfalse [6]
      5) ldstr [M]
      5) br [7]
  Label [6]:
      5) ldstr [_]
  Label [7]:
      5) call static str::Concat(str, str, str, str):str
      5) stfld (str,{r8,str},{r8,str})::_F0:str
      1) dup
      1) ldarg.0 [Arr<obj>]
      1) ldc.i4.3
      5) ldelem [({r8,str})]
      5) ldfld ({r8,str})::_F0:{r8,str}
      5) stfld (str,{r8,str},{r8,str})::_F1:{r8,str}
      1) dup
      1) ldarg.1 [{r8,str}]
      5) stfld (str,{r8,str},{r8,str})::_F2:{r8,str}
      1) ret
  Total Size: 233

Func sig: (QAs:{X:r8, Y:s}?*, QBs:{X:r8, Y:s}?*) to (s, {X:r8, Y:s}?, {X:r8, Y:s}?)**
Sequence: Seq<Seq<(str,{r8,str},{r8,str})>>
 0) Sequence: Seq<(str,{r8,str},{r8,str})>
     0) (MMMM, { X: 3.5, Y: hi }, { X: 3.5, Y: hi })
     1) (____, { X: 3.5, Y: hi }, { X: 5, Y: hi })
     2) (_M_M, { X: 3.5, Y: hi }, { X: 3.5, Y: HI })
     3) (____, { X: 3.5, Y: hi }, { X: 3.5, Y: hj })
     4) (____, { X: 3.5, Y: hi }, { X: NaN, Y: hi })
     5) (____, { X: 3.5, Y: hi }, { X: NaN, Y: HI })
     6) (____, { X: 3.5, Y: hi }, <null>)
 1) Sequence: Seq<(str,{r8,str},{r8,str})>
     0) (____, { X: NaN, Y: hi }, { X: 3.5, Y: hi })
     1) (____, { X: NaN, Y: hi }, { X: 5, Y: hi })
     2) (____, { X: NaN, Y: hi }, { X: 3.5, Y: HI })
     3) (____, { X: NaN, Y: hi }, { X: 3.5, Y: hj })
     4) (MM__, { X: NaN, Y: hi }, { X: NaN, Y: hi })
     5) (_M__, { X: NaN, Y: hi }, { X: NaN, Y: HI })
     6) (____, { X: NaN, Y: hi }, <null>)
 2) Sequence: Seq<(str,{r8,str},{r8,str})>
     0) (____, <null>, { X: 3.5, Y: hi })
     1) (____, <null>, { X: 5, Y: hi })
     2) (____, <null>, { X: 3.5, Y: HI })
     3) (____, <null>, { X: 3.5, Y: hj })
     4) (____, <null>, { X: NaN, Y: hi })
     5) (____, <null>, { X: NaN, Y: HI })
     6) (MM__, <null>, <null>)
###
> F(DAs, RBs)
F(DAs, RBs) : (s, {X:r8, Y:s}, {X:r8, Y:s})**
BndKind:Call, Type:(s, {X:r8, Y:s}, {X:r8, Y:s})**, Bnd:(Call(∂.ForEach([map:1] Global(DAs), Call(∂.ForEach([map:2] Global(RBs), (StrConcat(If(Cmp(Scope(1) @= Scope(2)), str(M), str(_)), If(Cmp(Scope(1) ~@= Scope(2)), str(M), str(_)), If(Cmp(Scope(1) $= Scope(2)), str(M), str(_)), If(Cmp(Scope(1) ~$= Scope(2)), str(M), str(_))), Scope(1), Scope(2)):(s, {X:r8, Y:s}, {X:r8, Y:s})):(s, {X:r8, Y:s}, {X:r8, Y:s})*)):(s, {X:r8, Y:s}, {X:r8, Y:s})**))
// (∂.DAs:{X:r8, Y:s}*, ∂.RBs:{X:r8, Y:s}*) : (s, {X:r8, Y:s}, {X:r8, Y:s})**
ForEach_1(Arr<obj>, {r8,str}):(str,{r8,str},{r8,str})
      5) newobj (str,{r8,str},{r8,str})()
      1) dup
      1) ldarg.0 [Arr<obj>]
      1) ldc.i4.3
      5) ldelem [({r8,str})]
      5) ldfld ({r8,str})::_F0:{r8,str}
      1) ldarg.1 [{r8,str}]
      5) call static {r8,str}::Equals2({r8,str}, {r8,str}):bool
      5) brfalse [0]
      5) ldstr [M]
      5) br [1]
  Label [0]:
      5) ldstr [_]
  Label [1]:
      1) ldarg.0 [Arr<obj>]
      1) ldc.i4.0
      5) ldelem [Arr<obj>]
      1) ldc.i4.0
      5) ldelem [EqualityComparer<{r8,str}>]
      1) ldarg.0 [Arr<obj>]
      1) ldc.i4.3
      5) ldelem [({r8,str})]
      5) ldfld ({r8,str})::_F0:{r8,str}
      1) ldarg.1 [{r8,str}]
      5) callvirt EqualityComparer<{r8,str}>::Equals({r8,str}, {r8,str}):bool
      5) brfalse [2]
      5) ldstr [M]
      5) br [3]
  Label [2]:
      5) ldstr [_]
  Label [3]:
      1) ldarg.0 [Arr<obj>]
      1) ldc.i4.0
      5) ldelem [Arr<obj>]
      1) ldc.i4.1
      5) ldelem [EqualityComparer<{r8,str}>]
      1) ldarg.0 [Arr<obj>]
      1) ldc.i4.3
      5) ldelem [({r8,str})]
      5) ldfld ({r8,str})::_F0:{r8,str}
      1) ldarg.1 [{r8,str}]
      5) callvirt EqualityComparer<{r8,str}>::Equals({r8,str}, {r8,str}):bool
      5) brfalse [4]
      5) ldstr [M]
      5) br [5]
  Label [4]:
      5) ldstr [_]
  Label [5]:
      1) ldarg.0 [Arr<obj>]
      1) ldc.i4.0
      5) ldelem [Arr<obj>]
      1) ldc.i4.2
      5) ldelem [EqualityComparer<{r8,str}>]
      1) ldarg.0 [Arr<obj>]
      1) ldc.i4.3
      5) ldelem [({r8,str})]
      5) ldfld ({r8,str})::_F0:{r8,str}
      1) ldarg.1 [{r8,str}]
      5) callvirt EqualityComparer<{r8,str}>::Equals({r8,str}, {r8,str}):bool
      5) brfalse [6]
      5) ldstr [M]
      5) br [7]
  Label [6]:
      5) ldstr [_]
  Label [7]:
      5) call static str::Concat(str, str, str, str):str
      5) stfld (str,{r8,str},{r8,str})::_F0:str
      1) dup
      1) ldarg.0 [Arr<obj>]
      1) ldc.i4.3
      5) ldelem [({r8,str})]
      5) ldfld ({r8,str})::_F0:{r8,str}
      5) stfld (str,{r8,str},{r8,str})::_F1:{r8,str}
      1) dup
      1) ldarg.1 [{r8,str}]
      5) stfld (str,{r8,str},{r8,str})::_F2:{r8,str}
      1) ret
  Total Size: 233

Func sig: (DAs:{X:r8, Y:s}*, RBs:{X:r8, Y:s}*) to (s, {X:r8, Y:s}, {X:r8, Y:s})**
Sequence: Seq<Seq<(str,{r8,str},{r8,str})>>
 0) Sequence: Seq<(str,{r8,str},{r8,str})>
     0) (MMMM, { X: 3.5, Y: hi }, { X: 3.5, Y: hi })
     1) (____, { X: 3.5, Y: hi }, { X: 5, Y: hi })
     2) (_M_M, { X: 3.5, Y: hi }, { X: 3.5, Y: HI })
     3) (____, { X: 3.5, Y: hi }, { X: 3.5, Y: hj })
     4) (____, { X: 3.5, Y: hi }, { X: NaN, Y: hi })
     5) (____, { X: 3.5, Y: hi }, { X: NaN, Y: HI })
 1) Sequence: Seq<(str,{r8,str},{r8,str})>
     0) (____, { X: NaN, Y: hi }, { X: 3.5, Y: hi })
     1) (____, { X: NaN, Y: hi }, { X: 5, Y: hi })
     2) (____, { X: NaN, Y: hi }, { X: 3.5, Y: HI })
     3) (____, { X: NaN, Y: hi }, { X: 3.5, Y: hj })
     4) (MM__, { X: NaN, Y: hi }, { X: NaN, Y: hi })
     5) (_M__, { X: NaN, Y: hi }, { X: NaN, Y: HI })
###
> F(DAs, QBs)
F(DAs, QBs) : (s, {X:r8, Y:s}, {X:r8, Y:s}?)**
BndKind:Call, Type:(s, {X:r8, Y:s}, {X:r8, Y:s}?)**, Bnd:(Call(∂.ForEach([map:1] Global(DAs), Call(∂.ForEach([map:2] Global(QBs), (StrConcat(If(Cmp(Scope(1) @= Scope(2)), str(M), str(_)), If(Cmp(Scope(1) ~@= Scope(2)), str(M), str(_)), If(Cmp(Scope(1) $= Scope(2)), str(M), str(_)), If(Cmp(Scope(1) ~$= Scope(2)), str(M), str(_))), Scope(1), Scope(2)):(s, {X:r8, Y:s}, {X:r8, Y:s}?)):(s, {X:r8, Y:s}, {X:r8, Y:s}?)*)):(s, {X:r8, Y:s}, {X:r8, Y:s}?)**))
// (∂.DAs:{X:r8, Y:s}*, ∂.QBs:{X:r8, Y:s}?*) : (s, {X:r8, Y:s}, {X:r8, Y:s}?)**
ForEach_1(Arr<obj>, {r8,str}):(str,{r8,str},{r8,str})
      5) newobj (str,{r8,str},{r8,str})()
      1) dup
      1) ldarg.0 [Arr<obj>]
      1) ldc.i4.3
      5) ldelem [({r8,str})]
      5) ldfld ({r8,str})::_F0:{r8,str}
      1) ldarg.1 [{r8,str}]
      5) call static {r8,str}::Equals2({r8,str}, {r8,str}):bool
      5) brfalse [0]
      5) ldstr [M]
      5) br [1]
  Label [0]:
      5) ldstr [_]
  Label [1]:
      1) ldarg.0 [Arr<obj>]
      1) ldc.i4.0
      5) ldelem [Arr<obj>]
      1) ldc.i4.0
      5) ldelem [EqualityComparer<{r8,str}>]
      1) ldarg.0 [Arr<obj>]
      1) ldc.i4.3
      5) ldelem [({r8,str})]
      5) ldfld ({r8,str})::_F0:{r8,str}
      1) ldarg.1 [{r8,str}]
      5) callvirt EqualityComparer<{r8,str}>::Equals({r8,str}, {r8,str}):bool
      5) brfalse [2]
      5) ldstr [M]
      5) br [3]
  Label [2]:
      5) ldstr [_]
  Label [3]:
      1) ldarg.0 [Arr<obj>]
      1) ldc.i4.0
      5) ldelem [Arr<obj>]
      1) ldc.i4.1
      5) ldelem [EqualityComparer<{r8,str}>]
      1) ldarg.0 [Arr<obj>]
      1) ldc.i4.3
      5) ldelem [({r8,str})]
      5) ldfld ({r8,str})::_F0:{r8,str}
      1) ldarg.1 [{r8,str}]
      5) callvirt EqualityComparer<{r8,str}>::Equals({r8,str}, {r8,str}):bool
      5) brfalse [4]
      5) ldstr [M]
      5) br [5]
  Label [4]:
      5) ldstr [_]
  Label [5]:
      1) ldarg.0 [Arr<obj>]
      1) ldc.i4.0
      5) ldelem [Arr<obj>]
      1) ldc.i4.2
      5) ldelem [EqualityComparer<{r8,str}>]
      1) ldarg.0 [Arr<obj>]
      1) ldc.i4.3
      5) ldelem [({r8,str})]
      5) ldfld ({r8,str})::_F0:{r8,str}
      1) ldarg.1 [{r8,str}]
      5) callvirt EqualityComparer<{r8,str}>::Equals({r8,str}, {r8,str}):bool
      5) brfalse [6]
      5) ldstr [M]
      5) br [7]
  Label [6]:
      5) ldstr [_]
  Label [7]:
      5) call static str::Concat(str, str, str, str):str
      5) stfld (str,{r8,str},{r8,str})::_F0:str
      1) dup
      1) ldarg.0 [Arr<obj>]
      1) ldc.i4.3
      5) ldelem [({r8,str})]
      5) ldfld ({r8,str})::_F0:{r8,str}
      5) stfld (str,{r8,str},{r8,str})::_F1:{r8,str}
      1) dup
      1) ldarg.1 [{r8,str}]
      5) stfld (str,{r8,str},{r8,str})::_F2:{r8,str}
      1) ret
  Total Size: 233

Func sig: (DAs:{X:r8, Y:s}*, QBs:{X:r8, Y:s}?*) to (s, {X:r8, Y:s}, {X:r8, Y:s}?)**
Sequence: Seq<Seq<(str,{r8,str},{r8,str})>>
 0) Sequence: Seq<(str,{r8,str},{r8,str})>
     0) (MMMM, { X: 3.5, Y: hi }, { X: 3.5, Y: hi })
     1) (____, { X: 3.5, Y: hi }, { X: 5, Y: hi })
     2) (_M_M, { X: 3.5, Y: hi }, { X: 3.5, Y: HI })
     3) (____, { X: 3.5, Y: hi }, { X: 3.5, Y: hj })
     4) (____, { X: 3.5, Y: hi }, { X: NaN, Y: hi })
     5) (____, { X: 3.5, Y: hi }, { X: NaN, Y: HI })
     6) (____, { X: 3.5, Y: hi }, <null>)
 1) Sequence: Seq<(str,{r8,str},{r8,str})>
     0) (____, { X: NaN, Y: hi }, { X: 3.5, Y: hi })
     1) (____, { X: NaN, Y: hi }, { X: 5, Y: hi })
     2) (____, { X: NaN, Y: hi }, { X: 3.5, Y: HI })
     3) (____, { X: NaN, Y: hi }, { X: 3.5, Y: hj })
     4) (MM__, { X: NaN, Y: hi }, { X: NaN, Y: hi })
     5) (_M__, { X: NaN, Y: hi }, { X: NaN, Y: HI })
     6) (____, { X: NaN, Y: hi }, <null>)
###
> F(DAs ++ [null], RBs)
F(DAs ++ [null], RBs) : (s, {X:r8, Y:s}?, {X:r8, Y:s})**
BndKind:Call, Type:(s, {X:r8, Y:s}?, {X:r8, Y:s})**, Bnd:(Call(∂.ForEach([map:1] SeqConcat(Ref<{X:r8, Y:s}?*>(Global(DAs)), [null:{X:r8, Y:s}?]:{X:r8, Y:s}?*), Call(∂.ForEach([map:2] Global(RBs), (StrConcat(If(Cmp(Scope(1) @= Scope(2)), str(M), str(_)), If(Cmp(Scope(1) ~@= Scope(2)), str(M), str(_)), If(Cmp(Scope(1) $= Scope(2)), str(M), str(_)), If(Cmp(Scope(1) ~$= Scope(2)), str(M), str(_))), Scope(1), Scope(2)):(s, {X:r8, Y:s}?, {X:r8, Y:s})):(s, {X:r8, Y:s}?, {X:r8, Y:s})*)):(s, {X:r8, Y:s}?, {X:r8, Y:s})**))
// (∂.DAs:{X:r8, Y:s}*, ∂.RBs:{X:r8, Y:s}*) : (s, {X:r8, Y:s}?, {X:r8, Y:s})**
ForEach_1(Arr<obj>, {r8,str}):(str,{r8,str},{r8,str})
      5) newobj (str,{r8,str},{r8,str})()
      1) dup
      1) ldarg.0 [Arr<obj>]
      1) ldc.i4.3
      5) ldelem [({r8,str})]
      5) ldfld ({r8,str})::_F0:{r8,str}
      1) ldarg.1 [{r8,str}]
      5) call static {r8,str}::Equals2({r8,str}, {r8,str}):bool
      5) brfalse [0]
      5) ldstr [M]
      5) br [1]
  Label [0]:
      5) ldstr [_]
  Label [1]:
      1) ldarg.0 [Arr<obj>]
      1) ldc.i4.0
      5) ldelem [Arr<obj>]
      1) ldc.i4.0
      5) ldelem [EqualityComparer<{r8,str}>]
      1) ldarg.0 [Arr<obj>]
      1) ldc.i4.3
      5) ldelem [({r8,str})]
      5) ldfld ({r8,str})::_F0:{r8,str}
      1) ldarg.1 [{r8,str}]
      5) callvirt EqualityComparer<{r8,str}>::Equals({r8,str}, {r8,str}):bool
      5) brfalse [2]
      5) ldstr [M]
      5) br [3]
  Label [2]:
      5) ldstr [_]
  Label [3]:
      1) ldarg.0 [Arr<obj>]
      1) ldc.i4.0
      5) ldelem [Arr<obj>]
      1) ldc.i4.1
      5) ldelem [EqualityComparer<{r8,str}>]
      1) ldarg.0 [Arr<obj>]
      1) ldc.i4.3
      5) ldelem [({r8,str})]
      5) ldfld ({r8,str})::_F0:{r8,str}
      1) ldarg.1 [{r8,str}]
      5) callvirt EqualityComparer<{r8,str}>::Equals({r8,str}, {r8,str}):bool
      5) brfalse [4]
      5) ldstr [M]
      5) br [5]
  Label [4]:
      5) ldstr [_]
  Label [5]:
      1) ldarg.0 [Arr<obj>]
      1) ldc.i4.0
      5) ldelem [Arr<obj>]
      1) ldc.i4.2
      5) ldelem [EqualityComparer<{r8,str}>]
      1) ldarg.0 [Arr<obj>]
      1) ldc.i4.3
      5) ldelem [({r8,str})]
      5) ldfld ({r8,str})::_F0:{r8,str}
      1) ldarg.1 [{r8,str}]
      5) callvirt EqualityComparer<{r8,str}>::Equals({r8,str}, {r8,str}):bool
      5) brfalse [6]
      5) ldstr [M]
      5) br [7]
  Label [6]:
      5) ldstr [_]
  Label [7]:
      5) call static str::Concat(str, str, str, str):str
      5) stfld (str,{r8,str},{r8,str})::_F0:str
      1) dup
      1) ldarg.0 [Arr<obj>]
      1) ldc.i4.3
      5) ldelem [({r8,str})]
      5) ldfld ({r8,str})::_F0:{r8,str}
      5) stfld (str,{r8,str},{r8,str})::_F1:{r8,str}
      1) dup
      1) ldarg.1 [{r8,str}]
      5) stfld (str,{r8,str},{r8,str})::_F2:{r8,str}
      1) ret
  Total Size: 233

Func sig: (DAs:{X:r8, Y:s}*, RBs:{X:r8, Y:s}*) to (s, {X:r8, Y:s}?, {X:r8, Y:s})**
Sequence: Seq<Seq<(str,{r8,str},{r8,str})>>
 0) Sequence: Seq<(str,{r8,str},{r8,str})>
     0) (MMMM, { X: 3.5, Y: hi }, { X: 3.5, Y: hi })
     1) (____, { X: 3.5, Y: hi }, { X: 5, Y: hi })
     2) (_M_M, { X: 3.5, Y: hi }, { X: 3.5, Y: HI })
     3) (____, { X: 3.5, Y: hi }, { X: 3.5, Y: hj })
     4) (____, { X: 3.5, Y: hi }, { X: NaN, Y: hi })
     5) (____, { X: 3.5, Y: hi }, { X: NaN, Y: HI })
 1) Sequence: Seq<(str,{r8,str},{r8,str})>
     0) (____, { X: NaN, Y: hi }, { X: 3.5, Y: hi })
     1) (____, { X: NaN, Y: hi }, { X: 5, Y: hi })
     2) (____, { X: NaN, Y: hi }, { X: 3.5, Y: HI })
     3) (____, { X: NaN, Y: hi }, { X: 3.5, Y: hj })
     4) (MM__, { X: NaN, Y: hi }, { X: NaN, Y: hi })
     5) (_M__, { X: NaN, Y: hi }, { X: NaN, Y: HI })
 2) Sequence: Seq<(str,{r8,str},{r8,str})>
     0) (____, <null>, { X: 3.5, Y: hi })
     1) (____, <null>, { X: 5, Y: hi })
     2) (____, <null>, { X: 3.5, Y: HI })
     3) (____, <null>, { X: 3.5, Y: hj })
     4) (____, <null>, { X: NaN, Y: hi })
     5) (____, <null>, { X: NaN, Y: HI })
###
> F(DAs ++ [null], QBs)
F(DAs ++ [null], QBs) : (s, {X:r8, Y:s}?, {X:r8, Y:s}?)**
BndKind:Call, Type:(s, {X:r8, Y:s}?, {X:r8, Y:s}?)**, Bnd:(Call(∂.ForEach([map:1] SeqConcat(Ref<{X:r8, Y:s}?*>(Global(DAs)), [null:{X:r8, Y:s}?]:{X:r8, Y:s}?*), Call(∂.ForEach([map:2] Global(QBs), (StrConcat(If(Cmp(Scope(1) @= Scope(2)), str(M), str(_)), If(Cmp(Scope(1) ~@= Scope(2)), str(M), str(_)), If(Cmp(Scope(1) $= Scope(2)), str(M), str(_)), If(Cmp(Scope(1) ~$= Scope(2)), str(M), str(_))), Scope(1), Scope(2)):(s, {X:r8, Y:s}?, {X:r8, Y:s}?)):(s, {X:r8, Y:s}?, {X:r8, Y:s}?)*)):(s, {X:r8, Y:s}?, {X:r8, Y:s}?)**))
// (∂.DAs:{X:r8, Y:s}*, ∂.QBs:{X:r8, Y:s}?*) : (s, {X:r8, Y:s}?, {X:r8, Y:s}?)**
ForEach_1(Arr<obj>, {r8,str}):(str,{r8,str},{r8,str})
      5) newobj (str,{r8,str},{r8,str})()
      1) dup
      1) ldarg.0 [Arr<obj>]
      1) ldc.i4.3
      5) ldelem [({r8,str})]
      5) ldfld ({r8,str})::_F0:{r8,str}
      1) ldarg.1 [{r8,str}]
      5) call static {r8,str}::Equals2({r8,str}, {r8,str}):bool
      5) brfalse [0]
      5) ldstr [M]
      5) br [1]
  Label [0]:
      5) ldstr [_]
  Label [1]:
      1) ldarg.0 [Arr<obj>]
      1) ldc.i4.0
      5) ldelem [Arr<obj>]
      1) ldc.i4.0
      5) ldelem [EqualityComparer<{r8,str}>]
      1) ldarg.0 [Arr<obj>]
      1) ldc.i4.3
      5) ldelem [({r8,str})]
      5) ldfld ({r8,str})::_F0:{r8,str}
      1) ldarg.1 [{r8,str}]
      5) callvirt EqualityComparer<{r8,str}>::Equals({r8,str}, {r8,str}):bool
      5) brfalse [2]
      5) ldstr [M]
      5) br [3]
  Label [2]:
      5) ldstr [_]
  Label [3]:
      1) ldarg.0 [Arr<obj>]
      1) ldc.i4.0
      5) ldelem [Arr<obj>]
      1) ldc.i4.1
      5) ldelem [EqualityComparer<{r8,str}>]
      1) ldarg.0 [Arr<obj>]
      1) ldc.i4.3
      5) ldelem [({r8,str})]
      5) ldfld ({r8,str})::_F0:{r8,str}
      1) ldarg.1 [{r8,str}]
      5) callvirt EqualityComparer<{r8,str}>::Equals({r8,str}, {r8,str}):bool
      5) brfalse [4]
      5) ldstr [M]
      5) br [5]
  Label [4]:
      5) ldstr [_]
  Label [5]:
      1) ldarg.0 [Arr<obj>]
      1) ldc.i4.0
      5) ldelem [Arr<obj>]
      1) ldc.i4.2
      5) ldelem [EqualityComparer<{r8,str}>]
      1) ldarg.0 [Arr<obj>]
      1) ldc.i4.3
      5) ldelem [({r8,str})]
      5) ldfld ({r8,str})::_F0:{r8,str}
      1) ldarg.1 [{r8,str}]
      5) callvirt EqualityComparer<{r8,str}>::Equals({r8,str}, {r8,str}):bool
      5) brfalse [6]
      5) ldstr [M]
      5) br [7]
  Label [6]:
      5) ldstr [_]
  Label [7]:
      5) call static str::Concat(str, str, str, str):str
      5) stfld (str,{r8,str},{r8,str})::_F0:str
      1) dup
      1) ldarg.0 [Arr<obj>]
      1) ldc.i4.3
      5) ldelem [({r8,str})]
      5) ldfld ({r8,str})::_F0:{r8,str}
      5) stfld (str,{r8,str},{r8,str})::_F1:{r8,str}
      1) dup
      1) ldarg.1 [{r8,str}]
      5) stfld (str,{r8,str},{r8,str})::_F2:{r8,str}
      1) ret
  Total Size: 233

Func sig: (DAs:{X:r8, Y:s}*, QBs:{X:r8, Y:s}?*) to (s, {X:r8, Y:s}?, {X:r8, Y:s}?)**
Sequence: Seq<Seq<(str,{r8,str},{r8,str})>>
 0) Sequence: Seq<(str,{r8,str},{r8,str})>
     0) (MMMM, { X: 3.5, Y: hi }, { X: 3.5, Y: hi })
     1) (____, { X: 3.5, Y: hi }, { X: 5, Y: hi })
     2) (_M_M, { X: 3.5, Y: hi }, { X: 3.5, Y: HI })
     3) (____, { X: 3.5, Y: hi }, { X: 3.5, Y: hj })
     4) (____, { X: 3.5, Y: hi }, { X: NaN, Y: hi })
     5) (____, { X: 3.5, Y: hi }, { X: NaN, Y: HI })
     6) (____, { X: 3.5, Y: hi }, <null>)
 1) Sequence: Seq<(str,{r8,str},{r8,str})>
     0) (____, { X: NaN, Y: hi }, { X: 3.5, Y: hi })
     1) (____, { X: NaN, Y: hi }, { X: 5, Y: hi })
     2) (____, { X: NaN, Y: hi }, { X: 3.5, Y: HI })
     3) (____, { X: NaN, Y: hi }, { X: 3.5, Y: hj })
     4) (MM__, { X: NaN, Y: hi }, { X: NaN, Y: hi })
     5) (_M__, { X: NaN, Y: hi }, { X: NaN, Y: HI })
     6) (____, { X: NaN, Y: hi }, <null>)
 2) Sequence: Seq<(str,{r8,str},{r8,str})>
     0) (____, <null>, { X: 3.5, Y: hi })
     1) (____, <null>, { X: 5, Y: hi })
     2) (____, <null>, { X: 3.5, Y: HI })
     3) (____, <null>, { X: 3.5, Y: hj })
     4) (____, <null>, { X: NaN, Y: hi })
     5) (____, <null>, { X: NaN, Y: HI })
     6) (MM__, <null>, <null>)
###
