**** New definitions: RA, type: (i8, s)
**** New definitions: QA, type: (i8, s)?
**** New definitions: NA, type: (i8, s)?
**** New definitions: RBs, type: (i8, s)*
**** New definitions: QBs, type: (i8, s)?*
**** New definitions: RCs, type: (i8, s)*
**** New definitions: __IL_Func_Ind, type: i8

> RA   = RBs
RA @= RBs : b*
BndKind:Call, Type:b*, Bnd:(Call(∂.ForEach([map:1] Global(RBs), Cmp(Global(RA) @= Scope(1))):b*))
// (∂.RBs:(i8, s)*, ∂.RA:(i8, s)) : b*
ForEach_1(Arr<obj>, (i8,str)):bool
      1) ldarg.0 [Arr<obj>]
      1) ldc.i4.2
      5) ldelem [((i8,str))]
      5) ldfld ((i8,str))::_F0:(i8,str)
      1) ldarg.1 [(i8,str)]
      5) call static (i8,str)::Equals2((i8,str), (i8,str)):bool
      1) ret
  Total Size: 19

Func sig: (RBs:(i8, s)*, RA:(i8, s)) to b*
Sequence: Seq<bool>
 0) true 
 1) false
 2) false
 3) false
###
> RA   = QBs
RA @= QBs : b*
BndKind:Call, Type:b*, Bnd:(Call(∂.ForEach([map:1] Global(QBs), Cmp(Global(RA) @= Scope(1))):b*))
// (∂.QBs:(i8, s)?*, ∂.RA:(i8, s)) : b*
ForEach_1(Arr<obj>, (i8,str)):bool
      1) ldarg.0 [Arr<obj>]
      1) ldc.i4.2
      5) ldelem [((i8,str))]
      5) ldfld ((i8,str))::_F0:(i8,str)
      1) ldarg.1 [(i8,str)]
      5) call static (i8,str)::Equals2((i8,str), (i8,str)):bool
      1) ret
  Total Size: 19

Func sig: (QBs:(i8, s)?*, RA:(i8, s)) to b*
Sequence: Seq<bool>
 0) true 
 1) false
 2) false
 3) false
 4) false
###
> QA   = RBs
QA @= RBs : b*
BndKind:Call, Type:b*, Bnd:(Call(∂.ForEach([map:1] Global(RBs), Cmp(Global(QA) @= Scope(1))):b*))
// (∂.RBs:(i8, s)*, ∂.QA:(i8, s)?) : b*
ForEach_1(Arr<obj>, (i8,str)):bool
      1) ldarg.0 [Arr<obj>]
      1) ldc.i4.2
      5) ldelem [((i8,str))]
      5) ldfld ((i8,str))::_F0:(i8,str)
      1) ldarg.1 [(i8,str)]
      5) call static (i8,str)::Equals2((i8,str), (i8,str)):bool
      1) ret
  Total Size: 19

Func sig: (RBs:(i8, s)*, QA:(i8, s)?) to b*
Sequence: Seq<bool>
 0) true 
 1) false
 2) false
 3) false
###
> QA   = QBs
QA @= QBs : b*
BndKind:Call, Type:b*, Bnd:(Call(∂.ForEach([map:1] Global(QBs), Cmp(Global(QA) @= Scope(1))):b*))
// (∂.QBs:(i8, s)?*, ∂.QA:(i8, s)?) : b*
ForEach_1(Arr<obj>, (i8,str)):bool
      1) ldarg.0 [Arr<obj>]
      1) ldc.i4.2
      5) ldelem [((i8,str))]
      5) ldfld ((i8,str))::_F0:(i8,str)
      1) ldarg.1 [(i8,str)]
      5) call static (i8,str)::Equals2((i8,str), (i8,str)):bool
      1) ret
  Total Size: 19

Func sig: (QBs:(i8, s)?*, QA:(i8, s)?) to b*
Sequence: Seq<bool>
 0) true 
 1) false
 2) false
 3) false
 4) false
###
> NA   = RBs
NA @= RBs : b*
BndKind:Call, Type:b*, Bnd:(Call(∂.ForEach([map:1] Global(RBs), Cmp(Global(NA) @= Scope(1))):b*))
// (∂.RBs:(i8, s)*, ∂.NA:(i8, s)?) : b*
ForEach_1(Arr<obj>, (i8,str)):bool
      1) ldarg.0 [Arr<obj>]
      1) ldc.i4.2
      5) ldelem [((i8,str))]
      5) ldfld ((i8,str))::_F0:(i8,str)
      1) ldarg.1 [(i8,str)]
      5) call static (i8,str)::Equals2((i8,str), (i8,str)):bool
      1) ret
  Total Size: 19

Func sig: (RBs:(i8, s)*, NA:(i8, s)?) to b*
Sequence: Seq<bool>
 0) false
 1) false
 2) false
 3) false
###
> NA   = QBs
NA @= QBs : b*
BndKind:Call, Type:b*, Bnd:(Call(∂.ForEach([map:1] Global(QBs), Cmp(Global(NA) @= Scope(1))):b*))
// (∂.QBs:(i8, s)?*, ∂.NA:(i8, s)?) : b*
ForEach_1(Arr<obj>, (i8,str)):bool
      1) ldarg.0 [Arr<obj>]
      1) ldc.i4.2
      5) ldelem [((i8,str))]
      5) ldfld ((i8,str))::_F0:(i8,str)
      1) ldarg.1 [(i8,str)]
      5) call static (i8,str)::Equals2((i8,str), (i8,str)):bool
      1) ret
  Total Size: 19

Func sig: (QBs:(i8, s)?*, NA:(i8, s)?) to b*
Sequence: Seq<bool>
 0) false
 1) false
 2) false
 3) false
 4) true 
###
> RA ! = RBs
RA !@= RBs : b*
BndKind:Call, Type:b*, Bnd:(Call(∂.ForEach([map:1] Global(RBs), Cmp(Global(RA) !@= Scope(1))):b*))
// (∂.RBs:(i8, s)*, ∂.RA:(i8, s)) : b*
ForEach_1(Arr<obj>, (i8,str)):bool
      1) ldarg.0 [Arr<obj>]
      1) ldc.i4.2
      5) ldelem [((i8,str))]
      5) ldfld ((i8,str))::_F0:(i8,str)
      1) ldarg.1 [(i8,str)]
      5) call static (i8,str)::Equals2((i8,str), (i8,str)):bool
      1) ldc.i4.0
      2) ceq
      1) ret
  Total Size: 22

Func sig: (RBs:(i8, s)*, RA:(i8, s)) to b*
Sequence: Seq<bool>
 0) false
 1) true 
 2) true 
 3) true 
###
> RA ! = QBs
RA !@= QBs : b*
BndKind:Call, Type:b*, Bnd:(Call(∂.ForEach([map:1] Global(QBs), Cmp(Global(RA) !@= Scope(1))):b*))
// (∂.QBs:(i8, s)?*, ∂.RA:(i8, s)) : b*
ForEach_1(Arr<obj>, (i8,str)):bool
      1) ldarg.0 [Arr<obj>]
      1) ldc.i4.2
      5) ldelem [((i8,str))]
      5) ldfld ((i8,str))::_F0:(i8,str)
      1) ldarg.1 [(i8,str)]
      5) call static (i8,str)::Equals2((i8,str), (i8,str)):bool
      1) ldc.i4.0
      2) ceq
      1) ret
  Total Size: 22

Func sig: (QBs:(i8, s)?*, RA:(i8, s)) to b*
Sequence: Seq<bool>
 0) false
 1) true 
 2) true 
 3) true 
 4) true 
###
> QA ! = RBs
QA !@= RBs : b*
BndKind:Call, Type:b*, Bnd:(Call(∂.ForEach([map:1] Global(RBs), Cmp(Global(QA) !@= Scope(1))):b*))
// (∂.RBs:(i8, s)*, ∂.QA:(i8, s)?) : b*
ForEach_1(Arr<obj>, (i8,str)):bool
      1) ldarg.0 [Arr<obj>]
      1) ldc.i4.2
      5) ldelem [((i8,str))]
      5) ldfld ((i8,str))::_F0:(i8,str)
      1) ldarg.1 [(i8,str)]
      5) call static (i8,str)::Equals2((i8,str), (i8,str)):bool
      1) ldc.i4.0
      2) ceq
      1) ret
  Total Size: 22

Func sig: (RBs:(i8, s)*, QA:(i8, s)?) to b*
Sequence: Seq<bool>
 0) false
 1) true 
 2) true 
 3) true 
###
> QA ! = QBs
QA !@= QBs : b*
BndKind:Call, Type:b*, Bnd:(Call(∂.ForEach([map:1] Global(QBs), Cmp(Global(QA) !@= Scope(1))):b*))
// (∂.QBs:(i8, s)?*, ∂.QA:(i8, s)?) : b*
ForEach_1(Arr<obj>, (i8,str)):bool
      1) ldarg.0 [Arr<obj>]
      1) ldc.i4.2
      5) ldelem [((i8,str))]
      5) ldfld ((i8,str))::_F0:(i8,str)
      1) ldarg.1 [(i8,str)]
      5) call static (i8,str)::Equals2((i8,str), (i8,str)):bool
      1) ldc.i4.0
      2) ceq
      1) ret
  Total Size: 22

Func sig: (QBs:(i8, s)?*, QA:(i8, s)?) to b*
Sequence: Seq<bool>
 0) false
 1) true 
 2) true 
 3) true 
 4) true 
###
> NA ! = RBs
NA !@= RBs : b*
BndKind:Call, Type:b*, Bnd:(Call(∂.ForEach([map:1] Global(RBs), Cmp(Global(NA) !@= Scope(1))):b*))
// (∂.RBs:(i8, s)*, ∂.NA:(i8, s)?) : b*
ForEach_1(Arr<obj>, (i8,str)):bool
      1) ldarg.0 [Arr<obj>]
      1) ldc.i4.2
      5) ldelem [((i8,str))]
      5) ldfld ((i8,str))::_F0:(i8,str)
      1) ldarg.1 [(i8,str)]
      5) call static (i8,str)::Equals2((i8,str), (i8,str)):bool
      1) ldc.i4.0
      2) ceq
      1) ret
  Total Size: 22

Func sig: (RBs:(i8, s)*, NA:(i8, s)?) to b*
Sequence: Seq<bool>
 0) true 
 1) true 
 2) true 
 3) true 
###
> NA ! = QBs
NA !@= QBs : b*
BndKind:Call, Type:b*, Bnd:(Call(∂.ForEach([map:1] Global(QBs), Cmp(Global(NA) !@= Scope(1))):b*))
// (∂.QBs:(i8, s)?*, ∂.NA:(i8, s)?) : b*
ForEach_1(Arr<obj>, (i8,str)):bool
      1) ldarg.0 [Arr<obj>]
      1) ldc.i4.2
      5) ldelem [((i8,str))]
      5) ldfld ((i8,str))::_F0:(i8,str)
      1) ldarg.1 [(i8,str)]
      5) call static (i8,str)::Equals2((i8,str), (i8,str)):bool
      1) ldc.i4.0
      2) ceq
      1) ret
  Total Size: 22

Func sig: (QBs:(i8, s)?*, NA:(i8, s)?) to b*
Sequence: Seq<bool>
 0) true 
 1) true 
 2) true 
 3) true 
 4) false
###
> RA  ~= RBs
RA ~@= RBs : b*
BndKind:Call, Type:b*, Bnd:(Call(∂.ForEach([map:1] Global(RBs), Cmp(Global(RA) ~@= Scope(1))):b*))
// (∂.RBs:(i8, s)*, ∂.RA:(i8, s)) : b*
ForEach_1(Arr<obj>, (i8,str)):bool
      1) ldarg.0 [Arr<obj>]
      1) ldc.i4.0
      5) ldelem [Arr<obj>]
      1) ldc.i4.0
      5) ldelem [EqualityComparer<(i8,str)>]
      1) ldarg.0 [Arr<obj>]
      1) ldc.i4.2
      5) ldelem [((i8,str))]
      5) ldfld ((i8,str))::_F0:(i8,str)
      1) ldarg.1 [(i8,str)]
      5) callvirt EqualityComparer<(i8,str)>::Equals((i8,str), (i8,str)):bool
      1) ret
  Total Size: 32

Func sig: (RBs:(i8, s)*, RA:(i8, s)) to b*
Sequence: Seq<bool>
 0) true 
 1) false
 2) true 
 3) false
###
> RA  ~= QBs
RA ~@= QBs : b*
BndKind:Call, Type:b*, Bnd:(Call(∂.ForEach([map:1] Global(QBs), Cmp(Global(RA) ~@= Scope(1))):b*))
// (∂.QBs:(i8, s)?*, ∂.RA:(i8, s)) : b*
ForEach_1(Arr<obj>, (i8,str)):bool
      1) ldarg.0 [Arr<obj>]
      1) ldc.i4.0
      5) ldelem [Arr<obj>]
      1) ldc.i4.0
      5) ldelem [EqualityComparer<(i8,str)>]
      1) ldarg.0 [Arr<obj>]
      1) ldc.i4.2
      5) ldelem [((i8,str))]
      5) ldfld ((i8,str))::_F0:(i8,str)
      1) ldarg.1 [(i8,str)]
      5) callvirt EqualityComparer<(i8,str)>::Equals((i8,str), (i8,str)):bool
      1) ret
  Total Size: 32

Func sig: (QBs:(i8, s)?*, RA:(i8, s)) to b*
Sequence: Seq<bool>
 0) true 
 1) false
 2) true 
 3) false
 4) false
###
> QA  ~= RBs
QA ~@= RBs : b*
BndKind:Call, Type:b*, Bnd:(Call(∂.ForEach([map:1] Global(RBs), Cmp(Global(QA) ~@= Scope(1))):b*))
// (∂.RBs:(i8, s)*, ∂.QA:(i8, s)?) : b*
ForEach_1(Arr<obj>, (i8,str)):bool
      1) ldarg.0 [Arr<obj>]
      1) ldc.i4.0
      5) ldelem [Arr<obj>]
      1) ldc.i4.0
      5) ldelem [EqualityComparer<(i8,str)>]
      1) ldarg.0 [Arr<obj>]
      1) ldc.i4.2
      5) ldelem [((i8,str))]
      5) ldfld ((i8,str))::_F0:(i8,str)
      1) ldarg.1 [(i8,str)]
      5) callvirt EqualityComparer<(i8,str)>::Equals((i8,str), (i8,str)):bool
      1) ret
  Total Size: 32

Func sig: (RBs:(i8, s)*, QA:(i8, s)?) to b*
Sequence: Seq<bool>
 0) true 
 1) false
 2) true 
 3) false
###
> QA  ~= QBs
QA ~@= QBs : b*
BndKind:Call, Type:b*, Bnd:(Call(∂.ForEach([map:1] Global(QBs), Cmp(Global(QA) ~@= Scope(1))):b*))
// (∂.QBs:(i8, s)?*, ∂.QA:(i8, s)?) : b*
ForEach_1(Arr<obj>, (i8,str)):bool
      1) ldarg.0 [Arr<obj>]
      1) ldc.i4.0
      5) ldelem [Arr<obj>]
      1) ldc.i4.0
      5) ldelem [EqualityComparer<(i8,str)>]
      1) ldarg.0 [Arr<obj>]
      1) ldc.i4.2
      5) ldelem [((i8,str))]
      5) ldfld ((i8,str))::_F0:(i8,str)
      1) ldarg.1 [(i8,str)]
      5) callvirt EqualityComparer<(i8,str)>::Equals((i8,str), (i8,str)):bool
      1) ret
  Total Size: 32

Func sig: (QBs:(i8, s)?*, QA:(i8, s)?) to b*
Sequence: Seq<bool>
 0) true 
 1) false
 2) true 
 3) false
 4) false
###
> NA  ~= RBs
NA ~@= RBs : b*
BndKind:Call, Type:b*, Bnd:(Call(∂.ForEach([map:1] Global(RBs), Cmp(Global(NA) ~@= Scope(1))):b*))
// (∂.RBs:(i8, s)*, ∂.NA:(i8, s)?) : b*
ForEach_1(Arr<obj>, (i8,str)):bool
      1) ldarg.0 [Arr<obj>]
      1) ldc.i4.0
      5) ldelem [Arr<obj>]
      1) ldc.i4.0
      5) ldelem [EqualityComparer<(i8,str)>]
      1) ldarg.0 [Arr<obj>]
      1) ldc.i4.2
      5) ldelem [((i8,str))]
      5) ldfld ((i8,str))::_F0:(i8,str)
      1) ldarg.1 [(i8,str)]
      5) callvirt EqualityComparer<(i8,str)>::Equals((i8,str), (i8,str)):bool
      1) ret
  Total Size: 32

Func sig: (RBs:(i8, s)*, NA:(i8, s)?) to b*
Sequence: Seq<bool>
 0) false
 1) false
 2) false
 3) false
###
> NA  ~= QBs
NA ~@= QBs : b*
BndKind:Call, Type:b*, Bnd:(Call(∂.ForEach([map:1] Global(QBs), Cmp(Global(NA) ~@= Scope(1))):b*))
// (∂.QBs:(i8, s)?*, ∂.NA:(i8, s)?) : b*
ForEach_1(Arr<obj>, (i8,str)):bool
      1) ldarg.0 [Arr<obj>]
      1) ldc.i4.0
      5) ldelem [Arr<obj>]
      1) ldc.i4.0
      5) ldelem [EqualityComparer<(i8,str)>]
      1) ldarg.0 [Arr<obj>]
      1) ldc.i4.2
      5) ldelem [((i8,str))]
      5) ldfld ((i8,str))::_F0:(i8,str)
      1) ldarg.1 [(i8,str)]
      5) callvirt EqualityComparer<(i8,str)>::Equals((i8,str), (i8,str)):bool
      1) ret
  Total Size: 32

Func sig: (QBs:(i8, s)?*, NA:(i8, s)?) to b*
Sequence: Seq<bool>
 0) false
 1) false
 2) false
 3) false
 4) true 
###
> RA !~= RBs
RA !~@= RBs : b*
BndKind:Call, Type:b*, Bnd:(Call(∂.ForEach([map:1] Global(RBs), Cmp(Global(RA) !~@= Scope(1))):b*))
// (∂.RBs:(i8, s)*, ∂.RA:(i8, s)) : b*
ForEach_1(Arr<obj>, (i8,str)):bool
      1) ldarg.0 [Arr<obj>]
      1) ldc.i4.0
      5) ldelem [Arr<obj>]
      1) ldc.i4.0
      5) ldelem [EqualityComparer<(i8,str)>]
      1) ldarg.0 [Arr<obj>]
      1) ldc.i4.2
      5) ldelem [((i8,str))]
      5) ldfld ((i8,str))::_F0:(i8,str)
      1) ldarg.1 [(i8,str)]
      5) callvirt EqualityComparer<(i8,str)>::Equals((i8,str), (i8,str)):bool
      1) ldc.i4.0
      2) ceq
      1) ret
  Total Size: 35

Func sig: (RBs:(i8, s)*, RA:(i8, s)) to b*
Sequence: Seq<bool>
 0) false
 1) true 
 2) false
 3) true 
###
> RA !~= QBs
RA !~@= QBs : b*
BndKind:Call, Type:b*, Bnd:(Call(∂.ForEach([map:1] Global(QBs), Cmp(Global(RA) !~@= Scope(1))):b*))
// (∂.QBs:(i8, s)?*, ∂.RA:(i8, s)) : b*
ForEach_1(Arr<obj>, (i8,str)):bool
      1) ldarg.0 [Arr<obj>]
      1) ldc.i4.0
      5) ldelem [Arr<obj>]
      1) ldc.i4.0
      5) ldelem [EqualityComparer<(i8,str)>]
      1) ldarg.0 [Arr<obj>]
      1) ldc.i4.2
      5) ldelem [((i8,str))]
      5) ldfld ((i8,str))::_F0:(i8,str)
      1) ldarg.1 [(i8,str)]
      5) callvirt EqualityComparer<(i8,str)>::Equals((i8,str), (i8,str)):bool
      1) ldc.i4.0
      2) ceq
      1) ret
  Total Size: 35

Func sig: (QBs:(i8, s)?*, RA:(i8, s)) to b*
Sequence: Seq<bool>
 0) false
 1) true 
 2) false
 3) true 
 4) true 
###
> QA !~= RBs
QA !~@= RBs : b*
BndKind:Call, Type:b*, Bnd:(Call(∂.ForEach([map:1] Global(RBs), Cmp(Global(QA) !~@= Scope(1))):b*))
// (∂.RBs:(i8, s)*, ∂.QA:(i8, s)?) : b*
ForEach_1(Arr<obj>, (i8,str)):bool
      1) ldarg.0 [Arr<obj>]
      1) ldc.i4.0
      5) ldelem [Arr<obj>]
      1) ldc.i4.0
      5) ldelem [EqualityComparer<(i8,str)>]
      1) ldarg.0 [Arr<obj>]
      1) ldc.i4.2
      5) ldelem [((i8,str))]
      5) ldfld ((i8,str))::_F0:(i8,str)
      1) ldarg.1 [(i8,str)]
      5) callvirt EqualityComparer<(i8,str)>::Equals((i8,str), (i8,str)):bool
      1) ldc.i4.0
      2) ceq
      1) ret
  Total Size: 35

Func sig: (RBs:(i8, s)*, QA:(i8, s)?) to b*
Sequence: Seq<bool>
 0) false
 1) true 
 2) false
 3) true 
###
> QA !~= QBs
QA !~@= QBs : b*
BndKind:Call, Type:b*, Bnd:(Call(∂.ForEach([map:1] Global(QBs), Cmp(Global(QA) !~@= Scope(1))):b*))
// (∂.QBs:(i8, s)?*, ∂.QA:(i8, s)?) : b*
ForEach_1(Arr<obj>, (i8,str)):bool
      1) ldarg.0 [Arr<obj>]
      1) ldc.i4.0
      5) ldelem [Arr<obj>]
      1) ldc.i4.0
      5) ldelem [EqualityComparer<(i8,str)>]
      1) ldarg.0 [Arr<obj>]
      1) ldc.i4.2
      5) ldelem [((i8,str))]
      5) ldfld ((i8,str))::_F0:(i8,str)
      1) ldarg.1 [(i8,str)]
      5) callvirt EqualityComparer<(i8,str)>::Equals((i8,str), (i8,str)):bool
      1) ldc.i4.0
      2) ceq
      1) ret
  Total Size: 35

Func sig: (QBs:(i8, s)?*, QA:(i8, s)?) to b*
Sequence: Seq<bool>
 0) false
 1) true 
 2) false
 3) true 
 4) true 
###
> NA !~= RBs
NA !~@= RBs : b*
BndKind:Call, Type:b*, Bnd:(Call(∂.ForEach([map:1] Global(RBs), Cmp(Global(NA) !~@= Scope(1))):b*))
// (∂.RBs:(i8, s)*, ∂.NA:(i8, s)?) : b*
ForEach_1(Arr<obj>, (i8,str)):bool
      1) ldarg.0 [Arr<obj>]
      1) ldc.i4.0
      5) ldelem [Arr<obj>]
      1) ldc.i4.0
      5) ldelem [EqualityComparer<(i8,str)>]
      1) ldarg.0 [Arr<obj>]
      1) ldc.i4.2
      5) ldelem [((i8,str))]
      5) ldfld ((i8,str))::_F0:(i8,str)
      1) ldarg.1 [(i8,str)]
      5) callvirt EqualityComparer<(i8,str)>::Equals((i8,str), (i8,str)):bool
      1) ldc.i4.0
      2) ceq
      1) ret
  Total Size: 35

Func sig: (RBs:(i8, s)*, NA:(i8, s)?) to b*
Sequence: Seq<bool>
 0) true 
 1) true 
 2) true 
 3) true 
###
> NA !~= QBs
NA !~@= QBs : b*
BndKind:Call, Type:b*, Bnd:(Call(∂.ForEach([map:1] Global(QBs), Cmp(Global(NA) !~@= Scope(1))):b*))
// (∂.QBs:(i8, s)?*, ∂.NA:(i8, s)?) : b*
ForEach_1(Arr<obj>, (i8,str)):bool
      1) ldarg.0 [Arr<obj>]
      1) ldc.i4.0
      5) ldelem [Arr<obj>]
      1) ldc.i4.0
      5) ldelem [EqualityComparer<(i8,str)>]
      1) ldarg.0 [Arr<obj>]
      1) ldc.i4.2
      5) ldelem [((i8,str))]
      5) ldfld ((i8,str))::_F0:(i8,str)
      1) ldarg.1 [(i8,str)]
      5) callvirt EqualityComparer<(i8,str)>::Equals((i8,str), (i8,str)):bool
      1) ldc.i4.0
      2) ceq
      1) ret
  Total Size: 35

Func sig: (QBs:(i8, s)?*, NA:(i8, s)?) to b*
Sequence: Seq<bool>
 0) true 
 1) true 
 2) true 
 3) true 
 4) false
###
> RA   = RBs = RBs
RA @= RBs @= RBs : b*
BndKind:Call, Type:b*, Bnd:(Call(∂.ForEach([map:1] Global(RBs), Cmp(Global(RA) @= Scope(1) @= Scope(1))):b*))
// (∂.RBs:(i8, s)*, ∂.RA:(i8, s)) : b*
ForEach_1(Arr<obj>, (i8,str)):bool
      1) ldarg.0 [Arr<obj>]
      1) ldc.i4.2
      5) ldelem [((i8,str))]
      5) ldfld ((i8,str))::_F0:(i8,str)
      1) ldarg.1 [(i8,str)]
      5) call static (i8,str)::Equals2((i8,str), (i8,str)):bool
      5) brfalse [0]
      1) ldarg.1 [(i8,str)]
      1) ldarg.1 [(i8,str)]
      5) call static (i8,str)::Equals2((i8,str), (i8,str)):bool
      5) br [1]
  Label [0]:
      1) ldc.i4.0
  Label [1]:
      1) ret
  Total Size: 37

Func sig: (RBs:(i8, s)*, RA:(i8, s)) to b*
Sequence: Seq<bool>
 0) true 
 1) false
 2) false
 3) false
###
> RA   = QBs = QBs
RA @= QBs @= QBs : b*
BndKind:Call, Type:b*, Bnd:(Call(∂.ForEach([map:1] Global(QBs), Cmp(Global(RA) @= Scope(1) @= Scope(1))):b*))
// (∂.QBs:(i8, s)?*, ∂.RA:(i8, s)) : b*
ForEach_1(Arr<obj>, (i8,str)):bool
      1) ldarg.0 [Arr<obj>]
      1) ldc.i4.2
      5) ldelem [((i8,str))]
      5) ldfld ((i8,str))::_F0:(i8,str)
      1) ldarg.1 [(i8,str)]
      5) call static (i8,str)::Equals2((i8,str), (i8,str)):bool
      5) brfalse [0]
      1) ldarg.1 [(i8,str)]
      1) ldarg.1 [(i8,str)]
      5) call static (i8,str)::Equals2((i8,str), (i8,str)):bool
      5) br [1]
  Label [0]:
      1) ldc.i4.0
  Label [1]:
      1) ret
  Total Size: 37

Func sig: (QBs:(i8, s)?*, RA:(i8, s)) to b*
Sequence: Seq<bool>
 0) true 
 1) false
 2) false
 3) false
 4) false
###
> QA   = RBs = RBs
QA @= RBs @= RBs : b*
BndKind:Call, Type:b*, Bnd:(Call(∂.ForEach([map:1] Global(RBs), Cmp(Global(QA) @= Scope(1) @= Scope(1))):b*))
// (∂.RBs:(i8, s)*, ∂.QA:(i8, s)?) : b*
ForEach_1(Arr<obj>, (i8,str)):bool
      1) ldarg.0 [Arr<obj>]
      1) ldc.i4.2
      5) ldelem [((i8,str))]
      5) ldfld ((i8,str))::_F0:(i8,str)
      1) ldarg.1 [(i8,str)]
      5) call static (i8,str)::Equals2((i8,str), (i8,str)):bool
      5) brfalse [0]
      1) ldarg.1 [(i8,str)]
      1) ldarg.1 [(i8,str)]
      5) call static (i8,str)::Equals2((i8,str), (i8,str)):bool
      5) br [1]
  Label [0]:
      1) ldc.i4.0
  Label [1]:
      1) ret
  Total Size: 37

Func sig: (RBs:(i8, s)*, QA:(i8, s)?) to b*
Sequence: Seq<bool>
 0) true 
 1) false
 2) false
 3) false
###
> QA   = QBs = QBs
QA @= QBs @= QBs : b*
BndKind:Call, Type:b*, Bnd:(Call(∂.ForEach([map:1] Global(QBs), Cmp(Global(QA) @= Scope(1) @= Scope(1))):b*))
// (∂.QBs:(i8, s)?*, ∂.QA:(i8, s)?) : b*
ForEach_1(Arr<obj>, (i8,str)):bool
      1) ldarg.0 [Arr<obj>]
      1) ldc.i4.2
      5) ldelem [((i8,str))]
      5) ldfld ((i8,str))::_F0:(i8,str)
      1) ldarg.1 [(i8,str)]
      5) call static (i8,str)::Equals2((i8,str), (i8,str)):bool
      5) brfalse [0]
      1) ldarg.1 [(i8,str)]
      1) ldarg.1 [(i8,str)]
      5) call static (i8,str)::Equals2((i8,str), (i8,str)):bool
      5) br [1]
  Label [0]:
      1) ldc.i4.0
  Label [1]:
      1) ret
  Total Size: 37

Func sig: (QBs:(i8, s)?*, QA:(i8, s)?) to b*
Sequence: Seq<bool>
 0) true 
 1) false
 2) false
 3) false
 4) false
###
> NA   = RBs = RBs
NA @= RBs @= RBs : b*
BndKind:Call, Type:b*, Bnd:(Call(∂.ForEach([map:1] Global(RBs), Cmp(Global(NA) @= Scope(1) @= Scope(1))):b*))
// (∂.RBs:(i8, s)*, ∂.NA:(i8, s)?) : b*
ForEach_1(Arr<obj>, (i8,str)):bool
      1) ldarg.0 [Arr<obj>]
      1) ldc.i4.2
      5) ldelem [((i8,str))]
      5) ldfld ((i8,str))::_F0:(i8,str)
      1) ldarg.1 [(i8,str)]
      5) call static (i8,str)::Equals2((i8,str), (i8,str)):bool
      5) brfalse [0]
      1) ldarg.1 [(i8,str)]
      1) ldarg.1 [(i8,str)]
      5) call static (i8,str)::Equals2((i8,str), (i8,str)):bool
      5) br [1]
  Label [0]:
      1) ldc.i4.0
  Label [1]:
      1) ret
  Total Size: 37

Func sig: (RBs:(i8, s)*, NA:(i8, s)?) to b*
Sequence: Seq<bool>
 0) false
 1) false
 2) false
 3) false
###
> NA   = QBs = QBs
NA @= QBs @= QBs : b*
BndKind:Call, Type:b*, Bnd:(Call(∂.ForEach([map:1] Global(QBs), Cmp(Global(NA) @= Scope(1) @= Scope(1))):b*))
// (∂.QBs:(i8, s)?*, ∂.NA:(i8, s)?) : b*
ForEach_1(Arr<obj>, (i8,str)):bool
      1) ldarg.0 [Arr<obj>]
      1) ldc.i4.2
      5) ldelem [((i8,str))]
      5) ldfld ((i8,str))::_F0:(i8,str)
      1) ldarg.1 [(i8,str)]
      5) call static (i8,str)::Equals2((i8,str), (i8,str)):bool
      5) brfalse [0]
      1) ldarg.1 [(i8,str)]
      1) ldarg.1 [(i8,str)]
      5) call static (i8,str)::Equals2((i8,str), (i8,str)):bool
      5) br [1]
  Label [0]:
      1) ldc.i4.0
  Label [1]:
      1) ret
  Total Size: 37

Func sig: (QBs:(i8, s)?*, NA:(i8, s)?) to b*
Sequence: Seq<bool>
 0) false
 1) false
 2) false
 3) false
 4) true 
###
> RA ! = RBs = RBs
RA !@= RBs @= RBs : b*
BndKind:Call, Type:b*, Bnd:(Call(∂.ForEach([map:1] Global(RBs), Cmp(Global(RA) !@= Scope(1) @= Scope(1))):b*))
// (∂.RBs:(i8, s)*, ∂.RA:(i8, s)) : b*
ForEach_1(Arr<obj>, (i8,str)):bool
      1) ldarg.0 [Arr<obj>]
      1) ldc.i4.2
      5) ldelem [((i8,str))]
      5) ldfld ((i8,str))::_F0:(i8,str)
      1) ldarg.1 [(i8,str)]
      5) call static (i8,str)::Equals2((i8,str), (i8,str)):bool
      5) brtrue [0]
      1) ldarg.1 [(i8,str)]
      1) ldarg.1 [(i8,str)]
      5) call static (i8,str)::Equals2((i8,str), (i8,str)):bool
      5) br [1]
  Label [0]:
      1) ldc.i4.0
  Label [1]:
      1) ret
  Total Size: 37

Func sig: (RBs:(i8, s)*, RA:(i8, s)) to b*
Sequence: Seq<bool>
 0) false
 1) true 
 2) true 
 3) true 
###
> RA ! = QBs = QBs
RA !@= QBs @= QBs : b*
BndKind:Call, Type:b*, Bnd:(Call(∂.ForEach([map:1] Global(QBs), Cmp(Global(RA) !@= Scope(1) @= Scope(1))):b*))
// (∂.QBs:(i8, s)?*, ∂.RA:(i8, s)) : b*
ForEach_1(Arr<obj>, (i8,str)):bool
      1) ldarg.0 [Arr<obj>]
      1) ldc.i4.2
      5) ldelem [((i8,str))]
      5) ldfld ((i8,str))::_F0:(i8,str)
      1) ldarg.1 [(i8,str)]
      5) call static (i8,str)::Equals2((i8,str), (i8,str)):bool
      5) brtrue [0]
      1) ldarg.1 [(i8,str)]
      1) ldarg.1 [(i8,str)]
      5) call static (i8,str)::Equals2((i8,str), (i8,str)):bool
      5) br [1]
  Label [0]:
      1) ldc.i4.0
  Label [1]:
      1) ret
  Total Size: 37

Func sig: (QBs:(i8, s)?*, RA:(i8, s)) to b*
Sequence: Seq<bool>
 0) false
 1) true 
 2) true 
 3) true 
 4) true 
###
> QA ! = RBs = RBs
QA !@= RBs @= RBs : b*
BndKind:Call, Type:b*, Bnd:(Call(∂.ForEach([map:1] Global(RBs), Cmp(Global(QA) !@= Scope(1) @= Scope(1))):b*))
// (∂.RBs:(i8, s)*, ∂.QA:(i8, s)?) : b*
ForEach_1(Arr<obj>, (i8,str)):bool
      1) ldarg.0 [Arr<obj>]
      1) ldc.i4.2
      5) ldelem [((i8,str))]
      5) ldfld ((i8,str))::_F0:(i8,str)
      1) ldarg.1 [(i8,str)]
      5) call static (i8,str)::Equals2((i8,str), (i8,str)):bool
      5) brtrue [0]
      1) ldarg.1 [(i8,str)]
      1) ldarg.1 [(i8,str)]
      5) call static (i8,str)::Equals2((i8,str), (i8,str)):bool
      5) br [1]
  Label [0]:
      1) ldc.i4.0
  Label [1]:
      1) ret
  Total Size: 37

Func sig: (RBs:(i8, s)*, QA:(i8, s)?) to b*
Sequence: Seq<bool>
 0) false
 1) true 
 2) true 
 3) true 
###
> QA ! = QBs = QBs
QA !@= QBs @= QBs : b*
BndKind:Call, Type:b*, Bnd:(Call(∂.ForEach([map:1] Global(QBs), Cmp(Global(QA) !@= Scope(1) @= Scope(1))):b*))
// (∂.QBs:(i8, s)?*, ∂.QA:(i8, s)?) : b*
ForEach_1(Arr<obj>, (i8,str)):bool
      1) ldarg.0 [Arr<obj>]
      1) ldc.i4.2
      5) ldelem [((i8,str))]
      5) ldfld ((i8,str))::_F0:(i8,str)
      1) ldarg.1 [(i8,str)]
      5) call static (i8,str)::Equals2((i8,str), (i8,str)):bool
      5) brtrue [0]
      1) ldarg.1 [(i8,str)]
      1) ldarg.1 [(i8,str)]
      5) call static (i8,str)::Equals2((i8,str), (i8,str)):bool
      5) br [1]
  Label [0]:
      1) ldc.i4.0
  Label [1]:
      1) ret
  Total Size: 37

Func sig: (QBs:(i8, s)?*, QA:(i8, s)?) to b*
Sequence: Seq<bool>
 0) false
 1) true 
 2) true 
 3) true 
 4) true 
###
> NA ! = RBs = RBs
NA !@= RBs @= RBs : b*
BndKind:Call, Type:b*, Bnd:(Call(∂.ForEach([map:1] Global(RBs), Cmp(Global(NA) !@= Scope(1) @= Scope(1))):b*))
// (∂.RBs:(i8, s)*, ∂.NA:(i8, s)?) : b*
ForEach_1(Arr<obj>, (i8,str)):bool
      1) ldarg.0 [Arr<obj>]
      1) ldc.i4.2
      5) ldelem [((i8,str))]
      5) ldfld ((i8,str))::_F0:(i8,str)
      1) ldarg.1 [(i8,str)]
      5) call static (i8,str)::Equals2((i8,str), (i8,str)):bool
      5) brtrue [0]
      1) ldarg.1 [(i8,str)]
      1) ldarg.1 [(i8,str)]
      5) call static (i8,str)::Equals2((i8,str), (i8,str)):bool
      5) br [1]
  Label [0]:
      1) ldc.i4.0
  Label [1]:
      1) ret
  Total Size: 37

Func sig: (RBs:(i8, s)*, NA:(i8, s)?) to b*
Sequence: Seq<bool>
 0) true 
 1) true 
 2) true 
 3) true 
###
> NA ! = QBs = QBs
NA !@= QBs @= QBs : b*
BndKind:Call, Type:b*, Bnd:(Call(∂.ForEach([map:1] Global(QBs), Cmp(Global(NA) !@= Scope(1) @= Scope(1))):b*))
// (∂.QBs:(i8, s)?*, ∂.NA:(i8, s)?) : b*
ForEach_1(Arr<obj>, (i8,str)):bool
      1) ldarg.0 [Arr<obj>]
      1) ldc.i4.2
      5) ldelem [((i8,str))]
      5) ldfld ((i8,str))::_F0:(i8,str)
      1) ldarg.1 [(i8,str)]
      5) call static (i8,str)::Equals2((i8,str), (i8,str)):bool
      5) brtrue [0]
      1) ldarg.1 [(i8,str)]
      1) ldarg.1 [(i8,str)]
      5) call static (i8,str)::Equals2((i8,str), (i8,str)):bool
      5) br [1]
  Label [0]:
      1) ldc.i4.0
  Label [1]:
      1) ret
  Total Size: 37

Func sig: (QBs:(i8, s)?*, NA:(i8, s)?) to b*
Sequence: Seq<bool>
 0) true 
 1) true 
 2) true 
 3) true 
 4) false
###
> RA  ~= RBs = RBs
RA ~@= RBs @= RBs : b*
BndKind:Call, Type:b*, Bnd:(Call(∂.ForEach([map:1] Global(RBs), Cmp(Global(RA) ~@= Scope(1) @= Scope(1))):b*))
// (∂.RBs:(i8, s)*, ∂.RA:(i8, s)) : b*
ForEach_1(Arr<obj>, (i8,str)):bool
      1) ldarg.0 [Arr<obj>]
      1) ldc.i4.0
      5) ldelem [Arr<obj>]
      1) ldc.i4.0
      5) ldelem [EqualityComparer<(i8,str)>]
      1) ldarg.0 [Arr<obj>]
      1) ldc.i4.2
      5) ldelem [((i8,str))]
      5) ldfld ((i8,str))::_F0:(i8,str)
      1) ldarg.1 [(i8,str)]
      5) callvirt EqualityComparer<(i8,str)>::Equals((i8,str), (i8,str)):bool
      5) brfalse [0]
      1) ldarg.1 [(i8,str)]
      1) ldarg.1 [(i8,str)]
      5) call static (i8,str)::Equals2((i8,str), (i8,str)):bool
      5) br [1]
  Label [0]:
      1) ldc.i4.0
  Label [1]:
      1) ret
  Total Size: 50

Func sig: (RBs:(i8, s)*, RA:(i8, s)) to b*
Sequence: Seq<bool>
 0) true 
 1) false
 2) true 
 3) false
###
> RA  ~= QBs = QBs
RA ~@= QBs @= QBs : b*
BndKind:Call, Type:b*, Bnd:(Call(∂.ForEach([map:1] Global(QBs), Cmp(Global(RA) ~@= Scope(1) @= Scope(1))):b*))
// (∂.QBs:(i8, s)?*, ∂.RA:(i8, s)) : b*
ForEach_1(Arr<obj>, (i8,str)):bool
      1) ldarg.0 [Arr<obj>]
      1) ldc.i4.0
      5) ldelem [Arr<obj>]
      1) ldc.i4.0
      5) ldelem [EqualityComparer<(i8,str)>]
      1) ldarg.0 [Arr<obj>]
      1) ldc.i4.2
      5) ldelem [((i8,str))]
      5) ldfld ((i8,str))::_F0:(i8,str)
      1) ldarg.1 [(i8,str)]
      5) callvirt EqualityComparer<(i8,str)>::Equals((i8,str), (i8,str)):bool
      5) brfalse [0]
      1) ldarg.1 [(i8,str)]
      1) ldarg.1 [(i8,str)]
      5) call static (i8,str)::Equals2((i8,str), (i8,str)):bool
      5) br [1]
  Label [0]:
      1) ldc.i4.0
  Label [1]:
      1) ret
  Total Size: 50

Func sig: (QBs:(i8, s)?*, RA:(i8, s)) to b*
Sequence: Seq<bool>
 0) true 
 1) false
 2) true 
 3) false
 4) false
###
> QA  ~= RBs = RBs
QA ~@= RBs @= RBs : b*
BndKind:Call, Type:b*, Bnd:(Call(∂.ForEach([map:1] Global(RBs), Cmp(Global(QA) ~@= Scope(1) @= Scope(1))):b*))
// (∂.RBs:(i8, s)*, ∂.QA:(i8, s)?) : b*
ForEach_1(Arr<obj>, (i8,str)):bool
      1) ldarg.0 [Arr<obj>]
      1) ldc.i4.0
      5) ldelem [Arr<obj>]
      1) ldc.i4.0
      5) ldelem [EqualityComparer<(i8,str)>]
      1) ldarg.0 [Arr<obj>]
      1) ldc.i4.2
      5) ldelem [((i8,str))]
      5) ldfld ((i8,str))::_F0:(i8,str)
      1) ldarg.1 [(i8,str)]
      5) callvirt EqualityComparer<(i8,str)>::Equals((i8,str), (i8,str)):bool
      5) brfalse [0]
      1) ldarg.1 [(i8,str)]
      1) ldarg.1 [(i8,str)]
      5) call static (i8,str)::Equals2((i8,str), (i8,str)):bool
      5) br [1]
  Label [0]:
      1) ldc.i4.0
  Label [1]:
      1) ret
  Total Size: 50

Func sig: (RBs:(i8, s)*, QA:(i8, s)?) to b*
Sequence: Seq<bool>
 0) true 
 1) false
 2) true 
 3) false
###
> QA  ~= QBs = QBs
QA ~@= QBs @= QBs : b*
BndKind:Call, Type:b*, Bnd:(Call(∂.ForEach([map:1] Global(QBs), Cmp(Global(QA) ~@= Scope(1) @= Scope(1))):b*))
// (∂.QBs:(i8, s)?*, ∂.QA:(i8, s)?) : b*
ForEach_1(Arr<obj>, (i8,str)):bool
      1) ldarg.0 [Arr<obj>]
      1) ldc.i4.0
      5) ldelem [Arr<obj>]
      1) ldc.i4.0
      5) ldelem [EqualityComparer<(i8,str)>]
      1) ldarg.0 [Arr<obj>]
      1) ldc.i4.2
      5) ldelem [((i8,str))]
      5) ldfld ((i8,str))::_F0:(i8,str)
      1) ldarg.1 [(i8,str)]
      5) callvirt EqualityComparer<(i8,str)>::Equals((i8,str), (i8,str)):bool
      5) brfalse [0]
      1) ldarg.1 [(i8,str)]
      1) ldarg.1 [(i8,str)]
      5) call static (i8,str)::Equals2((i8,str), (i8,str)):bool
      5) br [1]
  Label [0]:
      1) ldc.i4.0
  Label [1]:
      1) ret
  Total Size: 50

Func sig: (QBs:(i8, s)?*, QA:(i8, s)?) to b*
Sequence: Seq<bool>
 0) true 
 1) false
 2) true 
 3) false
 4) false
###
> NA  ~= RBs = RBs
NA ~@= RBs @= RBs : b*
BndKind:Call, Type:b*, Bnd:(Call(∂.ForEach([map:1] Global(RBs), Cmp(Global(NA) ~@= Scope(1) @= Scope(1))):b*))
// (∂.RBs:(i8, s)*, ∂.NA:(i8, s)?) : b*
ForEach_1(Arr<obj>, (i8,str)):bool
      1) ldarg.0 [Arr<obj>]
      1) ldc.i4.0
      5) ldelem [Arr<obj>]
      1) ldc.i4.0
      5) ldelem [EqualityComparer<(i8,str)>]
      1) ldarg.0 [Arr<obj>]
      1) ldc.i4.2
      5) ldelem [((i8,str))]
      5) ldfld ((i8,str))::_F0:(i8,str)
      1) ldarg.1 [(i8,str)]
      5) callvirt EqualityComparer<(i8,str)>::Equals((i8,str), (i8,str)):bool
      5) brfalse [0]
      1) ldarg.1 [(i8,str)]
      1) ldarg.1 [(i8,str)]
      5) call static (i8,str)::Equals2((i8,str), (i8,str)):bool
      5) br [1]
  Label [0]:
      1) ldc.i4.0
  Label [1]:
      1) ret
  Total Size: 50

Func sig: (RBs:(i8, s)*, NA:(i8, s)?) to b*
Sequence: Seq<bool>
 0) false
 1) false
 2) false
 3) false
###
> NA  ~= QBs = QBs
NA ~@= QBs @= QBs : b*
BndKind:Call, Type:b*, Bnd:(Call(∂.ForEach([map:1] Global(QBs), Cmp(Global(NA) ~@= Scope(1) @= Scope(1))):b*))
// (∂.QBs:(i8, s)?*, ∂.NA:(i8, s)?) : b*
ForEach_1(Arr<obj>, (i8,str)):bool
      1) ldarg.0 [Arr<obj>]
      1) ldc.i4.0
      5) ldelem [Arr<obj>]
      1) ldc.i4.0
      5) ldelem [EqualityComparer<(i8,str)>]
      1) ldarg.0 [Arr<obj>]
      1) ldc.i4.2
      5) ldelem [((i8,str))]
      5) ldfld ((i8,str))::_F0:(i8,str)
      1) ldarg.1 [(i8,str)]
      5) callvirt EqualityComparer<(i8,str)>::Equals((i8,str), (i8,str)):bool
      5) brfalse [0]
      1) ldarg.1 [(i8,str)]
      1) ldarg.1 [(i8,str)]
      5) call static (i8,str)::Equals2((i8,str), (i8,str)):bool
      5) br [1]
  Label [0]:
      1) ldc.i4.0
  Label [1]:
      1) ret
  Total Size: 50

Func sig: (QBs:(i8, s)?*, NA:(i8, s)?) to b*
Sequence: Seq<bool>
 0) false
 1) false
 2) false
 3) false
 4) true 
###
> RA !~= RBs = RBs
RA !~@= RBs @= RBs : b*
BndKind:Call, Type:b*, Bnd:(Call(∂.ForEach([map:1] Global(RBs), Cmp(Global(RA) !~@= Scope(1) @= Scope(1))):b*))
// (∂.RBs:(i8, s)*, ∂.RA:(i8, s)) : b*
ForEach_1(Arr<obj>, (i8,str)):bool
      1) ldarg.0 [Arr<obj>]
      1) ldc.i4.0
      5) ldelem [Arr<obj>]
      1) ldc.i4.0
      5) ldelem [EqualityComparer<(i8,str)>]
      1) ldarg.0 [Arr<obj>]
      1) ldc.i4.2
      5) ldelem [((i8,str))]
      5) ldfld ((i8,str))::_F0:(i8,str)
      1) ldarg.1 [(i8,str)]
      5) callvirt EqualityComparer<(i8,str)>::Equals((i8,str), (i8,str)):bool
      5) brtrue [0]
      1) ldarg.1 [(i8,str)]
      1) ldarg.1 [(i8,str)]
      5) call static (i8,str)::Equals2((i8,str), (i8,str)):bool
      5) br [1]
  Label [0]:
      1) ldc.i4.0
  Label [1]:
      1) ret
  Total Size: 50

Func sig: (RBs:(i8, s)*, RA:(i8, s)) to b*
Sequence: Seq<bool>
 0) false
 1) true 
 2) false
 3) true 
###
> RA !~= QBs = QBs
RA !~@= QBs @= QBs : b*
BndKind:Call, Type:b*, Bnd:(Call(∂.ForEach([map:1] Global(QBs), Cmp(Global(RA) !~@= Scope(1) @= Scope(1))):b*))
// (∂.QBs:(i8, s)?*, ∂.RA:(i8, s)) : b*
ForEach_1(Arr<obj>, (i8,str)):bool
      1) ldarg.0 [Arr<obj>]
      1) ldc.i4.0
      5) ldelem [Arr<obj>]
      1) ldc.i4.0
      5) ldelem [EqualityComparer<(i8,str)>]
      1) ldarg.0 [Arr<obj>]
      1) ldc.i4.2
      5) ldelem [((i8,str))]
      5) ldfld ((i8,str))::_F0:(i8,str)
      1) ldarg.1 [(i8,str)]
      5) callvirt EqualityComparer<(i8,str)>::Equals((i8,str), (i8,str)):bool
      5) brtrue [0]
      1) ldarg.1 [(i8,str)]
      1) ldarg.1 [(i8,str)]
      5) call static (i8,str)::Equals2((i8,str), (i8,str)):bool
      5) br [1]
  Label [0]:
      1) ldc.i4.0
  Label [1]:
      1) ret
  Total Size: 50

Func sig: (QBs:(i8, s)?*, RA:(i8, s)) to b*
Sequence: Seq<bool>
 0) false
 1) true 
 2) false
 3) true 
 4) true 
###
> QA !~= RBs = RBs
QA !~@= RBs @= RBs : b*
BndKind:Call, Type:b*, Bnd:(Call(∂.ForEach([map:1] Global(RBs), Cmp(Global(QA) !~@= Scope(1) @= Scope(1))):b*))
// (∂.RBs:(i8, s)*, ∂.QA:(i8, s)?) : b*
ForEach_1(Arr<obj>, (i8,str)):bool
      1) ldarg.0 [Arr<obj>]
      1) ldc.i4.0
      5) ldelem [Arr<obj>]
      1) ldc.i4.0
      5) ldelem [EqualityComparer<(i8,str)>]
      1) ldarg.0 [Arr<obj>]
      1) ldc.i4.2
      5) ldelem [((i8,str))]
      5) ldfld ((i8,str))::_F0:(i8,str)
      1) ldarg.1 [(i8,str)]
      5) callvirt EqualityComparer<(i8,str)>::Equals((i8,str), (i8,str)):bool
      5) brtrue [0]
      1) ldarg.1 [(i8,str)]
      1) ldarg.1 [(i8,str)]
      5) call static (i8,str)::Equals2((i8,str), (i8,str)):bool
      5) br [1]
  Label [0]:
      1) ldc.i4.0
  Label [1]:
      1) ret
  Total Size: 50

Func sig: (RBs:(i8, s)*, QA:(i8, s)?) to b*
Sequence: Seq<bool>
 0) false
 1) true 
 2) false
 3) true 
###
> QA !~= QBs = QBs
QA !~@= QBs @= QBs : b*
BndKind:Call, Type:b*, Bnd:(Call(∂.ForEach([map:1] Global(QBs), Cmp(Global(QA) !~@= Scope(1) @= Scope(1))):b*))
// (∂.QBs:(i8, s)?*, ∂.QA:(i8, s)?) : b*
ForEach_1(Arr<obj>, (i8,str)):bool
      1) ldarg.0 [Arr<obj>]
      1) ldc.i4.0
      5) ldelem [Arr<obj>]
      1) ldc.i4.0
      5) ldelem [EqualityComparer<(i8,str)>]
      1) ldarg.0 [Arr<obj>]
      1) ldc.i4.2
      5) ldelem [((i8,str))]
      5) ldfld ((i8,str))::_F0:(i8,str)
      1) ldarg.1 [(i8,str)]
      5) callvirt EqualityComparer<(i8,str)>::Equals((i8,str), (i8,str)):bool
      5) brtrue [0]
      1) ldarg.1 [(i8,str)]
      1) ldarg.1 [(i8,str)]
      5) call static (i8,str)::Equals2((i8,str), (i8,str)):bool
      5) br [1]
  Label [0]:
      1) ldc.i4.0
  Label [1]:
      1) ret
  Total Size: 50

Func sig: (QBs:(i8, s)?*, QA:(i8, s)?) to b*
Sequence: Seq<bool>
 0) false
 1) true 
 2) false
 3) true 
 4) true 
###
> NA !~= RBs = RBs
NA !~@= RBs @= RBs : b*
BndKind:Call, Type:b*, Bnd:(Call(∂.ForEach([map:1] Global(RBs), Cmp(Global(NA) !~@= Scope(1) @= Scope(1))):b*))
// (∂.RBs:(i8, s)*, ∂.NA:(i8, s)?) : b*
ForEach_1(Arr<obj>, (i8,str)):bool
      1) ldarg.0 [Arr<obj>]
      1) ldc.i4.0
      5) ldelem [Arr<obj>]
      1) ldc.i4.0
      5) ldelem [EqualityComparer<(i8,str)>]
      1) ldarg.0 [Arr<obj>]
      1) ldc.i4.2
      5) ldelem [((i8,str))]
      5) ldfld ((i8,str))::_F0:(i8,str)
      1) ldarg.1 [(i8,str)]
      5) callvirt EqualityComparer<(i8,str)>::Equals((i8,str), (i8,str)):bool
      5) brtrue [0]
      1) ldarg.1 [(i8,str)]
      1) ldarg.1 [(i8,str)]
      5) call static (i8,str)::Equals2((i8,str), (i8,str)):bool
      5) br [1]
  Label [0]:
      1) ldc.i4.0
  Label [1]:
      1) ret
  Total Size: 50

Func sig: (RBs:(i8, s)*, NA:(i8, s)?) to b*
Sequence: Seq<bool>
 0) true 
 1) true 
 2) true 
 3) true 
###
> NA !~= QBs = QBs
NA !~@= QBs @= QBs : b*
BndKind:Call, Type:b*, Bnd:(Call(∂.ForEach([map:1] Global(QBs), Cmp(Global(NA) !~@= Scope(1) @= Scope(1))):b*))
// (∂.QBs:(i8, s)?*, ∂.NA:(i8, s)?) : b*
ForEach_1(Arr<obj>, (i8,str)):bool
      1) ldarg.0 [Arr<obj>]
      1) ldc.i4.0
      5) ldelem [Arr<obj>]
      1) ldc.i4.0
      5) ldelem [EqualityComparer<(i8,str)>]
      1) ldarg.0 [Arr<obj>]
      1) ldc.i4.2
      5) ldelem [((i8,str))]
      5) ldfld ((i8,str))::_F0:(i8,str)
      1) ldarg.1 [(i8,str)]
      5) callvirt EqualityComparer<(i8,str)>::Equals((i8,str), (i8,str)):bool
      5) brtrue [0]
      1) ldarg.1 [(i8,str)]
      1) ldarg.1 [(i8,str)]
      5) call static (i8,str)::Equals2((i8,str), (i8,str)):bool
      5) br [1]
  Label [0]:
      1) ldc.i4.0
  Label [1]:
      1) ret
  Total Size: 50

Func sig: (QBs:(i8, s)?*, NA:(i8, s)?) to b*
Sequence: Seq<bool>
 0) true 
 1) true 
 2) true 
 3) true 
 4) false
###
> RA = RA   = RBs
RA @= RA @= RBs : b*
BndKind:Call, Type:b*, Bnd:(Call(∂.ForEach([map:1] Global(RBs), Cmp(Global(RA) @= Global(RA) @= Scope(1))):b*))
// (∂.RBs:(i8, s)*, ∂.RA:(i8, s)) : b*
ForEach_1(Arr<obj>, (i8,str)):bool
      1) ldarg.0 [Arr<obj>]
      1) ldc.i4.2
      5) ldelem [((i8,str))]
      5) ldfld ((i8,str))::_F0:(i8,str)
      1) ldarg.0 [Arr<obj>]
      1) ldc.i4.2
      5) ldelem [((i8,str))]
      5) ldfld ((i8,str))::_F0:(i8,str)
      1) dup
      1) stloc.0 [(i8,str)]
      5) call static (i8,str)::Equals2((i8,str), (i8,str)):bool
      5) brfalse [0]
      1) ldloc.0 [(i8,str)]
      1) ldarg.1 [(i8,str)]
      5) call static (i8,str)::Equals2((i8,str), (i8,str)):bool
      5) br [1]
  Label [0]:
      1) ldc.i4.0
  Label [1]:
      1) ret
  Total Size: 50

Func sig: (RBs:(i8, s)*, RA:(i8, s)) to b*
Sequence: Seq<bool>
 0) true 
 1) false
 2) false
 3) false
###
> RA = RA   = QBs
RA @= RA @= QBs : b*
BndKind:Call, Type:b*, Bnd:(Call(∂.ForEach([map:1] Global(QBs), Cmp(Global(RA) @= Global(RA) @= Scope(1))):b*))
// (∂.QBs:(i8, s)?*, ∂.RA:(i8, s)) : b*
ForEach_1(Arr<obj>, (i8,str)):bool
      1) ldarg.0 [Arr<obj>]
      1) ldc.i4.2
      5) ldelem [((i8,str))]
      5) ldfld ((i8,str))::_F0:(i8,str)
      1) ldarg.0 [Arr<obj>]
      1) ldc.i4.2
      5) ldelem [((i8,str))]
      5) ldfld ((i8,str))::_F0:(i8,str)
      1) dup
      1) stloc.0 [(i8,str)]
      5) call static (i8,str)::Equals2((i8,str), (i8,str)):bool
      5) brfalse [0]
      1) ldloc.0 [(i8,str)]
      1) ldarg.1 [(i8,str)]
      5) call static (i8,str)::Equals2((i8,str), (i8,str)):bool
      5) br [1]
  Label [0]:
      1) ldc.i4.0
  Label [1]:
      1) ret
  Total Size: 50

Func sig: (QBs:(i8, s)?*, RA:(i8, s)) to b*
Sequence: Seq<bool>
 0) true 
 1) false
 2) false
 3) false
 4) false
###
> QA = QA   = RBs
QA @= QA @= RBs : b*
BndKind:Call, Type:b*, Bnd:(Call(∂.ForEach([map:1] Global(RBs), Cmp(Global(QA) @= Global(QA) @= Scope(1))):b*))
// (∂.RBs:(i8, s)*, ∂.QA:(i8, s)?) : b*
ForEach_1(Arr<obj>, (i8,str)):bool
      1) ldarg.0 [Arr<obj>]
      1) ldc.i4.2
      5) ldelem [((i8,str))]
      5) ldfld ((i8,str))::_F0:(i8,str)
      1) ldarg.0 [Arr<obj>]
      1) ldc.i4.2
      5) ldelem [((i8,str))]
      5) ldfld ((i8,str))::_F0:(i8,str)
      1) dup
      1) stloc.0 [(i8,str)]
      5) call static (i8,str)::Equals2((i8,str), (i8,str)):bool
      5) brfalse [0]
      1) ldloc.0 [(i8,str)]
      1) ldarg.1 [(i8,str)]
      5) call static (i8,str)::Equals2((i8,str), (i8,str)):bool
      5) br [1]
  Label [0]:
      1) ldc.i4.0
  Label [1]:
      1) ret
  Total Size: 50

Func sig: (RBs:(i8, s)*, QA:(i8, s)?) to b*
Sequence: Seq<bool>
 0) true 
 1) false
 2) false
 3) false
###
> QA = QA   = QBs
QA @= QA @= QBs : b*
BndKind:Call, Type:b*, Bnd:(Call(∂.ForEach([map:1] Global(QBs), Cmp(Global(QA) @= Global(QA) @= Scope(1))):b*))
// (∂.QBs:(i8, s)?*, ∂.QA:(i8, s)?) : b*
ForEach_1(Arr<obj>, (i8,str)):bool
      1) ldarg.0 [Arr<obj>]
      1) ldc.i4.2
      5) ldelem [((i8,str))]
      5) ldfld ((i8,str))::_F0:(i8,str)
      1) ldarg.0 [Arr<obj>]
      1) ldc.i4.2
      5) ldelem [((i8,str))]
      5) ldfld ((i8,str))::_F0:(i8,str)
      1) dup
      1) stloc.0 [(i8,str)]
      5) call static (i8,str)::Equals2((i8,str), (i8,str)):bool
      5) brfalse [0]
      1) ldloc.0 [(i8,str)]
      1) ldarg.1 [(i8,str)]
      5) call static (i8,str)::Equals2((i8,str), (i8,str)):bool
      5) br [1]
  Label [0]:
      1) ldc.i4.0
  Label [1]:
      1) ret
  Total Size: 50

Func sig: (QBs:(i8, s)?*, QA:(i8, s)?) to b*
Sequence: Seq<bool>
 0) true 
 1) false
 2) false
 3) false
 4) false
###
> NA = NA   = RBs
NA @= NA @= RBs : b*
BndKind:Call, Type:b*, Bnd:(Call(∂.ForEach([map:1] Global(RBs), Cmp(Global(NA) @= Global(NA) @= Scope(1))):b*))
// (∂.RBs:(i8, s)*, ∂.NA:(i8, s)?) : b*
ForEach_1(Arr<obj>, (i8,str)):bool
      1) ldarg.0 [Arr<obj>]
      1) ldc.i4.2
      5) ldelem [((i8,str))]
      5) ldfld ((i8,str))::_F0:(i8,str)
      1) ldarg.0 [Arr<obj>]
      1) ldc.i4.2
      5) ldelem [((i8,str))]
      5) ldfld ((i8,str))::_F0:(i8,str)
      1) dup
      1) stloc.0 [(i8,str)]
      5) call static (i8,str)::Equals2((i8,str), (i8,str)):bool
      5) brfalse [0]
      1) ldloc.0 [(i8,str)]
      1) ldarg.1 [(i8,str)]
      5) call static (i8,str)::Equals2((i8,str), (i8,str)):bool
      5) br [1]
  Label [0]:
      1) ldc.i4.0
  Label [1]:
      1) ret
  Total Size: 50

Func sig: (RBs:(i8, s)*, NA:(i8, s)?) to b*
Sequence: Seq<bool>
 0) false
 1) false
 2) false
 3) false
###
> NA = NA   = QBs
NA @= NA @= QBs : b*
BndKind:Call, Type:b*, Bnd:(Call(∂.ForEach([map:1] Global(QBs), Cmp(Global(NA) @= Global(NA) @= Scope(1))):b*))
// (∂.QBs:(i8, s)?*, ∂.NA:(i8, s)?) : b*
ForEach_1(Arr<obj>, (i8,str)):bool
      1) ldarg.0 [Arr<obj>]
      1) ldc.i4.2
      5) ldelem [((i8,str))]
      5) ldfld ((i8,str))::_F0:(i8,str)
      1) ldarg.0 [Arr<obj>]
      1) ldc.i4.2
      5) ldelem [((i8,str))]
      5) ldfld ((i8,str))::_F0:(i8,str)
      1) dup
      1) stloc.0 [(i8,str)]
      5) call static (i8,str)::Equals2((i8,str), (i8,str)):bool
      5) brfalse [0]
      1) ldloc.0 [(i8,str)]
      1) ldarg.1 [(i8,str)]
      5) call static (i8,str)::Equals2((i8,str), (i8,str)):bool
      5) br [1]
  Label [0]:
      1) ldc.i4.0
  Label [1]:
      1) ret
  Total Size: 50

Func sig: (QBs:(i8, s)?*, NA:(i8, s)?) to b*
Sequence: Seq<bool>
 0) false
 1) false
 2) false
 3) false
 4) true 
###
> RA = RA ! = RBs
RA @= RA !@= RBs : b*
BndKind:Call, Type:b*, Bnd:(Call(∂.ForEach([map:1] Global(RBs), Cmp(Global(RA) @= Global(RA) !@= Scope(1))):b*))
// (∂.RBs:(i8, s)*, ∂.RA:(i8, s)) : b*
ForEach_1(Arr<obj>, (i8,str)):bool
      1) ldarg.0 [Arr<obj>]
      1) ldc.i4.2
      5) ldelem [((i8,str))]
      5) ldfld ((i8,str))::_F0:(i8,str)
      1) ldarg.0 [Arr<obj>]
      1) ldc.i4.2
      5) ldelem [((i8,str))]
      5) ldfld ((i8,str))::_F0:(i8,str)
      1) dup
      1) stloc.0 [(i8,str)]
      5) call static (i8,str)::Equals2((i8,str), (i8,str)):bool
      5) brfalse [0]
      1) ldloc.0 [(i8,str)]
      1) ldarg.1 [(i8,str)]
      5) call static (i8,str)::Equals2((i8,str), (i8,str)):bool
      1) ldc.i4.0
      2) ceq
      5) br [1]
  Label [0]:
      1) ldc.i4.0
  Label [1]:
      1) ret
  Total Size: 53

Func sig: (RBs:(i8, s)*, RA:(i8, s)) to b*
Sequence: Seq<bool>
 0) false
 1) true 
 2) true 
 3) true 
###
> RA = RA ! = QBs
RA @= RA !@= QBs : b*
BndKind:Call, Type:b*, Bnd:(Call(∂.ForEach([map:1] Global(QBs), Cmp(Global(RA) @= Global(RA) !@= Scope(1))):b*))
// (∂.QBs:(i8, s)?*, ∂.RA:(i8, s)) : b*
ForEach_1(Arr<obj>, (i8,str)):bool
      1) ldarg.0 [Arr<obj>]
      1) ldc.i4.2
      5) ldelem [((i8,str))]
      5) ldfld ((i8,str))::_F0:(i8,str)
      1) ldarg.0 [Arr<obj>]
      1) ldc.i4.2
      5) ldelem [((i8,str))]
      5) ldfld ((i8,str))::_F0:(i8,str)
      1) dup
      1) stloc.0 [(i8,str)]
      5) call static (i8,str)::Equals2((i8,str), (i8,str)):bool
      5) brfalse [0]
      1) ldloc.0 [(i8,str)]
      1) ldarg.1 [(i8,str)]
      5) call static (i8,str)::Equals2((i8,str), (i8,str)):bool
      1) ldc.i4.0
      2) ceq
      5) br [1]
  Label [0]:
      1) ldc.i4.0
  Label [1]:
      1) ret
  Total Size: 53

Func sig: (QBs:(i8, s)?*, RA:(i8, s)) to b*
Sequence: Seq<bool>
 0) false
 1) true 
 2) true 
 3) true 
 4) true 
###
> QA = QA ! = RBs
QA @= QA !@= RBs : b*
BndKind:Call, Type:b*, Bnd:(Call(∂.ForEach([map:1] Global(RBs), Cmp(Global(QA) @= Global(QA) !@= Scope(1))):b*))
// (∂.RBs:(i8, s)*, ∂.QA:(i8, s)?) : b*
ForEach_1(Arr<obj>, (i8,str)):bool
      1) ldarg.0 [Arr<obj>]
      1) ldc.i4.2
      5) ldelem [((i8,str))]
      5) ldfld ((i8,str))::_F0:(i8,str)
      1) ldarg.0 [Arr<obj>]
      1) ldc.i4.2
      5) ldelem [((i8,str))]
      5) ldfld ((i8,str))::_F0:(i8,str)
      1) dup
      1) stloc.0 [(i8,str)]
      5) call static (i8,str)::Equals2((i8,str), (i8,str)):bool
      5) brfalse [0]
      1) ldloc.0 [(i8,str)]
      1) ldarg.1 [(i8,str)]
      5) call static (i8,str)::Equals2((i8,str), (i8,str)):bool
      1) ldc.i4.0
      2) ceq
      5) br [1]
  Label [0]:
      1) ldc.i4.0
  Label [1]:
      1) ret
  Total Size: 53

Func sig: (RBs:(i8, s)*, QA:(i8, s)?) to b*
Sequence: Seq<bool>
 0) false
 1) true 
 2) true 
 3) true 
###
> QA = QA ! = QBs
QA @= QA !@= QBs : b*
BndKind:Call, Type:b*, Bnd:(Call(∂.ForEach([map:1] Global(QBs), Cmp(Global(QA) @= Global(QA) !@= Scope(1))):b*))
// (∂.QBs:(i8, s)?*, ∂.QA:(i8, s)?) : b*
ForEach_1(Arr<obj>, (i8,str)):bool
      1) ldarg.0 [Arr<obj>]
      1) ldc.i4.2
      5) ldelem [((i8,str))]
      5) ldfld ((i8,str))::_F0:(i8,str)
      1) ldarg.0 [Arr<obj>]
      1) ldc.i4.2
      5) ldelem [((i8,str))]
      5) ldfld ((i8,str))::_F0:(i8,str)
      1) dup
      1) stloc.0 [(i8,str)]
      5) call static (i8,str)::Equals2((i8,str), (i8,str)):bool
      5) brfalse [0]
      1) ldloc.0 [(i8,str)]
      1) ldarg.1 [(i8,str)]
      5) call static (i8,str)::Equals2((i8,str), (i8,str)):bool
      1) ldc.i4.0
      2) ceq
      5) br [1]
  Label [0]:
      1) ldc.i4.0
  Label [1]:
      1) ret
  Total Size: 53

Func sig: (QBs:(i8, s)?*, QA:(i8, s)?) to b*
Sequence: Seq<bool>
 0) false
 1) true 
 2) true 
 3) true 
 4) true 
###
> NA = NA ! = RBs
NA @= NA !@= RBs : b*
BndKind:Call, Type:b*, Bnd:(Call(∂.ForEach([map:1] Global(RBs), Cmp(Global(NA) @= Global(NA) !@= Scope(1))):b*))
// (∂.RBs:(i8, s)*, ∂.NA:(i8, s)?) : b*
ForEach_1(Arr<obj>, (i8,str)):bool
      1) ldarg.0 [Arr<obj>]
      1) ldc.i4.2
      5) ldelem [((i8,str))]
      5) ldfld ((i8,str))::_F0:(i8,str)
      1) ldarg.0 [Arr<obj>]
      1) ldc.i4.2
      5) ldelem [((i8,str))]
      5) ldfld ((i8,str))::_F0:(i8,str)
      1) dup
      1) stloc.0 [(i8,str)]
      5) call static (i8,str)::Equals2((i8,str), (i8,str)):bool
      5) brfalse [0]
      1) ldloc.0 [(i8,str)]
      1) ldarg.1 [(i8,str)]
      5) call static (i8,str)::Equals2((i8,str), (i8,str)):bool
      1) ldc.i4.0
      2) ceq
      5) br [1]
  Label [0]:
      1) ldc.i4.0
  Label [1]:
      1) ret
  Total Size: 53

Func sig: (RBs:(i8, s)*, NA:(i8, s)?) to b*
Sequence: Seq<bool>
 0) true 
 1) true 
 2) true 
 3) true 
###
> NA = NA ! = QBs
NA @= NA !@= QBs : b*
BndKind:Call, Type:b*, Bnd:(Call(∂.ForEach([map:1] Global(QBs), Cmp(Global(NA) @= Global(NA) !@= Scope(1))):b*))
// (∂.QBs:(i8, s)?*, ∂.NA:(i8, s)?) : b*
ForEach_1(Arr<obj>, (i8,str)):bool
      1) ldarg.0 [Arr<obj>]
      1) ldc.i4.2
      5) ldelem [((i8,str))]
      5) ldfld ((i8,str))::_F0:(i8,str)
      1) ldarg.0 [Arr<obj>]
      1) ldc.i4.2
      5) ldelem [((i8,str))]
      5) ldfld ((i8,str))::_F0:(i8,str)
      1) dup
      1) stloc.0 [(i8,str)]
      5) call static (i8,str)::Equals2((i8,str), (i8,str)):bool
      5) brfalse [0]
      1) ldloc.0 [(i8,str)]
      1) ldarg.1 [(i8,str)]
      5) call static (i8,str)::Equals2((i8,str), (i8,str)):bool
      1) ldc.i4.0
      2) ceq
      5) br [1]
  Label [0]:
      1) ldc.i4.0
  Label [1]:
      1) ret
  Total Size: 53

Func sig: (QBs:(i8, s)?*, NA:(i8, s)?) to b*
Sequence: Seq<bool>
 0) true 
 1) true 
 2) true 
 3) true 
 4) false
###
> RA = RA  ~= RBs
RA @= RA ~@= RBs : b*
BndKind:Call, Type:b*, Bnd:(Call(∂.ForEach([map:1] Global(RBs), Cmp(Global(RA) @= Global(RA) ~@= Scope(1))):b*))
// (∂.RBs:(i8, s)*, ∂.RA:(i8, s)) : b*
ForEach_1(Arr<obj>, (i8,str)):bool
      1) ldarg.0 [Arr<obj>]
      1) ldc.i4.2
      5) ldelem [((i8,str))]
      5) ldfld ((i8,str))::_F0:(i8,str)
      1) ldarg.0 [Arr<obj>]
      1) ldc.i4.2
      5) ldelem [((i8,str))]
      5) ldfld ((i8,str))::_F0:(i8,str)
      1) dup
      1) stloc.0 [(i8,str)]
      5) call static (i8,str)::Equals2((i8,str), (i8,str)):bool
      5) brfalse [0]
      1) ldarg.0 [Arr<obj>]
      1) ldc.i4.0
      5) ldelem [Arr<obj>]
      1) ldc.i4.0
      5) ldelem [EqualityComparer<(i8,str)>]
      1) ldloc.0 [(i8,str)]
      1) ldarg.1 [(i8,str)]
      5) callvirt EqualityComparer<(i8,str)>::Equals((i8,str), (i8,str)):bool
      5) br [1]
  Label [0]:
      1) ldc.i4.0
  Label [1]:
      1) ret
  Total Size: 63

Func sig: (RBs:(i8, s)*, RA:(i8, s)) to b*
Sequence: Seq<bool>
 0) true 
 1) false
 2) true 
 3) false
###
> RA = RA  ~= QBs
RA @= RA ~@= QBs : b*
BndKind:Call, Type:b*, Bnd:(Call(∂.ForEach([map:1] Global(QBs), Cmp(Global(RA) @= Global(RA) ~@= Scope(1))):b*))
// (∂.QBs:(i8, s)?*, ∂.RA:(i8, s)) : b*
ForEach_1(Arr<obj>, (i8,str)):bool
      1) ldarg.0 [Arr<obj>]
      1) ldc.i4.2
      5) ldelem [((i8,str))]
      5) ldfld ((i8,str))::_F0:(i8,str)
      1) ldarg.0 [Arr<obj>]
      1) ldc.i4.2
      5) ldelem [((i8,str))]
      5) ldfld ((i8,str))::_F0:(i8,str)
      1) dup
      1) stloc.0 [(i8,str)]
      5) call static (i8,str)::Equals2((i8,str), (i8,str)):bool
      5) brfalse [0]
      1) ldarg.0 [Arr<obj>]
      1) ldc.i4.0
      5) ldelem [Arr<obj>]
      1) ldc.i4.0
      5) ldelem [EqualityComparer<(i8,str)>]
      1) ldloc.0 [(i8,str)]
      1) ldarg.1 [(i8,str)]
      5) callvirt EqualityComparer<(i8,str)>::Equals((i8,str), (i8,str)):bool
      5) br [1]
  Label [0]:
      1) ldc.i4.0
  Label [1]:
      1) ret
  Total Size: 63

Func sig: (QBs:(i8, s)?*, RA:(i8, s)) to b*
Sequence: Seq<bool>
 0) true 
 1) false
 2) true 
 3) false
 4) false
###
> QA = QA  ~= RBs
QA @= QA ~@= RBs : b*
BndKind:Call, Type:b*, Bnd:(Call(∂.ForEach([map:1] Global(RBs), Cmp(Global(QA) @= Global(QA) ~@= Scope(1))):b*))
// (∂.RBs:(i8, s)*, ∂.QA:(i8, s)?) : b*
ForEach_1(Arr<obj>, (i8,str)):bool
      1) ldarg.0 [Arr<obj>]
      1) ldc.i4.2
      5) ldelem [((i8,str))]
      5) ldfld ((i8,str))::_F0:(i8,str)
      1) ldarg.0 [Arr<obj>]
      1) ldc.i4.2
      5) ldelem [((i8,str))]
      5) ldfld ((i8,str))::_F0:(i8,str)
      1) dup
      1) stloc.0 [(i8,str)]
      5) call static (i8,str)::Equals2((i8,str), (i8,str)):bool
      5) brfalse [0]
      1) ldarg.0 [Arr<obj>]
      1) ldc.i4.0
      5) ldelem [Arr<obj>]
      1) ldc.i4.0
      5) ldelem [EqualityComparer<(i8,str)>]
      1) ldloc.0 [(i8,str)]
      1) ldarg.1 [(i8,str)]
      5) callvirt EqualityComparer<(i8,str)>::Equals((i8,str), (i8,str)):bool
      5) br [1]
  Label [0]:
      1) ldc.i4.0
  Label [1]:
      1) ret
  Total Size: 63

Func sig: (RBs:(i8, s)*, QA:(i8, s)?) to b*
Sequence: Seq<bool>
 0) true 
 1) false
 2) true 
 3) false
###
> QA = QA  ~= QBs
QA @= QA ~@= QBs : b*
BndKind:Call, Type:b*, Bnd:(Call(∂.ForEach([map:1] Global(QBs), Cmp(Global(QA) @= Global(QA) ~@= Scope(1))):b*))
// (∂.QBs:(i8, s)?*, ∂.QA:(i8, s)?) : b*
ForEach_1(Arr<obj>, (i8,str)):bool
      1) ldarg.0 [Arr<obj>]
      1) ldc.i4.2
      5) ldelem [((i8,str))]
      5) ldfld ((i8,str))::_F0:(i8,str)
      1) ldarg.0 [Arr<obj>]
      1) ldc.i4.2
      5) ldelem [((i8,str))]
      5) ldfld ((i8,str))::_F0:(i8,str)
      1) dup
      1) stloc.0 [(i8,str)]
      5) call static (i8,str)::Equals2((i8,str), (i8,str)):bool
      5) brfalse [0]
      1) ldarg.0 [Arr<obj>]
      1) ldc.i4.0
      5) ldelem [Arr<obj>]
      1) ldc.i4.0
      5) ldelem [EqualityComparer<(i8,str)>]
      1) ldloc.0 [(i8,str)]
      1) ldarg.1 [(i8,str)]
      5) callvirt EqualityComparer<(i8,str)>::Equals((i8,str), (i8,str)):bool
      5) br [1]
  Label [0]:
      1) ldc.i4.0
  Label [1]:
      1) ret
  Total Size: 63

Func sig: (QBs:(i8, s)?*, QA:(i8, s)?) to b*
Sequence: Seq<bool>
 0) true 
 1) false
 2) true 
 3) false
 4) false
###
> NA = NA  ~= RBs
NA @= NA ~@= RBs : b*
BndKind:Call, Type:b*, Bnd:(Call(∂.ForEach([map:1] Global(RBs), Cmp(Global(NA) @= Global(NA) ~@= Scope(1))):b*))
// (∂.RBs:(i8, s)*, ∂.NA:(i8, s)?) : b*
ForEach_1(Arr<obj>, (i8,str)):bool
      1) ldarg.0 [Arr<obj>]
      1) ldc.i4.2
      5) ldelem [((i8,str))]
      5) ldfld ((i8,str))::_F0:(i8,str)
      1) ldarg.0 [Arr<obj>]
      1) ldc.i4.2
      5) ldelem [((i8,str))]
      5) ldfld ((i8,str))::_F0:(i8,str)
      1) dup
      1) stloc.0 [(i8,str)]
      5) call static (i8,str)::Equals2((i8,str), (i8,str)):bool
      5) brfalse [0]
      1) ldarg.0 [Arr<obj>]
      1) ldc.i4.0
      5) ldelem [Arr<obj>]
      1) ldc.i4.0
      5) ldelem [EqualityComparer<(i8,str)>]
      1) ldloc.0 [(i8,str)]
      1) ldarg.1 [(i8,str)]
      5) callvirt EqualityComparer<(i8,str)>::Equals((i8,str), (i8,str)):bool
      5) br [1]
  Label [0]:
      1) ldc.i4.0
  Label [1]:
      1) ret
  Total Size: 63

Func sig: (RBs:(i8, s)*, NA:(i8, s)?) to b*
Sequence: Seq<bool>
 0) false
 1) false
 2) false
 3) false
###
> NA = NA  ~= QBs
NA @= NA ~@= QBs : b*
BndKind:Call, Type:b*, Bnd:(Call(∂.ForEach([map:1] Global(QBs), Cmp(Global(NA) @= Global(NA) ~@= Scope(1))):b*))
// (∂.QBs:(i8, s)?*, ∂.NA:(i8, s)?) : b*
ForEach_1(Arr<obj>, (i8,str)):bool
      1) ldarg.0 [Arr<obj>]
      1) ldc.i4.2
      5) ldelem [((i8,str))]
      5) ldfld ((i8,str))::_F0:(i8,str)
      1) ldarg.0 [Arr<obj>]
      1) ldc.i4.2
      5) ldelem [((i8,str))]
      5) ldfld ((i8,str))::_F0:(i8,str)
      1) dup
      1) stloc.0 [(i8,str)]
      5) call static (i8,str)::Equals2((i8,str), (i8,str)):bool
      5) brfalse [0]
      1) ldarg.0 [Arr<obj>]
      1) ldc.i4.0
      5) ldelem [Arr<obj>]
      1) ldc.i4.0
      5) ldelem [EqualityComparer<(i8,str)>]
      1) ldloc.0 [(i8,str)]
      1) ldarg.1 [(i8,str)]
      5) callvirt EqualityComparer<(i8,str)>::Equals((i8,str), (i8,str)):bool
      5) br [1]
  Label [0]:
      1) ldc.i4.0
  Label [1]:
      1) ret
  Total Size: 63

Func sig: (QBs:(i8, s)?*, NA:(i8, s)?) to b*
Sequence: Seq<bool>
 0) false
 1) false
 2) false
 3) false
 4) true 
###
> RA = RA !~= RBs
RA @= RA !~@= RBs : b*
BndKind:Call, Type:b*, Bnd:(Call(∂.ForEach([map:1] Global(RBs), Cmp(Global(RA) @= Global(RA) !~@= Scope(1))):b*))
// (∂.RBs:(i8, s)*, ∂.RA:(i8, s)) : b*
ForEach_1(Arr<obj>, (i8,str)):bool
      1) ldarg.0 [Arr<obj>]
      1) ldc.i4.2
      5) ldelem [((i8,str))]
      5) ldfld ((i8,str))::_F0:(i8,str)
      1) ldarg.0 [Arr<obj>]
      1) ldc.i4.2
      5) ldelem [((i8,str))]
      5) ldfld ((i8,str))::_F0:(i8,str)
      1) dup
      1) stloc.0 [(i8,str)]
      5) call static (i8,str)::Equals2((i8,str), (i8,str)):bool
      5) brfalse [0]
      1) ldarg.0 [Arr<obj>]
      1) ldc.i4.0
      5) ldelem [Arr<obj>]
      1) ldc.i4.0
      5) ldelem [EqualityComparer<(i8,str)>]
      1) ldloc.0 [(i8,str)]
      1) ldarg.1 [(i8,str)]
      5) callvirt EqualityComparer<(i8,str)>::Equals((i8,str), (i8,str)):bool
      1) ldc.i4.0
      2) ceq
      5) br [1]
  Label [0]:
      1) ldc.i4.0
  Label [1]:
      1) ret
  Total Size: 66

Func sig: (RBs:(i8, s)*, RA:(i8, s)) to b*
Sequence: Seq<bool>
 0) false
 1) true 
 2) false
 3) true 
###
> RA = RA !~= QBs
RA @= RA !~@= QBs : b*
BndKind:Call, Type:b*, Bnd:(Call(∂.ForEach([map:1] Global(QBs), Cmp(Global(RA) @= Global(RA) !~@= Scope(1))):b*))
// (∂.QBs:(i8, s)?*, ∂.RA:(i8, s)) : b*
ForEach_1(Arr<obj>, (i8,str)):bool
      1) ldarg.0 [Arr<obj>]
      1) ldc.i4.2
      5) ldelem [((i8,str))]
      5) ldfld ((i8,str))::_F0:(i8,str)
      1) ldarg.0 [Arr<obj>]
      1) ldc.i4.2
      5) ldelem [((i8,str))]
      5) ldfld ((i8,str))::_F0:(i8,str)
      1) dup
      1) stloc.0 [(i8,str)]
      5) call static (i8,str)::Equals2((i8,str), (i8,str)):bool
      5) brfalse [0]
      1) ldarg.0 [Arr<obj>]
      1) ldc.i4.0
      5) ldelem [Arr<obj>]
      1) ldc.i4.0
      5) ldelem [EqualityComparer<(i8,str)>]
      1) ldloc.0 [(i8,str)]
      1) ldarg.1 [(i8,str)]
      5) callvirt EqualityComparer<(i8,str)>::Equals((i8,str), (i8,str)):bool
      1) ldc.i4.0
      2) ceq
      5) br [1]
  Label [0]:
      1) ldc.i4.0
  Label [1]:
      1) ret
  Total Size: 66

Func sig: (QBs:(i8, s)?*, RA:(i8, s)) to b*
Sequence: Seq<bool>
 0) false
 1) true 
 2) false
 3) true 
 4) true 
###
> QA = QA !~= RBs
QA @= QA !~@= RBs : b*
BndKind:Call, Type:b*, Bnd:(Call(∂.ForEach([map:1] Global(RBs), Cmp(Global(QA) @= Global(QA) !~@= Scope(1))):b*))
// (∂.RBs:(i8, s)*, ∂.QA:(i8, s)?) : b*
ForEach_1(Arr<obj>, (i8,str)):bool
      1) ldarg.0 [Arr<obj>]
      1) ldc.i4.2
      5) ldelem [((i8,str))]
      5) ldfld ((i8,str))::_F0:(i8,str)
      1) ldarg.0 [Arr<obj>]
      1) ldc.i4.2
      5) ldelem [((i8,str))]
      5) ldfld ((i8,str))::_F0:(i8,str)
      1) dup
      1) stloc.0 [(i8,str)]
      5) call static (i8,str)::Equals2((i8,str), (i8,str)):bool
      5) brfalse [0]
      1) ldarg.0 [Arr<obj>]
      1) ldc.i4.0
      5) ldelem [Arr<obj>]
      1) ldc.i4.0
      5) ldelem [EqualityComparer<(i8,str)>]
      1) ldloc.0 [(i8,str)]
      1) ldarg.1 [(i8,str)]
      5) callvirt EqualityComparer<(i8,str)>::Equals((i8,str), (i8,str)):bool
      1) ldc.i4.0
      2) ceq
      5) br [1]
  Label [0]:
      1) ldc.i4.0
  Label [1]:
      1) ret
  Total Size: 66

Func sig: (RBs:(i8, s)*, QA:(i8, s)?) to b*
Sequence: Seq<bool>
 0) false
 1) true 
 2) false
 3) true 
###
> QA = QA !~= QBs
QA @= QA !~@= QBs : b*
BndKind:Call, Type:b*, Bnd:(Call(∂.ForEach([map:1] Global(QBs), Cmp(Global(QA) @= Global(QA) !~@= Scope(1))):b*))
// (∂.QBs:(i8, s)?*, ∂.QA:(i8, s)?) : b*
ForEach_1(Arr<obj>, (i8,str)):bool
      1) ldarg.0 [Arr<obj>]
      1) ldc.i4.2
      5) ldelem [((i8,str))]
      5) ldfld ((i8,str))::_F0:(i8,str)
      1) ldarg.0 [Arr<obj>]
      1) ldc.i4.2
      5) ldelem [((i8,str))]
      5) ldfld ((i8,str))::_F0:(i8,str)
      1) dup
      1) stloc.0 [(i8,str)]
      5) call static (i8,str)::Equals2((i8,str), (i8,str)):bool
      5) brfalse [0]
      1) ldarg.0 [Arr<obj>]
      1) ldc.i4.0
      5) ldelem [Arr<obj>]
      1) ldc.i4.0
      5) ldelem [EqualityComparer<(i8,str)>]
      1) ldloc.0 [(i8,str)]
      1) ldarg.1 [(i8,str)]
      5) callvirt EqualityComparer<(i8,str)>::Equals((i8,str), (i8,str)):bool
      1) ldc.i4.0
      2) ceq
      5) br [1]
  Label [0]:
      1) ldc.i4.0
  Label [1]:
      1) ret
  Total Size: 66

Func sig: (QBs:(i8, s)?*, QA:(i8, s)?) to b*
Sequence: Seq<bool>
 0) false
 1) true 
 2) false
 3) true 
 4) true 
###
> NA = NA !~= RBs
NA @= NA !~@= RBs : b*
BndKind:Call, Type:b*, Bnd:(Call(∂.ForEach([map:1] Global(RBs), Cmp(Global(NA) @= Global(NA) !~@= Scope(1))):b*))
// (∂.RBs:(i8, s)*, ∂.NA:(i8, s)?) : b*
ForEach_1(Arr<obj>, (i8,str)):bool
      1) ldarg.0 [Arr<obj>]
      1) ldc.i4.2
      5) ldelem [((i8,str))]
      5) ldfld ((i8,str))::_F0:(i8,str)
      1) ldarg.0 [Arr<obj>]
      1) ldc.i4.2
      5) ldelem [((i8,str))]
      5) ldfld ((i8,str))::_F0:(i8,str)
      1) dup
      1) stloc.0 [(i8,str)]
      5) call static (i8,str)::Equals2((i8,str), (i8,str)):bool
      5) brfalse [0]
      1) ldarg.0 [Arr<obj>]
      1) ldc.i4.0
      5) ldelem [Arr<obj>]
      1) ldc.i4.0
      5) ldelem [EqualityComparer<(i8,str)>]
      1) ldloc.0 [(i8,str)]
      1) ldarg.1 [(i8,str)]
      5) callvirt EqualityComparer<(i8,str)>::Equals((i8,str), (i8,str)):bool
      1) ldc.i4.0
      2) ceq
      5) br [1]
  Label [0]:
      1) ldc.i4.0
  Label [1]:
      1) ret
  Total Size: 66

Func sig: (RBs:(i8, s)*, NA:(i8, s)?) to b*
Sequence: Seq<bool>
 0) true 
 1) true 
 2) true 
 3) true 
###
> NA = NA !~= QBs
NA @= NA !~@= QBs : b*
BndKind:Call, Type:b*, Bnd:(Call(∂.ForEach([map:1] Global(QBs), Cmp(Global(NA) @= Global(NA) !~@= Scope(1))):b*))
// (∂.QBs:(i8, s)?*, ∂.NA:(i8, s)?) : b*
ForEach_1(Arr<obj>, (i8,str)):bool
      1) ldarg.0 [Arr<obj>]
      1) ldc.i4.2
      5) ldelem [((i8,str))]
      5) ldfld ((i8,str))::_F0:(i8,str)
      1) ldarg.0 [Arr<obj>]
      1) ldc.i4.2
      5) ldelem [((i8,str))]
      5) ldfld ((i8,str))::_F0:(i8,str)
      1) dup
      1) stloc.0 [(i8,str)]
      5) call static (i8,str)::Equals2((i8,str), (i8,str)):bool
      5) brfalse [0]
      1) ldarg.0 [Arr<obj>]
      1) ldc.i4.0
      5) ldelem [Arr<obj>]
      1) ldc.i4.0
      5) ldelem [EqualityComparer<(i8,str)>]
      1) ldloc.0 [(i8,str)]
      1) ldarg.1 [(i8,str)]
      5) callvirt EqualityComparer<(i8,str)>::Equals((i8,str), (i8,str)):bool
      1) ldc.i4.0
      2) ceq
      5) br [1]
  Label [0]:
      1) ldc.i4.0
  Label [1]:
      1) ret
  Total Size: 66

Func sig: (QBs:(i8, s)?*, NA:(i8, s)?) to b*
Sequence: Seq<bool>
 0) true 
 1) true 
 2) true 
 3) true 
 4) false
###
> RA   in RBs
RA in RBs : b
BndKind:BinaryOp, Type:b, Bnd:(In(Global(RA), Global(RBs)))
// (<ctx>, ∂.RA:(i8, s), ∂.RBs:(i8, s)*) : b
top(Arr<obj>, Arr<obj>):obj
      1) ldarg.1 [Arr<obj>]
      1) ldc.i4.0
      1) ldelem.ref
      5) call static CodeGenUtil::ToRef(obj):ExecCtx
      1) stloc.0 [ExecCtx]
      1) ldarg.1 [Arr<obj>]
      1) ldc.i4.1
      1) ldelem.ref
      5) call static CodeGenUtil::ToRef(obj):(i8,str)
      1) stloc.1 [(i8,str)]
      1) ldarg.1 [Arr<obj>]
      1) ldc.i4.2
      1) ldelem.ref
      5) call static CodeGenUtil::ToRef(obj):Seq<(i8,str)>
      1) stloc.2 [Seq<(i8,str)>]
      1) ldloc.1 [(i8,str)]
      1) ldloc.2 [Seq<(i8,str)>]
      1) ldloc.0 [ExecCtx]
      1) ldc.i4.0
      5) call static CodeGenUtil::InImpl((i8,str), Seq<(i8,str)>, ExecCtx, i4):bool
      5) box [bool]
      1) ret
  Total Size: 42

Func sig: (<ctx>:x, RA:(i8, s), RBs:(i8, s)*) to b
Type: bool, Value: true 
*** Ctx ping count: 0
###
> RA   in RCs
RA in RCs : b
BndKind:BinaryOp, Type:b, Bnd:(In(Global(RA), Global(RCs)))
// (<ctx>, ∂.RA:(i8, s), ∂.RCs:(i8, s)*) : b
top(Arr<obj>, Arr<obj>):obj
      1) ldarg.1 [Arr<obj>]
      1) ldc.i4.0
      1) ldelem.ref
      5) call static CodeGenUtil::ToRef(obj):ExecCtx
      1) stloc.0 [ExecCtx]
      1) ldarg.1 [Arr<obj>]
      1) ldc.i4.1
      1) ldelem.ref
      5) call static CodeGenUtil::ToRef(obj):(i8,str)
      1) stloc.1 [(i8,str)]
      1) ldarg.1 [Arr<obj>]
      1) ldc.i4.2
      1) ldelem.ref
      5) call static CodeGenUtil::ToRef(obj):Seq<(i8,str)>
      1) stloc.2 [Seq<(i8,str)>]
      1) ldloc.1 [(i8,str)]
      1) ldloc.2 [Seq<(i8,str)>]
      1) ldloc.0 [ExecCtx]
      1) ldc.i4.0
      5) call static CodeGenUtil::InImpl((i8,str), Seq<(i8,str)>, ExecCtx, i4):bool
      5) box [bool]
      1) ret
  Total Size: 42

Func sig: (<ctx>:x, RA:(i8, s), RCs:(i8, s)*) to b
Type: bool, Value: false
*** Ctx ping count: 3
    [0](3): In(RA, RCs)
###
> RA ! in RBs
RA !in RBs : b
BndKind:BinaryOp, Type:b, Bnd:(InNot(Global(RA), Global(RBs)))
// (<ctx>, ∂.RA:(i8, s), ∂.RBs:(i8, s)*) : b
top(Arr<obj>, Arr<obj>):obj
      1) ldarg.1 [Arr<obj>]
      1) ldc.i4.0
      1) ldelem.ref
      5) call static CodeGenUtil::ToRef(obj):ExecCtx
      1) stloc.0 [ExecCtx]
      1) ldarg.1 [Arr<obj>]
      1) ldc.i4.1
      1) ldelem.ref
      5) call static CodeGenUtil::ToRef(obj):(i8,str)
      1) stloc.1 [(i8,str)]
      1) ldarg.1 [Arr<obj>]
      1) ldc.i4.2
      1) ldelem.ref
      5) call static CodeGenUtil::ToRef(obj):Seq<(i8,str)>
      1) stloc.2 [Seq<(i8,str)>]
      1) ldloc.1 [(i8,str)]
      1) ldloc.2 [Seq<(i8,str)>]
      1) ldloc.0 [ExecCtx]
      1) ldc.i4.0
      5) call static CodeGenUtil::InImpl((i8,str), Seq<(i8,str)>, ExecCtx, i4):bool
      1) ldc.i4.0
      2) ceq
      5) box [bool]
      1) ret
  Total Size: 45

Func sig: (<ctx>:x, RA:(i8, s), RBs:(i8, s)*) to b
Type: bool, Value: false
*** Ctx ping count: 0
###
> RA ! in RCs
RA !in RCs : b
BndKind:BinaryOp, Type:b, Bnd:(InNot(Global(RA), Global(RCs)))
// (<ctx>, ∂.RA:(i8, s), ∂.RCs:(i8, s)*) : b
top(Arr<obj>, Arr<obj>):obj
      1) ldarg.1 [Arr<obj>]
      1) ldc.i4.0
      1) ldelem.ref
      5) call static CodeGenUtil::ToRef(obj):ExecCtx
      1) stloc.0 [ExecCtx]
      1) ldarg.1 [Arr<obj>]
      1) ldc.i4.1
      1) ldelem.ref
      5) call static CodeGenUtil::ToRef(obj):(i8,str)
      1) stloc.1 [(i8,str)]
      1) ldarg.1 [Arr<obj>]
      1) ldc.i4.2
      1) ldelem.ref
      5) call static CodeGenUtil::ToRef(obj):Seq<(i8,str)>
      1) stloc.2 [Seq<(i8,str)>]
      1) ldloc.1 [(i8,str)]
      1) ldloc.2 [Seq<(i8,str)>]
      1) ldloc.0 [ExecCtx]
      1) ldc.i4.0
      5) call static CodeGenUtil::InImpl((i8,str), Seq<(i8,str)>, ExecCtx, i4):bool
      1) ldc.i4.0
      2) ceq
      5) box [bool]
      1) ret
  Total Size: 45

Func sig: (<ctx>:x, RA:(i8, s), RCs:(i8, s)*) to b
Type: bool, Value: true 
*** Ctx ping count: 3
    [0](3): InNot(RA, RCs)
###
> RA  ~in RBs
RA ~in RBs : b
BndKind:BinaryOp, Type:b, Bnd:(InCi(Global(RA), Global(RBs)))
// (<ctx>, ∂.RA:(i8, s), ∂.RBs:(i8, s)*) : b
top(Arr<obj>, Arr<obj>):obj
      1) ldarg.1 [Arr<obj>]
      1) ldc.i4.0
      1) ldelem.ref
      5) call static CodeGenUtil::ToRef(obj):ExecCtx
      1) stloc.0 [ExecCtx]
      1) ldarg.1 [Arr<obj>]
      1) ldc.i4.1
      1) ldelem.ref
      5) call static CodeGenUtil::ToRef(obj):(i8,str)
      1) stloc.1 [(i8,str)]
      1) ldarg.1 [Arr<obj>]
      1) ldc.i4.2
      1) ldelem.ref
      5) call static CodeGenUtil::ToRef(obj):Seq<(i8,str)>
      1) stloc.2 [Seq<(i8,str)>]
      1) ldloc.1 [(i8,str)]
      1) ldloc.2 [Seq<(i8,str)>]
      1) ldarg.0 [Arr<obj>]
      1) ldc.i4.0
      5) ldelem [EqualityComparer<(i8,str)>]
      1) ldloc.0 [ExecCtx]
      1) ldc.i4.0
      5) call static CodeGenUtil::InImpl((i8,str), Seq<(i8,str)>, IEqualityComparer<(i8,str)>, ExecCtx, i4):bool
      5) box [bool]
      1) ret
  Total Size: 49

Func sig: (<ctx>:x, RA:(i8, s), RBs:(i8, s)*) to b
Type: bool, Value: true 
*** Ctx ping count: 0
###
> RA  ~in RCs
RA ~in RCs : b
BndKind:BinaryOp, Type:b, Bnd:(InCi(Global(RA), Global(RCs)))
// (<ctx>, ∂.RA:(i8, s), ∂.RCs:(i8, s)*) : b
top(Arr<obj>, Arr<obj>):obj
      1) ldarg.1 [Arr<obj>]
      1) ldc.i4.0
      1) ldelem.ref
      5) call static CodeGenUtil::ToRef(obj):ExecCtx
      1) stloc.0 [ExecCtx]
      1) ldarg.1 [Arr<obj>]
      1) ldc.i4.1
      1) ldelem.ref
      5) call static CodeGenUtil::ToRef(obj):(i8,str)
      1) stloc.1 [(i8,str)]
      1) ldarg.1 [Arr<obj>]
      1) ldc.i4.2
      1) ldelem.ref
      5) call static CodeGenUtil::ToRef(obj):Seq<(i8,str)>
      1) stloc.2 [Seq<(i8,str)>]
      1) ldloc.1 [(i8,str)]
      1) ldloc.2 [Seq<(i8,str)>]
      1) ldarg.0 [Arr<obj>]
      1) ldc.i4.0
      5) ldelem [EqualityComparer<(i8,str)>]
      1) ldloc.0 [ExecCtx]
      1) ldc.i4.0
      5) call static CodeGenUtil::InImpl((i8,str), Seq<(i8,str)>, IEqualityComparer<(i8,str)>, ExecCtx, i4):bool
      5) box [bool]
      1) ret
  Total Size: 49

Func sig: (<ctx>:x, RA:(i8, s), RCs:(i8, s)*) to b
Type: bool, Value: true 
*** Ctx ping count: 1
    [0](1): InCi(RA, RCs)
###
> RA !~in RBs
RA !~in RBs : b
BndKind:BinaryOp, Type:b, Bnd:(InCiNot(Global(RA), Global(RBs)))
// (<ctx>, ∂.RA:(i8, s), ∂.RBs:(i8, s)*) : b
top(Arr<obj>, Arr<obj>):obj
      1) ldarg.1 [Arr<obj>]
      1) ldc.i4.0
      1) ldelem.ref
      5) call static CodeGenUtil::ToRef(obj):ExecCtx
      1) stloc.0 [ExecCtx]
      1) ldarg.1 [Arr<obj>]
      1) ldc.i4.1
      1) ldelem.ref
      5) call static CodeGenUtil::ToRef(obj):(i8,str)
      1) stloc.1 [(i8,str)]
      1) ldarg.1 [Arr<obj>]
      1) ldc.i4.2
      1) ldelem.ref
      5) call static CodeGenUtil::ToRef(obj):Seq<(i8,str)>
      1) stloc.2 [Seq<(i8,str)>]
      1) ldloc.1 [(i8,str)]
      1) ldloc.2 [Seq<(i8,str)>]
      1) ldarg.0 [Arr<obj>]
      1) ldc.i4.0
      5) ldelem [EqualityComparer<(i8,str)>]
      1) ldloc.0 [ExecCtx]
      1) ldc.i4.0
      5) call static CodeGenUtil::InImpl((i8,str), Seq<(i8,str)>, IEqualityComparer<(i8,str)>, ExecCtx, i4):bool
      1) ldc.i4.0
      2) ceq
      5) box [bool]
      1) ret
  Total Size: 52

Func sig: (<ctx>:x, RA:(i8, s), RBs:(i8, s)*) to b
Type: bool, Value: false
*** Ctx ping count: 0
###
> RA !~in RCs
RA !~in RCs : b
BndKind:BinaryOp, Type:b, Bnd:(InCiNot(Global(RA), Global(RCs)))
// (<ctx>, ∂.RA:(i8, s), ∂.RCs:(i8, s)*) : b
top(Arr<obj>, Arr<obj>):obj
      1) ldarg.1 [Arr<obj>]
      1) ldc.i4.0
      1) ldelem.ref
      5) call static CodeGenUtil::ToRef(obj):ExecCtx
      1) stloc.0 [ExecCtx]
      1) ldarg.1 [Arr<obj>]
      1) ldc.i4.1
      1) ldelem.ref
      5) call static CodeGenUtil::ToRef(obj):(i8,str)
      1) stloc.1 [(i8,str)]
      1) ldarg.1 [Arr<obj>]
      1) ldc.i4.2
      1) ldelem.ref
      5) call static CodeGenUtil::ToRef(obj):Seq<(i8,str)>
      1) stloc.2 [Seq<(i8,str)>]
      1) ldloc.1 [(i8,str)]
      1) ldloc.2 [Seq<(i8,str)>]
      1) ldarg.0 [Arr<obj>]
      1) ldc.i4.0
      5) ldelem [EqualityComparer<(i8,str)>]
      1) ldloc.0 [ExecCtx]
      1) ldc.i4.0
      5) call static CodeGenUtil::InImpl((i8,str), Seq<(i8,str)>, IEqualityComparer<(i8,str)>, ExecCtx, i4):bool
      1) ldc.i4.0
      2) ceq
      5) box [bool]
      1) ret
  Total Size: 52

Func sig: (<ctx>:x, RA:(i8, s), RCs:(i8, s)*) to b
Type: bool, Value: false
*** Ctx ping count: 1
    [0](1): InCiNot(RA, RCs)
###

**** New definitions: RAs, type: (r8, s)*
**** New definitions: QAs, type: (r8, s)?*
**** New definitions: RBs, type: (r8, s)*
**** New definitions: QBs, type: (r8, s)?*
**** New definitions: DAs, type: (r8, s)*
**** New udf: F, arity: 2

> F(RAs, RBs)
F(RAs, RBs) : (s, (r8, s), (r8, s))**
BndKind:Call, Type:(s, (r8, s), (r8, s))**, Bnd:(Call(∂.ForEach([map:1] Global(RAs), Call(∂.ForEach([map:2] Global(RBs), (StrConcat(If(Cmp(Scope(1) @= Scope(2)), str(M), str(_)), If(Cmp(Scope(1) ~@= Scope(2)), str(M), str(_)), If(Cmp(Scope(1) $= Scope(2)), str(M), str(_)), If(Cmp(Scope(1) ~$= Scope(2)), str(M), str(_))), Scope(1), Scope(2)):(s, (r8, s), (r8, s))):(s, (r8, s), (r8, s))*)):(s, (r8, s), (r8, s))**))
// (∂.RAs:(r8, s)*, ∂.RBs:(r8, s)*) : (s, (r8, s), (r8, s))**
ForEach_1(Arr<obj>, (r8,str)):(str,(r8,str),(r8,str))
      5) newobj (str,(r8,str),(r8,str))()
      1) dup
      1) ldarg.0 [Arr<obj>]
      1) ldc.i4.3
      5) ldelem [((r8,str))]
      5) ldfld ((r8,str))::_F0:(r8,str)
      1) ldarg.1 [(r8,str)]
      5) call static (r8,str)::Equals2((r8,str), (r8,str)):bool
      5) brfalse [0]
      5) ldstr [M]
      5) br [1]
  Label [0]:
      5) ldstr [_]
  Label [1]:
      1) ldarg.0 [Arr<obj>]
      1) ldc.i4.0
      5) ldelem [Arr<obj>]
      1) ldc.i4.0
      5) ldelem [EqualityComparer<(r8,str)>]
      1) ldarg.0 [Arr<obj>]
      1) ldc.i4.3
      5) ldelem [((r8,str))]
      5) ldfld ((r8,str))::_F0:(r8,str)
      1) ldarg.1 [(r8,str)]
      5) callvirt EqualityComparer<(r8,str)>::Equals((r8,str), (r8,str)):bool
      5) brfalse [2]
      5) ldstr [M]
      5) br [3]
  Label [2]:
      5) ldstr [_]
  Label [3]:
      1) ldarg.0 [Arr<obj>]
      1) ldc.i4.0
      5) ldelem [Arr<obj>]
      1) ldc.i4.1
      5) ldelem [EqualityComparer<(r8,str)>]
      1) ldarg.0 [Arr<obj>]
      1) ldc.i4.3
      5) ldelem [((r8,str))]
      5) ldfld ((r8,str))::_F0:(r8,str)
      1) ldarg.1 [(r8,str)]
      5) callvirt EqualityComparer<(r8,str)>::Equals((r8,str), (r8,str)):bool
      5) brfalse [4]
      5) ldstr [M]
      5) br [5]
  Label [4]:
      5) ldstr [_]
  Label [5]:
      1) ldarg.0 [Arr<obj>]
      1) ldc.i4.0
      5) ldelem [Arr<obj>]
      1) ldc.i4.2
      5) ldelem [EqualityComparer<(r8,str)>]
      1) ldarg.0 [Arr<obj>]
      1) ldc.i4.3
      5) ldelem [((r8,str))]
      5) ldfld ((r8,str))::_F0:(r8,str)
      1) ldarg.1 [(r8,str)]
      5) callvirt EqualityComparer<(r8,str)>::Equals((r8,str), (r8,str)):bool
      5) brfalse [6]
      5) ldstr [M]
      5) br [7]
  Label [6]:
      5) ldstr [_]
  Label [7]:
      5) call static str::Concat(str, str, str, str):str
      5) stfld (str,(r8,str),(r8,str))::_F0:str
      1) dup
      1) ldarg.0 [Arr<obj>]
      1) ldc.i4.3
      5) ldelem [((r8,str))]
      5) ldfld ((r8,str))::_F0:(r8,str)
      5) stfld (str,(r8,str),(r8,str))::_F1:(r8,str)
      1) dup
      1) ldarg.1 [(r8,str)]
      5) stfld (str,(r8,str),(r8,str))::_F2:(r8,str)
      1) ret
  Total Size: 233

Func sig: (RAs:(r8, s)*, RBs:(r8, s)*) to (s, (r8, s), (r8, s))**
Sequence: Seq<Seq<(str,(r8,str),(r8,str))>>
 0) Sequence: Seq<(str,(r8,str),(r8,str))>
     0) (MMMM, (3.5, hi), (3.5, hi))
     1) (____, (3.5, hi), (5, hi))
     2) (_M_M, (3.5, hi), (3.5, HI))
     3) (____, (3.5, hi), (3.5, hj))
     4) (____, (3.5, hi), (NaN, hi))
     5) (____, (3.5, hi), (NaN, HI))
 1) Sequence: Seq<(str,(r8,str),(r8,str))>
     0) (____, (NaN, hi), (3.5, hi))
     1) (____, (NaN, hi), (5, hi))
     2) (____, (NaN, hi), (3.5, HI))
     3) (____, (NaN, hi), (3.5, hj))
     4) (MM__, (NaN, hi), (NaN, hi))
     5) (_M__, (NaN, hi), (NaN, HI))
###
> F(RAs, QBs)
F(RAs, QBs) : (s, (r8, s), (r8, s)?)**
BndKind:Call, Type:(s, (r8, s), (r8, s)?)**, Bnd:(Call(∂.ForEach([map:1] Global(RAs), Call(∂.ForEach([map:2] Global(QBs), (StrConcat(If(Cmp(Scope(1) @= Scope(2)), str(M), str(_)), If(Cmp(Scope(1) ~@= Scope(2)), str(M), str(_)), If(Cmp(Scope(1) $= Scope(2)), str(M), str(_)), If(Cmp(Scope(1) ~$= Scope(2)), str(M), str(_))), Scope(1), Scope(2)):(s, (r8, s), (r8, s)?)):(s, (r8, s), (r8, s)?)*)):(s, (r8, s), (r8, s)?)**))
// (∂.RAs:(r8, s)*, ∂.QBs:(r8, s)?*) : (s, (r8, s), (r8, s)?)**
ForEach_1(Arr<obj>, (r8,str)):(str,(r8,str),(r8,str))
      5) newobj (str,(r8,str),(r8,str))()
      1) dup
      1) ldarg.0 [Arr<obj>]
      1) ldc.i4.3
      5) ldelem [((r8,str))]
      5) ldfld ((r8,str))::_F0:(r8,str)
      1) ldarg.1 [(r8,str)]
      5) call static (r8,str)::Equals2((r8,str), (r8,str)):bool
      5) brfalse [0]
      5) ldstr [M]
      5) br [1]
  Label [0]:
      5) ldstr [_]
  Label [1]:
      1) ldarg.0 [Arr<obj>]
      1) ldc.i4.0
      5) ldelem [Arr<obj>]
      1) ldc.i4.0
      5) ldelem [EqualityComparer<(r8,str)>]
      1) ldarg.0 [Arr<obj>]
      1) ldc.i4.3
      5) ldelem [((r8,str))]
      5) ldfld ((r8,str))::_F0:(r8,str)
      1) ldarg.1 [(r8,str)]
      5) callvirt EqualityComparer<(r8,str)>::Equals((r8,str), (r8,str)):bool
      5) brfalse [2]
      5) ldstr [M]
      5) br [3]
  Label [2]:
      5) ldstr [_]
  Label [3]:
      1) ldarg.0 [Arr<obj>]
      1) ldc.i4.0
      5) ldelem [Arr<obj>]
      1) ldc.i4.1
      5) ldelem [EqualityComparer<(r8,str)>]
      1) ldarg.0 [Arr<obj>]
      1) ldc.i4.3
      5) ldelem [((r8,str))]
      5) ldfld ((r8,str))::_F0:(r8,str)
      1) ldarg.1 [(r8,str)]
      5) callvirt EqualityComparer<(r8,str)>::Equals((r8,str), (r8,str)):bool
      5) brfalse [4]
      5) ldstr [M]
      5) br [5]
  Label [4]:
      5) ldstr [_]
  Label [5]:
      1) ldarg.0 [Arr<obj>]
      1) ldc.i4.0
      5) ldelem [Arr<obj>]
      1) ldc.i4.2
      5) ldelem [EqualityComparer<(r8,str)>]
      1) ldarg.0 [Arr<obj>]
      1) ldc.i4.3
      5) ldelem [((r8,str))]
      5) ldfld ((r8,str))::_F0:(r8,str)
      1) ldarg.1 [(r8,str)]
      5) callvirt EqualityComparer<(r8,str)>::Equals((r8,str), (r8,str)):bool
      5) brfalse [6]
      5) ldstr [M]
      5) br [7]
  Label [6]:
      5) ldstr [_]
  Label [7]:
      5) call static str::Concat(str, str, str, str):str
      5) stfld (str,(r8,str),(r8,str))::_F0:str
      1) dup
      1) ldarg.0 [Arr<obj>]
      1) ldc.i4.3
      5) ldelem [((r8,str))]
      5) ldfld ((r8,str))::_F0:(r8,str)
      5) stfld (str,(r8,str),(r8,str))::_F1:(r8,str)
      1) dup
      1) ldarg.1 [(r8,str)]
      5) stfld (str,(r8,str),(r8,str))::_F2:(r8,str)
      1) ret
  Total Size: 233

Func sig: (RAs:(r8, s)*, QBs:(r8, s)?*) to (s, (r8, s), (r8, s)?)**
Sequence: Seq<Seq<(str,(r8,str),(r8,str))>>
 0) Sequence: Seq<(str,(r8,str),(r8,str))>
     0) (MMMM, (3.5, hi), (3.5, hi))
     1) (____, (3.5, hi), (5, hi))
     2) (_M_M, (3.5, hi), (3.5, HI))
     3) (____, (3.5, hi), (3.5, hj))
     4) (____, (3.5, hi), (NaN, hi))
     5) (____, (3.5, hi), (NaN, HI))
     6) (____, (3.5, hi), <null>)
 1) Sequence: Seq<(str,(r8,str),(r8,str))>
     0) (____, (NaN, hi), (3.5, hi))
     1) (____, (NaN, hi), (5, hi))
     2) (____, (NaN, hi), (3.5, HI))
     3) (____, (NaN, hi), (3.5, hj))
     4) (MM__, (NaN, hi), (NaN, hi))
     5) (_M__, (NaN, hi), (NaN, HI))
     6) (____, (NaN, hi), <null>)
###
> F(QAs, RBs)
F(QAs, RBs) : (s, (r8, s)?, (r8, s))**
BndKind:Call, Type:(s, (r8, s)?, (r8, s))**, Bnd:(Call(∂.ForEach([map:1] Global(QAs), Call(∂.ForEach([map:2] Global(RBs), (StrConcat(If(Cmp(Scope(1) @= Scope(2)), str(M), str(_)), If(Cmp(Scope(1) ~@= Scope(2)), str(M), str(_)), If(Cmp(Scope(1) $= Scope(2)), str(M), str(_)), If(Cmp(Scope(1) ~$= Scope(2)), str(M), str(_))), Scope(1), Scope(2)):(s, (r8, s)?, (r8, s))):(s, (r8, s)?, (r8, s))*)):(s, (r8, s)?, (r8, s))**))
// (∂.QAs:(r8, s)?*, ∂.RBs:(r8, s)*) : (s, (r8, s)?, (r8, s))**
ForEach_1(Arr<obj>, (r8,str)):(str,(r8,str),(r8,str))
      5) newobj (str,(r8,str),(r8,str))()
      1) dup
      1) ldarg.0 [Arr<obj>]
      1) ldc.i4.3
      5) ldelem [((r8,str))]
      5) ldfld ((r8,str))::_F0:(r8,str)
      1) ldarg.1 [(r8,str)]
      5) call static (r8,str)::Equals2((r8,str), (r8,str)):bool
      5) brfalse [0]
      5) ldstr [M]
      5) br [1]
  Label [0]:
      5) ldstr [_]
  Label [1]:
      1) ldarg.0 [Arr<obj>]
      1) ldc.i4.0
      5) ldelem [Arr<obj>]
      1) ldc.i4.0
      5) ldelem [EqualityComparer<(r8,str)>]
      1) ldarg.0 [Arr<obj>]
      1) ldc.i4.3
      5) ldelem [((r8,str))]
      5) ldfld ((r8,str))::_F0:(r8,str)
      1) ldarg.1 [(r8,str)]
      5) callvirt EqualityComparer<(r8,str)>::Equals((r8,str), (r8,str)):bool
      5) brfalse [2]
      5) ldstr [M]
      5) br [3]
  Label [2]:
      5) ldstr [_]
  Label [3]:
      1) ldarg.0 [Arr<obj>]
      1) ldc.i4.0
      5) ldelem [Arr<obj>]
      1) ldc.i4.1
      5) ldelem [EqualityComparer<(r8,str)>]
      1) ldarg.0 [Arr<obj>]
      1) ldc.i4.3
      5) ldelem [((r8,str))]
      5) ldfld ((r8,str))::_F0:(r8,str)
      1) ldarg.1 [(r8,str)]
      5) callvirt EqualityComparer<(r8,str)>::Equals((r8,str), (r8,str)):bool
      5) brfalse [4]
      5) ldstr [M]
      5) br [5]
  Label [4]:
      5) ldstr [_]
  Label [5]:
      1) ldarg.0 [Arr<obj>]
      1) ldc.i4.0
      5) ldelem [Arr<obj>]
      1) ldc.i4.2
      5) ldelem [EqualityComparer<(r8,str)>]
      1) ldarg.0 [Arr<obj>]
      1) ldc.i4.3
      5) ldelem [((r8,str))]
      5) ldfld ((r8,str))::_F0:(r8,str)
      1) ldarg.1 [(r8,str)]
      5) callvirt EqualityComparer<(r8,str)>::Equals((r8,str), (r8,str)):bool
      5) brfalse [6]
      5) ldstr [M]
      5) br [7]
  Label [6]:
      5) ldstr [_]
  Label [7]:
      5) call static str::Concat(str, str, str, str):str
      5) stfld (str,(r8,str),(r8,str))::_F0:str
      1) dup
      1) ldarg.0 [Arr<obj>]
      1) ldc.i4.3
      5) ldelem [((r8,str))]
      5) ldfld ((r8,str))::_F0:(r8,str)
      5) stfld (str,(r8,str),(r8,str))::_F1:(r8,str)
      1) dup
      1) ldarg.1 [(r8,str)]
      5) stfld (str,(r8,str),(r8,str))::_F2:(r8,str)
      1) ret
  Total Size: 233

Func sig: (QAs:(r8, s)?*, RBs:(r8, s)*) to (s, (r8, s)?, (r8, s))**
Sequence: Seq<Seq<(str,(r8,str),(r8,str))>>
 0) Sequence: Seq<(str,(r8,str),(r8,str))>
     0) (MMMM, (3.5, hi), (3.5, hi))
     1) (____, (3.5, hi), (5, hi))
     2) (_M_M, (3.5, hi), (3.5, HI))
     3) (____, (3.5, hi), (3.5, hj))
     4) (____, (3.5, hi), (NaN, hi))
     5) (____, (3.5, hi), (NaN, HI))
 1) Sequence: Seq<(str,(r8,str),(r8,str))>
     0) (____, (NaN, hi), (3.5, hi))
     1) (____, (NaN, hi), (5, hi))
     2) (____, (NaN, hi), (3.5, HI))
     3) (____, (NaN, hi), (3.5, hj))
     4) (MM__, (NaN, hi), (NaN, hi))
     5) (_M__, (NaN, hi), (NaN, HI))
 2) Sequence: Seq<(str,(r8,str),(r8,str))>
     0) (____, <null>, (3.5, hi))
     1) (____, <null>, (5, hi))
     2) (____, <null>, (3.5, HI))
     3) (____, <null>, (3.5, hj))
     4) (____, <null>, (NaN, hi))
     5) (____, <null>, (NaN, HI))
###
> F(QAs, QBs)
F(QAs, QBs) : (s, (r8, s)?, (r8, s)?)**
BndKind:Call, Type:(s, (r8, s)?, (r8, s)?)**, Bnd:(Call(∂.ForEach([map:1] Global(QAs), Call(∂.ForEach([map:2] Global(QBs), (StrConcat(If(Cmp(Scope(1) @= Scope(2)), str(M), str(_)), If(Cmp(Scope(1) ~@= Scope(2)), str(M), str(_)), If(Cmp(Scope(1) $= Scope(2)), str(M), str(_)), If(Cmp(Scope(1) ~$= Scope(2)), str(M), str(_))), Scope(1), Scope(2)):(s, (r8, s)?, (r8, s)?)):(s, (r8, s)?, (r8, s)?)*)):(s, (r8, s)?, (r8, s)?)**))
// (∂.QAs:(r8, s)?*, ∂.QBs:(r8, s)?*) : (s, (r8, s)?, (r8, s)?)**
ForEach_1(Arr<obj>, (r8,str)):(str,(r8,str),(r8,str))
      5) newobj (str,(r8,str),(r8,str))()
      1) dup
      1) ldarg.0 [Arr<obj>]
      1) ldc.i4.3
      5) ldelem [((r8,str))]
      5) ldfld ((r8,str))::_F0:(r8,str)
      1) ldarg.1 [(r8,str)]
      5) call static (r8,str)::Equals2((r8,str), (r8,str)):bool
      5) brfalse [0]
      5) ldstr [M]
      5) br [1]
  Label [0]:
      5) ldstr [_]
  Label [1]:
      1) ldarg.0 [Arr<obj>]
      1) ldc.i4.0
      5) ldelem [Arr<obj>]
      1) ldc.i4.0
      5) ldelem [EqualityComparer<(r8,str)>]
      1) ldarg.0 [Arr<obj>]
      1) ldc.i4.3
      5) ldelem [((r8,str))]
      5) ldfld ((r8,str))::_F0:(r8,str)
      1) ldarg.1 [(r8,str)]
      5) callvirt EqualityComparer<(r8,str)>::Equals((r8,str), (r8,str)):bool
      5) brfalse [2]
      5) ldstr [M]
      5) br [3]
  Label [2]:
      5) ldstr [_]
  Label [3]:
      1) ldarg.0 [Arr<obj>]
      1) ldc.i4.0
      5) ldelem [Arr<obj>]
      1) ldc.i4.1
      5) ldelem [EqualityComparer<(r8,str)>]
      1) ldarg.0 [Arr<obj>]
      1) ldc.i4.3
      5) ldelem [((r8,str))]
      5) ldfld ((r8,str))::_F0:(r8,str)
      1) ldarg.1 [(r8,str)]
      5) callvirt EqualityComparer<(r8,str)>::Equals((r8,str), (r8,str)):bool
      5) brfalse [4]
      5) ldstr [M]
      5) br [5]
  Label [4]:
      5) ldstr [_]
  Label [5]:
      1) ldarg.0 [Arr<obj>]
      1) ldc.i4.0
      5) ldelem [Arr<obj>]
      1) ldc.i4.2
      5) ldelem [EqualityComparer<(r8,str)>]
      1) ldarg.0 [Arr<obj>]
      1) ldc.i4.3
      5) ldelem [((r8,str))]
      5) ldfld ((r8,str))::_F0:(r8,str)
      1) ldarg.1 [(r8,str)]
      5) callvirt EqualityComparer<(r8,str)>::Equals((r8,str), (r8,str)):bool
      5) brfalse [6]
      5) ldstr [M]
      5) br [7]
  Label [6]:
      5) ldstr [_]
  Label [7]:
      5) call static str::Concat(str, str, str, str):str
      5) stfld (str,(r8,str),(r8,str))::_F0:str
      1) dup
      1) ldarg.0 [Arr<obj>]
      1) ldc.i4.3
      5) ldelem [((r8,str))]
      5) ldfld ((r8,str))::_F0:(r8,str)
      5) stfld (str,(r8,str),(r8,str))::_F1:(r8,str)
      1) dup
      1) ldarg.1 [(r8,str)]
      5) stfld (str,(r8,str),(r8,str))::_F2:(r8,str)
      1) ret
  Total Size: 233

Func sig: (QAs:(r8, s)?*, QBs:(r8, s)?*) to (s, (r8, s)?, (r8, s)?)**
Sequence: Seq<Seq<(str,(r8,str),(r8,str))>>
 0) Sequence: Seq<(str,(r8,str),(r8,str))>
     0) (MMMM, (3.5, hi), (3.5, hi))
     1) (____, (3.5, hi), (5, hi))
     2) (_M_M, (3.5, hi), (3.5, HI))
     3) (____, (3.5, hi), (3.5, hj))
     4) (____, (3.5, hi), (NaN, hi))
     5) (____, (3.5, hi), (NaN, HI))
     6) (____, (3.5, hi), <null>)
 1) Sequence: Seq<(str,(r8,str),(r8,str))>
     0) (____, (NaN, hi), (3.5, hi))
     1) (____, (NaN, hi), (5, hi))
     2) (____, (NaN, hi), (3.5, HI))
     3) (____, (NaN, hi), (3.5, hj))
     4) (MM__, (NaN, hi), (NaN, hi))
     5) (_M__, (NaN, hi), (NaN, HI))
     6) (____, (NaN, hi), <null>)
 2) Sequence: Seq<(str,(r8,str),(r8,str))>
     0) (____, <null>, (3.5, hi))
     1) (____, <null>, (5, hi))
     2) (____, <null>, (3.5, HI))
     3) (____, <null>, (3.5, hj))
     4) (____, <null>, (NaN, hi))
     5) (____, <null>, (NaN, HI))
     6) (MM__, <null>, <null>)
###
> F(DAs, RBs)
F(DAs, RBs) : (s, (r8, s), (r8, s))**
BndKind:Call, Type:(s, (r8, s), (r8, s))**, Bnd:(Call(∂.ForEach([map:1] Global(DAs), Call(∂.ForEach([map:2] Global(RBs), (StrConcat(If(Cmp(Scope(1) @= Scope(2)), str(M), str(_)), If(Cmp(Scope(1) ~@= Scope(2)), str(M), str(_)), If(Cmp(Scope(1) $= Scope(2)), str(M), str(_)), If(Cmp(Scope(1) ~$= Scope(2)), str(M), str(_))), Scope(1), Scope(2)):(s, (r8, s), (r8, s))):(s, (r8, s), (r8, s))*)):(s, (r8, s), (r8, s))**))
// (∂.DAs:(r8, s)*, ∂.RBs:(r8, s)*) : (s, (r8, s), (r8, s))**
ForEach_1(Arr<obj>, (r8,str)):(str,(r8,str),(r8,str))
      5) newobj (str,(r8,str),(r8,str))()
      1) dup
      1) ldarg.0 [Arr<obj>]
      1) ldc.i4.3
      5) ldelem [((r8,str))]
      5) ldfld ((r8,str))::_F0:(r8,str)
      1) ldarg.1 [(r8,str)]
      5) call static (r8,str)::Equals2((r8,str), (r8,str)):bool
      5) brfalse [0]
      5) ldstr [M]
      5) br [1]
  Label [0]:
      5) ldstr [_]
  Label [1]:
      1) ldarg.0 [Arr<obj>]
      1) ldc.i4.0
      5) ldelem [Arr<obj>]
      1) ldc.i4.0
      5) ldelem [EqualityComparer<(r8,str)>]
      1) ldarg.0 [Arr<obj>]
      1) ldc.i4.3
      5) ldelem [((r8,str))]
      5) ldfld ((r8,str))::_F0:(r8,str)
      1) ldarg.1 [(r8,str)]
      5) callvirt EqualityComparer<(r8,str)>::Equals((r8,str), (r8,str)):bool
      5) brfalse [2]
      5) ldstr [M]
      5) br [3]
  Label [2]:
      5) ldstr [_]
  Label [3]:
      1) ldarg.0 [Arr<obj>]
      1) ldc.i4.0
      5) ldelem [Arr<obj>]
      1) ldc.i4.1
      5) ldelem [EqualityComparer<(r8,str)>]
      1) ldarg.0 [Arr<obj>]
      1) ldc.i4.3
      5) ldelem [((r8,str))]
      5) ldfld ((r8,str))::_F0:(r8,str)
      1) ldarg.1 [(r8,str)]
      5) callvirt EqualityComparer<(r8,str)>::Equals((r8,str), (r8,str)):bool
      5) brfalse [4]
      5) ldstr [M]
      5) br [5]
  Label [4]:
      5) ldstr [_]
  Label [5]:
      1) ldarg.0 [Arr<obj>]
      1) ldc.i4.0
      5) ldelem [Arr<obj>]
      1) ldc.i4.2
      5) ldelem [EqualityComparer<(r8,str)>]
      1) ldarg.0 [Arr<obj>]
      1) ldc.i4.3
      5) ldelem [((r8,str))]
      5) ldfld ((r8,str))::_F0:(r8,str)
      1) ldarg.1 [(r8,str)]
      5) callvirt EqualityComparer<(r8,str)>::Equals((r8,str), (r8,str)):bool
      5) brfalse [6]
      5) ldstr [M]
      5) br [7]
  Label [6]:
      5) ldstr [_]
  Label [7]:
      5) call static str::Concat(str, str, str, str):str
      5) stfld (str,(r8,str),(r8,str))::_F0:str
      1) dup
      1) ldarg.0 [Arr<obj>]
      1) ldc.i4.3
      5) ldelem [((r8,str))]
      5) ldfld ((r8,str))::_F0:(r8,str)
      5) stfld (str,(r8,str),(r8,str))::_F1:(r8,str)
      1) dup
      1) ldarg.1 [(r8,str)]
      5) stfld (str,(r8,str),(r8,str))::_F2:(r8,str)
      1) ret
  Total Size: 233

Func sig: (DAs:(r8, s)*, RBs:(r8, s)*) to (s, (r8, s), (r8, s))**
Sequence: Seq<Seq<(str,(r8,str),(r8,str))>>
 0) Sequence: Seq<(str,(r8,str),(r8,str))>
     0) (MMMM, (3.5, hi), (3.5, hi))
     1) (____, (3.5, hi), (5, hi))
     2) (_M_M, (3.5, hi), (3.5, HI))
     3) (____, (3.5, hi), (3.5, hj))
     4) (____, (3.5, hi), (NaN, hi))
     5) (____, (3.5, hi), (NaN, HI))
 1) Sequence: Seq<(str,(r8,str),(r8,str))>
     0) (____, (NaN, hi), (3.5, hi))
     1) (____, (NaN, hi), (5, hi))
     2) (____, (NaN, hi), (3.5, HI))
     3) (____, (NaN, hi), (3.5, hj))
     4) (MM__, (NaN, hi), (NaN, hi))
     5) (_M__, (NaN, hi), (NaN, HI))
###
> F(DAs, QBs)
F(DAs, QBs) : (s, (r8, s), (r8, s)?)**
BndKind:Call, Type:(s, (r8, s), (r8, s)?)**, Bnd:(Call(∂.ForEach([map:1] Global(DAs), Call(∂.ForEach([map:2] Global(QBs), (StrConcat(If(Cmp(Scope(1) @= Scope(2)), str(M), str(_)), If(Cmp(Scope(1) ~@= Scope(2)), str(M), str(_)), If(Cmp(Scope(1) $= Scope(2)), str(M), str(_)), If(Cmp(Scope(1) ~$= Scope(2)), str(M), str(_))), Scope(1), Scope(2)):(s, (r8, s), (r8, s)?)):(s, (r8, s), (r8, s)?)*)):(s, (r8, s), (r8, s)?)**))
// (∂.DAs:(r8, s)*, ∂.QBs:(r8, s)?*) : (s, (r8, s), (r8, s)?)**
ForEach_1(Arr<obj>, (r8,str)):(str,(r8,str),(r8,str))
      5) newobj (str,(r8,str),(r8,str))()
      1) dup
      1) ldarg.0 [Arr<obj>]
      1) ldc.i4.3
      5) ldelem [((r8,str))]
      5) ldfld ((r8,str))::_F0:(r8,str)
      1) ldarg.1 [(r8,str)]
      5) call static (r8,str)::Equals2((r8,str), (r8,str)):bool
      5) brfalse [0]
      5) ldstr [M]
      5) br [1]
  Label [0]:
      5) ldstr [_]
  Label [1]:
      1) ldarg.0 [Arr<obj>]
      1) ldc.i4.0
      5) ldelem [Arr<obj>]
      1) ldc.i4.0
      5) ldelem [EqualityComparer<(r8,str)>]
      1) ldarg.0 [Arr<obj>]
      1) ldc.i4.3
      5) ldelem [((r8,str))]
      5) ldfld ((r8,str))::_F0:(r8,str)
      1) ldarg.1 [(r8,str)]
      5) callvirt EqualityComparer<(r8,str)>::Equals((r8,str), (r8,str)):bool
      5) brfalse [2]
      5) ldstr [M]
      5) br [3]
  Label [2]:
      5) ldstr [_]
  Label [3]:
      1) ldarg.0 [Arr<obj>]
      1) ldc.i4.0
      5) ldelem [Arr<obj>]
      1) ldc.i4.1
      5) ldelem [EqualityComparer<(r8,str)>]
      1) ldarg.0 [Arr<obj>]
      1) ldc.i4.3
      5) ldelem [((r8,str))]
      5) ldfld ((r8,str))::_F0:(r8,str)
      1) ldarg.1 [(r8,str)]
      5) callvirt EqualityComparer<(r8,str)>::Equals((r8,str), (r8,str)):bool
      5) brfalse [4]
      5) ldstr [M]
      5) br [5]
  Label [4]:
      5) ldstr [_]
  Label [5]:
      1) ldarg.0 [Arr<obj>]
      1) ldc.i4.0
      5) ldelem [Arr<obj>]
      1) ldc.i4.2
      5) ldelem [EqualityComparer<(r8,str)>]
      1) ldarg.0 [Arr<obj>]
      1) ldc.i4.3
      5) ldelem [((r8,str))]
      5) ldfld ((r8,str))::_F0:(r8,str)
      1) ldarg.1 [(r8,str)]
      5) callvirt EqualityComparer<(r8,str)>::Equals((r8,str), (r8,str)):bool
      5) brfalse [6]
      5) ldstr [M]
      5) br [7]
  Label [6]:
      5) ldstr [_]
  Label [7]:
      5) call static str::Concat(str, str, str, str):str
      5) stfld (str,(r8,str),(r8,str))::_F0:str
      1) dup
      1) ldarg.0 [Arr<obj>]
      1) ldc.i4.3
      5) ldelem [((r8,str))]
      5) ldfld ((r8,str))::_F0:(r8,str)
      5) stfld (str,(r8,str),(r8,str))::_F1:(r8,str)
      1) dup
      1) ldarg.1 [(r8,str)]
      5) stfld (str,(r8,str),(r8,str))::_F2:(r8,str)
      1) ret
  Total Size: 233

Func sig: (DAs:(r8, s)*, QBs:(r8, s)?*) to (s, (r8, s), (r8, s)?)**
Sequence: Seq<Seq<(str,(r8,str),(r8,str))>>
 0) Sequence: Seq<(str,(r8,str),(r8,str))>
     0) (MMMM, (3.5, hi), (3.5, hi))
     1) (____, (3.5, hi), (5, hi))
     2) (_M_M, (3.5, hi), (3.5, HI))
     3) (____, (3.5, hi), (3.5, hj))
     4) (____, (3.5, hi), (NaN, hi))
     5) (____, (3.5, hi), (NaN, HI))
     6) (____, (3.5, hi), <null>)
 1) Sequence: Seq<(str,(r8,str),(r8,str))>
     0) (____, (NaN, hi), (3.5, hi))
     1) (____, (NaN, hi), (5, hi))
     2) (____, (NaN, hi), (3.5, HI))
     3) (____, (NaN, hi), (3.5, hj))
     4) (MM__, (NaN, hi), (NaN, hi))
     5) (_M__, (NaN, hi), (NaN, HI))
     6) (____, (NaN, hi), <null>)
###
> F(DAs ++ [null], RBs)
F(DAs ++ [null], RBs) : (s, (r8, s)?, (r8, s))**
BndKind:Call, Type:(s, (r8, s)?, (r8, s))**, Bnd:(Call(∂.ForEach([map:1] SeqConcat(Ref<(r8, s)?*>(Global(DAs)), [null:(r8, s)?]:(r8, s)?*), Call(∂.ForEach([map:2] Global(RBs), (StrConcat(If(Cmp(Scope(1) @= Scope(2)), str(M), str(_)), If(Cmp(Scope(1) ~@= Scope(2)), str(M), str(_)), If(Cmp(Scope(1) $= Scope(2)), str(M), str(_)), If(Cmp(Scope(1) ~$= Scope(2)), str(M), str(_))), Scope(1), Scope(2)):(s, (r8, s)?, (r8, s))):(s, (r8, s)?, (r8, s))*)):(s, (r8, s)?, (r8, s))**))
// (∂.DAs:(r8, s)*, ∂.RBs:(r8, s)*) : (s, (r8, s)?, (r8, s))**
ForEach_1(Arr<obj>, (r8,str)):(str,(r8,str),(r8,str))
      5) newobj (str,(r8,str),(r8,str))()
      1) dup
      1) ldarg.0 [Arr<obj>]
      1) ldc.i4.3
      5) ldelem [((r8,str))]
      5) ldfld ((r8,str))::_F0:(r8,str)
      1) ldarg.1 [(r8,str)]
      5) call static (r8,str)::Equals2((r8,str), (r8,str)):bool
      5) brfalse [0]
      5) ldstr [M]
      5) br [1]
  Label [0]:
      5) ldstr [_]
  Label [1]:
      1) ldarg.0 [Arr<obj>]
      1) ldc.i4.0
      5) ldelem [Arr<obj>]
      1) ldc.i4.0
      5) ldelem [EqualityComparer<(r8,str)>]
      1) ldarg.0 [Arr<obj>]
      1) ldc.i4.3
      5) ldelem [((r8,str))]
      5) ldfld ((r8,str))::_F0:(r8,str)
      1) ldarg.1 [(r8,str)]
      5) callvirt EqualityComparer<(r8,str)>::Equals((r8,str), (r8,str)):bool
      5) brfalse [2]
      5) ldstr [M]
      5) br [3]
  Label [2]:
      5) ldstr [_]
  Label [3]:
      1) ldarg.0 [Arr<obj>]
      1) ldc.i4.0
      5) ldelem [Arr<obj>]
      1) ldc.i4.1
      5) ldelem [EqualityComparer<(r8,str)>]
      1) ldarg.0 [Arr<obj>]
      1) ldc.i4.3
      5) ldelem [((r8,str))]
      5) ldfld ((r8,str))::_F0:(r8,str)
      1) ldarg.1 [(r8,str)]
      5) callvirt EqualityComparer<(r8,str)>::Equals((r8,str), (r8,str)):bool
      5) brfalse [4]
      5) ldstr [M]
      5) br [5]
  Label [4]:
      5) ldstr [_]
  Label [5]:
      1) ldarg.0 [Arr<obj>]
      1) ldc.i4.0
      5) ldelem [Arr<obj>]
      1) ldc.i4.2
      5) ldelem [EqualityComparer<(r8,str)>]
      1) ldarg.0 [Arr<obj>]
      1) ldc.i4.3
      5) ldelem [((r8,str))]
      5) ldfld ((r8,str))::_F0:(r8,str)
      1) ldarg.1 [(r8,str)]
      5) callvirt EqualityComparer<(r8,str)>::Equals((r8,str), (r8,str)):bool
      5) brfalse [6]
      5) ldstr [M]
      5) br [7]
  Label [6]:
      5) ldstr [_]
  Label [7]:
      5) call static str::Concat(str, str, str, str):str
      5) stfld (str,(r8,str),(r8,str))::_F0:str
      1) dup
      1) ldarg.0 [Arr<obj>]
      1) ldc.i4.3
      5) ldelem [((r8,str))]
      5) ldfld ((r8,str))::_F0:(r8,str)
      5) stfld (str,(r8,str),(r8,str))::_F1:(r8,str)
      1) dup
      1) ldarg.1 [(r8,str)]
      5) stfld (str,(r8,str),(r8,str))::_F2:(r8,str)
      1) ret
  Total Size: 233

Func sig: (DAs:(r8, s)*, RBs:(r8, s)*) to (s, (r8, s)?, (r8, s))**
Sequence: Seq<Seq<(str,(r8,str),(r8,str))>>
 0) Sequence: Seq<(str,(r8,str),(r8,str))>
     0) (MMMM, (3.5, hi), (3.5, hi))
     1) (____, (3.5, hi), (5, hi))
     2) (_M_M, (3.5, hi), (3.5, HI))
     3) (____, (3.5, hi), (3.5, hj))
     4) (____, (3.5, hi), (NaN, hi))
     5) (____, (3.5, hi), (NaN, HI))
 1) Sequence: Seq<(str,(r8,str),(r8,str))>
     0) (____, (NaN, hi), (3.5, hi))
     1) (____, (NaN, hi), (5, hi))
     2) (____, (NaN, hi), (3.5, HI))
     3) (____, (NaN, hi), (3.5, hj))
     4) (MM__, (NaN, hi), (NaN, hi))
     5) (_M__, (NaN, hi), (NaN, HI))
 2) Sequence: Seq<(str,(r8,str),(r8,str))>
     0) (____, <null>, (3.5, hi))
     1) (____, <null>, (5, hi))
     2) (____, <null>, (3.5, HI))
     3) (____, <null>, (3.5, hj))
     4) (____, <null>, (NaN, hi))
     5) (____, <null>, (NaN, HI))
###
> F(DAs ++ [null], QBs)
F(DAs ++ [null], QBs) : (s, (r8, s)?, (r8, s)?)**
BndKind:Call, Type:(s, (r8, s)?, (r8, s)?)**, Bnd:(Call(∂.ForEach([map:1] SeqConcat(Ref<(r8, s)?*>(Global(DAs)), [null:(r8, s)?]:(r8, s)?*), Call(∂.ForEach([map:2] Global(QBs), (StrConcat(If(Cmp(Scope(1) @= Scope(2)), str(M), str(_)), If(Cmp(Scope(1) ~@= Scope(2)), str(M), str(_)), If(Cmp(Scope(1) $= Scope(2)), str(M), str(_)), If(Cmp(Scope(1) ~$= Scope(2)), str(M), str(_))), Scope(1), Scope(2)):(s, (r8, s)?, (r8, s)?)):(s, (r8, s)?, (r8, s)?)*)):(s, (r8, s)?, (r8, s)?)**))
// (∂.DAs:(r8, s)*, ∂.QBs:(r8, s)?*) : (s, (r8, s)?, (r8, s)?)**
ForEach_1(Arr<obj>, (r8,str)):(str,(r8,str),(r8,str))
      5) newobj (str,(r8,str),(r8,str))()
      1) dup
      1) ldarg.0 [Arr<obj>]
      1) ldc.i4.3
      5) ldelem [((r8,str))]
      5) ldfld ((r8,str))::_F0:(r8,str)
      1) ldarg.1 [(r8,str)]
      5) call static (r8,str)::Equals2((r8,str), (r8,str)):bool
      5) brfalse [0]
      5) ldstr [M]
      5) br [1]
  Label [0]:
      5) ldstr [_]
  Label [1]:
      1) ldarg.0 [Arr<obj>]
      1) ldc.i4.0
      5) ldelem [Arr<obj>]
      1) ldc.i4.0
      5) ldelem [EqualityComparer<(r8,str)>]
      1) ldarg.0 [Arr<obj>]
      1) ldc.i4.3
      5) ldelem [((r8,str))]
      5) ldfld ((r8,str))::_F0:(r8,str)
      1) ldarg.1 [(r8,str)]
      5) callvirt EqualityComparer<(r8,str)>::Equals((r8,str), (r8,str)):bool
      5) brfalse [2]
      5) ldstr [M]
      5) br [3]
  Label [2]:
      5) ldstr [_]
  Label [3]:
      1) ldarg.0 [Arr<obj>]
      1) ldc.i4.0
      5) ldelem [Arr<obj>]
      1) ldc.i4.1
      5) ldelem [EqualityComparer<(r8,str)>]
      1) ldarg.0 [Arr<obj>]
      1) ldc.i4.3
      5) ldelem [((r8,str))]
      5) ldfld ((r8,str))::_F0:(r8,str)
      1) ldarg.1 [(r8,str)]
      5) callvirt EqualityComparer<(r8,str)>::Equals((r8,str), (r8,str)):bool
      5) brfalse [4]
      5) ldstr [M]
      5) br [5]
  Label [4]:
      5) ldstr [_]
  Label [5]:
      1) ldarg.0 [Arr<obj>]
      1) ldc.i4.0
      5) ldelem [Arr<obj>]
      1) ldc.i4.2
      5) ldelem [EqualityComparer<(r8,str)>]
      1) ldarg.0 [Arr<obj>]
      1) ldc.i4.3
      5) ldelem [((r8,str))]
      5) ldfld ((r8,str))::_F0:(r8,str)
      1) ldarg.1 [(r8,str)]
      5) callvirt EqualityComparer<(r8,str)>::Equals((r8,str), (r8,str)):bool
      5) brfalse [6]
      5) ldstr [M]
      5) br [7]
  Label [6]:
      5) ldstr [_]
  Label [7]:
      5) call static str::Concat(str, str, str, str):str
      5) stfld (str,(r8,str),(r8,str))::_F0:str
      1) dup
      1) ldarg.0 [Arr<obj>]
      1) ldc.i4.3
      5) ldelem [((r8,str))]
      5) ldfld ((r8,str))::_F0:(r8,str)
      5) stfld (str,(r8,str),(r8,str))::_F1:(r8,str)
      1) dup
      1) ldarg.1 [(r8,str)]
      5) stfld (str,(r8,str),(r8,str))::_F2:(r8,str)
      1) ret
  Total Size: 233

Func sig: (DAs:(r8, s)*, QBs:(r8, s)?*) to (s, (r8, s)?, (r8, s)?)**
Sequence: Seq<Seq<(str,(r8,str),(r8,str))>>
 0) Sequence: Seq<(str,(r8,str),(r8,str))>
     0) (MMMM, (3.5, hi), (3.5, hi))
     1) (____, (3.5, hi), (5, hi))
     2) (_M_M, (3.5, hi), (3.5, HI))
     3) (____, (3.5, hi), (3.5, hj))
     4) (____, (3.5, hi), (NaN, hi))
     5) (____, (3.5, hi), (NaN, HI))
     6) (____, (3.5, hi), <null>)
 1) Sequence: Seq<(str,(r8,str),(r8,str))>
     0) (____, (NaN, hi), (3.5, hi))
     1) (____, (NaN, hi), (5, hi))
     2) (____, (NaN, hi), (3.5, HI))
     3) (____, (NaN, hi), (3.5, hj))
     4) (MM__, (NaN, hi), (NaN, hi))
     5) (_M__, (NaN, hi), (NaN, HI))
     6) (____, (NaN, hi), <null>)
 2) Sequence: Seq<(str,(r8,str),(r8,str))>
     0) (____, <null>, (3.5, hi))
     1) (____, <null>, (5, hi))
     2) (____, <null>, (3.5, HI))
     3) (____, <null>, (3.5, hj))
     4) (____, <null>, (NaN, hi))
     5) (____, <null>, (NaN, HI))
     6) (MM__, <null>, <null>)
###
